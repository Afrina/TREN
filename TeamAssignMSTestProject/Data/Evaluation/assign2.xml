<bugs>
    <bug>
        <id>508110</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-11-24 07:35:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>JavaElement.newNotPresentException logged when running AllAllRefactoringTests</short_desc>
        <thetext>I20161121-2000 but started to happen during M2.

http://download.eclipse.org/eclipse/downloads/drops4/I20161121-2000/testresults/ep47I-unit-lin64_linux.gtk.x86_64_8.0/org.eclipse.jdt.ui.tests.refactoring.all.AllAllRefactoringTests.txt

The tests pass.


It seems to happen in NLSHintHelperTest.tearDown but running just the NLSHintHelperTest works fine.

It looks like some listener later tries to access the nls.jar where it no longer exists.

I can reproduce it in the IDE too.</thetext>
        <comment>
            <comment_id>2779597</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-24 07:37:26 -0500</when>
            <comment_text>Targeting M5, though M4 would be better.</comment_text>
        </comment>
        <comment>
            <comment_id>2780800</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-28 23:45:20 -0500</when>
            <comment_text>Hmm.. This the code that logs this message:

case IResourceDelta.REMOVED:
	// Close the containing package fragment root to reset its cached children.
	// See http://bugs.eclipse.org/500714
	IPackageFragmentRoot root = findContainingPackageFragmentRoot(resource);
	if (root != null &amp;&amp; root.isOpen()) {
		try {
			root.close();
		} catch (JavaModelException e) {
			Util.log(e);
		}
	}

We know that the resource has been removed and so we try to close the package fragment root, but for some reason we try to look up the underlying resource.

Sergey, can you please take care of this? Thanks!</comment_text>
        </comment>
    </bug>
    <bug>
        <id>486013</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-01-18 02:25:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9][tests] Test case issues</short_desc>
        <thetext>Umbrella bug for addressing all 1.9 test case issues.</thetext>
        <comment>
            <comment_id>2717776</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-07 02:54:19 -0400</when>
            <comment_text>First set of fixes released via:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=9155dfe5fa69fb2096196e5313e43eeabab82363

This addresses all the failures in org.eclipse.jdt.core.tests.eval.TestAll.

What's left now fall largely in two buckets:

1. Failures due to additional warning about deprecated stuff in Java 9.
2. Our JRT file system not considering javax.* modules, which are required by som tests.</comment_text>
        </comment>
        <comment>
            <comment_id>2718522</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-08 12:59:36 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #1)
&gt; 1. Failures due to additional warning about deprecated stuff in Java 9.

This is fixed via:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=aee2925515ff92b7466c70c1632476d226c7aba8</comment_text>
        </comment>
        <comment>
            <comment_id>2718722</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-09 01:59:25 -0400</when>
            <comment_text>These are the four tests currently failing:

test008 - (org.eclipse.jdt.core.tests.compiler.regression.SerialVersionUIDTests)
test009 - (org.eclipse.jdt.core.tests.compiler.regression.SerialVersionUIDTests)
test010 - (org.eclipse.jdt.core.tests.compiler.regression.SerialVersionUIDTests)
testBug386356_1 - (org.eclipse.jdt.core.tests.compiler.regression.AnnotationTest)

Totally there are 26 failures across all compliance levels.

Besides, the following two tests have been disabled for now and should be investigated:

CodeSnippetTest.testPackage()
NegativeCodeSnippetTest.testChangePackage()</comment_text>
        </comment>
        <comment>
            <comment_id>2718930</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-09 10:47:00 -0400</when>
            <comment_text>Looks like the SerialVersionUIDTests tests are failing because our effort in loading classes from non java.base modules through our extended class loader is failing. This class loader is redirecting all requests for system classes to findSystemClass(). But my guess is in classpath mode, non java.base modules are not available. Perhaps there's a way; will check with the Jigsaw experts.

I did a small experiment by commenting out the overridden loadClass in VerifyClassLoader and this makes all mentioned tests pass. But obviously this is done for some reason, proven by other failing tests.</comment_text>
        </comment>
        <comment>
            <comment_id>2718991</comment_id>
            <comment_count>5</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-06-09 12:16:43 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #2)
&gt; (In reply to Jay Arthanareeswaran from comment #1)
&gt; &gt; 1. Failures due to additional warning about deprecated stuff in Java 9.
&gt; 
&gt; This is fixed via:
&gt; 
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
&gt; ?h=BETA_JAVA9&amp;id=aee2925515ff92b7466c70c1632476d226c7aba8

Jay I see the failure for ConditionalExpressionTest @ 8</comment_text>
        </comment>
        <comment>
            <comment_id>2733631</comment_id>
            <comment_count>6</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-07-26 00:35:35 -0400</when>
            <comment_text>(In reply to Manoj Palat from comment #5)
&gt; Jay I see the failure for ConditionalExpressionTest @ 8

This no longer fails. However, there are a bunch of failures in the following suites:

org.eclipse.jdt.compiler.apt.tests.BatchDispatchTests
org.eclipse.jdt.compiler.apt.tests.FilerTests
org.eclipse.jdt.compiler.apt.tests.NegativeTests

Causing being the same in all cases. the failing test is:

junit.framework.TestCase.assertEquals("Only one compiler available", 1, compilerCounter);

in BatchTestUtils line number 288.</comment_text>
        </comment>
        <comment>
            <comment_id>2733649</comment_id>
            <comment_count>7</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-07-26 03:02:40 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #6)

Looks like there is a change in behavior of java.util.ServiceLoader.load(Class&lt;T&gt;) in JRE. In JRE 8, we get only one instance of this after loading EclipseCompiler with a Class.forName(), but in JRE 9 we get both JavacTool and EclipseCompiler. The EclipseCompiler is retrieved even when I comment out the Class.forName(). I wonder if the test should worry about this at all.</comment_text>
        </comment>
        <comment>
            <comment_id>2735940</comment_id>
            <comment_count>8</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-01 01:39:41 -0400</when>
            <comment_text>The following annotation related tests are failing:

testProcessorArgumentsWithEclipseCompiler(org.eclipse.jdt.compiler.apt.tests.BatchDispatchTests)
testCompilerOneClassWithEclipseCompiler(org.eclipse.jdt.compiler.apt.tests.BatchDispatchTests)
testTwoAnnotations(org.eclipse.jdt.compiler.apt.tests.BatchDispatchTests)
testElementWithEclipseCompiler(org.eclipse.jdt.compiler.apt.tests.FilerTests)
testNegativeModel10WithEclipseCompiler(org.eclipse.jdt.compiler.apt.tests.NegativeTests)

The failure are caused by this commit:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=0171d3fa20410a884ea6de07ec393bc179fb73bd

The compiler is calling reset() on the annotation processing manager after each round (in the same session, though) of compilation, which results in loosing the loaded processors. Needs a closer look.</comment_text>
        </comment>
        <comment>
            <comment_id>2737417</comment_id>
            <comment_count>9</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-04 23:32:44 -0400</when>
            <comment_text>There were test failures in the last Y build due to the hard-coded file path separator in the testcase. 

http://download.eclipse.org/eclipse/downloads/drops4/Y20160804-1000/testresults/html/org.eclipse.jdt.core.tests.compiler_ep47Y-unit-lin64_linux.gtk.x86_64_8.0.html

Fixed with this commit:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=4f43bd149065ac93c6dd889b2740091a2111c0b4</comment_text>
        </comment>
        <comment>
            <comment_id>2748795</comment_id>
            <comment_count>10</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-09 03:13:33 -0400</when>
            <comment_text>One more failing test was found with JRE 9 and is fixed with:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=4853bfa39b4537870df1c5f0503a1078575fae46

and the failing tests @1.8 mentioned with comment #9 are disable for now:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=4853bfa39b4537870df1c5f0503a1078575fae46

At 1.9, there these failures:

testInheritedAnnosWithEclipseCompiler(org.eclipse.jdt.compiler.apt.tests.BatchDispatchTests)
testProcessorArgumentsWithSystemCompiler(org.eclipse.jdt.compiler.apt.tests.BatchDispatchTests)
testTypeMirrorWithEclipseCompiler(org.eclipse.jdt.compiler.apt.tests.ModelTests)
testTypeMirrorWithSystemCompiler(org.eclipse.jdt.compiler.apt.tests.ModelTests)
testGenericsWithEclipseCompiler(org.eclipse.jdt.compiler.apt.tests.ModelTests)
testElementWithEclipseCompiler(org.eclipse.jdt.compiler.apt.tests.ModelTests)
testPackageAnnotationsWithJavac(org.eclipse.jdt.compiler.apt.tests.Java8ElementsTests)

And whole suite is unable to run with JRE 9: org.eclipse.jdt.compiler.tool.tests.AllTests</comment_text>
        </comment>
        <comment>
            <comment_id>2756278</comment_id>
            <comment_count>11</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-28 03:11:16 -0400</when>
            <comment_text>The following tests are disabled for now:

AnnotationTest#testBug386356_1
SerialVersionUIDTests#test008
SerialVersionUIDTests#test009
SerialVersionUIDTests#test010

These don't fail when run alone, but fail when run as part of the suite.</comment_text>
        </comment>
        <comment>
            <comment_id>2778978</comment_id>
            <comment_count>12</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-11-23 01:39:06 -0500</when>
            <comment_text>note: RunAllJava9Tests (ref bug 506952) can be used run all Java 9 tests</comment_text>
        </comment>
    </bug>
    <bug>
        <id>487832</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-02-15 11:21:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] Modules should be compiled properly even with non jigsaw JDK/JRE</short_desc>
        <thetext>After the recent changes in BETA_JAVA9 branch, looks like modules are no longer compiled properly with non Jigsaw JDK in the build path. The problem seems to be that modules are not loaded (because of the missing module-info.class of the system modules). However, the module-info.java from the source module is still recognized (at 1.9 level, of course). When this source module requests for types/packages from java.base, the module system is not able to pass on the request to the correct module location, in this case, ClasspathJimage.</thetext>
        <comment>
            <comment_id>2671847</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-02-15 11:21:37 -0500</when>
            <comment_text>Fix should be simple, I will take a look.</comment_text>
        </comment>
        <comment>
            <comment_id>2747422</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-06 11:51:57 -0400</when>
            <comment_text>I just saw your comment in ModuleBuilderTests._test006()

// Test that a module that doesn't exist but specified as requires in module-info
// doesn't affect rest of the compilation.

Shouldn't this case report an error against module-info?</comment_text>
        </comment>
        <comment>
            <comment_id>2747447</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-06 12:44:17 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #2)
&gt; I just saw your comment in ModuleBuilderTests._test006()
&gt; 
&gt; // Test that a module that doesn't exist but specified as requires in
&gt; module-info
&gt; // doesn't affect rest of the compilation.
&gt; 
&gt; Shouldn't this case report an error against module-info?

Yes, I believe so. The test was written when compiler didn't have full support for compiling module-info.java. This should be revisited at a suitable time and amended as necessary.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488885</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-03-02 12:56:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] Trigger a full build when module-info.java has changed</short_desc>
        <thetext>Just like classpath change, change in module information should trigger full build of the current project and dependent projects if any. At the moment, only the modified module-info.java is compiled by the incremental compiler.

I have a patch that triggers build on any content change of the module-info. But clearly this needs improvement. A complete fix should identify the elements of the module that affect the compilation of the build and trigger the build accordingly - most probably these would be 'exports' and 'requires'.</thetext>
        <comment>
            <comment_id>2678227</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-03-03 01:22:30 -0500</when>
            <comment_text>A first cut fix is released here with relevant tests.

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=a54886812b7dc23c212e40cce3ea10b5dc5e1c5e

One of the new tests is disabled because of a known issue. Here are the known issues:
1. The fix doesn't look at the things that are changed in the module-info. Any content change (other than encoding change etc.) will trigger the build.
2. When a "requires java.base" is added or removed, a build is triggered. This should not happen. At the moment, the equals() method of IModule implementations simply call Arrays.equals() on requires. But we should find a way to leave java.base out of the equation.</comment_text>
        </comment>
        <comment>
            <comment_id>2678605</comment_id>
            <comment_count>2</comment_count>
            <who>Paul Benedict</who>
            <commenter_username>pbenedict</commenter_username>
            <when>2016-03-03 15:51:53 -0500</when>
            <comment_text>How is this going to interact with tooling? Theoretically, maybe in the future, module-info.java could be generated from a tool like Maven. In that kind of scenario, this feature would clash because a build would be triggered on the wrong kind of change.</comment_text>
        </comment>
        <comment>
            <comment_id>2678674</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-03-04 00:10:33 -0500</when>
            <comment_text>(In reply to Paul Benedict from comment #2)
&gt; How is this going to interact with tooling? Theoretically, maybe in the
&gt; future, module-info.java could be generated from a tool like Maven. In that
&gt; kind of scenario, this feature would clash because a build would be
&gt; triggered on the wrong kind of change.

I don't know what you mean by wrong kind of change. What I have released is a stop gap fix. A full fix should trigger the build only if it is absolutely required.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490096</id>
        <developer>David Albrecht</developer>
        <developer_username>d.albrecht</developer_username>
        <dup_id/>
        <creation_time>2016-03-21 10:46:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>StackOverflowError on code complete of a lambda expression</short_desc>
        <thetext>Created attachment 260451
Class to reproduce the error

Code completion on a certain expression with lambdas fails with StackOverflowError. See steps to reproduce and the attached class for details.

Steps to reproduce:
1. Import the attached class into a project
2. Make sure classpath is valid (add JUnit4)
3. Open the class in the editor
4. Place the cursor just before the semicolon at line 12 (right after the dot)
5. Code completion fails with a StackOverflowError

The error is reproducible using out-of-box Mars.2 JEE IDE.</thetext>
        <comment>
            <comment_id>2685144</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-03-21 11:01:20 -0400</when>
            <comment_text>I can reproduce it with I20160317-0200.

Caused by: java.lang.StackOverflowError
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:128)
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:226)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.handle(ProblemReporter.java:2391)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.typeMismatchError(ProblemReporter.java:7972)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve(ReturnStatement.java:382)
...</comment_text>
        </comment>
        <comment>
            <comment_id>2685234</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-21 12:59:04 -0400</when>
            <comment_text>(In reply to Noopur Gupta from comment #1)
&gt; I can reproduce it with I20160317-0200.
&gt; 
&gt; Caused by: java.lang.StackOverflowError
&gt; 	at
&gt; org.eclipse.jdt.internal.compiler.problem.ProblemHandler.
&gt; handle(ProblemHandler.java:128)
&gt; 	at
&gt; org.eclipse.jdt.internal.compiler.problem.ProblemHandler.
&gt; handle(ProblemHandler.java:226)
&gt; 	at
&gt; org.eclipse.jdt.internal.compiler.problem.ProblemReporter.
&gt; handle(ProblemReporter.java:2391)
&gt; 	at
&gt; org.eclipse.jdt.internal.compiler.problem.ProblemReporter.
&gt; typeMismatchError(ProblemReporter.java:7972)
&gt; 	at
&gt; org.eclipse.jdt.internal.compiler.ast.ReturnStatement.
&gt; resolve(ReturnStatement.java:382)
&gt; ...

Do you have just a few more lines of that stack trace, so we can see the recursion?</comment_text>
        </comment>
        <comment>
            <comment_id>2685259</comment_id>
            <comment_count>3</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-03-21 14:02:27 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #2)
&gt; Do you have just a few more lines of that stack trace, so we can see the
&gt; recursion?

Caused by: java.lang.StackOverflowError
	at org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory.getLocalizedMessage(DefaultProblemFactory.java:135)
	at org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory.createProblem(DefaultProblemFactory.java:100)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine$CompletionProblemFactory.createProblem(CompletionEngine.java:244)
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.createProblem(ProblemHandler.java:101)
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:173)
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:226)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.handle(ProblemReporter.java:2391)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.typeMismatchError(ProblemReporter.java:7972)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve(ReturnStatement.java:382)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.resolveType(LambdaExpression.java:428)
	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolvePolyExpressionArguments(ASTNode.java:691)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:922)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.codeassist.complete.CompletionOnMemberAccess.resolveType(CompletionOnMemberAccess.java:56)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.resolveType(LambdaExpression.java:428)
	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolvePolyExpressionArguments(ASTNode.java:691)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:922)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.codeassist.complete.CompletionOnMemberAccess.resolveType(CompletionOnMemberAccess.java:56)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.resolveType(LambdaExpression.java:428)
...</comment_text>
        </comment>
        <comment>
            <comment_id>2685387</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-21 18:52:13 -0400</when>
            <comment_text>Thanks Noopur, so the ProblemHandler has nothing to do with the bug.
The bug is a cycle in the completion AST like this:

this	CompletionOnMemberAccess  (id=9977)	
  ...
  receiver	MessageSend  (id=10008)	
    ...
    arguments	Expression[1]  (id=10013)	
      [0]	LambdaExpression  (id=10021)	
	...
	body	Block  (id=10027)	
	  ...
	  statements	Statement[5]  (id=10036)	
	    [0]	ReturnStatement  (id=10038)	
	    [1]	CompletionOnMemberAccess  (id=9977)</comment_text>
        </comment>
        <comment>
            <comment_id>2685402</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-21 19:51:42 -0400</when>
            <comment_text>When debugging the CompletionParser I see a bogus if statement created in CompletionParser.buildMoreCompletionEnclosingContext().

This happens, because 'this.elementInfoStack[index] == IF'. 

In fact the info, however, was pushed from 

  pushOnElementStack(K_LAMBDA_EXPRESSION_DELIMITER, BLOCK_BODY, this.previousObjectInfo);

We are confusing constants 'IF' and 'BLOCK_BODY', which happen to share the same value (1). 
=&gt; when checking 
  this.elementInfoStack[index] == IF
we *always* need to also test 
  this.elementKindStack[index]

The info '1' only means 'IF' if the kind is either K_BLOCK_DELIMITER or K_BETWEEN_INSTANCEOF_AND_RPAREN.

Unfortunately, inserting such a check does not fix the cyclic AST.</comment_text>
        </comment>
        <comment>
            <comment_id>2685408</comment_id>
            <comment_count>6</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-21 20:19:10 -0400</when>
            <comment_text>One contributor to the AST cycle is this method in CompletionParser:

protected void consumeEmptyStatement() {
	super.consumeEmptyStatement();
	/* Sneak in the assist node. The reason we can't do that when we see the assist node is that 
	   we don't know whether it is the first or subsequent statement in a block to be able to
	   decide whether to call contactNodeLists. See Parser.consumeBlockStatement(s) 
	*/
	if (this.shouldStackAssistNode &amp;&amp; this.assistNode != null)
		this.astStack[this.astPtr] = this.assistNodeParent instanceof MessageSend ? this.assistNodeParent : this.assistNode;
	this.shouldStackAssistNode = false;
}

the second but last line may create an alias for the assist identifier which may also be contained in the 'currentElement' (inside a RecoveredStatement insided a RecoveredBlock).

The cycle can be broken (brute-force) by either of:
- skipping the above assignment to his.astStack[this.astPtr], or
- 'deleting' a statement from the RecoveredBlock by setting statementCount to 0
Either tweak avoids the SOE, but probably creates wrong results.

I'll stop my analysis here.

Anybody familiar with this code region?
To really understand this, one would have to dive into the rabbit hole of bug 422468 and friends, I'm afraid...</comment_text>
        </comment>
        <comment>
            <comment_id>2685447</comment_id>
            <comment_count>7</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-03-22 01:30:44 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #6)
&gt; Anybody familiar with this code region?
&gt; To really understand this, one would have to dive into the rabbit hole of
&gt; bug 422468 and friends, I'm afraid...

I am not familiar with that code per se, but will take a look.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490103</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-03-21 11:49:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] JREContainer should work without any physical libraries</short_desc>
        <thetext>The bug is same as reported in bug 489207. That bug provided a short-term fix by adding the jrt-fs.jar as the single library to the container. But ideally we should try to make the JREContainer work without referring to any physical library because there isn't any in case of JRE 9.</thetext>
        <comment>
            <comment_id>2685496</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-03-22 05:10:43 -0400</when>
            <comment_text>I don't think we should fiddle with the IClasspathContainer#getClasspathEntries() and affect existing clients. Here's one idea that could work with minimal code changes:

I propose a new IClasspathEntry kind namely:

  IClasspathEntry#CPE_SYSTEM

The path could point to the root of the JRE, i.e. what is represented by the JREContainer. The JREContainer would be responsible for creating this (only in case of JRE 9) and making it available via getClasspathEntries().

And all we need to do in JDT Core is to look for this new kind and do what is required (i.e. create a ClasspathJimage, a kind of ClasspathLocation that specializes in reading from JRE 9 images).

Any suggestions?</comment_text>
        </comment>
        <comment>
            <comment_id>2685857</comment_id>
            <comment_count>2</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-03-22 15:17:54 -0400</when>
            <comment_text>The problem with a new IClasspathEntry kind is that this will break every client that assumes the set given in IClasspathEntry#getEntryKind() is closed. The Javadoc of IClasspathEntry supports that viewpoint. I know that jdt.ui will throw exceptions if you do that, and I assume others won't like it either.

Can't we keep using CPE_LIBRARY and just use the root of the JRE as path? That probably needs some magic to distinguish the root of a JRE from a class folder, but I think that would cause less breakage.</comment_text>
        </comment>
        <comment>
            <comment_id>2687711</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-03-29 05:28:46 -0400</when>
            <comment_text>(In reply to Markus Keller from comment #2)
&gt; Can't we keep using CPE_LIBRARY and just use the root of the JRE as path?
&gt; That probably needs some magic to distinguish the root of a JRE from a class
&gt; folder, but I think that would cause less breakage.

That magic could well be the presence of the jrt-fs.jar directly under the path. But we should think about the clients that are probably expecting this CPE_LIBRARY (a folder) to contain binary classes. They would be broken too.</comment_text>
        </comment>
        <comment>
            <comment_id>2750684</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-14 05:47:55 -0400</when>
            <comment_text>The suggestion from comment #1 was based on the assumption that there would be at least one entry from #getClasspathEntries(). But that's wrong. The JREContainer should clearly tell its clients that they are dealing with a JRT file system.

What we currently have is a crude way of such communication - i.e. the JREContainer#getClasspathEntries() returns exactly one entry pointing to jrt-fs.jar. This was clearly a stop-gap measure. So, I propose the new API goes to IClasspathContainer.

Once again IClasspathContainer#getKind() is closed. So, I propose this:

    /**
     * Answers whether or not this is a Java 9 runtime or later. The Java Run Time (shortly JRT)
     * is not represented by list of libraries but a format internal to the runtime. 
     * Therefore, for containers representing such a runtime, {@link #getClasspathEntries()}
     * returns an empty array. The kind of such a container, however, would remain one of
     * {@link #K_SYSTEM} or {@link #K_DEFAULT_SYSTEM} as applicable.
     *
     * @since 3.13 BETA_JAVA9
     * @see #getClasspathEntries()
     * @see #getKind() 
     */
    default boolean isJava9Runtime() {
    	return false;
    }</comment_text>
        </comment>
        <comment>
            <comment_id>2750704</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-14 06:49:30 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #4)
&gt; Once again IClasspathContainer#getKind() is closed. So, I propose this:

Note that this alone is not enough to make things work again. We would still require to tag the resolved IClasspathEntry with something to represent the JRT. It remains to be seen, though, how many clients are broken by using the incorrect CPE_LIBRARY as the entry kind that points to the root of the JDK/JRE.</comment_text>
        </comment>
        <comment>
            <comment_id>2750705</comment_id>
            <comment_count>6</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-14 06:56:16 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #4)
&gt; Once again IClasspathContainer#getKind() is closed. So, I propose this:

Duh, the IClasspathContainer#getPath() returns the container path and not the VM install location.

Sarika, what are your thoughts?</comment_text>
        </comment>
        <comment>
            <comment_id>2750710</comment_id>
            <comment_count>7</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-14 07:06:31 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #6)
&gt; Sarika, what are your thoughts?

If instead of providing a new API as I suggested, do you see problems in the JREContainer directly creating the special entry and supply via getClasspathEntries()? Perhaps, JavaCore can provide some methods for you to create such a special entry?</comment_text>
        </comment>
        <comment>
            <comment_id>2750712</comment_id>
            <comment_count>8</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-09-14 07:18:33 -0400</when>
            <comment_text>I feel the JRE container is redundant in a module setting. With java9, it is merely used to point to the JRE that needs to be used and for that, it does not need to be a container. With the target platform including system libraries as well and Module path container handling all module dependencies, we can probably do away with the JREContainer? Define an IModulePathEntry that can represent a module path entry and let it produce the necessary IClasspathEntries. With that, just an isModule() API in IClasspathEntry would be enough?</comment_text>
        </comment>
        <comment>
            <comment_id>2750723</comment_id>
            <comment_count>9</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-14 07:39:30 -0400</when>
            <comment_text>(In reply to Sasikanth Bharadwaj from comment #8)
&gt; Define an
&gt; IModulePathEntry that can represent a module path entry and let it produce
&gt; the necessary IClasspathEntries. With that, just an isModule() API in
&gt; IClasspathEntry would be enough?

That will probably help us leave some of the baggages behind.

BTW, I also found some API in IJavaProject that might make our life bit difficult. For e.g:

IJavaProject#getPackageFragmentRoot(String externalLibraryPath)

Where the implementation is expected to come up with a Package fragment root by just looking at the path.</comment_text>
        </comment>
        <comment>
            <comment_id>2751030</comment_id>
            <comment_count>10</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-15 00:25:27 -0400</when>
            <comment_text>I think I am hitting too many roadblocks to park this work. I guess I will wait to see how the target platform shapes and decide the course for this.

The existing solution works, except that ...

... if one adds the jrt-fs.jar to the build path as an individual JAR, that adds the whole system libraries to the build path :(</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490570</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-03-29 05:00:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] JDT's ant adapter should not rely on attributes unsupported in Jigsaw</short_desc>
        <thetext>The Ant compiler adapter (mostly in JDTCompilerAdapter) is using attributes such as -bootclasspath, -extdirs which no longer make sense with Jigsaw.

I currently don't know if this poses a problem, but we will use this bug to investigate and track if there's any impact.</thetext>
        <comment>
            <comment_id>2741365</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-18 09:16:34 -0400</when>
            <comment_text>I can confirm that with Javc the following testcase fails:

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project name="Eclipse Batch Compiler" default="init" basedir=".."&gt;
	&lt;target name="init"&gt;
		&lt;property name="srcdir" value="${user.dir}/src" /&gt;
		&lt;property name="dest" value="${user.dir}/dest" /&gt;
		&lt;javac target="1.9" source="1.9" srcdir="${srcdir}" destdir="${dest}" &gt;
		    &lt;compilerarg value="-Xbootclasspath/p:${boot.path}"/&gt;
  		&lt;/javac&gt;
	&lt;/target&gt;
&lt;/project&gt;

Error reported:

    [javac] javac: option -Xbootclasspath/p: not allowed with target 1.9

As of now, ECJ doesn't report any error.</comment_text>
        </comment>
        <comment>
            <comment_id>2741694</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-19 02:34:20 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #1)
&gt;     [javac] javac: option -Xbootclasspath/p: not allowed with target 1.9
&gt; 
&gt; As of now, ECJ doesn't report any error.

With a fix for bug 499961, the error is reported for bootclasspath and extdirs. ECJ doesn't appear to do anything with -Xbootclasspath, in which case, not reporting the error seems fine to me.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491408</id>
        <developer>David Williams</developer>
        <developer_username>david_williams</developer_username>
        <dup_id/>
        <creation_time>2016-04-11 00:29:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Some JDT Unit tests are sensitive to locale or encoding on test machine</short_desc>
        <thetext>See bug 490651 for background and the specific tests involved. 

There is nothing wrong with having tests that depend on "UTF-8" (or, whatever file system settings are appropriate for the tests), but then the tests themselves should check if the machine meets to qualifications and either not run at all, or perhaps print a warning, or perhaps just have one failure that clearly stats "15 test not ran due to file encoding being XXXX" (or, something better. :)</thetext>
    </bug>
    <bug>
        <id>491892</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-04-18 05:34:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][content assist] Keyword 'super' not proposed</short_desc>
        <thetext>package pp;

interface I {
	default int foo() {
		return -1;
	}
}

class C implements I {
	@Override
	public int foo() {
		// I.super.foo()
		return I.
	}
}

- Press Ctrl+space after "I." in the given code.
=&gt; Keyword 'super' is not proposed.

It is proposed correctly if Ctrl+space is pressed after "I.s".</thetext>
        <comment>
            <comment_id>2696878</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-20 07:19:16 -0400</when>
            <comment_text>I don't know why but the super keyword is added to the choice only when the token length is &gt; 0. But we propose 'this' with or without anything being typed in. Can't infer much from the history either.</comment_text>
        </comment>
        <comment>
            <comment_id>2697413</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-20 23:37:59 -0400</when>
            <comment_text>The problem reported in comment #0 can easily be fixed. But bigger problem is we seem to propose 'super' in cases where it is not allowed.

That might be bigger effort. Will take it up later.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492947</id>
        <developer>Matthew DOnofrio</developer>
        <developer_username>artist</developer_username>
        <dup_id/>
        <creation_time>2016-05-04 02:07:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Code assist does not work in certain forms of lambdas</short_desc>
        <thetext>I'm using lambdas extensively and suddenly my code completion stops working! Tested on the latest Eclipse 4.6.0M6. It's driving me absolutely crazy having to copy/paste my code out and back every time I want to make a change.

Example:

package com.somepackage.sometest;

public class Main {
   public interface SomeInterface {
      public void someMethod();
   }
   
   public enum SomeEnum {
      SOME_ENUM(() -&gt;
            // All proposals broken within here. Even code templates!
         }
      
      SomeEnum(SomeInterface callable) {
      }
   }
   
   public static void main(String[] args) {
   }
}</thetext>
        <comment>
            <comment_id>2702828</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-04 05:57:42 -0400</when>
            <comment_text>The parsed CU looks like this before we attempt to resolve it:

public class Main {
  public interface SomeInterface {
    public void someMethod();
  }
  public enum SomeEnum {
    SOME_ENUM(() -&gt; {
  ;
}),
    {
    }
    public SomeEnum() {
    }
    &lt;clinit&gt;() {
    }
  }
  public Main() {
  }
}

What's interesting is the missing constructor 

SomeEnum(SomeInterface callable){}

Looks like the syntax error is forcing the parser to skip the constructor. Unfortunately here, we need the missing constructor to be able to resolve the PolyTypeBinding.</comment_text>
        </comment>
        <comment>
            <comment_id>2703177</comment_id>
            <comment_count>2</comment_count>
            <who>Matthew DOnofrio</who>
            <commenter_username>artist</commenter_username>
            <when>2016-05-04 16:40:04 -0400</when>
            <comment_text>The syntax error was my mistake on submission. The bug is there without the syntax error:

public class Main {
   public interface SomeInterface {
      public void someMethod();
   }
   
   public enum SomeEnum {
      SOME_ENUM(() -&gt; {
            // All proposals broken within here. Even code templates!
         });
      
      SomeEnum(SomeInterface callable) {
      }
   }
   
   public static void main(String[] args) {
   }
}</comment_text>
        </comment>
        <comment>
            <comment_id>2703254</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-04 23:42:44 -0400</when>
            <comment_text>(In reply to Matthew DOnofrio from comment #2)
&gt; The syntax error was my mistake on submission. The bug is there without the
&gt; syntax error:

I was talking about the syntax error that will always be present when the completion is requested for. The problem remains even after fixing that.</comment_text>
        </comment>
        <comment>
            <comment_id>2703263</comment_id>
            <comment_count>4</comment_count>
            <who>Matthew DOnofrio</who>
            <commenter_username>artist</commenter_username>
            <when>2016-05-05 00:52:43 -0400</when>
            <comment_text>Eclipse doesn't report a syntax error for me. Can you be more specific?</comment_text>
        </comment>
        <comment>
            <comment_id>2703294</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-05 04:06:41 -0400</when>
            <comment_text>(In reply to Matthew DOnofrio from comment #4)
&gt; Eclipse doesn't report a syntax error for me. Can you be more specific?

In most cases, the completion parser will work with a broken code, for example:

public void foo(String str) {
   str.toSt
}

When you try to complete here, the parser sees this incomplete code and tries to recover the code so that the complete context is created. This is not about your code, this is how the completion works in Eclipse. Sorry for not being clear enough earlier.</comment_text>
        </comment>
        <comment>
            <comment_id>2703299</comment_id>
            <comment_count>6</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-05 04:14:03 -0400</when>
            <comment_text>I'll take a look during 4.7</comment_text>
        </comment>
        <comment>
            <comment_id>2704090</comment_id>
            <comment_count>7</comment_count>
            <who>Matthew DOnofrio</who>
            <commenter_username>artist</commenter_username>
            <when>2016-05-09 02:04:59 -0400</when>
            <comment_text>I just now realized what you meant. Code completion DOES work until you type something that would result in a syntax error.

I didn't notice this at first because I have "Report problems as you type" disabled.

This is a very interesting bug.</comment_text>
        </comment>
        <comment>
            <comment_id>2753010</comment_id>
            <comment_count>8</comment_count>
            <who>Mickael Istria - away until ...</who>
            <commenter_username>mistria</commenter_username>
            <when>2016-09-20 03:25:39 -0400</when>
            <comment_text>This seems to be a very major issue for JDT and a reason driving Java developers away to other IDEs nowadays. If doable, it would be great to target those fixes for Neon.2.</comment_text>
        </comment>
        <comment>
            <comment_id>2753111</comment_id>
            <comment_count>9</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-20 05:37:41 -0400</when>
            <comment_text>(In reply to Mickael Istria from comment #8)
&gt; This seems to be a very major issue for JDT and a reason driving Java
&gt; developers away to other IDEs nowadays. If doable, it would be great to
&gt; target those fixes for Neon.2.

Mickael,

We fixed some bugs in this area during 4.6 and early 4.7. 

This particular bug is an old one and seems to be more about Enum than Lambdas themselves.

For e.g. even changing the lambda to an anonymous doesn't make the content assist work.</comment_text>
        </comment>
        <comment>
            <comment_id>2753122</comment_id>
            <comment_count>10</comment_count>
            <who>Mickael Istria - away until ...</who>
            <commenter_username>mistria</commenter_username>
            <when>2016-09-20 05:53:54 -0400</when>
            <comment_text>Thanks Jay. I didn't look into details on how code-assist bugs are organized, so I just commented it there. But the general idea is that IMO, all issues regarding completions in lambdas should be considered for a maintenance release (Neon.2) as this is currently a reason why some Java developers (especially influent ones demoing lambdas in conference) go away from Eclipse IDE.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492977</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-05-04 07:09:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[test][compiler] create a test infrastructure for running ecj standalone</short_desc>
        <thetext>Create a test infrastructure to build the standalone ecj and then run that ecj in command line to mimic user scenario - refer bug 492858 comment 4 for a use case</thetext>
    </bug>
    <bug>
        <id>495396</id>
        <developer>Ralf Thaenert</developer>
        <developer_username>ralf.thaenert</developer_username>
        <dup_id/>
        <creation_time>2016-06-03 08:53:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Inherited annotations are not visible on bridge methods (JDK 6695379)</short_desc>
        <thetext>Created attachment 262221
Maven Project example to reproduce this issue

This was apparently already reported in fixed for other versions in https://bugs.eclipse.org/437446 and https://bugs.eclipse.org/427745. 
I do get the same problem using Eclipse Mars (4.5.1) with JDT plugin version .

For the OpenJDK compiler this was fixed with JDK-6695379.

In the attached exported Project there are two classes:

@Stateless
abstract class BeanSuperclass {

    @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
    public void doSomething() {

    }
}

public class Bean extends BeanSuperclass { }

I would have expected to see the TransactionAttribute annotation on the bridge method of the inherited class.
When compiled using the OpenJDK compiler (with maven from the command line the generated class file for Bean.java shows the @TransactionAttribute annotation on the bridge method doSomething:

  public void doSomething();
    descriptor: ()V 
    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #2                  // Method de/thaenert/test/BeanSuperclass.doSomething:()V
         4: return
      LineNumberTable:
        line 10: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lde/thaenert/test/Bean;
    RuntimeVisibleAnnotations:
      0: #14(#15=e#16.#17)
}

If compiled from Eclipse however the annotation is not visible:

  public void doSomething();
    descriptor: ()V 
    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC
    RuntimeVisibleAnnotations:
      0: #16(#17=e#18.#19)
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #20                 // Method de/thaenert/test/BeanSuperclass.doSomething:()V
         4: return
      LineNumberTable:
        line 1: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
}</thetext>
        <comment>
            <comment_id>2716791</comment_id>
            <comment_count>1</comment_count>
            <who>Ralf Thaenert</who>
            <commenter_username>ralf.thaenert</commenter_username>
            <when>2016-06-03 08:56:00 -0400</when>
            <comment_text>Forgot the JDT plugin version: 3.11.1.v20150904-0015.</comment_text>
        </comment>
        <comment>
            <comment_id>2716839</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-03 10:15:28 -0400</when>
            <comment_text>We will look at it during 4.7</comment_text>
        </comment>
        <comment>
            <comment_id>2716911</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-03 12:37:20 -0400</when>
            <comment_text>In the forum you said this worked with older versions of JDT. If that's true, can you please also state the exact version where you see it working - ideally as the version of plugin org.eclipse.jdt.core? TIA.</comment_text>
        </comment>
        <comment>
            <comment_id>2717345</comment_id>
            <comment_count>4</comment_count>
            <who>Ralf Thaenert</who>
            <commenter_username>ralf.thaenert</commenter_username>
            <when>2016-06-06 02:56:18 -0400</when>
            <comment_text>Sorry, forgot that: On a colleagues machine using Eclipse Luna the bug does not appear. That was Eclipse with JDT plugin version:  3.10.1.v20150204-1700.</comment_text>
        </comment>
        <comment>
            <comment_id>2718135</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-07 17:33:29 -0400</when>
            <comment_text>(In reply to Ralf Thaenert from comment #4)
&gt; Sorry, forgot that: On a colleagues machine using Eclipse Luna the bug does
&gt; not appear. That was Eclipse with JDT plugin version:  3.10.1.v20150204-1700.

That's the version I cannot identify. 3.10.1 should be time-stamped v20140902-0626. 
Closest to 20150204 would be 3.10.2.v20150120-1634 - neither the micro version nor the qualifier really matches.

Where did he get that version from??</comment_text>
        </comment>
        <comment>
            <comment_id>2719878</comment_id>
            <comment_count>6</comment_count>
            <who>Ralf Thaenert</who>
            <commenter_username>ralf.thaenert</commenter_username>
            <when>2016-06-13 08:54:49 -0400</when>
            <comment_text>Created attachment 262405
Version information for which this bug does NOT occur</comment_text>
        </comment>
        <comment>
            <comment_id>2719879</comment_id>
            <comment_count>7</comment_count>
            <who>Ralf Thaenert</who>
            <commenter_username>ralf.thaenert</commenter_username>
            <when>2016-06-13 08:56:22 -0400</when>
            <comment_text>This version was at some point downloaded regularly from http://www.eclipse.org/downloads/ as far as i know. Updates might have been installed. 

Maybe the attachment helps?</comment_text>
        </comment>
        <comment>
            <comment_id>2719952</comment_id>
            <comment_count>8</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-13 10:35:53 -0400</when>
            <comment_text>I see the misunderstanding now: I asked for version of plugin org.eclipse.jdt.core, you answered the version of feature org.eclipse.jdt.

At that level, what you show perfectly matches 4.4.2.

BTW, @Jay: is that intended or a process glitch: to have jdt feature 3.10.1 in 4.4.2 holding jdt.core at 3.10.2? What I'm surprised about is the .1 in the feature version.</comment_text>
        </comment>
        <comment>
            <comment_id>2720128</comment_id>
            <comment_count>9</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-13 23:09:36 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #8)
&gt; I see the misunderstanding now: I asked for version of plugin
&gt; org.eclipse.jdt.core, you answered the version of feature org.eclipse.jdt.
&gt; 
&gt; At that level, what you show perfectly matches 4.4.2.
&gt; 
&gt; BTW, @Jay: is that intended or a process glitch: to have jdt feature 3.10.1
&gt; in 4.4.2 holding jdt.core at 3.10.2? What I'm surprised about is the .1 in
&gt; the feature version.

Let me also mention that jdt.ui might have a different version too. Anyway, I don't know the answer to your question.

Dani would know.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496503</id>
        <developer>Raffi Khatchadourian</developer>
        <developer_username>raffi.khatchadourian</developer_username>
        <dup_id/>
        <creation_time>2016-06-21 15:16:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>org.eclipse.jdt.core.ITypeHierarchy.getAllSuperInterfaces(IType) does not seem to consider interface hierarchy.</short_desc>
        <thetext>Consider the following example:

interface I {}
class A implements I {}

getAllSuperInterfaces(A) would return I, which is correct. Now, consider this example:

interface I {}
class A implements I {}
class B extends A {}

getAllSuperInterfaces(B) would return I as well, which is also correct. Finally, consider the following example:

interface I {}
interface J extends I {}
class A implements J {}

getAllSuperInterfaces(A) seems to *only* return J, but, I would argue that I is also a super interface of A. Henceforth, getAllSuperInterfaces(A) should return both I and J.

-- Configuration Details --
Product: Eclipse 4.5.2.20160218-0600 (org.eclipse.epp.package.committers.product)
Installed Features:
 org.eclipse.jdt 3.11.2.v20160212-1500</thetext>
        <comment>
            <comment_id>2724764</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-28 05:58:29 -0400</when>
            <comment_text>I agree. This is what the Javadoc of ITypeHierarchy.getAllSuperInterfaces(IType) says:


 * Returns all resolved superinterfaces (direct and indirect) of the given type.
 * If the given type is a class, this includes all superinterfaces of all superclasses.
 * An empty array is returned if there are no resolved superinterfaces for the
 * given type.

Will take a look little later.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497423</id>
        <developer>NoDataFound -</developer>
        <developer_username>baldurien</developer_username>
        <dup_id/>
        <creation_time>2016-07-06 16:33:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[content assist] A static method from generic type added to the favorites is not shown</short_desc>
        <thetext>Created attachment 262952
A sample project with a class that fails

Hello,

I am using Eclipse Neon on Windows 7x64 + JDK 1.8u92. This bug also appear on Eclipse Luna.

When I add a static import in Editor &gt; Content Assist &gt; Favorites whether it is a member import or a "all" (*) import, it is never proposed when using the method.

I've attached a zip containing two class for which the favorites content assist fails: please use the class fr.nodatafound.ide.p2.StaticImportFail to test for yourself:

class fr.nodatafound.ide.ClassWithGenericsAndStaticMethod&lt;A&gt; {
  public static &lt;A&gt; ClassWithGenericsAndStaticMethod&lt;A&gt; newGenericClassWithGenericMethod(A) {...}
  public static &lt;A&gt; ClassWithGenericsAndStaticMethod&lt;A&gt; newGenericClassWithObjectMethod(Object) {...}
}
class fr.nodatafound.ide.ClassWithoutGenericsAndStaticMethod {
  public static &lt;A&gt; ClassWithoutGenericsAndStaticMethod newClassWithGenericMethod(A) {...}
  public static &lt;A&gt; ClassWithoutGenericsAndStaticMethod newClassWithObjectMethod(Object) {...}
}


In the four cases, the static import fails either by no proposing the class, either by going completely wrong:

    final String value = null;
    // with type favorite: fr.nodatafound.ide.ClassWithGenericsAndStaticMethod.*
    // with type favorite: fr.nodatafound.ide.ClassWithoutGenericsAndStaticMethod.*

    // OK proposed fr.nodatafound.ide.ClassWithoutGenericsAndStaticMethod.newClassWithGenericMethod;
    newClassWithGenericMethod("a");

    // OK proposed fr.nodatafound.ide.ClassWithoutGenericsAndStaticMethod.newClassWithObjectMethod;
    newClassWithObjectMethod("b");

    // FAIL (propose to create private method)
    newGenericClassWithGenericMethod("c");

    // FAIL (propose to create private method)
    newGenericClassWithObjectMethod("d");

    // now remove the previous favorites and add to member favorites:
    // fr.nodatafound.ide.ClassWithGenericsAndStaticMethod.newGenericClassWithGenericMethod
    // fr.nodatafound.ide.ClassWithGenericsAndStaticMethod.newGenericClassWithObjectMethod
    // fr.nodatafound.ide.ClassWithoutGenericsAndStaticMethod.newClassWithGenericMethod
    // fr.nodatafound.ide.ClassWithoutGenericsAndStaticMethod.newClassWithObjectMethod

    // FAIL (propose to add fr.nodatafound.ide.newGenericClassWithGenericMethod;)
    newGenericClassWithGenericMethod("c");

    // FAIL (propose to add fr.nodatafound.ide.newGenericClassWithObjectMethod)
    newGenericClassWithObjectMethod("d");

    // OK proposed fr.nodatafound.ide.ClassWithoutGenericsAndStaticMethod.newClassWithGenericMethod
    newClassWithGenericMethod("a");

    // OK proposed  fr.nodatafound.ide.ClassWithoutGenericsAndStaticMethod.newClassWithObjectMethod;
    newClassWithObjectMethod("b");

    // with type favorite: java.util.Optional.*
    // with type favorite: java.util.OptionalInt.*

    // FAIL proposed to create private method
    ofNullable(null);

    // FAIL proposed java.util.OptionalInt.of
    of(value);

    // FAIL proposed java.util.OptionalInt.of
    of("A");

    // OK proposed java.util.OptionalInt.of
    of(1);

As you can see, it also fails with java.util.Optional, com.google.common.collect.ImmutableList and other classes of Guava.

The problem seems to appear when the class use generics: this is true at least for my test case, for Optional and ImmutableList.

The case with member favorites is very strange, because the parent class is completely removed.

Note: I have much more static import that the list I gave here. I don't think it conflicts ... and because there is no option to only export that list (I know the import/export preferences does it, but you can't select only these).

Is there a way to debug Eclipse (perhaps some logs) in determine what the algorithm is NOT doing ?</thetext>
        <comment>
            <comment_id>2730102</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-07-13 07:02:52 -0400</when>
            <comment_text>Reproducible with Eclipse Neon. 

See also bug 339789. 

Smaller example to reproduce the issue - Add "p.Test" as "New Type" in Favorites:

------------------------------------------------
package p;

public class Test2 {
	void m1() {
		doSome
	}
}

------------------------------------------------
package p;

public class Test&lt;T&gt; {
	public static void doSomething(String abc) {
	}
}

------------------------------------------------

Content assist works again when "&lt;T&gt;" is deleted in class "Test".</comment_text>
        </comment>
        <comment>
            <comment_id>2733626</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-07-25 21:57:41 -0400</when>
            <comment_text>Not sure I can take this up during Oxygen, but will keep it on my radar.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498032</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-07-18 01:56:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Provide support for --add-exports option</short_desc>
        <thetext>JEP 261 says this about this option:

Breaking encapsulation

It is sometimes necessary to violate the access-control boundaries defined by the module system, and enforced by the compiler and virtual machine, in order to allow one module to access some of the unexported types of another module. This may be desirable in order to, e.g., enable white-box testing of internal types, or to expose unsupported internal APIs to code that has come to depend upon them. The --add-exports option can be used, at both compile time and run time, to do this. Its syntax is:

--add-exports &lt;source-module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*

where &lt;source-module&gt; and &lt;target-module&gt; are module names and &lt;package&gt; is the name of a package.

The --add-exports option can be used more than once, but at most once for any particular combination of source module and package name.

The ModuleEnvironment should provide support and the batch compiler should leverage this via the new option.</thetext>
    </bug>
    <bug>
        <id>498501</id>
        <developer>Nikolay Metchev</developer>
        <developer_username>nikolaymetchev</developer_username>
        <dup_id/>
        <creation_time>2016-07-26 11:04:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>External Ant Builder refresh doesn't detect re-creation of source directory</short_desc>
        <thetext>Created attachment 263317
example workspace

I have attached a workspace which hopefully can be used to demonstrate the problem.

In the workspace there is a simple build.xml ant file.
The Test eclipse project is configured with an external Ant Builder to be run as part of the build and the clean.

The clean will delete the src/generated folder
The build will simply generate a very simple java file called GeneratedClass.java in the src/generated/java/p folder.

The external ant builder is configured to trigger whenever Trigger.txt is modified. The external ant builder is also configured to refresh the src folder and all its subfolders.

To reproduce the problem you have to run "ant clean" outside of eclipse.
This will delete the src/generated folder. This will correctly put the Test project in the error state saying missing source folder src/generated/java.

However if you then from within eclipse modify Trigger.txt which will in turn trigger the external ant builder to run and re-created the src/generated folder the eclipse error state doesn't go away.
The src/generated folder does correctly re-appear in the project view but the error in the problem view doesn't go away. Eclipse still complains that the src/generated/java folder is missing.</thetext>
        <comment>
            <comment_id>2734014</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-07-27 00:49:50 -0400</when>
            <comment_text>My guess is we don't do classpath validation that would have flushed the classpath markers. Looks like we don't take care of such changed that happen outside Eclipse.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500151</id>
        <developer>Goktug Gokdogan</developer>
        <developer_username>goktug</developer_username>
        <dup_id/>
        <creation_time>2016-08-23 13:00:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>ITypeBinding#getBinaryName() returns incorrect value for TypeVariable's defined by a generic method</short_desc>
        <thetext>Per http://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1:

"The binary name of a type variable declared by a generic method (§8.4.4) is the binary name of the type declaring the method, followed by $, followed by the descriptor of the method (JVMS §4.3.3), followed by $, followed by the simple name of the type variable.:


JLS defines the name of the method as part of the binary name; since it is missing; the API doesn't correctly follow its contract and the generated names are not unique.

Also see https://bugs.eclipse.org/bugs/show_bug.cgi?id=107001</thetext>
        <comment>
            <comment_id>2743055</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-24 02:40:44 -0400</when>
            <comment_text>Keeping tentatively in 4.7.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500170</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-08-24 03:09:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Command line compiler puts the module-info.class in wrong location</short_desc>
        <thetext>I ran a simple test with the following command:

java -jar ecj.jar -modulesourcepath src -d C:\JDT\tools\ecj\mods src\mod.one\module-info.java

This is supposed to compiler just the module-info.java in mod.one into mods\mod.one\module.info.class. However, ECJ generates the class directly inside mods. This is not inline with Javac.</thetext>
        <comment>
            <comment_id>2743064</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-24 03:10:57 -0400</when>
            <comment_text>When the module-info.java is not specified in command line, like below:

java -jar ecj.jar -modulesourcepath src -d C:\JDT\tools\ecj\mods

The module-info.class can be found in the right place, i.e. mods\mod.one.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500410</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-08-29 06:16:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Unnamed modules should have access only to exported packages</short_desc>
        <thetext>As per the State of the Module, unnamed modules should not see unexported packages in other named modules. Current ECJ behavior is not correct. I even see this comment in ModuleCompilationTests.test019().

// Unnamed module tries to access a type from an unexported package successfully. 

Both the test and code need change. 

Another error in the test is it takes sun.management package is unexported. But the package is exported by the java.management module.

I have a patch that I am testing right now.</thetext>
    </bug>
    <bug>
        <id>500905</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-09-06 05:54:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Read modules from JMOD</short_desc>
        <thetext>Jigsaw introduces a new format to pack Java modules - JMOD. Although the new archive format is based on ZIP format, the folder structure within the archive is different from that of a JAR. Unlike the JAR, the JMOD contains several top level folders, one of which (classes) contains all the class files. The other top level folders in some examples are bin, conf and native. I am not sure if the list is limited to these. In any case, my 'guess' is, the compiler is only interested in 'classes'.</thetext>
        <comment>
            <comment_id>2750534</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-14 01:27:36 -0400</when>
            <comment_text>Created attachment 264138
Proof that JMOD can be read like a JAR

Here's a half-baked patch that proves that JMOD files can be read just like ZIP/JAR files. The patch is far from complete, as the compiler still doesn't get the class file contents. But the package explorer shows the contents, although the "classes" sub folder should be removed. I will take this up again at a suitable time.

Just a thought (could be wrong) but we might also require a new IPackageFragmentRoot.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501101</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-09-08 15:07:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[test]BatchCompilerTest#testBug419351() doesn't test endorsed folder</short_desc>
        <thetext>(In reply to Jay Arthanareeswaran from bug 466944 comment #9)
&gt; At least one of those tests (testBug419351() ) seems to be about endorsed
&gt; directory, which is removed in JRE 9?

BatchCompilerTest#testBug419351() is bogus.

     System.setProperty("java.endorsed.dirs", endorsedPath)

doesn't affect the separate javac process. You would have to pass "-Djava.endorsed.dirs=" on the command line to test endorsed directories.

Once the test is fixed, it will fail when run with JRE 9. AbstractCompilerTest#isJRE9 can be used to disable the test in that case.</thetext>
        <comment>
            <comment_id>2770800</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-28 02:46:07 -0400</when>
            <comment_text>Bulk change, moving out all bugs that couldn't make it to M3.</comment_text>
        </comment>
        <comment>
            <comment_id>2783096</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-05 23:42:13 -0500</when>
            <comment_text>Sorry, missed out. Moving out to M5.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501243</id>
        <developer>Frank Benoit</developer>
        <developer_username>frank.rene.benoit</developer_username>
        <dup_id/>
        <creation_time>2016-09-12 08:33:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Code completion does not show enum types nested in a base interface.</short_desc>
        <thetext>Created attachment 264100
Suggestion MyEnum is missing

This was working in Eclipse 4.4.1.

In Eclipse Neon, the suggestion of "MyEnum" is not shown. See screenshot.
And attached source files.</thetext>
        <comment>
            <comment_id>2749608</comment_id>
            <comment_count>1</comment_count>
            <who>Frank Benoit</who>
            <commenter_username>frank.rene.benoit</commenter_username>
            <when>2016-09-12 08:33:54 -0400</when>
            <comment_text>Created attachment 264101
BaseItf</comment_text>
        </comment>
        <comment>
            <comment_id>2749610</comment_id>
            <comment_count>2</comment_count>
            <who>Frank Benoit</who>
            <commenter_username>frank.rene.benoit</commenter_username>
            <when>2016-09-12 08:34:14 -0400</when>
            <comment_text>Created attachment 264102
TopItf</comment_text>
        </comment>
        <comment>
            <comment_id>2749611</comment_id>
            <comment_count>3</comment_count>
            <who>Frank Benoit</who>
            <commenter_username>frank.rene.benoit</commenter_username>
            <when>2016-09-12 08:34:29 -0400</when>
            <comment_text>Created attachment 264103
Use</comment_text>
        </comment>
        <comment>
            <comment_id>2749953</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-13 02:35:26 -0400</when>
            <comment_text>For easy reference, here are the classes involved:

package prj;
public class Use {
	static int myVal = TopItf.MyEnum.ONE.ordinal();
}
interface BaseItf {
	public enum MyEnum { ONE, TWO; }
}
interface TopItf extends BaseItf {
	enum Sec {};
	void func();
}

One more observation is that if we use BaseItf.MyE|, the completion is offered. And this is in sync with the following code in CompletionEngine:

if (this.insideQualifiedReference
    || typeName.length == 0) { // do not search up the hierarchy
         findMemberTypes(...

Basically, we don't bother with the super types or interfaces if the qualified name is used. It seems to suggest we expect the user to use the exact type that contains the member type. It can be argued that because this code is allowed, we should offer the completion as well, which I agree with.

Keeping it in my 4.7 list.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501327</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-09-13 07:30:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Reconciler throws ClassCastException: BaseTypeBinding cannot be cast to ArrayBinding</short_desc>
        <thetext>This is same as bug 500673, except that the use cases triggering this bug is different. The same use case mentioned in bug 500673 can be used, but for making people's life easier, I inline them here:

final class mfa implements mfi {
} 

interface mfi {
    public transient void a(Throwable throwable);
}

The use cases need to be checked are full-build and reconciliation.</thetext>
        <comment>
            <comment_id>2750309</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-13 11:34:43 -0400</when>
            <comment_text>In particular, all consumers of AST that do not trigger LE.completeTypeBindings() are probably affected.

OTOH, the given example is a weird corner case to begin with :)</comment_text>
        </comment>
        <comment>
            <comment_id>2770806</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-28 02:46:20 -0400</when>
            <comment_text>Bulk change, moving out all bugs that couldn't make it to M3.</comment_text>
        </comment>
        <comment>
            <comment_id>2770992</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-28 08:50:47 -0400</when>
            <comment_text>See also the preliminary analysis in bug 500673 comment 11 ff.</comment_text>
        </comment>
        <comment>
            <comment_id>2783095</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-05 23:38:54 -0500</when>
            <comment_text>No time in M4, moving out.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>504051</id>
        <developer>lala lala</developer>
        <developer_username>h1976763</developer_username>
        <dup_id/>
        <creation_time>2016-10-05 06:23:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>context assintant doesn't always work on lambda</short_desc>
        <thetext>Considering following code:

public class La {
    public static void main(String [] args)  {		 		
        La l = new La();
	String res = l.calc((a, b) -&gt; "sum:" + (a.intValue() + b.intValue()), new Integer(2), new Integer(2));
        System.out.println(res);	
    }

    public String calc(BiFunction&lt;Integer, Integer, String&gt; bi, Integer i1, Integer i2) {
        return bi.apply(i1, i2);
    }
}

Context assistant does not work when cursor placed just after "a." in statement "a.intValue()", but it works when placed after "b." 
"a" is however correctly recognized as Integer, but context assistant only correctly works on "b".</thetext>
        <comment>
            <comment_id>2760774</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-05 06:34:50 -0400</when>
            <comment_text>Reproduced, will take a look during 4.7.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>504095</id>
        <developer>Igor Fedorenko</developer>
        <developer_username>igor</developer_username>
        <dup_id/>
        <creation_time>2016-10-05 11:08:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Content assist confused by @interface-typed elements</short_desc>
        <thetext>Using eclipse 4.6.1, I do not see expected content assist proposals when expression is assigned to @interface-typed variable. Content assist works as expected if target type is a regular class. Here is a small example.

    static @interface Parameter {
    }
  
    void method(Class&lt;?&gt; clazz) {
      for (Field member : clazz.getDeclaredFields()) {
        Parameter parameter = memb
                              //  ^ content assist does not offer "member"
      }
    }</thetext>
        <comment>
            <comment_id>2765463</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-12 03:58:05 -0400</when>
            <comment_text>Reproduced in master. Tentatively marking for M3.</comment_text>
        </comment>
        <comment>
            <comment_id>2770804</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-28 02:46:18 -0400</when>
            <comment_text>Bulk change, moving out all bugs that couldn't make it to M3.</comment_text>
        </comment>
        <comment>
            <comment_id>2783099</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-05 23:58:34 -0500</when>
            <comment_text>Sorry, this has to be moved out to M5.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506004</id>
        <developer>Brian McNamara</developer>
        <developer_username>brianmay27</developer_username>
        <dup_id/>
        <creation_time>2016-10-14 12:33:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Compiler - EclipseCompilerImpl reports warnings when annotations should suppress.</short_desc>
        <thetext>Created attachment 264866
Proposed fix

The issue is with the EclipseCompilerImpl class. It overrides the getProblemFactory and the loggingExtraProblems and reports the warnings directly to the logger. 

After debugging it appears that the annotation processor is invoked downstream from the problemFactory and filters whether it should be logged a bit later. 

To reproduce:
The easiest way to reproduce is to use Intellij which uses the JavaCompiler interface which uses the EclipseCompilerImpl underneath. If you really don't want to use Intellij, you can tap into the JavaCompiler interface and create a simple compiler project.

Once you have a compiler, create a simple project with a Main class/method
Create a unchecked cast (Object to Map) or however you want to use the annotation support. 

If you compile via Intellij and via the command line 
(java -jar path/to/ecj.jar -noExit -g -deprecation -proceedOnError -properties /Users/brian.mcnamara/projects/SimpleJavaTester/.settings/org.eclipse.jdt.core.prefs -encoding UTF-8 -source 1.6 -target 1.6 -s /Users/brian.mcnamara/projects/SimpleJavaTester/out/production/HelloWorld/generated /Users/brian.mcnamara/projects/SimpleJavaTester/src/Main.java)
You should expect a warning

Now add a @SupressWarning("unchecked") to the method (or the line) and again compile. You will notice Command line respects the annotation processor where as Intellij (EclipseCompilerImpl) still reports it as a warning.


See attachment for what my proposed solution is (Im no expert in this class so please review and let me know what you end up doing)

P.S. While poking around I found what appears to be unused code which I removed... If there is a real purpous maybe add a comment but I removed it on my end.

--Brian</thetext>
        <comment>
            <comment_id>2766811</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-14 16:04:22 -0400</when>
            <comment_text>What you propose seems to partially revert (wrt EclipseCompiler.java) commit ccd12469d7fc21a8e1a0a597451a059df56002ad which claims:
   Fixes for 192774, 189799 and 191082
but in none of the referenced bugs can I see any connection to the change in EclipseCompiler.java


Not the best starting point for understanding the situation based on software archeology :(</comment_text>
        </comment>
        <comment>
            <comment_id>2766947</comment_id>
            <comment_count>2</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-15 15:14:07 -0400</when>
            <comment_text>GitHub Pull Request 8 created by [brian-mcnamara]
https://github.com/eclipse/eclipse.jdt.core/pull/8</comment_text>
        </comment>
        <comment>
            <comment_id>2766949</comment_id>
            <comment_count>3</comment_count>
            <who>Brian McNamara</who>
            <commenter_username>brianmay27</commenter_username>
            <when>2016-10-15 15:22:55 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #1)
&gt; What you propose seems to partially revert (wrt EclipseCompiler.java) commit
&gt; ccd12469d7fc21a8e1a0a597451a059df56002ad which claims:
&gt;    Fixes for 192774, 189799 and 191082
&gt; but in none of the referenced bugs can I see any connection to the change in
&gt; EclipseCompiler.java
&gt; 
&gt; 
&gt; Not the best starting point for understanding the situation based on
&gt; software archeology :(

Yeah :/ Now that I look at the commit its not too clear why it was added. I submitted a PR but I left out this as its not necessary to fix this bug. Did want to point it out as it for sure seems unused and unneeded but maybe that should be another bug/investigation :)</comment_text>
        </comment>
        <comment>
            <comment_id>2767079</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-16 23:45:43 -0400</when>
            <comment_text>I am not sure either. Will take a close look later during 4.7 time permitting.</comment_text>
        </comment>
        <comment>
            <comment_id>2767539</comment_id>
            <comment_count>5</comment_count>
            <who>Brian McNamara</who>
            <commenter_username>brianmay27</commenter_username>
            <when>2016-10-18 03:04:57 -0400</when>
            <comment_text>I added a test based on my fix. Also helps demonstrate the issue.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506426</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-10-24 07:14:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[test] Resources apparently locked during tests</short_desc>
        <thetext>There seems to be a problem in some of the resources created/used by tests:

WARNING in test: org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite$1 - protect
	- problems occured while deleting resource P/JavaSearchBugs
	- stack trace:
		-&gt; org.eclipse.jdt.core.tests.util.Util.waitUntilResourceDeleted(Util.java:1299)
		-&gt; org.eclipse.jdt.core.tests.util.Util.delete(Util.java:446)
		-&gt; org.eclipse.jdt.core.tests.model.AbstractJavaModelTests.deleteResource(AbstractJavaModelTests.java:1881)
		-&gt; org.eclipse.jdt.core.tests.model.AbstractJavaModelTests.deleteProject(AbstractJavaModelTests.java:1849)
		-&gt; org.eclipse.jdt.core.tests.model.JavaSearchBugs8Tests.tearDownSuite(JavaSearchBugs8Tests.java:130)
		-&gt; org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite$1.protect(SuiteOfTestCases.java:81)

Need to investigate whether this is test only issue or there's something in the component. To reproduce, just run AllJavaModelTests test suite alone.</thetext>
    </bug>
    <bug>
        <id>506469</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-10-24 17:13:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] codeSelect for modules does not spawn module name</short_desc>
        <thetext>Code select now works on the segments, e.g. for "foo.bar", it works on "foo" and on "bar", instead on "foo.bar". Which means one can see the hyperlink on "foo" and on "bar" as instead on "foo.bar".</thetext>
    </bug>
    <bug>
        <id>506878</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-11-02 04:57:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Provide means to support automatic modules</short_desc>
        <thetext>Automatic modules are important in the migration path to completely module based systems. The compiler should, both in the IDE and command line avatar, provide means to support automatic modules. As far as the command line tool is concerned, we can simply look for plain old JARs in the -modulepath and promote them to automatic modules. However, the IDE is going to need more than that. To start with, we will need a new IClasspathAttribute and support in the UI as well (I will create a new bug for this later).</thetext>
        <comment>
            <comment_id>2777962</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-21 01:21:53 -0500</when>
            <comment_text>I am taking this up now.</comment_text>
        </comment>
        <comment>
            <comment_id>2777964</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-21 01:48:48 -0500</when>
            <comment_text>Important requirements for an automatic module, from the SOTM, not yet in any official doc, though:

1. an automatic module is made to read every other named module, whether automatic or explicit
2. Every package in an automatic module is, therefore, considered to be exported even if it might actually be intended only for internal use
3. An automatic module therefore grants implied readability to all other automatic modules</comment_text>
        </comment>
        <comment>
            <comment_id>2779081</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-23 06:34:02 -0500</when>
            <comment_text>Created attachment 265542
Proposed fix

Will soon add tests to the patch. A significant portion of the changes are due to renaming IModuleEnvironment to IModuleLocation. This is done so people don't mix this with IModuleAwareNameEnvironment.</comment_text>
        </comment>
        <comment>
            <comment_id>2779409</comment_id>
            <comment_count>4</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-24 00:35:14 -0500</when>
            <comment_text>(In reply to comment #3)
&gt; Created attachment 265542
&gt; Proposed fix
&gt; 
&gt; Will soon add tests to the patch. A significant portion of the changes are due
&gt; to renaming IModuleEnvironment to IModuleLocation. This is done so people don't
&gt; mix this with IModuleAwareNameEnvironment.

Many compile errors with the patch, looks like the refactoring didn't go well. Are you sure it's the right patch from the right branch? Or could it be something with my workspace?</comment_text>
        </comment>
        <comment>
            <comment_id>2779410</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-24 01:02:44 -0500</when>
            <comment_text>(In reply to Sasikanth Bharadwaj from comment #4)
&gt; Many compile errors with the patch, looks like the refactoring didn't go
&gt; well. Are you sure it's the right patch from the right branch? Or could it
&gt; be something with my workspace?

Turns out my repo was behind origin. Will adjust the code and post the patch.</comment_text>
        </comment>
        <comment>
            <comment_id>2779923</comment_id>
            <comment_count>6</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-25 00:05:32 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85737</comment_text>
        </comment>
        <comment>
            <comment_id>2780409</comment_id>
            <comment_count>7</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-27 21:48:18 -0500</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/85737 was merged to [BETA_JAVA9].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=04ca4c9cd4a2f15abd74d1eb904bcd80b765934d</comment_text>
        </comment>
        <comment>
            <comment_id>2780433</comment_id>
            <comment_count>8</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-28 03:33:21 -0500</when>
            <comment_text>Jay, I think explicit modules still need to add a requires statement to be able to read automatic modules, 'automatic' really only applies to the module definition, which is implicit and not to the inclusion in module graph. I guess this statement in SOTMS implies that.
This will define an observable module whose name, org.baz.qux, is derived from that of the JAR file so that other, non-automatic modules can depend upon it in the usual way:
The usual way, I'd assume is by adding a requires statement to the module-info. Although, there is no way for us to be sure about it until the spec is out, I have tried a quick example with javac ea 142 that confirms this behavior, and I'd like to believe that is what makes most sense because that is what would be easiest to implement :-). With that restriction, I believe our implementation can be simplified a lot. What am I missing?</comment_text>
        </comment>
        <comment>
            <comment_id>2780437</comment_id>
            <comment_count>9</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-28 03:46:42 -0500</when>
            <comment_text>(In reply to Sasikanth Bharadwaj from comment #8)
&gt; Jay, I think explicit modules still need to add a requires statement to be
&gt; able to read automatic modules, 'automatic' really only applies to the
&gt; module definition, which is implicit and not to the inclusion in module
&gt; graph. I guess this statement in SOTMS implies that.
&gt; This will define an observable module whose name, org.baz.qux, is derived
&gt; from that of the JAR file so that other, non-automatic modules can depend
&gt; upon it in the usual way:

I didn't pay enough attention to that. Thanks for pointing out and confirming with Javac behavior.

&gt; The usual way, I'd assume is by adding a requires statement to the
&gt; module-info. Although, there is no way for us to be sure about it until the
&gt; spec is out, I have tried a quick example with javac ea 142 that confirms
&gt; this behavior, and I'd like to believe that is what makes most sense because
&gt; that is what would be easiest to implement :-). With that restriction, I
&gt; believe our implementation can be simplified a lot. 

Indeed, some part of the released fix can be simplified. I will take care of this.</comment_text>
        </comment>
        <comment>
            <comment_id>2780440</comment_id>
            <comment_count>10</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-28 03:50:16 -0500</when>
            <comment_text>Curious question: What happens if there are two jar files with same name (different locations, of course) and want to be promoted to modules? Just let them be promoted and let the module system report on them?</comment_text>
        </comment>
        <comment>
            <comment_id>2780444</comment_id>
            <comment_count>11</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-28 03:55:53 -0500</when>
            <comment_text>I will try with javac, see what happens and update :-)</comment_text>
        </comment>
        <comment>
            <comment_id>2780482</comment_id>
            <comment_count>12</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-28 04:51:26 -0500</when>
            <comment_text>(In reply to Sasikanth Bharadwaj from comment #11)
&gt; I will try with javac, see what happens and update :-)

There's some more doc on this in the sotm:

"Many existing JAR files can be used as automatic modules, but some cannot. If two or more JAR files on the class path contain types in the same package then at most one of them can be used as an automatic module, since the module system still guarantees that every named module reads at most one named module defining a given package and that named modules defining identically-named packages do not interfere with each other. In such situations it often turns out that only one of the JAR files is actually needed. If the others are duplicates or near-duplicates, somehow placed on the class path by mistake, then one can be used as an automatic module and the others can be discarded. If, however, multiple JAR files on the class path intentionally contain types in the same package then on the class path they must remain."</comment_text>
        </comment>
        <comment>
            <comment_id>2780491</comment_id>
            <comment_count>13</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-28 05:07:57 -0500</when>
            <comment_text>I skimmed the document and I can't find anywhere that named modules get precedence over automatic modules. I will not revert that part, however, until we have the spec to confirm.</comment_text>
        </comment>
        <comment>
            <comment_id>2780616</comment_id>
            <comment_count>14</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-28 10:17:35 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85878</comment_text>
        </comment>
        <comment>
            <comment_id>2780805</comment_id>
            <comment_count>15</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-29 00:33:46 -0500</when>
            <comment_text>(In reply to Eclipse Genie from comment #14)
&gt; New Gerrit change created: https://git.eclipse.org/r/85878

There's one additional rule that is missing from the patch:

In addition to reading every other named module, an automatic module is also made to read the "unnamed module".</comment_text>
        </comment>
        <comment>
            <comment_id>2780820</comment_id>
            <comment_count>16</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-29 02:05:26 -0500</when>
            <comment_text>Jay, I see an OutOfMemoryError when I start my runtime workbench, which I believe occurs because we are writing a new boolean into the State but not handling it when reading. 

Here's the stack trace

java.lang.OutOfMemoryError: Java heap space
	at org.eclipse.jdt.internal.compiler.util.SimpleLookupTable.&lt;init&gt;(SimpleLookupTable.java:37)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:291)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:150)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4018)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2219)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:422)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.isWorthBuilding(JavaBuilder.java:690)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:171)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:735)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:301)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:304)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:360)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:383)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:142)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:232)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:56)</comment_text>
        </comment>
        <comment>
            <comment_id>2780822</comment_id>
            <comment_count>17</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-29 02:08:36 -0500</when>
            <comment_text>(In reply to Sasikanth Bharadwaj from comment #16)
&gt; Jay, I see an OutOfMemoryError when I start my runtime workbench, which I
&gt; believe occurs because we are writing a new boolean into the State but not
&gt; handling it when reading. 
&gt; 

Actually, I think it is because we try to read it the first time, but it was never written. I saw that too, but at this point not sure how we handle it the first time we add a new attribute.</comment_text>
        </comment>
        <comment>
            <comment_id>2780859</comment_id>
            <comment_count>18</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-29 03:54:43 -0500</when>
            <comment_text>(In reply to comment #17)
&gt; (In reply to Sasikanth Bharadwaj from comment #16)
&gt; &gt; Jay, I see an OutOfMemoryError when I start my runtime workbench, which I
&gt; &gt; believe occurs because we are writing a new boolean into the State but not
&gt; &gt; handling it when reading.
&gt; &gt;
&gt; 
&gt; Actually, I think it is because we try to read it the first time, but it was
&gt; never written. I saw that too, but at this point not sure how we handle it the
&gt; first time we add a new attribute.
Oh, ok :-(</comment_text>
        </comment>
        <comment>
            <comment_id>2782711</comment_id>
            <comment_count>19</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-05 01:47:23 -0500</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/85878 was merged to [BETA_JAVA9].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=d5754530cfb724106e94c36adc5d9f821553ee05</comment_text>
        </comment>
        <comment>
            <comment_id>2782747</comment_id>
            <comment_count>20</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-05 04:08:20 -0500</when>
            <comment_text>(In reply to Eclipse Genie from comment #19)
&gt; Gerrit change https://git.eclipse.org/r/85878 was merged to [BETA_JAVA9].
&gt; Commit:
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
&gt; ?id=d5754530cfb724106e94c36adc5d9f821553ee05

This commit includes fixes for issues reported in comment #8 and comment #16.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506935</id>
        <developer>Andras Kerekes</developer>
        <developer_username>akerekes</developer_username>
        <dup_id/>
        <creation_time>2016-11-02 15:10:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Custom user agent for javadoc http connections</short_desc>
        <thetext>org.eclipse.jdt.internal.core.JavaElement.getURLContents(URL, String) does not set a user agent, thus uses the default one set by the JDK. Some CDN providers (CloudFlare is one of them) by default uses a browser integrity check (https://support.cloudflare.com/hc/en-us/articles/200170086-What-does-the-Browser-Integrity-Check-do-) that filters out requests that have 'Java/*' as user agent (and possibly others as well) and responds with an HTTP 403. It would be useful, if the request would set a different user agent, e.g.: 'Eclipse JDT/&lt;version&gt;'.

Possible workarounds:
1. use -Dhttp.agent="&lt;something other than Java/*&gt;"
2. get in touch with the site's maintainer that is hosted on the CDN and ask them to turn off/customize this check</thetext>
        <comment>
            <comment_id>2772512</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-03 01:34:25 -0400</when>
            <comment_text>(In reply to Andras Kerekes from comment #0)
&gt; It
&gt; would be useful, if the request would set a different user agent, e.g.:
&gt; 'Eclipse JDT/&lt;version&gt;'.

This sounds reasonable to me, although it will just be a dummy user agent, as what eventually renders the HTML is the system's browser.</comment_text>
        </comment>
        <comment>
            <comment_id>2772725</comment_id>
            <comment_count>2</comment_count>
            <who>Brian de Alwis</who>
            <commenter_username>bsd</commenter_username>
            <when>2016-11-03 11:43:45 -0400</when>
            <comment_text>This can currently be seen when setting a Javadoc location for a library to something hosted on static.javadocs.io.

$ curl —silent --show-error --head -A Java/1.8 \
   'http://static.javadoc.io/com.googlecode.objectify/objectify/5.1.13/com/googlecode/objectify/ObjectifyFactory.html'
HTTP/1.1 403 Forbidden
Date: Thu, 03 Nov 2016 15:41:16 GMT
[snip]</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507936</id>
        <developer>David Karnok</developer>
        <developer_username>akarnokd</developer_username>
        <dup_id/>
        <creation_time>2016-11-22 06:27:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Show declaration (F3) on a method not working if followed by some lambda with { }</short_desc>
        <thetext>Eclipse Java EE IDE for Web Developers.

Version: Neon.1a Release (4.6.1)
Build id: 20161007-1200

Given the following class in a plain Java 8 project:


import java.util.function.*;

public class A {
    public static class C {
        public C m() {
            return this;
        }
   
        public s(Consumer&lt;Object&gt; a, Consumer&lt;Object&gt; b) {
        }
    }

    public static void main(String[] args) {
        new C().m().s(v -&gt; System.out.println(v), e -&gt; { System.out.println(e); });
    }
}

Using F3 or CTRL+Click on "m" doesn't work but works for "C", "s" or anything else in that line. If I remove the { } from the second lambda:

        new C().m().s(v -&gt; System.out.println(v), e -&gt; System.out.println(e));

CTRL+Click works for "m" as well.

If I add { } to the first lambda, CLTR+Click on "m" stops working again:

        new C().m().s(v -&gt;  { System.out.println(v); }, e -&gt; System.out.println(e));

(There are no compilation errors.)</thetext>
        <comment>
            <comment_id>2778583</comment_id>
            <comment_count>1</comment_count>
            <who>David Karnok</who>
            <commenter_username>akarnokd</commenter_username>
            <when>2016-11-22 06:49:45 -0500</when>
            <comment_text>If I add a semicolon before the expression:

;

new C().m().s(v -&gt; System.out.println(v), e -&gt; { System.out.println(e); });


CTLR+Click works on "m"</comment_text>
        </comment>
        <comment>
            <comment_id>2778621</comment_id>
            <comment_count>2</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-11-22 07:50:46 -0500</when>
            <comment_text>It's a bug in ICodeAssist.codeSelect(..) which does not return any Java element in this case. Moving to JDT/Core.</comment_text>
        </comment>
        <comment>
            <comment_id>2778687</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-22 09:52:29 -0500</when>
            <comment_text>Tentatively targeting 4.7.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508222</id>
        <developer>Ian Robertson</developer>
        <developer_username>ianbrobertson</developer_username>
        <dup_id/>
        <creation_time>2016-11-25 17:25:00 -0500</creation_time>
        <product>JDT</product>
        <component>APT</component>
        <short_desc>getEnclosingType fails to return type of kind NONE for DeclaredType for static member class</short_desc>
        <thetext>Created attachment 265592
Pair of projects which demonstrate the bug

According to the javadoc for javax.lang.model.type.DeclaredType.getEnclosingType, "Only types corresponding to inner classes have an enclosing instance." Because only non-static member types are considered inner classes, an annotation processor looking at the DeclaredType representing a static member class should see a NoType of kind None when invoking getEnclosingType(). Unfortunately, the eclipse annotation processor instead returns a DeclaredType referencing the containing class of the static member type.

An unfortunate side effect of this is that it makes it impossible for an annotation processor to determine if a nested type has a no-argument constructor. Calling getParameters on the ExecutableElement representing the constructor of an inner class returns a list that does not include the synthetic parameter referencing the "outer this". Only by knowing that a class is an inner class can an annotation processor conclude the existence of this parameter. This, combined with violation of the spec, is why I've chosen to give this bug an initial severity of major.

I've attached a pair of maven/eclipse projects which demonstrate the bug. The first, EclipseAnnotationBug, defines an annotation, @ShowEnclosingType, and an annotation processor for @ShowEnclosingType which will emit a warning with the enclosing type and its TypeKind. The second project, EclipseAnnotationBugWitness, has a single class with two member types. The first, Inner, is a non-static member class, while the second, StaticMember, is a static member type. When running mvn compile on the EclipseAnnotationBugWitness project, the following warnings are printed:

Enclosing type Witness of Witness.Inner is of type DECLARED
Enclosing type none of Witness.StaticMember is of type NONE

However, the same project in eclipse shows the following warnings:

Enclosing type Witness of Witness.Inner is of type DECLARED
Enclosing type Witness of Witness.StaticMember is of type DECLARED

The second warning is evidence of the bug.</thetext>
        <comment>
            <comment_id>2780319</comment_id>
            <comment_count>1</comment_count>
            <who>Walter Harley</who>
            <commenter_username>eclipse</commenter_username>
            <when>2016-11-26 16:43:18 -0500</when>
            <comment_text>Yep, that looks like a bug to me too.  The javadoc in Java 6 says the same thing.</comment_text>
        </comment>
        <comment>
            <comment_id>2780410</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-28 00:13:22 -0500</when>
            <comment_text>Will take a look.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508302</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-11-28 10:15:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Adopt new layout of JDK's src.zip  ($MODULE/$PACKAGE/*.java)</short_desc>
        <thetext>https://bugs.openjdk.java.net/browse/JDK-8062810
http://mail.openjdk.java.net/pipermail/jigsaw-dev/2016-October/009550.html

It looks like b143 will change the layout of sources in the JDK's src.zip to:

$MODULE/$PACKAGE/*.java

We need to
- support this layout in the SourceMapper and maybe elsewhere,
- add support for reading $MODULE/module-info.java 
- adjust Javadoc of IClasspathEntry#getSourceAttachmentRootPath()
- make sure source attachments for non-modular classpath entries continue to work</thetext>
        <comment>
            <comment_id>2780804</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-29 00:27:37 -0500</when>
            <comment_text>The proposal also mentions about bundling the sources for both the JDK and JavaFX in one zip.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508709</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-12-06 01:31:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[tests] Fix the Discouraged access warnings in jdt.core.tests.model</short_desc>
        <thetext>There are several Discouraged access warnings in jdt.core.tests.model in the official build, such as the latest:

http://download.eclipse.org/eclipse/downloads/drops4/I20161205-2000/compilelogs/plugins/org.eclipse.jdt.debug_3.11.0.v20161130-0636/jdimodel.jar.html#DISCOURAGED_WARNINGS

Currently in dev environment this is set to ignore, so we don't see them. When we have time, we should look at these and either fix these or make an exception for this project in tycho set up.</thetext>
        <comment>
            <comment_id>2783334</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-06 09:44:26 -0500</when>
            <comment_text>And here's the link for jdt.core.tests.model: http://download.eclipse.org/eclipse/downloads/drops4/I20161205-2000/compilelogs/plugins/org.eclipse.jdt.core.tests.model_3.10.300.v20161205-1547/@dot.html

:)

Of course that link will go stale soon. 
Extracting the the first few from a long list, the warnings affect references to

- org.eclipse.jdt.internal.formatter.DefaultCodeFormatter
- fields of DefaultCodeFormatterOptions
- org.eclipse.jdt.internal.compiler.impl.CompilerOptions
- org.eclipse.jdt.internal.core.search.matching.PatternLocator
- org.eclipse.jdt.internal.core.ClasspathEntry
- ...

&gt; Currently in dev environment this is set to ignore, so we don't see them.

Should we just change our settings to "warning"?

Otherwise, with latest compiler when we use @SuppressWarnings("restriction"), we'd get the following info as the answer:

  At least one of the problems in category 'restriction' is not analysed due to a compiler option being ignored

:)</comment_text>
        </comment>
        <comment>
            <comment_id>2783335</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-06 09:47:56 -0500</when>
            <comment_text>I quickly pondered about added core.tests.model to the x-friends of the corresponding packages, but so far we don't use x-friends for tests, only for things like APT and API tools. Is that a conscious decision or mere coincidence?</comment_text>
        </comment>
        <comment>
            <comment_id>2783635</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-06 23:17:20 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #2)
&gt; I quickly pondered about added core.tests.model to the x-friends of the
&gt; corresponding packages, but so far we don't use x-friends for tests, only
&gt; for things like APT and API tools. Is that a conscious decision or mere
&gt; coincidence?

Not sure. Will there be any problems for consumers of jdt.core in the absence of test.model bundles? 

(In reply to Stephan Herrmann from comment #1)
&gt; Should we just change our settings to "warning"?

There are quite a few places to fix and more than 4000 warnings as of today. Do you see problems with making the tycho build reflect our dev environment preference of "ignore" ?</comment_text>
        </comment>
        <comment>
            <comment_id>2784100</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-07 15:38:24 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #3)
&gt; There are quite a few places to fix and more than 4000 warnings as of today.
&gt; Do you see problems with making the tycho build reflect our dev environment
&gt; preference of "ignore" ?

Even if 4000 warnings can be silenced by - say - 50 class-level @SW, telling tycho to be more lenient sounds fine to me.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508799</id>
        <developer>Rostyslav Smirnov</developer>
        <developer_username>rostyslav_smirnov</developer_username>
        <dup_id/>
        <creation_time>2016-12-06 17:41:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Incremental compile produces invalid errors</short_desc>
        <thetext>Since Eclipse 4.6 editing certain classes with "Build Automatically" enabled produces invalid compile errors. Compilation succeeds after cleaning the project. Compilation using Java compiler also succeeds.

Steps to Reproduce:
1) Create a Java project with attached source files.
2) Enable "Build Automatically".
3) Edit the body of class C in some way that should compile and note that there are errors.
4) Clean the project and note that the errors are gone.</thetext>
        <comment>
            <comment_id>2783603</comment_id>
            <comment_count>1</comment_count>
            <who>Rostyslav Smirnov</who>
            <commenter_username>rostyslav_smirnov</commenter_username>
            <when>2016-12-06 17:43:02 -0500</when>
            <comment_text>Created attachment 265737
A.java</comment_text>
        </comment>
        <comment>
            <comment_id>2783604</comment_id>
            <comment_count>2</comment_count>
            <who>Rostyslav Smirnov</who>
            <commenter_username>rostyslav_smirnov</commenter_username>
            <when>2016-12-06 17:43:21 -0500</when>
            <comment_text>Created attachment 265738
B1.java</comment_text>
        </comment>
        <comment>
            <comment_id>2783605</comment_id>
            <comment_count>3</comment_count>
            <who>Rostyslav Smirnov</who>
            <commenter_username>rostyslav_smirnov</commenter_username>
            <when>2016-12-06 17:43:47 -0500</when>
            <comment_text>Created attachment 265739
B2.java</comment_text>
        </comment>
        <comment>
            <comment_id>2783606</comment_id>
            <comment_count>4</comment_count>
            <who>Rostyslav Smirnov</who>
            <commenter_username>rostyslav_smirnov</commenter_username>
            <when>2016-12-06 17:44:02 -0500</when>
            <comment_text>Created attachment 265740
C.java</comment_text>
        </comment>
        <comment>
            <comment_id>2783639</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-06 23:45:40 -0500</when>
            <comment_text>Reproduced with the latest. Will take a look.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>509123</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-12-13 03:14:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Tests fail with JRE 9 due to change in type signature</short_desc>
        <thetext>The following tests are failing:

GenericTypeTest.test1151()
GenericTypeTest.test1153()
GenericTypeTest.test1155()

The failing comparison is something like this:

----------- Expected ------------
java.lang.ref.Reference&lt;X&lt;java.lang.String&gt;.Other&lt;java.lang.Thread&gt;.Deeply&gt;
------------ but was ------------
java.lang.ref.Reference&lt;X&lt;java.lang.String&gt;$Other&lt;java.lang.Thread&gt;$Deeply&gt;

Only difference is the separator for inner types has changed from '.' to '$' in JRE 9.

There could be other similar failures. I will add if there are.</thetext>
    </bug>
    <bug>
        <id>488287</id>
        <developer>Bob Street</developer>
        <developer_username>bob_street</developer_username>
        <dup_id/>
        <creation_time>2016-02-23 07:36:00 -0500</creation_time>
        <product>JDT</product>
        <component>APT</component>
        <short_desc>Cut and Paste of ant build.xml adds extra tab</short_desc>
        <thetext>When editing build.xml file. The cut and paste always adds an extra tab in the paste eventhough the source does not have them. I have turned off tabs in every eclipse preference I can find. We never use tabs in our source.</thetext>
    </bug>
    <bug>
        <id>492338</id>
        <developer>Andreas  Hoehmann</developer>
        <developer_username>andreas.hoehmann</developer_username>
        <dup_id/>
        <creation_time>2016-04-25 02:58:00 -0400</creation_time>
        <product>JDT</product>
        <component>APT</component>
        <short_desc>UI Freeze &gt;3 seconds without stacktrace</short_desc>
        <thetext>In the log I can only find such entries:

!ENTRY org.eclipse.ui.monitoring 4 0 2016-04-25 08:55:53.903
!MESSAGE UI freeze of 3,0s at 08:55:50.878

Please tell me:
1. what additional info do you need?
2. and where can I "enable" more output for such errors?

-- Error Details --
Date: Mon Apr 25 08:52:08 CEST 2016
Message: UI freeze of 3,5s at 08:52:04.656
Severity: Error
Product: Eclipse 4.5.2.20160218-0600 (org.eclipse.epp.package.jee.product)
Plugin: org.eclipse.ui.monitoring
Session Data:
eclipse.buildId=4.5.2.M20160212-1500
java.version=1.8.0_66
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -refresh -showlocation -product org.eclipse.epp.package.jee.product -profileid local-goosds-eclipse-goos-new-fc0de5b8
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -clean -refresh -showlocation -debug -consolelog -product org.eclipse.epp.package.jee.product -profileid local-goosds-eclipse-goos-new-fc0de5b8 -data D:\Dev\eclipse-goos-new</thetext>
        <comment>
            <comment_id>2698785</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-25 04:38:17 -0400</when>
            <comment_text>Please refer to this page on getting additional trouble-shooting info:

https://wiki.eclipse.org/How_to_report_a_deadlock</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492370</id>
        <developer>Young Etheridge</developer>
        <developer_username>yhe</developer_username>
        <dup_id/>
        <creation_time>2016-04-25 09:20:00 -0400</creation_time>
        <product>JDT</product>
        <component>APT</component>
        <short_desc>jre/bin/java mode bits for execute not set correctly for application package build on linux</short_desc>
        <thetext>On Eclipse Mars, 4.5.2:

Building a org.eclipse.e4.ui.workbench.swt.E4Application;

Execution environment is set to bundle the JRE with the product;

Using the Eclipse product export wizard to package and export the application;

Package is created as expected with the jre packaged with the application.

As built, the application executable exits with "JVM terminated. Exit code=13";

Checked the jre/bin/java to find that the execution mode was not set for any of the jre/bin executables;

chmod'd the jre/bin/java to be executable and the application ran as expected;

Apparently the script that copies the configured jre needs to be repaired to preserve all mode bits?

Note: this problem does not arise for the same application, built and run on Windows - have not tested on OS/X;


-- Configuration Details --
Product: Eclipse SDK 4.5.2.v20160212-1500 (org.eclipse.sdk.ide)
Installed Features:
 org.eclipse.jdt 3.11.2.v20160212-1500</thetext>
        <comment>
            <comment_id>2702699</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-04 02:14:25 -0400</when>
            <comment_text>I am not really an expert in this area. Perhaps this belongs in e4 tools or PDE. Could you please attach the sample product file which exhibits this problem. Thanks!

Copying Vikas to the discussion.</comment_text>
        </comment>
        <comment>
            <comment_id>2703318</comment_id>
            <comment_count>2</comment_count>
            <who>Vikas Chandra</who>
            <commenter_username>Vikas.Chandra</commenter_username>
            <when>2016-05-05 04:55:23 -0400</when>
            <comment_text>Can you attach sample plugins so that we can recreate this problem?</comment_text>
        </comment>
        <comment>
            <comment_id>2703441</comment_id>
            <comment_count>3</comment_count>
            <who>Young Etheridge</who>
            <commenter_username>yhe</commenter_username>
            <when>2016-05-05 10:27:18 -0400</when>
            <comment_text>It is not possible for me to send the plug-in, feature, and product projects by which I encountered this issue.

I suspect that the example projects that are distributed with Lars Vogel's book, "Eclipse Rich Client Platform", can produce this problem on Linux. The development platform that I use is Linux Mint 17.3, Cinnamon 64-bit, Java JDK build 1.8.0_91-b14, Eclipse 4.5.2 using Vogella e4 tools for Mars. I expect that my configuration is coincidental; not a direct Eclipse issue; but an OS utility issue for copying the JRE to embed in the built application.

My work-around is to chmod the applications in the copied jre/bin to turn on the missing execute mode for {user, group, other}.

I reiterate: this problem does not arise for a Windows build.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492622</id>
        <developer>suraj gupta</developer>
        <developer_username>surajgupta49</developer_username>
        <dup_id/>
        <creation_time>2016-04-28 00:19:00 -0400</creation_time>
        <product>JDT</product>
        <component>APT</component>
        <short_desc>Mars2 4.5.2 Version :: Building Workspace making infinite loop</short_desc>
        <thetext>Hi..I am facing bug in eclipse mars2 4.5.2 release. Building workspace is making infinite loop and system gets low in memory resulting in shut down of processes. Please help about this</thetext>
        <comment>
            <comment_id>2700684</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-28 02:05:34 -0400</when>
            <comment_text>Please refer to this page, which will help you provide us more information on the hang:

https://wiki.eclipse.org/How_to_report_a_deadlock</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495225</id>
        <developer>Michael Bolin</developer>
        <developer_username>bolinfest</developer_username>
        <dup_id/>
        <creation_time>2016-06-01 18:31:00 -0400</creation_time>
        <product>JDT</product>
        <component>APT</component>
        <short_desc>APT does not generate import statements for other generated types</short_desc>
        <thetext>[Buck](https://github.com/facebook/buck) uses the [Immutables annotation processor](http://immutables.github.io/) to generate many types. I know that a bunch of work has been done recently to fix issues with Eclipse's APT and Immutables, but it isn't quite there yet.

As I noted in [this recent commit](https://github.com/facebook/buck/commit/fc3b37f69ea0acbcf6f256462950bd3ed2bf459b), when I load the Buck project in Eclipse 4.6.0RC2 and choose "Project &gt; Clean..." and select Buck, I still get a broken build due to compilation errors in files in the generated .apt_generated folder.

Alphabetically, the first such error is in .apt_generated/com/facebook/buck/android/AndroidPackageableCollection.java. It complains about two unknown types: BuildTarget and BuildConfigFields. However, these files exist (Eclipse even takes you to them if you cmd-click on their names in AndroidPackageableCollection.java):

.apt_generated/com/facebook/buck/model/BuildTarget.java
.apt_generated/com/facebook/buck/rules/coercer/BuildConfigFields.java

The issue is that there are no import statements for these types in AndroidPackageableCollection.java.

Note that this is not an issue when these files are generated via the annotation processing logic that comes with javac when run from the command line. The missing import statements are the only difference between the javac and ECJ versions; otherwise, they are byte-for-byte identical.</thetext>
        <comment>
            <comment_id>2715935</comment_id>
            <comment_count>1</comment_count>
            <who>Ievgen Lukash</who>
            <commenter_username>e.lucash</commenter_username>
            <when>2016-06-01 19:36:35 -0400</when>
            <comment_text>Thank you Michael for reporting this! It's probably to early to declare any specific problem with ECJ. Let me investigate it on the side of Immutables, I'll get back here to report findings.</comment_text>
        </comment>
        <comment>
            <comment_id>2717324</comment_id>
            <comment_count>2</comment_count>
            <who>Ievgen Lukash</who>
            <commenter_username>e.lucash</commenter_username>
            <when>2016-06-05 23:24:23 -0400</when>
            <comment_text>The problem was in the change in annotation processor classloading in Eclipse.
When running in IDE (as opposed to running compiler in a batch mode), Thread.getContextClassLoader() able to provide a classloader that load ECJ-specific classes throught which we access necessary advanced functionality.

I believe the changes in classloading was necessary for something important, so we adapted the Immutables annotation processor to use special proxy classloader to work around the change.

I would say that this would never be an issue if the annotation processor use only standard apis and never touch compiler internals, but the amount of bugs in both Javac and ECJ, and other discrepancies between the two are too much of a problem and it cannot be dealt with only using standard APIs.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496143</id>
        <developer>Jefferson Quidor</developer>
        <developer_username>jlquidor</developer_username>
        <dup_id/>
        <creation_time>2016-06-14 23:30:00 -0400</creation_time>
        <product>JDT</product>
        <component>APT</component>
        <short_desc>Unable to launch Edit Class Annotation window in Eclipse Luna in Eclipse for Oracle CCB. The window feature is working in Eclipse Indigo</short_desc>
        <thetext>Unable to launch Edit Class Annotation window in Eclipse Luna in Eclipse for Oracle CCB. The window feature is working in Eclipse Indigo</thetext>
        <comment>
            <comment_id>2720630</comment_id>
            <comment_count>1</comment_count>
            <who>Jefferson Quidor</who>
            <commenter_username>jlquidor</commenter_username>
            <when>2016-06-14 23:45:32 -0400</when>
            <comment_text>Created attachment 262445
Screenshot</comment_text>
        </comment>
        <comment>
            <comment_id>2720640</comment_id>
            <comment_count>2</comment_count>
            <who>Vikas Chandra</who>
            <commenter_username>Vikas.Chandra</commenter_username>
            <when>2016-06-15 01:49:45 -0400</when>
            <comment_text>Not sure where this bug belongs. 

Moving to JDT for comments.</comment_text>
        </comment>
        <comment>
            <comment_id>2720720</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-15 04:50:28 -0400</when>
            <comment_text>I am unable to open the attachment. What format is it in?</comment_text>
        </comment>
        <comment>
            <comment_id>2720766</comment_id>
            <comment_count>4</comment_count>
            <who>Jefferson Quidor</who>
            <commenter_username>jlquidor</commenter_username>
            <when>2016-06-15 05:57:55 -0400</when>
            <comment_text>Hi Jay, it's outlook message format. Kindly open it using MS Outlook. Thanks</comment_text>
        </comment>
        <comment>
            <comment_id>2720769</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-15 06:01:42 -0400</when>
            <comment_text>(In reply to Jefferson Quidor from comment #4)
&gt; Hi Jay, it's outlook message format. Kindly open it using MS Outlook. Thanks

I don't have access to Outlook. Could you please put this in an image or something? TIA!</comment_text>
        </comment>
        <comment>
            <comment_id>2721118</comment_id>
            <comment_count>6</comment_count>
            <who>Jefferson Quidor</who>
            <commenter_username>jlquidor</commenter_username>
            <when>2016-06-15 21:34:08 -0400</when>
            <comment_text>Created attachment 262482
image</comment_text>
        </comment>
        <comment>
            <comment_id>2721442</comment_id>
            <comment_count>7</comment_count>
            <who>Jefferson Quidor</who>
            <commenter_username>jlquidor</commenter_username>
            <when>2016-06-16 21:38:38 -0400</when>
            <comment_text>would like to follow-up on this. Thanks</comment_text>
        </comment>
        <comment>
            <comment_id>2721905</comment_id>
            <comment_count>8</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-20 00:04:16 -0400</when>
            <comment_text>Hmm.. I have no clue where this is coming from!

Noopur/Stephan, any idea?</comment_text>
        </comment>
        <comment>
            <comment_id>2721949</comment_id>
            <comment_count>9</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-06-20 04:01:57 -0400</when>
            <comment_text>I couldn't find it in jdt.ui.

You can use the plug-in menu spy to check the plug-in/class contributing that menu item.

Press Alt+Shift+F2 and then right-click in the source editor to invoke the context menu. Then click on the "Edit Class Annotation" item.

This will popup the "Plug-in Menu Spy" dialog with the details about that menu item.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499026</id>
        <developer>Jean-Marie HENAFF</developer>
        <developer_username>jmhenaff</developer_username>
        <dup_id/>
        <creation_time>2016-08-02 04:46:00 -0400</creation_time>
        <product>JDT</product>
        <component>APT</component>
        <short_desc>Issue with ecj Types.asMemberOf() and Generics</short_desc>
        <thetext>Created attachment 263415
Sample project to reproduce the issue

I've attached a sample project to reproduce the issue.

Execute run.sh and the following error message should appear:

1. ERROR in /tmp/test/Sample/src/com/test/src/Test.java (at line 0)
	/*
	^
Internal compiler error: java.lang.Exception: java.lang.IllegalArgumentException: element public void set(T)  is not a member of the containing type com.test.src.GenericChild&lt;com.test.src.Test.MyTypeChild&gt; nor any of its superclasses at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundDispatcher.handleProcessor(RoundDispatcher.java:169)
----------
1 problem (1 error)


The test calls Types.asMemberOf() to get method "void set(T t)" (defined in GenericSuper&lt;T&gt;) from a parameterized type of a field declared as GenericChild&lt;MyTypeChild&gt;, with

public class GenericChild&lt;T extends MyType&gt; extends GenericSuper&lt;T&gt; {

}

where method is seen as "void set(com.test.src.Test.MyTypeChild)". then areParameterErasuresEqual() fails to find a match.

What seemed to work but might not be the right way to fix this, is to change TypesImpl.asMemberOf() from:

                    MethodBinding methodBinding = ((MethodBinding) memberBinding);
                    for (MethodBinding method : typeBinding.methods()) {
                      if (CharOperation.equals(method.selector, methodBinding.selector)
                          &amp;&amp; (method.original() == methodBinding
                              || method.areParameterErasuresEqual(methodBinding))) {
                        return TypesImpl.this._env.getFactory().newTypeMirror(method);
                      }
                    }

to

                    MethodBinding methodBinding = ((MethodBinding) memberBinding).original();
                    for (MethodBinding methodG : typeBinding.methods()) {
                      MethodBinding method = methodG.original();
                      if (CharOperation.equals(method.selector, methodBinding.selector)
                          &amp;&amp; (method.original() == methodBinding
                              || method.areParameterErasuresEqual(methodBinding))) {
                        return TypesImpl.this._env.getFactory().newTypeMirror(methodG);
                      }
                    }</thetext>
    </bug>
    <bug>
        <id>499028</id>
        <developer>Jean-Marie HENAFF</developer>
        <developer_username>jmhenaff</developer_username>
        <dup_id/>
        <creation_time>2016-08-02 04:56:00 -0400</creation_time>
        <product>JDT</product>
        <component>APT</component>
        <short_desc>Indirectly referenced type issue with annotation processor</short_desc>
        <thetext>Created attachment 263416
Sample to reproduce the issue

The problem appears when using env.getElementUtils().getTypeElement() to lookup a type in a library on path that makes a reference to a another type which absent from classpath (here as a field type).

I've reproduced it in sample project attached to this bug.

The fact that Main, the compiled type, extends the missing type, which is supposed to be generated by the annotationprocessor, is important.

Run the sample by invoking run.sh, and the following message should appear:


Looking up Test...
----------
1. ERROR in /tmp/test/Sample/src/com/test/src/Main.java (at line 0)
	package com.test.src;
	^
Internal compiler error: java.lang.Exception: org.eclipse.jdt.internal.compiler.problem.AbortCompilation: Pb(324) The type com.test.lib.Excluded cannot be resolved. It is indirectly referenced from required .class files at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundDispatcher.handleProcessor(RoundDispatcher.java:169)
[...]</thetext>
    </bug>
    <bug>
        <id>499446</id>
        <developer>Ulrich Hobelmann</developer>
        <developer_username>ulrich.hobelmann</developer_username>
        <dup_id/>
        <creation_time>2016-08-09 09:45:00 -0400</creation_time>
        <product>JDT</product>
        <component>APT</component>
        <short_desc>Exception during code completion</short_desc>
        <thetext>Not sure what triggered it, I was in the middle of an if-expression and may have hit the wrong key, ending up on another line.

-- Error Details --
Date: Tue Aug 09 15:42:57 CEST 2016
Message: Problems occurred when invoking code from plug-in: "org.eclipse.text".
Severity: Error
Product: Eclipse 4.6.0.20160613-1800 (org.eclipse.epp.package.java.product)
Plugin: org.eclipse.text
Exception Stack Trace:
java.lang.IllegalStateException: startLine (229) does not match endLine (230)
	at org.eclipse.jface.text.projection.ProjectionMapping.toImageLine(ProjectionMapping.java:459)
	at org.eclipse.jface.text.TextViewer.modelLine2WidgetLine(TextViewer.java:5123)
	at org.eclipse.jface.text.source.MatchingCharacterPainter.handleDrawRequest(MatchingCharacterPainter.java:212)
	at org.eclipse.jface.text.source.MatchingCharacterPainter.paintControl(MatchingCharacterPainter.java:182)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:231)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5219)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1340)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1366)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1349)
	at org.eclipse.swt.widgets.Control.gtk_expose_event(Control.java:3382)
	at org.eclipse.swt.widgets.Composite.gtk_expose_event(Composite.java:771)
	at org.eclipse.swt.widgets.Canvas.gtk_expose_event(Canvas.java:182)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:1993)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:5819)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5490)
	at org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(Native Method)
	at org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:9545)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1275)
	at org.eclipse.swt.internal.gtk.OS._gdk_window_process_updates(Native Method)
	at org.eclipse.swt.internal.gtk.OS.gdk_window_process_updates(OS.java:6123)
	at org.eclipse.swt.widgets.ProgressBar.updateBar(ProgressBar.java:313)
	at org.eclipse.swt.widgets.ProgressBar.setMinimum(ProgressBar.java:240)
	at org.eclipse.jface.dialogs.ProgressIndicator.done(ProgressIndicator.java:108)
	at org.eclipse.jface.action.StatusLine.done(StatusLine.java:396)
	at org.eclipse.jface.action.StatusLineManager$1.done(StatusLineManager.java:159)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installOccurrencesFinder(JavaEditor.java:3376)
	at org.eclipse.jdt.internal.ui.javaeditor.EditorHighlightingSynchronizer.left(EditorHighlightingSynchronizer.java:52)
	at org.eclipse.jface.text.link.LinkedModeModel.exit(LinkedModeModel.java:341)
	at org.eclipse.jface.text.link.LinkedModeModel$DocumentListener.documentChanged(LinkedModeModel.java:202)
	at org.eclipse.jface.text.AbstractDocument.doFireDocumentChanged2(AbstractDocument.java:743)
	at org.eclipse.jface.text.AbstractDocument.doFireDocumentChanged(AbstractDocument.java:712)
	at org.eclipse.jface.text.AbstractDocument.doFireDocumentChanged(AbstractDocument.java:696)
	at org.eclipse.jface.text.AbstractDocument.fireDocumentChanged(AbstractDocument.java:770)
	at org.eclipse.jface.text.AbstractDocument.replace(AbstractDocument.java:1101)
	at org.eclipse.core.internal.filebuffers.SynchronizableDocument.replace(SynchronizableDocument.java:173)
	at org.eclipse.jface.text.AbstractDocument.replace(AbstractDocument.java:1119)
	at org.eclipse.core.internal.filebuffers.SynchronizableDocument.replace(SynchronizableDocument.java:161)
	at org.eclipse.jface.text.projection.ProjectionTextStore.replace(ProjectionTextStore.java:103)
	at org.eclipse.jface.text.AbstractDocument.replace(AbstractDocument.java:1094)
	at org.eclipse.jface.text.AbstractDocument.replace(AbstractDocument.java:1119)
	at org.eclipse.jface.text.projection.ProjectionDocument.replace(ProjectionDocument.java:625)
	at org.eclipse.jface.text.DefaultDocumentAdapter.replaceTextRange(DefaultDocumentAdapter.java:233)
	at org.eclipse.swt.custom.StyledText.modifyContent(StyledText.java:7374)
	at org.eclipse.swt.custom.StyledText.sendKeyEvent(StyledText.java:8225)
	at org.eclipse.swt.custom.StyledText.doContent(StyledText.java:2530)
	at org.eclipse.swt.custom.StyledText.handleKey(StyledText.java:6018)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6049)
	at org.eclipse.swt.custom.StyledText$7.handleEvent(StyledText.java:5733)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5219)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1340)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1366)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1349)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1378)
	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:764)
	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:3457)
	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:801)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2000)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:5819)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5490)
	at org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(Native Method)
	at org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:9545)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1275)
	at org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method)
	at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:2495)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4141)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:687)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)</thetext>
    </bug>
    <bug>
        <id>500589</id>
        <developer>Christian Manning</developer>
        <developer_username>christianm</developer_username>
        <dup_id/>
        <creation_time>2016-08-31 10:30:00 -0400</creation_time>
        <product>JDT</product>
        <component>APT</component>
        <short_desc>TypeElement.getEnclosedElements does not reflect declaration order when sourced from a compiled class</short_desc>
        <thetext>Created attachment 263869
Reproducing project

TypeElement.getEnclosedElements() should be returning elements in the order they were declared. This was previously reported in bug #300408, but only for TypeElements coming from source files. This bug is for TypeElements representing already compiled types.

Attached is a project that will demonstrate the difference in output between JDT and javac. This uses a simple annotation processor &amp; invokes the JavaCompilers directly in a unit test (ElementOrderProcessorTest). There's a jar in there with a couple of simple POJOs, as this behaviour is only revealed when the TypeElement comes from a compiled class.

I have a fix for TypeElementImpl, I'm just looking into the process for contribution.


Reproducible: Always

Steps to Reproduce:
1. Create an annotation processor that calls getEnclosedElements() on a TypeElement for a type originating from byte code.
2. Create a class with an annotation that will trigger the created annotation processor.
3. Analyse the order of elements returned by TypeElement.getEnclosedElements().</thetext>
        <comment>
            <comment_id>2745650</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-08-31 11:59:15 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/80142</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501618</id>
        <developer>Hal Fisher</developer>
        <developer_username>reallynolie</developer_username>
        <dup_id/>
        <creation_time>2016-09-16 16:51:00 -0400</creation_time>
        <product>JDT</product>
        <component>APT</component>
        <short_desc>Implement Access To Newly Created Class in Project and use as Super</short_desc>
        <thetext>I am sooooooooooo new to this and it's frustrating to see something that should be simple, but is not simple.  Why on earth (or is it just too deeply hidden?) can't a newly created class be instantly used as a super to another newly created class?  I think I compiled the new class (I shouldn't need to necessarily do this, but thought maybe that was a requirement, but still no luck).  Sorry, just seems like this should be obvious and it may well be, to a season veteran, but not to a new person.

Hal

-- Configuration Details --
Product: Eclipse 4.6.0.20160613-1800 (org.eclipse.epp.package.java.product)
Installed Features:
 org.eclipse.jdt 3.12.0.v20160606-1100</thetext>
        <comment>
            <comment_id>2752280</comment_id>
            <comment_count>1</comment_count>
            <who>Walter Harley</who>
            <commenter_username>eclipse</commenter_username>
            <when>2016-09-18 01:01:42 -0400</when>
            <comment_text>Sorry, we'll need a bit more detail to understand what you're describing.  You've posted this to the JDT/APT (annotation processing tooling) subcomponent; are you talking about classes generated by annotation processors?  If so, can you attach a sample annotation processor that demonstrates the problem?

Or are you just talking about using the Eclipse IDE to write and compile Java classes?  If so, you may want to start by posting to discussion forums, rather than filing a bug.

As it stands, I'm not at all clear whether you're reporting a bug or asking for help, nor what you're asking for help on.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>502998</id>
        <developer>Stefan Xenos</developer>
        <developer_username>sxenos</developer_username>
        <dup_id/>
        <creation_time>2016-09-30 21:49:00 -0400</creation_time>
        <product>JDT</product>
        <component>APT</component>
        <short_desc>Improve the process for setting up annotation processors in Eclipse</short_desc>
        <thetext>Lars Vogel posted the following on the JDT core mailing list:

A fellow Java champion pointed out to me that the annotation
processing setup in Eclipse is very complex compared to other IDEs.
Here is what we wrote me (slightly reworked for readability):

QUOTE_BEGIN
------------
- NetBeans automatically finds APT JARs in the classpath. You can't
turn it off. You can't tweak any settings.
- IntelliJ  allows to activate APT processing (per project) with a
checkbox; this will find all available APT JARs in the classpath by
default. You can also configure which JARs may be used.
- Eclipse forces you to locate and define every APT JAR by hand, per project.

This means NB is on one side of the spectrum (fully automatic) where
Eclipse is at the opposite side (fully manual), while Intellij sits
somewhere in between.

Example instructions for all IDEs can be found at
http://griffon-framework.org/tutorials/1_getting_started.html#_tutorial_1_4
------------
QUOTE_END

--- End original post to JDT core mailing list

My own preference would be to have something across from NetBeans and IntelliJ. We could have some fairly fine-grained settings to control what annotation processor is used for each package, but the default value of the setting would be to use everything that appears on the classpath... so if you don't change any defaults, things will work pretty much like NetBeans... but you could still have fine-grained control if you want to use - say - two different IoC injectors in the same project at the same time.

However, I think that making this "just work" by default would require fixing bug 472175 first since Eclipse would otherwise end up loading unreliable APT code into its own VM.</thetext>
    </bug>
    <bug>
        <id>507573</id>
        <developer>Kevin Wilson</developer>
        <developer_username>kevinmwilson1956</developer_username>
        <dup_id/>
        <creation_time>2016-11-15 23:55:00 -0500</creation_time>
        <product>JDT</product>
        <component>APT</component>
        <short_desc>Install of MARS 2.47.1 on Windows 10</short_desc>
        <thetext>eclipse.buildId=4.5.0.I20150603-2000
java.version=1.8.0_112
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

org.eclipse.jface
Error
Tue Nov 15 20:44:33 MST 2016
Unable to resolve plug-in "platform:/plugin/org.cfeclipse.cfml.snippets/icons/ctool16/library.gif".

java.io.IOException: Unable to resolve plug-in "platform:/plugin/org.cfeclipse.cfml.snippets/icons/ctool16/library.gif".
	at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.parse(PlatformURLPluginConnection.java:65)
	at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.resolve(PlatformURLPluginConnection.java:77)
	at org.eclipse.core.internal.boot.PlatformURLHandler.openConnection(PlatformURLHandler.java:69)
	at org.eclipse.osgi.internal.url.URLStreamHandlerProxy.openConnection(URLStreamHandlerProxy.java:114)
	at java.net.URL.openConnection(Unknown Source)
	at org.eclipse.core.internal.runtime.PlatformURLConverter.toFileURL(PlatformURLConverter.java:34)
	at org.eclipse.core.runtime.FileLocator.toFileURL(FileLocator.java:207)
	at org.eclipse.jface.resource.URLImageDescriptor.getFilePath(URLImageDescriptor.java:219)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:283)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:224)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:202)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImageFromURI(SWTPartRenderer.java:225)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImage(SWTPartRenderer.java:236)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.createTab(StackRenderer.java:877)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.processContents(LazyStackRenderer.java:139)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:151)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:151)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:151)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:49)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer$1.handleEvent(LazyStackRenderer.java:72)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:186)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4761)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:85)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:59)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl.setSelectedElement(PerspectiveStackImpl.java:135)
	at org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl.setSelectedElement(PerspectiveStackImpl.java:1)
	at org.eclipse.ui.internal.WorkbenchPage.setPerspective(WorkbenchPage.java:4010)
	at org.eclipse.ui.internal.WorkbenchWindow.setup(WorkbenchWindow.java:737)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:898)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:121)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:86)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.inject(ContextInjectionFactory.java:73)
	at org.eclipse.ui.internal.Workbench.createWorkbenchWindow(Workbench.java:1486)
	at org.eclipse.ui.internal.Workbench.openWorkbenchWindow(Workbench.java:2635)
	at org.eclipse.ui.internal.Workbench.getWorkbenchPage(Workbench.java:2018)
	at org.eclipse.ui.internal.Workbench.setReference(Workbench.java:2066)
	at org.eclipse.ui.internal.Workbench.access$27(Workbench.java:2034)
	at org.eclipse.ui.internal.Workbench$35.handleEvent(Workbench.java:1956)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:186)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4761)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:85)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:59)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.basic.impl.PartImpl.setContext(PartImpl.java:431)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:615)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:525)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:509)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:69)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:971)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1306)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:151)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:49)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:63)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:151)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:614)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1061)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:654)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1515)



eclipse.buildId=4.4.0.I20140606-1215
java.version=1.8.0_92
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Command-line arguments:  -os win32 -ws win32 -arch x86_64

org.eclipse.ui
Error
Sat Aug 27 12:33:43 MDT 2016
Invalid activity requirement binding: missing ID of the required activity (contributed by 'org.eclipse.ui.tests')

eclipse.buildId=4.4.0.I20140606-1215
java.version=1.8.0_92
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Command-line arguments:  -os win32 -ws win32 -arch x86_64

org.eclipse.ui
Error
Sat Aug 27 12:33:43 MDT 2016
Invalid activity pattern binding: missing the pattern to be bound (contributed by 'org.eclipse.ui.tests')


-- Configuration Details --
Product: Eclipse 4.5.0.20150621-1200 (org.eclipse.epp.package.java.product)
Installed Features:
 org.eclipse.jdt 3.11.0.v20150603-2000</thetext>
        <comment>
            <comment_id>2776810</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-16 23:39:58 -0500</when>
            <comment_text>Can you tell us what you meant by MARS 2.47.1? Not sure if that's an eclipse version. Also there are two eclipse.buildId in your report: 4.5.0.I20150603-2000 and 4.4.0.I20140606-1215.

It will help if you can tell us what exactly you are trying to do.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>485066</id>
        <developer>Sasikanth Bharadwaj</developer>
        <developer_username>sasikanth.bharadwaj</developer_username>
        <dup_id/>
        <creation_time>2016-01-01 04:05:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.7-][compiler] eclipse reports ambiguous method error, code compiles fine with javac</short_desc>
        <thetext>Steps to reproduce

1. in the eclipse git repository view, clone the project (https://github.com/jenkinsci/git-plugin.git)
2. after the clone is complete, select the new repository in the Git Repositories view, right-click and select the "import maven projects..." menu
3. after the import is complete (it took several minutes on my system) right-click the project in the package explorer (or whatever view you prefer) and click the maven-&gt;update project menu.
4. when the update is complete, and the automatic project build completes, you will see two errors in the problems view on the /git/src/test/java/hudson/plugins/git/GitSCMTest.java module.

Reproducible on master.</thetext>
        <comment>
            <comment_id>2655822</comment_id>
            <comment_count>1</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-01-01 04:07:36 -0500</when>
            <comment_text>Shorter test case that can be pasted into PE. This code compiles fine at 1.8 but reports ambiguous method error at 1.7 and below

/----

public class Test {
	public static Project createProject() {
		return null;
	}
	public static void main(String[] args) {
		new TestCase().test(createProject()); // problem here
	}
}
class TestCase {
	&lt;T extends Job&gt; T test(T t){
		return null;
	}
	&lt;P extends Item&gt; P test(P p) {
		return null;
	}
}
interface Item {}
class AbstractItem implements Item {}
class Run&lt;T extends Job&lt;T,R&gt;, R extends Run&lt;T,R&gt;&gt; {
	
}
class Job&lt;T extends Job&lt;T,R&gt;,R extends Run&lt;T, R&gt;&gt; extends AbstractItem {}
class Build extends Run&lt;Project, Build&gt; {}
class Project extends Job&lt;Project, Build&gt; {}

/-----</comment_text>
        </comment>
        <comment>
            <comment_id>2655825</comment_id>
            <comment_count>2</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-01-01 04:12:38 -0500</when>
            <comment_text>Initial analysis shows that msmb computation fails to pick one method over the other at 1.7 compliance. Prime suspect is the raw type Job in the method &lt;T extends Job&gt; T test(T t). Changing this to &lt;T extends Job&lt;?,?&gt;&gt; T test(T t) resolves the problem.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>485086</id>
        <developer>Ed Willink</developer>
        <developer_username>ed</developer_username>
        <dup_id/>
        <creation_time>2016-01-03 08:14:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Support multiple external annotations locations.</short_desc>
        <thetext>When working on layered project A, B, C, I require multiple external annotations locations.

When working on A, I will have a A-specific location.

When working on B, I want B-specific and A-specific,

When working on C ... etc.</thetext>
    </bug>
    <bug>
        <id>485088</id>
        <developer>Ed Willink</developer>
        <developer_username>ed</developer_username>
        <dup_id/>
        <creation_time>2016-01-03 08:32:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Support external annotations for source code too</short_desc>
        <thetext>Auto-generated code using vintage generators such as EMF do not support Java 8 annotations. It would be helpful to be able to manually (or automatically) maintain annotations for Java code that exists as source classes rather than as binary classes.

Suggest that in the Package Explorer, below Plugin Dependencies, any plugin/project can have its external annotation path specified for persistence in the .settings file.

Suggest too that annotating the "Plugin Dependencies" directly maintains a multi-entry path applicable to all dependencies; the first entry is writeable for new contributions, further entries are read-only.</thetext>
    </bug>
    <bug>
        <id>485135</id>
        <developer>Mickael Istria - away until ...</developer>
        <developer_username>mistria</developer_username>
        <dup_id/>
        <creation_time>2016-01-04 07:34:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>"Method does not override a package visible method" should also apply to private methods</short_desc>
        <thetext>With the "Method does not override a package visible method" warning on, I would expect the following piece of code to show a warning on Extend.method() definition:

public class Base {
  private void method() {}
}

public class Extend extends Base {
  void method() {}
}</thetext>
        <comment>
            <comment_id>2656125</comment_id>
            <comment_count>1</comment_count>
            <who>Mickael Istria - away until ...</who>
            <commenter_username>mistria</commenter_username>
            <when>2016-01-04 07:35:24 -0500</when>
            <comment_text>This is item 13 of http://wheredatapp.com/blog/2015/11/19/why-intellij-idea-is-better-than-eclipse</comment_text>
        </comment>
        <comment>
            <comment_id>2656238</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-01-04 11:03:07 -0500</when>
            <comment_text>(In reply to Mickael Istria from comment #0)
&gt; With the "Method does not override a package visible method" warning on, I
&gt; would expect the following piece of code to show a warning on
&gt; Extend.method() definition:

Except that Base.method() is not package visible.

=&gt; The label and semantics of the option would need to be *changed*.

Generally, I'd say, this is what @Override is for. It faithfully reports every failed attempt to override, and also helps for documentation.</comment_text>
        </comment>
        <comment>
            <comment_id>2656243</comment_id>
            <comment_count>3</comment_count>
            <who>Mickael Istria - away until ...</who>
            <commenter_username>mistria</commenter_username>
            <when>2016-01-04 11:08:55 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #2)
&gt; Except that Base.method() is not package visible.
&gt; =&gt; The label and semantics of the option would need to be *changed*.

Ok, so it would most likely be another check then? If so, I let you update the title to something more appropriate.

&gt; Generally, I'd say, this is what @Override is for. It faithfully reports
&gt; every failed attempt to override, and also helps for documentation.

I agree that @Override is the best way to go. But IDEs are not only for good developers, so we can easily imagine some of Eclipse IDE users not using @Override where they should. Also, there is the case of a user overriding the parent private method by mistake: since the private method is not visible in the scope of their development, users can easily create a new method with same name and face potential issue later, if the method in parent becomes package-public or protected.
That's why a warning could tell: "You're creating a method with same name as a private method already existing in class hierarchy. It's recommended to use a different name."</comment_text>
        </comment>
    </bug>
    <bug>
        <id>485338</id>
        <developer>Marvin  Fröhlich</developer>
        <developer_username>qudus</developer_username>
        <dup_id/>
        <creation_time>2016-01-07 07:27:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Option to ignore dependent errors</short_desc>
        <thetext>Some errors clearly depend on others. A very common example is

The import a.b.c.Clazz cannot be resolved

Any usage of Clazz in that class will result in yet another error, which is in many cases resolved with the resolution of the wrong import.

Here an option to ignore theses dependent errors would lead to clearer error reports.</thetext>
    </bug>
    <bug>
        <id>485441</id>
        <developer>Gray</developer>
        <developer_username>gray.eclipse</developer_username>
        <dup_id/>
        <creation_time>2016-01-08 12:56:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null][loop] Improper deadcode/null detection in an exception handler</short_desc>
        <thetext>Created attachment 259087
Example java program.

With the following code, reader is flagged as always null in the IOException catch block.

	LineNumberReader reader = null;
	try {
		// this throws IOException
		FileReader fileReader = new FileReader("testdata.sql");
		reader = new LineNumberReader(fileReader);
		// but so does this
		while (reader.readLine() != null) {
			// just count them
		}
	} catch (IOException e) {
		if (reader == null) {
			System.err.println("Problems opening file");
		} else {
			// reader might not be null if readLine throws
			System.err.println("Problems reading from " + reader.getLineNumber());
		}
	}

Interestingly, if I remove the while loop and just call reader.readLine(); this problem goes away so it's something about the while loop.</thetext>
        <comment>
            <comment_id>2658434</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-01-08 15:47:27 -0500</when>
            <comment_text>Thanks, I can reproduce.

Lets' see what we can do.

It looks like the IOException thrown from readLine() isn't correctly reporting a path into the catch block after assigning reader.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>485475</id>
        <developer>Jonah Graham</developer>
        <developer_username>jonah</developer_username>
        <dup_id/>
        <creation_time>2016-01-09 06:19:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Code Assist prefer perfect camel case</short_desc>
        <thetext>(Initiated as part of a conversation on SO http://stackoverflow.com/q/34607614/2796832)

When completing the list of options does not prefer perfect Camel Case matches. 

For example, when completing "IO" I get IOException, IOError, IndexOutOfBoundsException ahead of ImageObserver which is a perfect Camel Case match.

I have reviewed Bug 175326 (similar, but not specifically about camel case) and Bug 102572 (which originally added Camel Case (aka Camel Hump) type of completions). 

Is it possible to score perfect matches higher? Is this something that makes sense to do?</thetext>
    </bug>
    <bug>
        <id>485492</id>
        <developer>Antti Haapala</developer>
        <developer_username>antti.haapala</developer_username>
        <dup_id/>
        <creation_time>2016-01-10 07:03:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Content assist does not work in a braced lambda in enum constructor call</short_desc>
        <thetext>Consider the following code:

    import java.util.function.Function;

    public enum Foo {
	BAR((x) -&gt; {	
            x. // no assistance here
            return x; // though, completion for x members here works
        });
	
        Foo(Function&lt;String, String&gt; func) { }
    }

In 4.5.1 content assist fails inside braced lambdas that are arguments to enum constructors, though completion works for a single-expression lambda in enum construction.</thetext>
        <comment>
            <comment_id>2659177</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-01-11 22:59:41 -0500</when>
            <comment_text>Hmm... This again points in the recovery not being perfect. In the buggy case, the Foo function loses its formal parameters and as a result, the right constructor not being found.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>485661</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-01-12 09:27:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][null] bogus conflict reported between @NonNull type variable and its @Nullable upper bound</short_desc>
        <thetext>NTAT.testBinary06() expects this error:

	public class X2&lt;@NonNull W extends @Nullable Object&gt; {}
	                                   ^^^^^^^^^
This nullness annotation conflicts with a '@NonNull' annotation which is effective on the same type parameter 


This doesn't make sense, since "extends @Nullable" imposes no restriction. The given snippet is meaningless, but not erroneous.</thetext>
    </bug>
    <bug>
        <id>485739</id>
        <developer>Torge Kummerow</developer>
        <developer_username>torgato</developer_username>
        <dup_id/>
        <creation_time>2016-01-13 06:38:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Calling method from constructor can trick null annotations</short_desc>
        <thetext>Hi,

While adopting my project to Null Annotations, I came across two different special cases where they did not work as I would have expected.
Both are related methods being called from the constructor.

Scenario 1: NPE even though @NonNull is defined and no warnings are present.

class A {
  @NonNull String field;
  
  public A() {
    this.field = update();
  }

  private @NonNull String update() {
    if (this.field.length() &lt; 3)
      return "Test1";

    return "Test2;
  }
}


Scenario 2: Not initialized warning is shown even though the field is initialized jsut fine.

class B {
  @NonNull String field;
  
  public B() {
    init();
  }
  
  private void init() {
    this.field = "Test";
  }
}

I am not sure if this can be fixed easily, maybe taint methods that are called from constructors recursively and threat them accordingly. But if not, maybe enhance the documentation to mention these special cases as limitations.</thetext>
        <comment>
            <comment_id>2660199</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-01-13 13:01:08 -0500</when>
            <comment_text>Thanks.

A good test for the logic of our analysis for field initialization is always: try to make the field final and see what the compiler has to say.

Analysis of @NonNull fields is as good but no better than analysis of definite assignment of final fields (before read).

I'd argue that developers should be aware of the dangers of calling methods from a constructor. But, yes, a hint in the documentation is a good idea.</comment_text>
        </comment>
        <comment>
            <comment_id>2661255</comment_id>
            <comment_count>2</comment_count>
            <who>Torge Kummerow</who>
            <commenter_username>torgato</commenter_username>
            <when>2016-01-16 05:38:45 -0500</when>
            <comment_text>I thaugt a bit about it and wounder if it would maybe make sense to raise 2 new kinds of warnings when a @NonNull field is assigned in a constructor by either a method call to a method of the same object or by passing "this" as a parameter to another object's method.

Something along the lines: Potential null poiter access to field 'xxx' by calling method of not fully initialized object.

And: Potential null pointer access to field 'xxx' by passing not fully initialized object as parameter.

Of course, only if there actually is a not initialized NonNull field at that point.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>485775</id>
        <developer>leokom leokom</developer>
        <developer_username>lrozenblyum</developer_username>
        <dup_id/>
        <creation_time>2016-01-13 11:19:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler] Doesn't report cycle inheritance problem which is detected by Oracle JDK</short_desc>
        <thetext>Let's have 2 classes:

public class First implements Second.SecondInterf {
    interface FirstInterf {

    }
}

public class Second implements First.FirstInterf {
    interface SecondInterf {

    }
}

javac First.java reports error: cyclic inheritance involving Second

While Eclipse compiler silently allows such cycle.
Probably Eclipse compiler should have validation for such situation synchronous with the JDK (because otherwise code that compiles well in Eclipse fails to compile under standalone JDK).

Related discussion on stackoverflow about why Java prohibits such cycle:
http://stackoverflow.com/a/7998053/1429367
Spec:
https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.1.4</thetext>
        <comment>
            <comment_id>2737265</comment_id>
            <comment_count>1</comment_count>
            <who>Jean-Marie HENAFF</who>
            <commenter_username>jmhenaff</commenter_username>
            <when>2016-08-04 12:17:34 -0400</when>
            <comment_text>Created attachment 263457
File with no cycle detected by ecj</comment_text>
        </comment>
        <comment>
            <comment_id>2737267</comment_id>
            <comment_count>2</comment_count>
            <who>Jean-Marie HENAFF</who>
            <commenter_username>jmhenaff</commenter_username>
            <when>2016-08-04 12:20:35 -0400</when>
            <comment_text>Reproduced on Linux with latest integration and nightly build (N20160730).

I've attached source files to reproduce the case.

Note that removing the imports make the compilation fail.</comment_text>
        </comment>
        <comment>
            <comment_id>2737286</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-04 12:58:44 -0400</when>
            <comment_text>Well, the example in comment 0 is rejected by all versions of ecj.
This is in line with javac's behavior and the accepted answer on SO.

The attached project, OTOH, uses imports and simple type references, and hence I don't see X mentioned in its hierarchy. =&gt; This program does not violate JLS as quoted in the SO answer.

However, the corresponding JLS section has since been changed from

  as a qualifier of a superclass or superinterface name

to

  as a qualifier in the fully qualified form of a superclass or superinterface name

This change was effective as of Java 7 and should be adopted by ecj.</comment_text>
        </comment>
        <comment>
            <comment_id>2737289</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-04 13:01:26 -0400</when>
            <comment_text>Also javac 6 accepts the attached example, demonstrating that this was an intented change.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>486011</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-01-18 02:06:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9][model] Java 9 Support in Java Model</short_desc>
        <thetext>Umbrella bug for Java 9 support in JDT Core Java Model</thetext>
        <comment>
            <comment_id>2758505</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-01 03:21:12 -0400</when>
            <comment_text>Created attachment 264522
Draft patch

This is the first cut draft patch. This is not complete by any means, but I just wanted to give an idea of what I think is needed from Java model. At a high level, I think we need two different kind of Java elements. One should be represent the module description for the module-info. This will be a child of ITypeRoot, equivalent to IType. I have added this in the attached path, in the form of IModuleDescription.

The second is the notion of a Java module, that a module project represents. Now, this needs more discussion. My idea for this is that it should:

1. provide the packages within this module
2. provide the packages exported within this module
3. provide a handle to the other "required" modules
4. provide the services provided and used.

I am not yet sure what the intended use for this, though.

For now, I will work on completing the former. It still needs support on element handle, source range etc.</comment_text>
        </comment>
        <comment>
            <comment_id>2767594</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-18 05:00:14 -0400</when>
            <comment_text>Created attachment 264910
Updated model changes

This adds more stuff to the previous patch. The patch has pretty much everything wrt to the module descriptor, except handle/identifier for new elements.</comment_text>
        </comment>
        <comment>
            <comment_id>2767599</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-18 05:03:57 -0400</when>
            <comment_text>Created attachment 264911
Code select changeds

Patch to be applied on top of the previous model related patch. But these need to be synced up with the latest BETA_JAVA9 branches as it collides with some of Sasi's recent changes.</comment_text>
        </comment>
        <comment>
            <comment_id>2768190</comment_id>
            <comment_count>4</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-19 06:43:27 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/83513</comment_text>
        </comment>
        <comment>
            <comment_id>2768212</comment_id>
            <comment_count>5</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-19 08:13:25 -0400</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/83513 was merged to [BETA_JAVA9].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=623763b4b76f1ec0b4fe3fc56f794a085f27cd95</comment_text>
        </comment>
        <comment>
            <comment_id>2768476</comment_id>
            <comment_count>6</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-20 02:17:15 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #5)
&gt; Gerrit change https://git.eclipse.org/r/83513 was merged to [BETA_JAVA9].
&gt; Commit:
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
&gt; ?id=623763b4b76f1ec0b4fe3fc56f794a085f27cd95

This patch caused three tests to fail in TypeHierarchyTests and I have commented out them for now. My investigation so far shows there is some undesired dependency between tests. I can emulate the same failure without my fix by opening some Java elements explicitly in tests.</comment_text>
        </comment>
        <comment>
            <comment_id>2769003</comment_id>
            <comment_count>7</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-10-21 09:49:01 -0400</when>
            <comment_text>The following stack trace comes up when I start eclipse:

	at java.io.DataInputStream.readBoolean(DataInputStream.java:244)
	at org.eclipse.jdt.internal.core.JavaModelManager$VariablesAndContainersLoadHelper.loadBoolean(JavaModelManager.java:3647)
	at org.eclipse.jdt.internal.core.JavaModelManager$VariablesAndContainersLoadHelper.loadPath(JavaModelManager.java:3737)
	at org.eclipse.jdt.internal.core.JavaModelManager$VariablesAndContainersLoadHelper.loadContainers(JavaModelManager.java:3709)
	at org.eclipse.jdt.internal.core.JavaModelManager$VariablesAndContainersLoadHelper.loadProjects(JavaModelManager.java:3767)
	at org.eclipse.jdt.internal.core.JavaModelManager$VariablesAndContainersLoadHelper.load(JavaModelManager.java:3601)
	at org.eclipse.jdt.internal.core.JavaModelManager.loadVariablesAndContainers(JavaModelManager.java:3438)
	at org.eclipse.jdt.internal.core.JavaModelManager.startup(JavaModelManager.java:5176)
	at org.eclipse.jdt.core.JavaCore.start(JavaCore.java:5878)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:774)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:724)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:933)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:309)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)</comment_text>
        </comment>
        <comment>
            <comment_id>2769060</comment_id>
            <comment_count>8</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-21 11:47:03 -0400</when>
            <comment_text>(In reply to Manoj Palat Limited Availability Till Nov 2 from comment #7)
&gt; The following stack trace comes up when I start eclipse:

This is probably related to the module source path container, but it will help if you can debug and post which container causes this.</comment_text>
        </comment>
        <comment>
            <comment_id>2769072</comment_id>
            <comment_count>9</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-10-21 12:10:34 -0400</when>
            <comment_text>Created attachment 264999
Projects to reproduce the scenario

@Jay - please find the reproducible zip</comment_text>
        </comment>
        <comment>
            <comment_id>2769142</comment_id>
            <comment_count>10</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-10-21 15:55:02 -0400</when>
            <comment_text>I agree that we need an IJavaElement that represents the module declaration in the module-info.java. But I don't think we need any children of this element.

Here are the main purposes of the Java model elements:

- Present a hierarchical structure of named elements that constitute a Java code base

- Serve as target element for user and API client operations, e.g. search for references, open type hierarchy, open call hierarchy, rename, open declaration

- Serve as context element for search results (e.g. the Search view shows the IMethod in whose body the search engine found a reference to a field, type, package, etc.)

- Offer a stable handleIdentifier string that can be used to store and re-create the element

IModuleDescription should be renamed to IModule. All other element types could also be called I*Description; the appendix doesn't add valuable information. The module element is structurally similar to the IPackageDeclaration element, but I guess that element was only called *Declaration to avoid confusion with the other IPackage* element types.

IModule should extend IJavaElement, ISourceReference. None of the methods on IMember is required on a module. There are a few that could have a reasonable implementation (getClassFile(), getCompilationUnit(), getTypeRoot(), isBinary()), but like for IPackageDeclaration, that information is trivially available by inspecting the type of getParent(). On IMember, these methods are interesting because members can be nested recursively. But that's not the case for package declarations and modules.

The children of IModuleDescription all represent references to other elements, not declarations that have individual names. They are comparable to references inside an IMethod's body. Such details are better left to an AST (which we currently don't need, but which could be added later).

Caveat: For bug 506369, I've added a reference to the type IModuleDescription in JDT UI. When you rename IModuleDescription to IModule, please leave an "interface IModuleDescription extends IModule" for a few days, so that we can update the UI without breakages.</comment_text>
        </comment>
        <comment>
            <comment_id>2769184</comment_id>
            <comment_count>11</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-21 22:45:23 -0400</when>
            <comment_text>(In reply to Markus Keller from comment #10)
&gt; IModuleDescription should be renamed to IModule. All other element types
&gt; could also be called I*Description; the appendix doesn't add valuable
&gt; information. The module element is structurally similar to the
&gt; IPackageDeclaration element, but I guess that element was only called
&gt; *Declaration to avoid confusion with the other IPackage* element types.

As I called out in comment #1, I wanted to specifically make that distinction between a module description and a module, esp. because at this point I wasn't sure of what a "module" provides to the client. In other words, a IJavaProject can "have" an IModuleDescription and "be" a IModule. I have no problem in having just one element (and call it IModule) if we are absolutely sure that we want to put every module related API in just one. On the other hand, having a separate IModule gives us the opportunity to provide additional APIs for the client, hypothetically at least.


&gt; IModule should extend IJavaElement, ISourceReference. None of the methods on
&gt; IMember is required on a module. There are a few that could have a
&gt; reasonable implementation (getClassFile(), getCompilationUnit(),
&gt; getTypeRoot(), isBinary()), but like for IPackageDeclaration, that
&gt; information is trivially available by inspecting the type of getParent(). On
&gt; IMember, these methods are interesting because members can be nested
&gt; recursively. But that's not the case for package declarations and modules.

That's about half the methods declared in IMember :). Let me also throw in the getSourceRange() from ISourceReference. And who knows, there could be modifiers (add getFlags() here) and Javadoc (add getJavadocRange() here). There's nothing in the docs of IMember that binds us to only those that can be nested. So, I am inclined to take the convenient approach here.

&gt; The children of IModuleDescription all represent references to other
&gt; elements, not declarations that have individual names. They are comparable
&gt; to references inside an IMethod's body. Such details are better left to an
&gt; AST (which we currently don't need, but which could be added later).

I had a discussion with Manoj some time back, and IIRC, he said search could use individual elements for better indexing/search.</comment_text>
        </comment>
        <comment>
            <comment_id>2769286</comment_id>
            <comment_count>12</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-23 02:38:11 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/83749</comment_text>
        </comment>
        <comment>
            <comment_id>2769287</comment_id>
            <comment_count>13</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-23 02:42:11 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #12)
&gt; New Gerrit change created: https://git.eclipse.org/r/83749

This patch addresses two issues:

1) Binary modules were not offered as part of completion. This was a regression  introduced by the first commit through this bug.

2) code select would only work on the last segment of the module name, for e.g., in my.mod, select only works on "mod" and not on "my". This was due to the fact that module name, unlike packages and types, is a single identifier. The '.' are not really separators but part of the identifier.

Added some test. But more tests on the way for model and code select.</comment_text>
        </comment>
        <comment>
            <comment_id>2769288</comment_id>
            <comment_count>14</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-23 04:13:59 -0400</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/83749 was merged to [BETA_JAVA9].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=e1882fb7451cd4afded135030307a827a4d3a76c</comment_text>
        </comment>
    </bug>
    <bug>
        <id>486021</id>
        <developer>Sergey Toshin</developer>
        <developer_username>stoshins</developer_username>
        <dup_id/>
        <creation_time>2016-01-18 04:18:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>this() call is resolved binding to wrong constructor</short_desc>
        <thetext>Created attachment 259232
Build to both files

Build the both files. Then open file Test.java, and call resolveConstructorBinding for this();

IMethodBinding for the same constructor will be given, but it's wrong, because they have different parameter sets.</thetext>
    </bug>
    <bug>
        <id>486222</id>
        <developer>jeps</developer>
        <developer_username>petteri.stenius</developer_username>
        <dup_id/>
        <creation_time>2016-01-21 01:53:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>NPE when launching JUnit tests by right clicking project</short_desc>
        <thetext>Launching JUnit tests for one of the projects in my workspace started to fail with NPE if I try to launch tests by right-clicking the project in Package Explorer. 

Running individual tests still works as expected. Also running JUnit tests for other projects works.

Eclipse Platform	4.5.1.M20150904-0015
Eclipse Java Development Tools	3.11.1.v20150904-0015

Stack trace

java.lang.NullPointerException
	at java.lang.String.&lt;init&gt;(String.java:166)
	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.findSuperInterfaces(HierarchyResolver.java:304)
	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.reportHierarchy(HierarchyResolver.java:566)
	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:851)
	at org.eclipse.jdt.internal.core.hierarchy.RegionBasedHierarchyBuilder.createTypeHierarchyBasedOnRegion(RegionBasedHierarchyBuilder.java:91)
	at org.eclipse.jdt.internal.core.hierarchy.RegionBasedHierarchyBuilder.build(RegionBasedHierarchyBuilder.java:60)
	at org.eclipse.jdt.internal.core.hierarchy.RegionBasedTypeHierarchy.compute(RegionBasedTypeHierarchy.java:98)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1268)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.core.JavaCore.newTypeHierarchy(JavaCore.java:4560)
	at org.eclipse.jdt.internal.junit.launcher.JUnit4TestFinder.findTestsInContainer(JUnit4TestFinder.java:128)
	at org.eclipse.jdt.junit.launcher.JUnitLaunchConfigurationDelegate.evaluateTests(JUnitLaunchConfigurationDelegate.java:260)
	at org.eclipse.jdt.junit.launcher.JUnitLaunchConfigurationDelegate.launch(JUnitLaunchConfigurationDelegate.java:125)
	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:885)
	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:739)
	at org.eclipse.debug.internal.ui.DebugUIPlugin.buildAndLaunch(DebugUIPlugin.java:1039)
	at org.eclipse.debug.internal.ui.DebugUIPlugin$8.run(DebugUIPlugin.java:1256)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)</thetext>
        <comment>
            <comment_id>2662727</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-01-21 04:04:54 -0500</when>
            <comment_text>Please attach the sample project which causes NPE.

Transferring to JDT Core for further comments.</comment_text>
        </comment>
        <comment>
            <comment_id>2662744</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-01-21 04:38:34 -0500</when>
            <comment_text>Looking at the code, we somehow end up with a super interface name of null. Possibly something is going wrong with the calculation of start/end. It would be nice to have a testcase, though.</comment_text>
        </comment>
        <comment>
            <comment_id>2662886</comment_id>
            <comment_count>3</comment_count>
            <who>jeps</who>
            <commenter_username>petteri.stenius</commenter_username>
            <when>2016-01-21 07:55:40 -0500</when>
            <comment_text>I'm sorry I cannot easily send the project causing the NPE. I have not been able to isolate the issue into a sample project.
Please let me know if there's anything else I could do.</comment_text>
        </comment>
        <comment>
            <comment_id>2663718</comment_id>
            <comment_count>4</comment_count>
            <who>jeps</who>
            <commenter_username>petteri.stenius</commenter_username>
            <when>2016-01-23 03:05:55 -0500</when>
            <comment_text>Created attachment 259347
Eclipse486222.java</comment_text>
        </comment>
        <comment>
            <comment_id>2663719</comment_id>
            <comment_count>5</comment_count>
            <who>jeps</who>
            <commenter_username>petteri.stenius</commenter_username>
            <when>2016-01-23 03:16:07 -0500</when>
            <comment_text>By going backwards in my SCM i was able to identify the code change that causes the failure.
The code is in the attachment Eclipse486222.java. If this file exists in a project's src/main/java tree then running JUnit tests for the project fails with NPE.
The code has a static method that defines a local class, where the local class name ends with a '$' character. If I rename the local class to something more appropriate without special characters then everything works ok.</comment_text>
        </comment>
        <comment>
            <comment_id>2663737</comment_id>
            <comment_count>6</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-01-23 07:08:15 -0500</when>
            <comment_text>(In reply to jeps from comment #5)
&gt; By going backwards in my SCM i was able to identify the code change that
&gt; causes the failure.
&gt; The code is in the attachment Eclipse486222.java. If this file exists in a
&gt; project's src/main/java tree then running JUnit tests for the project fails
&gt; with NPE.
&gt; The code has a static method that defines a local class, where the local
&gt; class name ends with a '$' character. If I rename the local class to
&gt; something more appropriate without special characters then everything works
&gt; ok.

Thanks for the analysis, but: Outch, that looks like asking for trouble.

The binary name of that local class is eclipse486222/Eclipse486222$1Predicate$

I guess when we see the first '$' we start trying to interpret '$' as the separator for nested classes, not part of a class name. Then when we encounter the second '$' we assume a second-level nested class, but we end up with no name for that second nested class -&gt; NPE

I'm not even sure if avoiding the NPE on our side is the best course of action, because quite likely that would just mask the underlying problem, without really supporting that strange class in functionality like search &amp; hierarchy lookup. To fully support all combinations of class nesting and source-level names including '$' would require to testing all possible interpretations with lots of accesses to the file system, like, if we have a type a$b$c, we need to check existence of
- c as nested in (b nested in a)
- class with source name b$c nested in a
- c nested in class with source name a$b
- class with source name a$b$c
More dollars cause combinatorial explosion.

I believe (without having checked the sources) we typically assume '$' is *either* a part of the name *or* the nested class separator, but don't account for it playing both roles within the same binary name!

And: there are lots of locations in the code that deal with the problem of interpreting '$'.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>486375</id>
        <developer>Stefan Xenos</developer>
        <developer_username>sxenos</developer_username>
        <dup_id/>
        <creation_time>2016-01-22 10:59:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Provide a mechanism to have different JavaDoc warning levels in different subtrees</short_desc>
        <thetext>Our codebase has slightly different JavaDoc conventions for unit tests and non-tests. In particular, normal code requires JavaDoc on all public declations but unit tests do not.

The same project contains both tests and non-tests, located in different source roots. I have a reliable way to tell the difference between tests and non-tests programmatically.

If it's already possible to do so, I'd like to write a plugin that causes the "missing javadoc on public declarations" feature to be enabled for non-tests and disabled for tests, such that these markers don't show up when compiling unit tests. 

If it's not possible, I'd like to contribute whatever JDT core support is necessary to facilitate such a plugin.

Either way, I could really use the advice of a JDT core expert to point me in the right direction. Where would be the best place to plug this feature in?

It looks to me as though the problem severity is determined by ProblemReporter, which in turn consults CompilerOptions... so if I could somehow use a different set of CompilerOptions for different subtrees, that should do the trick. Any tips?</thetext>
        <comment>
            <comment_id>2663555</comment_id>
            <comment_count>1</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-01-22 11:21:06 -0500</when>
            <comment_text>I notice that ProblemHandler.java line 145 tests for "ignoreOptionalProblems()" on the compilation unit, which in turn consults a property attached to the source root.

Perhaps a similar mechanism would work here. Something like ICompilationUnit#ignoreProblemId(problemId), which could in turn consult a blacklist attached to the source root.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>486415</id>
        <developer>Pascal Filion</developer>
        <developer_username>pascal.filion</developer_username>
        <dup_id/>
        <creation_time>2016-01-23 09:06:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Error when trying to move classes to a sub-package</short_desc>
        <thetext>What steps will reproduce the problem?
1. Move 5 classes to a sub-package withi n he same project.
2. I selected them from the Types view, tried Context Menu -&gt; Refactor -&gt; Move, tried drag and drop
3. Got the same error.

-- Error Details --
Date: Sat Jan 23 09:01:16 EST 2016
Message: Internal Error
Severity: Error
Product: Eclipse 4.5.1.20150917-1200 (org.eclipse.epp.package.java.product)
Plugin: org.eclipse.ltk.ui.refactoring
Session Data:
eclipse.buildId=4.5.1.M20150904-0015
java.version=1.8.0_65
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data C:\Development\oracle.cloud.mobile\toolkit\workspace

Exception Stack Trace:
java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:420)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:331)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:637)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:153)
	at org.eclipse.jdt.internal.ui.refactoring.reorg.ReorgMoveWizard$MoveInputPage.performFinish(ReorgMoveWizard.java:122)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:710)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:455)
	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:466)
	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:619)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4362)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4180)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3769)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:827)
	at org.eclipse.jface.window.Window.open(Window.java:803)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:187)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:202)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:122)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:38)
	at org.eclipse.jdt.internal.ui.refactoring.reorg.ReorgMoveStarter.run(ReorgMoveStarter.java:80)
	at org.eclipse.jdt.internal.ui.packageview.SelectionTransferDropAdapter.handleDropMove(SelectionTransferDropAdapter.java:283)
	at org.eclipse.jdt.internal.ui.packageview.SelectionTransferDropAdapter.performDrop(SelectionTransferDropAdapter.java:220)
	at org.eclipse.jdt.internal.ui.dnd.JdtViewerDropAdapter.drop(JdtViewerDropAdapter.java:246)
	at org.eclipse.jface.util.DelegatingDropAdapter$3.run(DelegatingDropAdapter.java:219)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:173)
	at org.eclipse.jface.util.DelegatingDropAdapter.drop(DelegatingDropAdapter.java:216)
	at org.eclipse.swt.dnd.DNDListener.handleEvent(DNDListener.java:91)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4362)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1137)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1122)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:788)
	at org.eclipse.swt.dnd.DropTarget.Drop(DropTarget.java:456)
	at org.eclipse.swt.dnd.DropTarget.Drop_64(DropTarget.java:392)
	at org.eclipse.swt.dnd.DropTarget$3.method6(DropTarget.java:260)
	at org.eclipse.swt.internal.ole.win32.COMObject.callback6(COMObject.java:119)
	at org.eclipse.swt.internal.ole.win32.COM.DoDragDrop(Native Method)
	at org.eclipse.swt.dnd.DragSource.drag(DragSource.java:363)
	at org.eclipse.swt.dnd.DragSource.access$0(DragSource.java:289)
	at org.eclipse.swt.dnd.DragSource$1.handleEvent(DragSource.java:172)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4362)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4180)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3769)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:654)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1515)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1488)
Caused by: java.lang.NullPointerException
Root exception:
java.lang.NullPointerException</thetext>
        <comment>
            <comment_id>2664547</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-01-26 08:31:05 -0500</when>
            <comment_text>(In reply to Pascal Filion from comment #0)
&gt; Caused by: java.lang.NullPointerException
&gt; Root exception:
&gt; java.lang.NullPointerException

Do you have any details of this NullPointerException?</comment_text>
        </comment>
        <comment>
            <comment_id>2664559</comment_id>
            <comment_count>2</comment_count>
            <who>Pascal Filion</who>
            <commenter_username>pascal.filion</commenter_username>
            <when>2016-01-26 08:52:45 -0500</when>
            <comment_text>Unfortunately no, the stack trace didn't include it. I was surprised about that.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>486430</id>
        <developer>Pawel Nowak</developer>
        <developer_username>siersciotluk</developer_username>
        <dup_id/>
        <creation_time>2016-01-24 09:12:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Auto increment serial version UUID with each save</short_desc>
        <thetext>I think it would be nice feature to increment the default serial version uuid (1L) each time whevener a class have been saved after beging marked dirty.</thetext>
    </bug>
    <bug>
        <id>486445</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-01-25 04:19:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[content assist] Substring completion for Javadoc tags</short_desc>
        <thetext>Created attachment 259358
patch

public class C {
	/**
	 * @p
	 */
	public static void main(String[] args) {}
}

In the above example, invoke content assist after "@p" when substring completion is enabled in preferences. =&gt; ICodeAssist#codeComplete does not return substring proposals like '@deprecated'.

Fix should go in CompletionJavadocParser#possibleTags, which should have a check for substringMatch along with prefixEquals. See attached patch.

However, before calling #substringMatch, there should be a check to see if substring completion is enabled. I am not sure how this information can be accessed in CompletionJavadocParser from CompletionEngine#options.

Also, the proposals relevance should be adjusted similar to bug 481752.

Jay, please have a look.</thetext>
    </bug>
    <bug>
        <id>486622</id>
        <developer>Markus Duft</developer>
        <developer_username>markus.duft</developer_username>
        <dup_id/>
        <creation_time>2016-01-27 02:35:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>newTypeHierarchy throws IndexOutOfBounds</short_desc>
        <thetext>We have some functionality built on top of JDT that allows us to search for specific classes extending a certain well known type. We call newTypeHierarchy on that well known type (of course only if it is present). This works very well, except sometimes, and I have NO idea what causes this, we get this exception:

java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
	at java.util.ArrayList.rangeCheck(ArrayList.java:653)
	at java.util.ArrayList.get(ArrayList.java:429)
	at org.eclipse.jdt.internal.core.Buffer.notifyChanged(Buffer.java:261)
	at org.eclipse.jdt.internal.core.Buffer.close(Buffer.java:111)
	at org.eclipse.jdt.internal.core.Openable.closeBuffer(Openable.java:90)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:588)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:316)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:302)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:120)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:160)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getType(PackageBinding.java:145)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.isViewedAsDeprecated(PackageBinding.java:229)
	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isViewedAsDeprecated(ReferenceBinding.java:1550)
	at org.eclipse.jdt.internal.compiler.ast.ASTNode.isTypeUseDeprecated(ASTNode.java:589)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveLeafType(ParameterizedSingleTypeReference.java:297)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:146)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveType(ParameterizedSingleTypeReference.java:365)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:567)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType(TypeReference.java:541)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype(ClassScope.java:1292)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperclass(ClassScope.java:938)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:1095)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:323)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:292)
	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.accept(HierarchyResolver.java:166)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:178)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:201)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findImport(CompilationUnitScope.java:468)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findSingleImport(CompilationUnitScope.java:522)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.resolveSingleImport(CompilationUnitScope.java:735)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3309)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:3041)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveLeafType(ParameterizedSingleTypeReference.java:174)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:146)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveType(ParameterizedSingleTypeReference.java:365)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:567)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType(TypeReference.java:541)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype(ClassScope.java:1292)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperclass(ClassScope.java:938)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:1095)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:323)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:292)
	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.accept(HierarchyResolver.java:166)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:178)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:201)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3329)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:3041)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveLeafType(ParameterizedSingleTypeReference.java:174)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:146)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveType(ParameterizedSingleTypeReference.java:365)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:567)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType(TypeReference.java:541)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype(ClassScope.java:1292)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperclass(ClassScope.java:938)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:1095)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:323)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:292)
	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.accept(HierarchyResolver.java:166)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:178)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:201)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findImport(CompilationUnitScope.java:468)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findSingleImport(CompilationUnitScope.java:522)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.resolveSingleImport(CompilationUnitScope.java:735)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3309)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:3041)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:51)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:472)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:571)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:567)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType(TypeReference.java:541)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype(ClassScope.java:1292)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperclass(ClassScope.java:938)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:1095)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:323)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:317)
	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:816)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.buildForProject(IndexBasedHierarchyBuilder.java:227)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.buildFromPotentialSubtypes(IndexBasedHierarchyBuilder.java:307)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:132)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:301)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1268)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:832)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:790)
	at com.wamas.ide.junit4.view.scanner.TestScanner.scan(TestScanner.java:35)
	at com.wamas.ide.junit4.view.RefreshTestsJob.run(RefreshTestsJob.java:30)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)</thetext>
        <comment>
            <comment_id>2665287</comment_id>
            <comment_count>1</comment_count>
            <who>Timo Kinnunen</who>
            <commenter_username>timo.kinnunen</commenter_username>
            <when>2016-01-27 16:32:31 -0500</when>
            <comment_text>org.eclipse.jdt.internal.core.Buffer has this comment right after the point where the exception is thrown: 

// ensure that no other thread is adding/removing a listener at the same time (https://bugs.eclipse.org/bugs/show_bug.cgi?id=126673)

Could be the fix for bug 126673 was incomplete.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>486705</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-01-28 04:51:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[completion] code completion for keywords ignores compliance</short_desc>
        <thetext>Followup of bug 486359

In a project of 1.4 compliance, completing on num| results in "enum" being shown as one of the proposals.

Note: This is an issue with prefix completion as well.</thetext>
        <comment>
            <comment_id>2665427</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-01-28 05:12:54 -0500</when>
            <comment_text>The issue is reproducible with Eclipse 3.8.1 also.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>486710</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-01-28 05:16:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8] issue with Open Declared Type for lambda parameter with recovery</short_desc>
        <thetext>followup of bug 479963 comment 9

As of Build id: I20160127-2000 the issue exists.

import java.util.function.Consumer;
import java.util.function.Supplier;

class X1 {
	Supplier&lt;Consumer&lt;String&gt;&gt; c = new Supplier&lt;Consumer&lt;String&gt;&gt;() {
		@Override
		public Consumer&lt;String&gt; get() {
			return item -&gt; System.out.println(item);
		}
		
	};
	{
		"a".eq;
	}

}</thetext>
    </bug>
    <bug>
        <id>486823</id>
        <developer>Ralf Sternberg</developer>
        <developer_username>rsternberg</developer_username>
        <dup_id/>
        <creation_time>2016-01-29 09:00:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>NPE logged as warning, error reporter does not pop up</short_desc>
        <thetext>I get the following NPE frequently when content assist tries (and fails) to replace some parameter type or return type. This error ends up as a warning in the error log and the error reporting tool does not pop up.

Not sure what to make of this. Is it a JFace issue that reports the NPE only as a warning? Is it aeri that ignores it?

If this stacktrace is not already in your database, could you please delegate the issue? Thanks.

The IDE is Neon, RCP package, a recent milestone:
Eclipse for RCP and RAP Developers	4.6.0.20151218-1543	epp.package.rcp

java.lang.NullPointerException
	at org.eclipse.jdt.internal.formatter.TokenManager.firstIndexBefore(TokenManager.java:216)
	at org.eclipse.jdt.internal.formatter.TokenManager.firstTokenBefore(TokenManager.java:220)
	at org.eclipse.jdt.internal.formatter.SpacePreparator.handleTokenBefore(SpacePreparator.java:946)
	at org.eclipse.jdt.internal.formatter.SpacePreparator.visit(SpacePreparator.java:197)
	at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:611)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2782)
	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:470)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)
	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.prepareSpaces(DefaultCodeFormatter.java:354)
	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.prepareFormattedCode(DefaultCodeFormatter.java:195)
	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:157)
	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:141)
	at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteFormatter.formatString(ASTRewriteFormatter.java:246)
	at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteFormatter.formatNode(ASTRewriteFormatter.java:376)
	at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteFormatter.getFormattedResult(ASTRewriteFormatter.java:187)
	at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer.doTextInsert(ASTRewriteAnalyzer.java:1357)
	at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer.rewriteRequiredNode(ASTRewriteAnalyzer.java:824)
	at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer.rewriteReturnType(ASTRewriteAnalyzer.java:1822)
	at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer.visit(ASTRewriteAnalyzer.java:2017)
	at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:611)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)
	at org.eclipse.jdt.core.dom.rewrite.ASTRewrite.internalRewriteAST(ASTRewrite.java:302)
	at org.eclipse.jdt.core.dom.rewrite.ASTRewrite.rewriteAST(ASTRewrite.java:291)
	at org.eclipse.jdt.ui.text.java.correction.ASTRewriteCorrectionProposal.addEdits(ASTRewriteCorrectionProposal.java:113)
	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createTextChange(CUCorrectionProposal.java:231)
	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createChange(CUCorrectionProposal.java:238)
	at org.eclipse.jdt.ui.text.java.correction.ChangeCorrectionProposal.getChange(ChangeCorrectionProposal.java:366)
	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.getTextChange(CUCorrectionProposal.java:248)
	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.getAdditionalProposalInfo(CUCorrectionProposal.java:141)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$Timer$2$1.run(AdditionalInfoController.java:113)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)</thetext>
        <comment>
            <comment_id>2666051</comment_id>
            <comment_count>1</comment_count>
            <who>Marcel Bruch</who>
            <commenter_username>marcel.bruch</commenter_username>
            <when>2016-01-29 09:15:22 -0500</when>
            <comment_text>Ralf,

by convention AERI (automated *error* reporting) does not respond to warnings. That explains why you don't get an error popup.

This particular problem belongs to JDT UI I guess.  Moving it there for triage.</comment_text>
        </comment>
        <comment>
            <comment_id>2666200</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-01-29 14:58:55 -0500</when>
            <comment_text>@Mateusz, do you think this qualifies as a duplicate of bug 475746?</comment_text>
        </comment>
        <comment>
            <comment_id>2666223</comment_id>
            <comment_count>3</comment_count>
            <who>Mateusz Matela</who>
            <commenter_username>mateusz.matela</commenter_username>
            <when>2016-01-29 16:37:48 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #2)
&gt; @Mateusz, do you think this qualifies as a duplicate of bug 475746?

Well, identical stack trace and matching time frame suggest that this particular exception will almost certainly not occur with newer builds.

This bug report is more general though, isn't it? Ralf suggests that when a problem like that occurs in the formatter (or other components), the user should be able to send a report on it. I agree it may help catching more bugs.

I've seen some automated reports for exceptions from the formatter, so I'm not sure why it's not the case here. Maybe it's because the formatting was called from ASTRewrite which decided that failure at this point is not important enough, or maybe something has changed recently in this context.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>486893</id>
        <developer>Lukas Eder</developer>
        <developer_username>lukas.eder</developer_username>
        <dup_id/>
        <creation_time>2016-01-30 12:29:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[quick assist][quick fix] Create local variable should not partially reformat statement</short_desc>
        <thetext>Consider the following code:


---------------------------------------------
import java.util.stream.Stream;

public class Test {
    void x() {
        s =
        Stream.of(1, 2, 3)
              .limit(2);
    }
}
---------------------------------------------


Calling the quick fix "create local variable 's'" on 's' produces the following, undesired output


---------------------------------------------
public class Test {
    void x() {
        Stream&lt;Integer&gt; s = Stream.of(1, 2, 3)
              .limit(2);
    }
}
---------------------------------------------

Expected output:

---------------------------------------------
public class Test {
    void x() {
        Stream&lt;Integer&gt; s = 
        Stream.of(1, 2, 3)
              .limit(2);
    }
}
---------------------------------------------

The quick fix should be unopinionated about my formatting style.</thetext>
        <comment>
            <comment_id>2669384</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-02-08 08:17:19 -0500</when>
            <comment_text>Mateusz, what can we do here? I believe quick fix always goes through rewrite, which means the formatting will change.

But what's interesting is that the output changes when I do a format.</comment_text>
        </comment>
        <comment>
            <comment_id>2694270</comment_id>
            <comment_count>2</comment_count>
            <who>Mateusz Matela</who>
            <commenter_username>mateusz.matela</commenter_username>
            <when>2016-04-13 16:23:30 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #1)
&gt; Mateusz, what can we do here? I believe quick fix always goes through
&gt; rewrite, which means the formatting will change.
Yeah, the formatter only gets this line to format:
Stream&lt;Integer&gt; s=MISSING();
So nothing can be done at this level, something in ASTRewrite would need to change.

&gt; But what's interesting is that the output changes when I do a format.
You mean the "Expected output" from comment 0? It depends on formatter wrapping settings.</comment_text>
        </comment>
        <comment>
            <comment_id>2694650</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-14 10:08:01 -0400</when>
            <comment_text>Lukas, can you check your formatter wrapper settings? If the output after the rewrite is as per your preference, then I am afraid we can't do much here.</comment_text>
        </comment>
        <comment>
            <comment_id>2694700</comment_id>
            <comment_count>4</comment_count>
            <who>Lukas Eder</who>
            <commenter_username>lukas.eder</commenter_username>
            <when>2016-04-14 10:50:41 -0400</when>
            <comment_text>Hmm,

I don't see how formatting settings are related to this issue. I mean

   a) other options don't have this effect, including "create field" and "create parameter"
   b) It works differently (but still incorrectly) like this:

      ---------------------------------------------
      import java.util.stream.Stream;

      public class Test {
          void x() {
              s =
                  /* */
              Stream.of(1, 2, 3)
                    .limit(2);
          }
      }
      ---------------------------------------------

      which produces

      ---------------------------------------------
      import java.util.stream.Stream;

      public class Test {
          void x() {
              Object s = /* */
              Stream.of(1, 2, 3)
                    .limit(2);
          }
      }
      ---------------------------------------------</comment_text>
        </comment>
        <comment>
            <comment_id>2702220</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-03 05:11:09 -0400</when>
            <comment_text>(In reply to Lukas Eder from comment #4)
&gt;    a) other options don't have this effect, including "create field" and
&gt; "create parameter"

In those cases (after the rewrite) and in the code specified as expected output in comment #0, can you try what happens when you format the code? If the output changes, then you could fix the behavior by adjusting your formatter settings.

Mateusz, BTW, I played around with the Assignment's wrapper options but can't quite get the format specified as expected output. Any hints?


(In reply to Mateusz Matela from comment #2)
&gt; Yeah, the formatter only gets this line to format:
&gt; Stream&lt;Integer&gt; s=MISSING();
&gt; So nothing can be done at this level, something in ASTRewrite would need to
&gt; change.

This needs to be looked at.</comment_text>
        </comment>
        <comment>
            <comment_id>2702282</comment_id>
            <comment_count>6</comment_count>
            <who>Lukas Eder</who>
            <commenter_username>lukas.eder</commenter_username>
            <when>2016-05-03 07:07:50 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #5)
&gt; In those cases (after the rewrite) and in the code specified as expected
&gt; output in comment #0, can you try what happens when you format the code?

The output does change.

&gt; If the output changes, then you could fix the behavior by adjusting your
&gt; formatter settings.

While that might be a workaround (in case I do find which one of the hundreds of formatting options gets involved here), I still don't fully understand why the formatter is applied in the first place. I really wish the formatter were applied only explicitly, when I want it to be applied.

In the case of Stream formatting (or any builder pattern API), I *never* want the formatter to be applied.

I understand you don't agree with this, but if there were at least an option somewhere in the preferences where I can say: "Leave formatting untouched after any refactoring action", or an option "Format only when explicitly requested", then I'd be very happy. :-)</comment_text>
        </comment>
        <comment>
            <comment_id>2702291</comment_id>
            <comment_count>7</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-03 07:21:29 -0400</when>
            <comment_text>(In reply to Lukas Eder from comment #6)
&gt; I really wish
&gt; the formatter were applied only explicitly, when I want it to be applied.
&gt; 
&gt; In the case of Stream formatting (or any builder pattern API), I *never*
&gt; want the formatter to be applied.
&gt; 
&gt; I understand you don't agree with this, but if there were at least an option
&gt; somewhere in the preferences where I can say: "Leave formatting untouched
&gt; after any refactoring action", or an option "Format only when explicitly
&gt; requested", then I'd be very happy. :-)

&lt;rant&gt;
to leave formatting untouched seems to conflict with the requirement to change the code. It has to be changed in some format, doesn't it?

What about this "unformatted" result:
public class Test {
    void x() {
Stream&lt;Integer&gt; s = 
        Stream.of(1, 2, 3)
              .limit(2);
    }
}
is that better?
For other quick fixes it would be even worse, think of quick fix to implement an inherited abstract method, should it really be created "without format"?

@Override public String test() throws IOException { // TODO Auto-generated method stub return null;  }

this doesn't even compile
&lt;/rant&gt;

Just saying :)</comment_text>
        </comment>
        <comment>
            <comment_id>2702355</comment_id>
            <comment_count>8</comment_count>
            <who>Lukas Eder</who>
            <commenter_username>lukas.eder</commenter_username>
            <when>2016-05-03 09:08:51 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #7)
&gt; to leave formatting untouched seems to conflict with the requirement to
&gt; change the code. It has to be changed in some format, doesn't it?

OK, you're right. By that definition, some "formatting" needs to be done. So, I'll bite

&gt; 
&gt; What about this "unformatted" result:
&gt; [...]
&gt; is that better?

No. "Obviously" not. But what's "obvious"?

&gt; For other quick fixes it would be even worse, think of quick fix to
&gt; implement an inherited abstract method, should it really be created "without
&gt; format"?

I suspect that *in this case* it would be the expected default. But not in my case. All I'm asking Eclipse to do is amend the variable declaration with a type definition, or, fix the syntax. I have every reason to assume that this will only ever prepend the type to the variable name at the exact location where the variable was, and not format a subsection of my code that seems unrelated to the action itself.

Conversely, check this out:

----------------------------------------
import java.util.stream.Stream;

public class Test {
    void x() {
        // Deliberate excess indentation 
           s =
        Stream.of(1, 2, 3)
                .limit(2);
    }
}
----------------------------------------

Now, repeat the exercise to get this:

----------------------------------------
import java.util.stream.Stream;

public class Test {
    void x() {
           Stream&lt;Integer&gt; s = Stream.of(1, 2, 3)
                .limit(2);
    }
}
----------------------------------------

Somehow, the excess indentation seems to be more important than the fact that I like newlines in this particular case.

Now, consider this:

----------------------------------------
import java.util.stream.Stream;

public class Test {
    void x() {
        Stream&lt;Integer&gt; s1;
        
        s = s1 =
        Stream.of(1, 2, 3)
                .limit(2);
    }
}
----------------------------------------

Repeat the exercise to get this (finally, the "wanted" behaviour):

----------------------------------------
import java.util.stream.Stream;

public class Test {
    void x() {
        Stream&lt;Integer&gt; s1;
        
        Stream&lt;Integer&gt; s = s1 =
        Stream.of(1, 2, 3)
                .limit(2);
    }
}
----------------------------------------

Apply formatting to get again this:

----------------------------------------
import java.util.stream.Stream;

public class Test {
    void x() {
        Stream&lt;Integer&gt; s1;

        Stream&lt;Integer&gt; s = s1 = Stream.of(1, 2, 3)
            .limit(2);
    }
}
----------------------------------------

I could do this all day to show you that this refactoring hardly ever matches my formatting rules, such that formatting currently has a different effect from refactoring. :)


I don't think there's a single rule to rule them all, which is to always apply "some" formatting. You're right in your case. When overriding a method, the stub can be formatted according to some overriding stub formatting rules, if you want.


But a general rule will never be consistent (probably), unless you format the entire file after refactoring, which really isn't close to what anyone wants. Ideally, you'll just implement the "minimal intrusion" (just prepend the type, don't really modify the rest) and let the user decide if they want to format any given section according to their rules.

"Just saying" ;-) And I totally rest my case that I would like to be able to opt out of any implicit, automatic formatting from Eclipse.</comment_text>
        </comment>
        <comment>
            <comment_id>2702395</comment_id>
            <comment_count>9</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-03 10:16:27 -0400</when>
            <comment_text>I see two directions in this discussion: 
(1) Make rewriting smarter to further minimize format changes.
(2) A global preference option to make rewriting on behalf of quick fixes totally format-agnostic.

@Lukas, are you really asking for (2)? It sounds like it, but to me this is really hard to believe; anticipating that in the majority of cases you'll be disappointed how stupid format-agnostic rewriting is.

Conversely, I believe we can all easily agree on the intention (1), but here my feeling is: much has already been done to apply formatting only were needed, and further fine tuning *may* be quite an effort compared to a small gain.
At least the observation re "Stream&lt;Integer&gt; s=MISSING();" indicates some room for improvement in this particular case. So should we focus on this?

(In reply to Lukas Eder from comment #8)
&gt; Ideally, you'll just implement the "minimal intrusion" (just prepend
&gt; the type, don't really modify the rest) ...

here's where I think it might be technical issues, what gets in our way: There is no AST node where we can simply "prepend the type", we have to replace an Assignment by a SingleVariableDeclaration. I assume that this technicality currently dictates the scope of formatting. It'd be a bad excuse, for sure, just saying that this seemingly trivial request cannot be served by our current infra structure (if my interpretation is right).</comment_text>
        </comment>
        <comment>
            <comment_id>2702410</comment_id>
            <comment_count>10</comment_count>
            <who>Lukas Eder</who>
            <commenter_username>lukas.eder</commenter_username>
            <when>2016-05-03 10:28:47 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #9)
&gt; I see two directions in this discussion: 
&gt; (1) Make rewriting smarter to further minimize format changes.
&gt; (2) A global preference option to make rewriting on behalf of quick fixes
&gt; totally format-agnostic.

Excellent.

&gt; @Lukas, are you really asking for (2)? It sounds like it, but to me this is
&gt; really hard to believe; anticipating that in the majority of cases you'll be
&gt; disappointed how stupid format-agnostic rewriting is.

I'm not really asking for this, but if the Ctrl+Shift+F rules should apply (partially) as suggested here, then I might review that opinion. To me Ctrl+Shift+F always formats a given and large scope, e.g. a selection. In this case, formatting is much more local, not even spanning an entire expression.

&gt; Conversely, I believe we can all easily agree on the intention (1), but here
&gt; my feeling is: much has already been done to apply formatting only were
&gt; needed, and further fine tuning *may* be quite an effort compared to a small
&gt; gain.
&gt; At least the observation re "Stream&lt;Integer&gt; s=MISSING();" indicates some
&gt; room for improvement in this particular case. So should we focus on this?

Sure! :) When I opened this issue, I only wanted to focus on this particular case. Then, the formatting discussion somehow started and escalated...</comment_text>
        </comment>
        <comment>
            <comment_id>2702631</comment_id>
            <comment_count>11</comment_count>
            <who>Mateusz Matela</who>
            <commenter_username>mateusz.matela</commenter_username>
            <when>2016-05-03 16:34:37 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #5)
&gt; Mateusz, BTW, I played around with the Assignment's wrapper options but
&gt; can't quite get the format specified as expected output. Any hints?

You're right, it cannot be done. We'd need to introduce a new indentation policy - "Do not indent".</comment_text>
        </comment>
    </bug>
    <bug>
        <id>486992</id>
        <developer>nwao nwao</developer>
        <developer_username>xhihx</developer_username>
        <dup_id/>
        <creation_time>2016-02-02 04:10:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Java Syntax coloring can't save</short_desc>
        <thetext>I unchecked Bold checkbox of Prefrences-&gt;Java-&gt;Editor-&gt;Syntax coloring, and click Apply. 
After restarted Eclipse the checkbox is checked automatically. It seems can't save. 

I'm working on Eclipse jee-mars on Win7 64bit
-- Configuration Details --
Product: Eclipse 4.5.1.20150917-1200 (org.eclipse.epp.package.jee.product)
Installed Features:
 org.eclipse.jdt 3.11.1.v20150904-0015</thetext>
    </bug>
    <bug>
        <id>487383</id>
        <developer>Carl Myers</developer>
        <developer_username>cmyers</developer_username>
        <dup_id/>
        <creation_time>2016-02-05 19:04:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][compiler][generics] Discrepancy between Eclipse compiler and sun compiler when using wildcards and inference</short_desc>
        <thetext>Created attachment 259610
Code that compiles with javac but fails with ecj

The supplied code compiles with javac but fails to compile with ecj-4.6M5 (and 4.5.1).  Also attached as a file for convenience.

JAVAC:
javac A.java
=&gt; success

ECJ:

java -jar ecj-4.6M5.jar -source 1.8 -target 1.8 A.java
=&gt; failure

----------
1. ERROR in /home/cmyers/projects/private_notes/persistent/bugs/20160205-jdk-versus-ecj/A.java (at line 24)
        Iterable&lt;Out&lt;?&gt;&gt; outs = transform(ins, this::fn);
                                ^^^^^^^^^^^^^^^^^^^^^^^^
Type mismatch: cannot convert from Iterable&lt;Object&gt; to Iterable&lt;A.Out&lt;?&gt;&gt;
----------
1 problem (1 error)


====

import java.util.ArrayList;

class A {

    interface Function&lt;B, C&gt; {
        C apply(B input);
    }

    private &lt;B,C&gt; Iterable&lt;C&gt; transform(Iterable&lt;B&gt; iterable, Function&lt;? super B, ? extends C&gt; transform) {
        // impl not relevant for bug
        return new ArrayList&lt;&gt;();
    }

    public static class In&lt;V&gt; {}
    public static class Out&lt;V&gt; {}

    public &lt;V&gt; Out&lt;V&gt; fn(In&lt;V&gt; in) {
        return null;
    }

    public void lambda() {
        Iterable&lt;In&lt;?&gt;&gt; ins = new ArrayList&lt;&gt;();

        Iterable&lt;Out&lt;?&gt;&gt; outs = transform(ins, this::fn);
    }

    public void anonymous() {
        Iterable&lt;In&lt;?&gt;&gt; ins = new ArrayList&lt;&gt;();

        Iterable&lt;Out&lt;?&gt;&gt; outs = transform(ins, new Function&lt;In&lt;?&gt;, Out&lt;?&gt;&gt;() {
            @Override
            public Out&lt;?&gt; apply(In&lt;?&gt; in) {
                return null;
            }
        });
    }
}</thetext>
        <comment>
            <comment_id>2669074</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-06 07:23:29 -0500</when>
            <comment_text>Thanks, I can reproduce in all versions of ecj since Java 8 GA.

Interestingly, this variant *is* accepted:

//---
    public void lambda2() {
        Iterable&lt;In&lt;?&gt;&gt; ins = new ArrayList&lt;&gt;();

        Iterable&lt;Out&lt;?&gt;&gt; outs = transform(ins, i -&gt; fn(i));
    }
//---</comment_text>
        </comment>
    </bug>
    <bug>
        <id>487391</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-02-06 12:31:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler][1.8] detect super type cycle due to new rule in JLS</short_desc>
        <thetext/>
        <comment>
            <comment_id>2669087</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-06 12:35:34 -0500</when>
            <comment_text>https://bugs.openjdk.java.net/browse/JDK-8041994 defines a new kind of dependency, which needs to be implemented for cycle detection.

The spec addition is 

"A class C directly depends on a type T if T is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier +++in the fully qualified form+++ of a superclass or superinterface name."</comment_text>
        </comment>
    </bug>
    <bug>
        <id>487686</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-02-11 13:03:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[formatter] Make default profiles work with auto-format: Disable formatting for commented code</short_desc>
        <thetext>I've been forced to work in projects that use the "Eclipse [built-in]" code formatter profile and Save Actions that include auto-format. This combination is unbearable if you're testing/developing code and you have to temporarily comment out some lines of code.

The fix is already available in the formatter, but it's not enabled by default:

On the Comments page:
- Disable: Format line comments on first column
- Enable: Never indent line comments on first column

This is a request to change these settings in the default profiles.</thetext>
        <comment>
            <comment_id>2670926</comment_id>
            <comment_count>1</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-02-11 13:34:05 -0500</when>
            <comment_text>+1 for the change.

@Markus, I use Git-&gt; replace with HEAD to revert such test changes</comment_text>
        </comment>
        <comment>
            <comment_id>2670929</comment_id>
            <comment_count>2</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-02-11 13:39:15 -0500</when>
            <comment_text>This bug is also to great reminder that the Platform projects should use their own defaults. 

I guess if Markus would be forced to use the default Java Debug perspective we would have something useful soon.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>487787</id>
        <developer>Ed Willink</developer>
        <developer_username>ed</developer_username>
        <dup_id/>
        <creation_time>2016-02-13 09:57:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null] null-free map is not null-free</short_desc>
        <thetext>The example below demonstrates a rather evil misdiagnosis that a variable cannot be null, when it can. If the diagnostic is exploited by the priogrammer to eliminate the "redundant null check" the program becomes buggy. The problem is that the call to initializeStrings is not diagnosed as unsafe. IMHO passing an @NonNull template parameter to undeclared-null must be at least a warning and quite probably an error.


import java.util.HashMap;
import java.util.Map;

import org.eclipse.jdt.annotation.NonNull;

public class Test {

	public static void main(String[] args) {
		Map&lt;@NonNull String, @NonNull String&gt; nonNullString2nonNullString = new HashMap&lt;@NonNull String, @NonNull String&gt;();
		initializeStrings(nonNullString2nonNullString);  // There should be a warning/error here
		for (Map.Entry&lt;@NonNull String, @NonNull String&gt; entry : nonNullString2nonNullString.entrySet()) {
				String value = entry.getValue();
				if (value != null) {		// "Redundant null check: The variable value cannot be null at this location"
					value.toString();
				}
		}
	}
	
	private static void initializeStrings(Map&lt;String, String&gt; bindings) {
		bindings.put(null, null);
	}
}</thetext>
    </bug>
    <bug>
        <id>487812</id>
        <developer>yuhki nagise</developer>
        <developer_username>nagise</developer_username>
        <dup_id/>
        <creation_time>2016-02-15 06:30:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Illegal overload with type variable</short_desc>
        <thetext>The following code compiles with Eclipse:

------------------------------------------------
public class Sample {
	public interface Foo {}
	public interface Bar {}
	
	public &lt;T extends Foo&amp;Bar&gt; void xxx(T t){}
	public &lt;T extends Bar&amp;Foo&gt; void xxx(T t){}
}
------------------------------------------------

Whereas it fails with javac 1.8.0_51:

------------------------------------------------
Sample.java:8: error: method &lt;T&gt;xxx(T) is already defined in class Sample
        public &lt;T extends Bar&amp;Foo&gt; void xxx(T t){}
                                        ^
  where T is a type-variable:
    T extends Foo,Bar declared in method &lt;T&gt;xxx(T)
1 error
------------------------------------------------

and, it fails with Eclipse:

------------------------------------------------
public class SampleEx extends Sample{
	@Override
	public &lt;T extends Foo &amp; Bar&gt; void xxx(T t) {}
	@Override
	public &lt;T extends Bar &amp; Foo&gt; void xxx(T t) {}
}
------------------------------------------------

Name clash: The method xxx(T) of type SampleEx has the same erasure as xxx(T) of type Sample but does not override it

The method xxx(T) of type SampleEx must override or implement a supertype method</thetext>
    </bug>
    <bug>
        <id>487848</id>
        <developer>Hrishikesh Joshi</developer>
        <developer_username>hrish.j</developer_username>
        <dup_id/>
        <creation_time>2016-02-15 22:54:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Build stuck at 66% when building gradle project with Spark and HBase dependencies</short_desc>
        <thetext>The workspace keeps building when the with gradle project having hbase and spark dependencies.
Also I find the .log file gets deleted everytime the project is opened.

-- Configuration Details --
Product: Eclipse 4.4.2.20150219-0708 (org.eclipse.epp.package.java.product)
Installed Features:
 org.eclipse.jdt 3.10.1.v20150204-1700</thetext>
        <comment>
            <comment_id>2672071</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-16 06:58:58 -0500</when>
            <comment_text>Do you use the BuildShip plugin for gradle integration?

If so, does the hang also occur when you (temporarily) disable the gradle builder?

We need to find out if this is a genuine JDT problem or should be moved towards the BuildShip project.</comment_text>
        </comment>
        <comment>
            <comment_id>2681600</comment_id>
            <comment_count>2</comment_count>
            <who>Hrishikesh Joshi</who>
            <commenter_username>hrish.j</commenter_username>
            <when>2016-03-14 00:26:12 -0400</when>
            <comment_text>No. Not using buildship plugin. Infact its not the gradle build which fails but building eclipse workspace (When we chose from Project &gt;&gt; Build Project Automatically) is getting stuck</comment_text>
        </comment>
        <comment>
            <comment_id>2682074</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-14 16:30:28 -0400</when>
            <comment_text>If not using buildship, how do you tell JDT about your dependencies? Perhaps attaching .project and .classpath might be a start towards understanding your solution.

Additionally for any problem with stuck / hanging processes please see the following hints on how to gather more information: https://wiki.eclipse.org/How_to_report_a_deadlock</comment_text>
        </comment>
        <comment>
            <comment_id>2682177</comment_id>
            <comment_count>4</comment_count>
            <who>Hrishikesh Joshi</who>
            <commenter_username>hrish.j</commenter_username>
            <when>2016-03-14 22:08:52 -0400</when>
            <comment_text>Hi Stephan,
I have observed after some debugging on my side, the eclipse getting stuck is happening due to only one source file. Will follow the steps the link mentioned to take the heap dump and will attach.</comment_text>
        </comment>
        <comment>
            <comment_id>2682740</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-15 18:51:32 -0400</when>
            <comment_text>(In reply to Hrishikesh Joshi from comment #4)
&gt; [...] mentioned to take the heap dump and will attach.

I hope you meant to say "thread dump"</comment_text>
        </comment>
    </bug>
    <bug>
        <id>487850</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-02-16 02:02:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] Delay initialization of IModuleLocation until a build is requested</short_desc>
        <thetext>Some versions of IModuleLocation have initializeModule() method that is called before a build. Normally this works, but in certain cases, this causes the exception:

java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.builder.ClasspathDirectory.acceptModule(ClasspathDirectory.java:124)
	at org.eclipse.jdt.internal.core.builder.ClasspathDirectory.initializeModule(ClasspathDirectory.java:69)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forSourceFolder(ClasspathLocation.java:36)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:259)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:150)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:3912)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2155)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:422)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:177)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:735)


The problem is that the module location tries to access its INameEnvironment but there is only a null, because in the case where the state is read from persistence, the name environment is null. Need to find a way to delay initializeModule() until the build is necessary and the JavaBuilder can fill the State and in turn the module locations with the name environment.</thetext>
        <comment>
            <comment_id>2671985</comment_id>
            <comment_count>1</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-02-16 03:14:20 -0500</when>
            <comment_text>This is the same exception I encountered (as in bug 487204 comment 2) and I have modified the current scheme to achieve this, so may be you can look at my upcoming patch for module resolution and see if that is adequate</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488077</id>
        <developer>Peter Rader</developer>
        <developer_username>p.rader</developer_username>
        <dup_id/>
        <creation_time>2016-02-19 03:38:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Jump to wrong declaration while compilation error, should jump to nested Class before Class.</short_desc>
        <thetext>Warning: This only works in uncompilable code.

If i have two classes:

public interface Inter{
  public interface Test{
  }
}
public class Test extends Inter{
  private Test t = new Test(); //&lt;-- gives compilatoin error, but ignore that.
}

If you press Ctrl+LMB to the type of the field, it takes you to the Class but should take you to the nested Interface.</thetext>
        <comment>
            <comment_id>2673582</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-02-19 03:58:14 -0500</when>
            <comment_text>Actually the compilation error in on the class declaration itself about type being extended should be a class and not an interface. Is that not what you see?

And I don't understand why you think the class Test is not a valid type for the field. Can you elaborate please?</comment_text>
        </comment>
        <comment>
            <comment_id>2673843</comment_id>
            <comment_count>2</comment_count>
            <who>Peter Rader</who>
            <commenter_username>p.rader</commenter_username>
            <when>2016-02-19 13:03:30 -0500</when>
            <comment_text>Sure, we have two types of name "Test", a class and a interface.

Inside the class "Test" the type-declaration of the field resolves to the nested-interface, not the outer-class.

You will understand that if you reproduce the problem.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488078</id>
        <developer>Boris van Katwijk</developer>
        <developer_username>bvkatwijk</developer_username>
        <dup_id/>
        <creation_time>2016-02-19 04:07:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Incorrect JavaDoc /** + Enter autocomplete when method contains "*/"</short_desc>
        <thetext>If a method contains the string "*/", like:

	public static String getJavadocEndTag() {
		return "*/";
	}

 typing [/** + Enter] to generate JavaDoc will generate:

	/**
	 * 
	public static String getJavadocEndTag() {
		return "*/";
	}

It does not seem to matter where the "*/" occurs in the method.

Note: when using the "generate comment" shortcut (Alt+Shift+J), the JavaDoc generation works fine.

Tested in Luna (4.4.0) and Mars (5.4.1)</thetext>
    </bug>
    <bug>
        <id>488229</id>
        <developer>Oliver Gierke</developer>
        <developer_username>ogierke</developer_username>
        <dup_id/>
        <creation_time>2016-02-22 09:57:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Trailing whitespace still not correctly removed in JavaDoc</short_desc>
        <thetext>Consider the following setup:

1. The formatter settings are configured to add an empty line between JavaDoc description and @tags.
2. Save actions are activated to remove all trailing whitespace.

Consider the following state of a Java class

class Foo {

  /**
   * Some description.
   * @return
   */
  public void foo() { … }
}

If that class is saved, a new line is added between the description and the @return tag and it still contains a trailing space:

class Foo {

  /**
   * Some description.
   * &lt;- trailing space here
   * @return
   */
  public void foo() { … }
}

If I now make another change to the file and save it again, the trailing space is removed.

class Foo {

  /**
   * Some description &lt;-removed the dot here
   *&lt;- no trailing space here
   * @return
   */
  public void foo() { … }
}

So we're basically left with a quite inconsistent way of trailing whitespace removal, depending on what gets added and changed.</thetext>
    </bug>
    <bug>
        <id>488244</id>
        <developer>Gray</developer>
        <developer_username>gray.eclipse</developer_username>
        <dup_id/>
        <creation_time>2016-02-22 11:50:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Inserting { inside of a constructor string argument causes cursor to move to end of line</short_desc>
        <thetext>When I have a constructor (not a method call) that takes a String (or String[]) that contains "{", Eclipse gets confused when I insert another "{" in to the string.

   // position the cursor, inside of the "" and try to insert another {
   new String("");

Trying to insert a { inside of the "" causes the cursor to move to the end of the line but then it is very confused about the cursor position.  Deleting the new { returns the cursor inside the constructor string argument.</thetext>
        <comment>
            <comment_id>2674475</comment_id>
            <comment_count>1</comment_count>
            <who>Gray</who>
            <commenter_username>gray.eclipse</commenter_username>
            <when>2016-02-22 11:54:41 -0500</when>
            <comment_text>Aha.  This only happens if you have "Automatically insert at correct position... Braces" checked off.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488327</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-02-23 12:51:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>disable fatalOptionalErrors in our code</short_desc>
        <thetext>I'd like to leverage bug 479303, mostly I have this use case:

- I want to test the difference made by a certain code block, so I comment the block and run tests.

- Then I notice that by commenting, an import became unused =&gt; error

Since bug 479303 this shouldn't block running tests, except that bug 479303 respects the option fatalOptionalErrors, so I'm back at square one, where for each such experiments imports unnecessarily have to be "organized".

Therefor I'm suggesting we switch fatalOptionalErrors to disabled.

If there's any error (optional or mandatory) this will fail the build anyway, so no danger we'd ever ship such code, right?</thetext>
    </bug>
    <bug>
        <id>488328</id>
        <developer>Roberto Lublinerman</developer>
        <developer_username>rluble</developer_username>
        <dup_id/>
        <creation_time>2016-02-23 12:53:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][compiler][inference] Wrong method overload resolution (may lead to VerifyError)</short_desc>
        <thetext>Compiling with -source 8 the following class results in a VerifyError in when attempting to run it.

class Test {
  static class A&lt;R&gt; {
    class  I {
    }
  }

  public static &lt;R&gt; void m(A&lt;R&gt;.I instance, R generic) {
    System.out.println("called with A&lt;R&gt;.I");
  }

  public static void m(long l, Object o) {
    System.out.println("called with long");
  }

  public static void main(String... args) {
    Long l = new Long(3);
    m(l, l);
  }
}

The error is the following 

Error: A JNI error has occurred, please check your installation and try again
Exception in thread "main" java.lang.VerifyError: Bad type on operand stack
Exception Details:
  Location:
    Test.main([Ljava/lang/String;)V @13: invokestatic
  Reason:
    Type 'java/lang/Long' (current frame, stack[0]) is not assignable to 'Test$A$I'
  Current Frame:
    bci: @13
    flags: { }
    locals: { '[Ljava/lang/String;', 'java/lang/Long' }
    stack: { 'java/lang/Long', 'java/lang/Long' }
  Bytecode:
    0x0000000: bb00 2259 1400 24b7 0026 4c2b 2bb8 0029
    0x0000010: b1                                     

	at java.lang.Class.getDeclaredMethods0(Native Method)
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2703)
	at java.lang.Class.privateGetMethodRecursive(Class.java:3050)
	at java.lang.Class.getMethod0(Class.java:3020)
	at java.lang.Class.getMethod(Class.java:1786)
	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)
	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)


IMHO this is the result of choosing the wrong overload and happens only in 1.8 mode when there is generics and autoconversion involved.

The code compiles and runs fine in 4.4.2 but fails in 4.5 onwards. I have seen a similar failure where the wrong overload is chosen but does not result in a VerifyError, instead it results in wrong dispatch. I'll post that repro case once I can repro it in a small example.</thetext>
        <comment>
            <comment_id>2674899</comment_id>
            <comment_count>1</comment_count>
            <who>Roberto Lublinerman</who>
            <commenter_username>rluble</commenter_username>
            <when>2016-02-23 13:00:28 -0500</when>
            <comment_text>Slightly changing the example to 

public class Test2 {

  static class A&lt;R&gt; {
    class  I {
    }
  }

  public static &lt;R&gt; void m(A&lt;R&gt;.I instance, R generic) {
    System.out.println("called with A&lt;R&gt;.I");
  }

  public static void m(Integer s, Object o) {
    System.out.println("called with integer");
  }

  public static void main(String... args) {
    Long l = new Long(3);
    m(l, l);
  }
}

makes it fail under 4.4.2 as well. Under java 7 this code is correctly rejected in 4.4.2.</comment_text>
        </comment>
        <comment>
            <comment_id>2674915</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-23 13:32:25 -0500</when>
            <comment_text>Thanks.

Here's what ecj -1.7 says:

        m(l, l);
        ^
The method m(Test2.A&lt;R&gt;.I, R) in the type Test2 is not applicable for the arguments (Long, Long)

javac reports similarly (across versions).

ecj -1.8 clearly is the odd one out, since neither of the 'm' methods is applicable.</comment_text>
        </comment>
        <comment>
            <comment_id>2674930</comment_id>
            <comment_count>3</comment_count>
            <who>Roberto Lublinerman</who>
            <commenter_username>rluble</commenter_username>
            <when>2016-02-23 14:04:53 -0500</when>
            <comment_text>Yes. 

But in the case of the first example (the one in the original post) m(A.I, Object) is chosen incorrectly with -1.8 in 4.5 triggering a VerifyError.

The right overload m(long, Object) is chose with -1.7.</comment_text>
        </comment>
        <comment>
            <comment_id>2674998</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-23 17:32:05 -0500</when>
            <comment_text>(In reply to Roberto Lublinerman from comment #3)
&gt; Yes. 
&gt; 
&gt; But in the case of the first example (the one in the original post) m(A.I,
&gt; Object) is chosen incorrectly with -1.8 in 4.5 triggering a VerifyError.

That sounds like a variant of the same problem: ecj -1.8 considers m(A.I,Object) as applicable where in fact it is not (this method overload is also the one wrongly chosen in comment 1).</comment_text>
        </comment>
        <comment>
            <comment_id>2688323</comment_id>
            <comment_count>5</comment_count>
            <who>Jesper Moller</who>
            <commenter_username>jesper</commenter_username>
            <when>2016-03-30 05:47:05 -0400</when>
            <comment_text>I'll have a look at this unless you object, Stephen?</comment_text>
        </comment>
        <comment>
            <comment_id>2692921</comment_id>
            <comment_count>6</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-04-11 09:39:05 -0400</when>
            <comment_text>(In reply to Jesper Moller from comment #5)
&gt; I'll have a look at this unless you object, Stephen?

No objection :)
Do you have a theory already, where things might be going wrong in ecj?</comment_text>
        </comment>
        <comment>
            <comment_id>2692926</comment_id>
            <comment_count>7</comment_count>
            <who>Jesper Moller</who>
            <commenter_username>jesper</commenter_username>
            <when>2016-04-11 09:41:58 -0400</when>
            <comment_text>Sorry, no, I haven't, and I won't be able to work on it this week.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488454</id>
        <developer>Lukas Eder</developer>
        <developer_username>lukas.eder</developer_username>
        <dup_id/>
        <creation_time>2016-02-25 06:59:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[quick assist] Convert to 'for' loop using index eats comments</short_desc>
        <thetext>Consider this test program:

------------------------------------------------------------
import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        for (String s : Arrays.asList("a", "b")) {
            /* xx */

            // abc
            System.out.println(s);
        }
    }
}
------------------------------------------------------------

Now, on the for loop, choose the quick assist (Ctrl+1) option "Convert to 'for' loop using index". The /* xx */ comment disappears and I get the following result:

------------------------------------------------------------
import java.util.Arrays;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        List&lt;String&gt; asList = Arrays.asList("a", "b");
        for (int i = 0; i &lt; asList.size(); i++) {
            String s = asList.get(i);
            // abc
            System.out.println(s);
        }
    }
}
------------------------------------------------------------

Expected result:


------------------------------------------------------------
import java.util.Arrays;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        List&lt;String&gt; asList = Arrays.asList("a", "b");
        for (int i = 0; i &lt; asList.size(); i++) {
            String s = asList.get(i);
            /* xx */

            // abc
            System.out.println(s);
        }
    }
}
------------------------------------------------------------</thetext>
        <comment>
            <comment_id>2675630</comment_id>
            <comment_count>1</comment_count>
            <who>Lukas Eder</who>
            <commenter_username>lukas.eder</commenter_username>
            <when>2016-02-25 07:09:34 -0500</when>
            <comment_text>Also, comments that are placed before the loop disappear as well:

Before:

------------------------------------------------------------
import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        // xx
        for (String s : Arrays.asList("a", "b")) {
            // abc
            System.out.println(s);
        }
    }
}
------------------------------------------------------------

After:

------------------------------------------------------------
import java.util.Arrays;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        List&lt;String&gt; asList = Arrays.asList("a", "b");
        for (int i = 0; i &lt; asList.size(); i++) {
            String s = asList.get(i);
            // abc
            System.out.println(s);
        }
    }
}
------------------------------------------------------------

Expected:


------------------------------------------------------------
import java.util.Arrays;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        List&lt;String&gt; asList = Arrays.asList("a", "b");
        // xx
        for (int i = 0; i &lt; asList.size(); i++) {
            String s = asList.get(i);
            // abc
            System.out.println(s);
        }
    }
}
------------------------------------------------------------</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488532</id>
        <developer>Vladimir Piskarev</developer>
        <developer_username>pisv</developer_username>
        <dup_id/>
        <creation_time>2016-02-26 03:11:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Compilation unit exists when its parent doesn't</short_desc>
        <thetext>Created attachment 259950
Test projects

It can be demonstrated that a compilation unit (not a working copy) can answer true from #exists() when its parent package fragment doesn't exist in the Java model. Probably not a big deal but might be worth reporting.

Steps to reproduce:

1. Import the two projects from the attached test.zip (don't import the nested 'TestProject')

2. Run the 'test' project as JUnit Plug-in Test

3. Observe the failing test

Perhaps it would be a bit more consistent if Openable#exists() explicitly checked for parent existence? Something like this:

public boolean exists() {
    if (JavaModelManager.getJavaModelManager().getInfo(this) != null)
        return true;
    IJavaElement parent = getParent();
    if (parent != null &amp;&amp; !parent.exists())
        return false;
    ...
}</thetext>
    </bug>
    <bug>
        <id>488541</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-02-26 05:25:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] restricted keywords in module-info.java</short_desc>
        <thetext>Created attachment 259951
Screenshot

"module" is a new keyword with the scope of module-info.java.

So I can still create packages having the word "module". And I should be able to use these packages in my module-info.java file.

For example, the following file should not have any error (assuming I have packages named "module", "test.module" and "p1" in my source folder - see attached screenshot):

module src {
	exports module;
	exports test.module;
	exports p1;
	provides java.lang.module.ModuleDescriptor with p1.A1;
	uses java.lang.module.Configuration;
}

Currently we get compile error at all the usages of "module" (except at the declaration).

Also, "module" should not be colored as a keyword (except at the declaration) - to be fixed in jdt.text.

Please clarify if the above is not the correct understanding.</thetext>
        <comment>
            <comment_id>2709485</comment_id>
            <comment_count>1</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-05-19 13:32:37 -0400</when>
            <comment_text>The grammar given in http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html#jigsaw-1 is not a syntactic grammar in the sense of JLS8 2.3, because it contains a set of &lt;Identifier&gt;s that are considered "restricted keywords".

This new style of grammar is a new concept, and the ECJ parser and the scanner APIs are not prepared to deal with context-sensitive keywords. I.e. I'm not sure http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=1cc7d27c43e9d6f266edd7944e7969b3b5f0e4f4 made sense. E.g. something like IScanner#resetTo(int, int) cannot be implemented without keeping state if some character sequences can be either a keyword or an identifier, depending on context.

I don't know whether the parser generator supports context-sensitive grammars. We probably better keep the module file parser completely separate from the normal Java parser. Their only common parts are the productions for Identifier, PackageName, and TypeName, and those are trivial.</comment_text>
        </comment>
        <comment>
            <comment_id>2709643</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-19 17:05:41 -0400</when>
            <comment_text>What do we know about the meaning of "restricted keywords"?

All I can find is: "(i.e. they are keywords solely where they appear as terminals in ModuleDeclaration, and are identifiers everywhere else)"

On first reading I had assumed that this makes use of these words as Identifier impossible for the entire module-info file.

How could we read that sentence to allow the example from comment 0?

Things would be obvious if the spec just stated:
"they are keywords solely where they appear in ModuleDeclaration, and are identifiers everywhere else"

In that case "module" etc. were definitely keywords throughout the full body of a module declaration, not usable as identifiers.

Can the insertion of "as terminals" change the meaning? Also Identifier is a terminal, so I don't see how that insertion helps any. I think what Markus is expecting should be phrased as:
"they are keywords solely where they appear as keywords in ModuleDeclaration, and are identifiers everywhere else".
Now it's getting spooky :)

If still allowing "module" in identifier position inside a module declaration were the intended meaning then perhaps, we'd need rules like

   Name = Identifier | 'module' | 'requires' | ...

and retrofit the scanned keywords into identifiers when needed.


I'd love to see more from the EG before jumping to any conclusion here.</comment_text>
        </comment>
        <comment>
            <comment_id>2709954</comment_id>
            <comment_count>3</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-05-20 07:59:52 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #2)

The following module-info.java file compiles with javac but not with ECJ (Syntax error on token "module", Identifier expected):
module src {
	uses java.lang.module.Configuration;
}

Also, section 1.4 of http://openjdk.java.net/projects/jigsaw/spec/sotms/ shows the module-info.java file for java.base, which has this statement:
exports java.lang.module;</comment_text>
        </comment>
        <comment>
            <comment_id>2710056</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-20 09:47:20 -0400</when>
            <comment_text>(In reply to Noopur Gupta from comment #3)
&gt; (In reply to Stephan Herrmann from comment #2)
&gt; 
&gt; The following module-info.java file compiles with javac but not with ECJ
&gt; (Syntax error on token "module", Identifier expected):
&gt; module src {
&gt; 	uses java.lang.module.Configuration;
&gt; }
&gt; 
&gt; Also, section 1.4 of http://openjdk.java.net/projects/jigsaw/spec/sotms/
&gt; shows the module-info.java file for java.base, which has this statement:
&gt; exports java.lang.module;

Mh, specification by example?

So the following would be legal, too?

 module module {
   requires requires;
   exports to to exports;
   uses module;
   provides uses with to;
 }

etc.

Is that the intention? I really wonder how that would be specified.
Perhaps pattern matching is more appropriate here than parsing.</comment_text>
        </comment>
        <comment>
            <comment_id>2710141</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-20 10:46:07 -0400</when>
            <comment_text>More on the constructive side: IF the intention is indeed to allow restricted keywords "as much as possible", we seem to be looking for an alternating scanner, which perpetually toggles between two states "module" vs. "regular" (only if the current CUD is module-info.java).

I seems, if we ignore ';' and '{' that every odd token in the stream should recognize restricted keywords as keywords, and every even token will accept them as identifiers.

This should restore applicability of jikespg etc for module-info.java. Whether or not we use two separate grammars or one big doesn't seem to make much difference to me.</comment_text>
        </comment>
        <comment>
            <comment_id>2710225</comment_id>
            <comment_count>6</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-05-20 12:28:03 -0400</when>
            <comment_text>&gt; Perhaps pattern matching is more appropriate here than parsing.

Yup, but a problem is that module files should probably support comments as well, so those would have to be removed before the pattern matching hits in.

&gt; we seem to be looking for an alternating scanner, which perpetually toggles
&gt; between two states "module" vs. "regular"

The problem with that is that you need to know *where* to toggle. I've quickly explored this in bug 488754 comment 1. You basically have to parse the qualified names to know when you've reached the last segment of a name -- which would be the point where to go back to "module" state.

A fact that could help in parsing module files is that the structure of the ModuleDeclaration production is quite simple, and the only place where there's some recursion are the ModuleName|PackageName|TypeName nonterminals.</comment_text>
        </comment>
        <comment>
            <comment_id>2710248</comment_id>
            <comment_count>7</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-20 13:15:37 -0400</when>
            <comment_text>(In reply to Markus Keller from comment #6)
&gt; &gt; we seem to be looking for an alternating scanner, which perpetually toggles
&gt; &gt; between two states "module" vs. "regular"
&gt; 
&gt; The problem with that is that you need to know *where* to toggle. I've
&gt; quickly explored this in bug 488754 comment 1. You basically have to parse
&gt; the qualified names to know when you've reached the last segment of a name
&gt; -- which would be the point where to go back to "module" state.

Why not let Identifier and '.' participate in the toggling? 

Saw a '.' -&gt; next is regular java.
Saw an Identifier -&gt; next is module context (which includes recognizing '.')
See another '.' -&gt; go back to regular 
etc.

My comment about odd and even tokens was meant quite literally.
Only ';' and '{' and 'public' break the pattern by staying in "module" state.</comment_text>
        </comment>
        <comment>
            <comment_id>2720466</comment_id>
            <comment_count>8</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-06-14 12:03:33 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #7)
&gt; Why not let Identifier and '.' participate in the toggling? 

That would mean the '.' in a package name or fully-qualified type name would not belong to the Java context? Sounds like calling for trouble.

Maybe we should just keep the Java scanner unchanged, always consider the "restricted keywords" as identifiers, and let higher-level infrastructure report bad structures as syntax errors.</comment_text>
        </comment>
        <comment>
            <comment_id>2720480</comment_id>
            <comment_count>9</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-14 12:23:15 -0400</when>
            <comment_text>(In reply to Markus Keller -- away till June 25 from comment #8)
&gt; (In reply to Stephan Herrmann from comment #7)
&gt; &gt; Why not let Identifier and '.' participate in the toggling? 
&gt; 
&gt; That would mean the '.' in a package name or fully-qualified type name would
&gt; not belong to the Java context?

That's not what I meant. I only meant that '.' would be a *trigger* for toggling Java vs. module scanner contexts.

My comment "next is module context (which includes recognizing '.')" may have been misleading in this regard, sorry.

&gt; Maybe we should just keep the Java scanner unchanged, always consider the
&gt; "restricted keywords" as identifiers, and let higher-level infrastructure
&gt; report bad structures as syntax errors.

I'm not sure how we would ever create a module AST, if all are Identifiers at that stage?


FWIW, I just fed my example from comment 4 into javac (b122) and indeed, we only get resolve errors, no syntax errors. Interesting! 
Do we meanwhile have any spec that backs this interpretation of "restricted keywords"?</comment_text>
        </comment>
        <comment>
            <comment_id>2720533</comment_id>
            <comment_count>10</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-06-14 14:02:18 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/75266</comment_text>
        </comment>
        <comment>
            <comment_id>2720535</comment_id>
            <comment_count>11</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-14 14:04:12 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #10)
&gt; New Gerrit change created: https://git.eclipse.org/r/75266

Illustration of what I have in mind. Passes all parser tests, incl. the nonsense example from comment 4.

WDYT?</comment_text>
        </comment>
        <comment>
            <comment_id>2720591</comment_id>
            <comment_count>12</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-14 16:18:55 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #11)
&gt; (In reply to Eclipse Genie from comment #10)
&gt; &gt; New Gerrit change created: https://git.eclipse.org/r/75266
&gt; 
&gt; Illustration of what I have in mind. Passes all parser tests, incl. the
&gt; nonsense example from comment 4.
&gt; 
&gt; WDYT?

We have +1 from hudson.</comment_text>
        </comment>
        <comment>
            <comment_id>2720758</comment_id>
            <comment_count>13</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-06-15 05:48:59 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #11)
&gt; WDYT?

I'm about to leave for vacation, so only a quick and unverified answer:

I don't see how IScanner#resetTo(..) could be implemented correctly if the scanner keeps internal state like isInModuleDeclaration() and areRestrictedModuleKeywordsActive(). The idea of the scanner is that you get a context-free token stream.

(In reply to Stephan Herrmann from comment #9)
&gt; I'm not sure how we would ever create a module AST, if all are Identifiers
&gt; at that stage?

The internal AST may not look pretty, since you e.g. can't distinguish sequences of 2 identifiers. But the DOM AST can have a structure similar to the context-sensitive grammar, since it can depend on the actual contents of the identifiers.</comment_text>
        </comment>
        <comment>
            <comment_id>2720879</comment_id>
            <comment_count>14</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-15 10:41:06 -0400</when>
            <comment_text>(In reply to Markus Keller -- away till June 25 from comment #13)
&gt; (In reply to Stephan Herrmann from comment #11)
&gt; &gt; WDYT?
&gt; 
&gt; I'm about to leave for vacation, so only a quick and unverified answer:
&gt; 
&gt; I don't see how IScanner#resetTo(..) could be implemented correctly if the
&gt; scanner keeps internal state like isInModuleDeclaration() and
&gt; areRestrictedModuleKeywordsActive().

Right, currently it just discards that state.

&gt; The idea of the scanner is that you get
&gt; a context-free token stream.

To me this sounds like contradictory requirements: detect keywords depending on context, but remain context-free. At some point we *must* interpret the token and the *requires* context.

My strategy for resolving this conflict would be: try to ensure that resetTo() always goes to a checkpoint of the same "color", most likely: to a location where a keyword is expected (only relevant when inside module-info.java of course).
 

&gt; (In reply to Stephan Herrmann from comment #9)
&gt; &gt; I'm not sure how we would ever create a module AST, if all are Identifiers
&gt; &gt; at that stage?
&gt; 
&gt; The internal AST may not look pretty, since you e.g. can't distinguish
&gt; sequences of 2 identifiers. But the DOM AST can have a structure similar to
&gt; the context-sensitive grammar, since it can depend on the actual contents of
&gt; the identifiers.

In my understanding a keyword-less scanner will not support any real parsing but will only push lots of identifiers on the identifier stack without ever consuming anything from stacks. Evaluating this stack of identifiers sounds like manually implementing a parser in the first place. Am I missing anything? What can the existing infrastructure (jikespg etc.) help, if the scanner doesn't recognize any keywords?


If s.o. wants to implement that keyword-less parser, I'm fine. But the contextual scanner we already have and only need to ensure that we never try to start from / resetTo an identifier position. That sounds doable to me. Are there other uses of resetTo that I might be missing? 
I don't see on-demand parsing of details playing a role for module-info.java (as we have it for diet vs. parseMethodBodies) - we don't have any bodies in this language.


While Jenkins already approved my changes we can easily agree that we need more tests involving:
- comments
- syntax errors / recovery
- anything else needing special focus during testing?</comment_text>
        </comment>
        <comment>
            <comment_id>2746719</comment_id>
            <comment_count>15</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-03 18:37:34 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #10)
&gt; New Gerrit change created: https://git.eclipse.org/r/75266

Patch set #3 contains a corresponding implementation of resetTo(..) that does an AST-less parsing upto the start position in order to determine the scan context.

I left in a commented sysout in resetTo(..) for easier experimentation (use with: set selection in the editor and hit Shift-Alt-T).

@Sasi: the main things we were missing were
- one call to setActiveParser()
- handling of EOF (to immediately stop parsing).

With this cleaned-up version resetTo(..) seems to work as desired, expect for the case of selecting inside the initial 'module' keyword. May require special-casing.

@Markus: we are confident that the machinery we have in place should also support the up-coming challenges from Valhalla.</comment_text>
        </comment>
        <comment>
            <comment_id>2746728</comment_id>
            <comment_count>16</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-04 03:05:23 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #15)
&gt; (In reply to Eclipse Genie from comment #10)
&gt; &gt; New Gerrit change created: https://git.eclipse.org/r/75266
&gt; 
&gt; Patch set #3 contains a corresponding implementation of resetTo(..) that
&gt; does an AST-less parsing upto the start position in order to determine the
&gt; scan context.

Test failures are in compiler.apt.tests and read:
Internal compiler error: java.util.ServiceConfigurationError: javax.annotation.processing.Processor: Provider org.eclipse.jdt.compiler.apt.tests.processors.messager.MessagerProc not found at java.util.ServiceLoader.fail(ServiceLoader.java:239)

Has anyone seen this? S.t. running in module mode which lacks a module-info?

In the logs I could not find which jdk9 version is being used for tests. Where would I find this info?</comment_text>
        </comment>
        <comment>
            <comment_id>2747131</comment_id>
            <comment_count>17</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-06 00:16:23 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #16)
&gt; Has anyone seen this? S.t. running in module mode which lacks a module-info?

These are probably same as ones reported in bug 486013, comment #8? Known issue but not yet investigated.</comment_text>
        </comment>
        <comment>
            <comment_id>2747229</comment_id>
            <comment_count>18</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-06 05:46:56 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #17)
&gt; (In reply to Stephan Herrmann from comment #16)
&gt; &gt; Has anyone seen this? S.t. running in module mode which lacks a module-info?
&gt; 
&gt; These are probably same as ones reported in bug 486013, comment #8? Known
&gt; issue but not yet investigated.

Yes, seems to be the same. 

I tried to understand the connection between the mentioned http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=0171d3fa20410a884ea6de07ec393bc179fb73bd and bug 487421 on which it is booked. Why exactly is the offending override needed?
If closing is needed, is there a better why to do this without spoiling the class loader? It seems only getResourceAsStream() can add items into URLCL.closeables, so if clients of said method properly close the stream all should be fine?</comment_text>
        </comment>
        <comment>
            <comment_id>2747601</comment_id>
            <comment_count>19</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-06 18:14:41 -0400</when>
            <comment_text>Patch set #4 has 3 updates:

(1) fix an off-by-one error: getScanContext() should stop *before* the begin of resetTo().

(2) enable parser-less scanners to signal 'isModuleInfo' in resetTo(), used by SelectionEngine.

(3) some tests in a new suite ResolveTests9


Together, (2) &amp; (3) demonstrate that indeed the same word can correctly produce a code selection (in identifier position) or not (in keyword position).


@Sasi, what do you think of this version?</comment_text>
        </comment>
        <comment>
            <comment_id>2748104</comment_id>
            <comment_count>20</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-07 17:53:09 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #17)
&gt; (In reply to Stephan Herrmann from comment #16)
&gt; &gt; Has anyone seen this? S.t. running in module mode which lacks a module-info?
&gt; 
&gt; These are probably same as ones reported in bug 486013, comment #8? Known
&gt; issue but not yet investigated.

How do you guys test these days, when hudson aborts upon these failures?

Should we disable the tests for now?</comment_text>
        </comment>
        <comment>
            <comment_id>2748131</comment_id>
            <comment_count>21</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-07 23:52:11 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #20)
&gt; How do you guys test these days, when hudson aborts upon these failures?

I run the tests locally before pushing it. I know it's a step backward, but much more predictable than Hudson these days :)

&gt; Should we disable the tests for now?

Sorry I was just happy with my make-shift arrangement not thinking about others who rely on Hudson. Agree, that's the right thing to do. Let me disable the failing tests for now.</comment_text>
        </comment>
        <comment>
            <comment_id>2749409</comment_id>
            <comment_count>22</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-09-12 02:30:08 -0400</when>
            <comment_text>(In reply to comment #19)
&gt; Patch set #4 has 3 updates:
&gt; 
&gt; (1) fix an off-by-one error: getScanContext() should stop *before* the begin of
&gt; resetTo().
&gt; 
&gt; (2) enable parser-less scanners to signal 'isModuleInfo' in resetTo(), used by
&gt; SelectionEngine.
&gt; 
&gt; (3) some tests in a new suite ResolveTests9
&gt; 
&gt; 
&gt; Together, (2) &amp; (3) demonstrate that indeed the same word can correctly produce
&gt; a code selection (in identifier position) or not (in keyword position).
&gt; 
&gt; 
&gt; @Sasi, what do you think of this version?
Wow.. Will use this with the upcoming grammar changes for new keywords (exports dynamic, requires static etc) and see if I can find a case where something breaks</comment_text>
        </comment>
        <comment>
            <comment_id>2776785</comment_id>
            <comment_count>23</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-16 19:10:35 -0500</when>
            <comment_text>Bad news:

restricted keywords are indeed keywords when they are keywords, and identifiers otherwise. No way around a self-referential definition.

My wording, but the essence of thread "Compiling Java 9" in http://mail.openjdk.java.net/pipermail/jigsaw-dev/2016-November/thread.html

To add insult to injury: with the change from "requires public" to "requires transitive" we have the following ambiguous pair of rules:

ModuleStatement:
  requires transitive ModuleName ;
  requires ModuleName ; 

We can't fully classify tokens as keywords or identifiers until we see the terminating ';'.

Even with our best patches so far will not be able to solve this.

As rumours go, Oracle have a fully hand-written parser for this. Now we know why.

OTOH, they don't have to support parse-as-you-type.


What options do we have?

- implement our own hand-written parser, too. Including manually implementing recovery, error reporting, handling of source positions and all that. That parser must include the full annotation sub-language of Java. Maybe a hand-written module-parser could actually delegate to the normal java-parser for annotations (in that context restricted keywords are strictly disabled).

- continue to pile one tweak on another. For the particular case of 'transitive' (where even with full context info it could be keyword *or* identifier) we could add another instance of a vanguard parser, just to tell what kind of token this is.

- some heuristic rules by Jon Gibbons, claiming that limited lookahead suffices: http://mail.openjdk.java.net/pipermail/jigsaw-dev/2016-November/010130.html

- parse only identifiers, '{', '}', '.' and ';', put it all in an unstructured intermediate representation and do a post parse phase that interprets everything and creates "nice" AST. Manually implement recovery, error reporting etc.

- others?

BTW: I asked, if s.t. like an escape character had been considered, which would explicitly turn a keyword back into an identifier. Xtext languages, e.g., do this by default.

Answer was: no, it has not been considered.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488857</id>
        <developer>Tim Knies</developer>
        <developer_username>knies</developer_username>
        <dup_id/>
        <creation_time>2016-03-02 08:39:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[formatter] Add new option "at end of class" for "New Lines" settings</short_desc>
        <thetext>It would be a great feature, when there is a new formatter option to create a new line at the end of a class.

public class Example {

    public void doExample() {
    }
//-- add new line here --//
}</thetext>
    </bug>
    <bug>
        <id>488860</id>
        <developer>Davy Landman</developer>
        <developer_username>davy.landman</developer_username>
        <dup_id/>
        <creation_time>2016-03-02 09:03:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Binding recovery fails for the other occurrences of a unresolvable binding (making createASTs order dependent)</short_desc>
        <thetext>Created attachment 260046
Runner file

We've been using JDT for quite a while now to extract bindings from java code. Thanks for the work!

Recently we observed that sometimes MethodDeclaration bindings were missing. After quite some debugging we found that for certain Types that can't be solved (incomplete class path) and that they only get solved the first time. The second time JDT sees the same Type, it will put a null there, and this cascades through.

The examples I've made are for return types, but the same problem occurs with them as argument of the method.

In the attachment there is the code I've used to reproduce this bug. The strange thing is, given two files with the same unsolvable type in them, the first file in the array of ASTParser.createASTs get's a type binding, while the rest will get a null type binding. This contradicts the documentation of ASTParser: "The compilation units are processed one at a time in no specified order.".

I've tried debugging, and it seems in case of a unsolvable type, it guesses a rough type, and put's it into the typeOrPackageCache cache of the CompilationUnitScope, but there is a difference between the first time it puts it in there, and subsequent retrieval from the cache.

I think it is related, so I didn't make a separate issue for it. But in case of a qualifiedName with a generic argument, it always fails, no order dependence.</thetext>
        <comment>
            <comment_id>2677915</comment_id>
            <comment_count>1</comment_count>
            <who>Davy Landman</who>
            <commenter_username>davy.landman</commenter_username>
            <when>2016-03-02 09:05:16 -0500</when>
            <comment_text>Created attachment 260047
NestedClass1.java</comment_text>
        </comment>
        <comment>
            <comment_id>2677917</comment_id>
            <comment_count>2</comment_count>
            <who>Davy Landman</who>
            <commenter_username>davy.landman</commenter_username>
            <when>2016-03-02 09:07:07 -0500</when>
            <comment_text>Created attachment 260048
test files used in the Examples.

My bad, forgot every attachment send new emails, here are all the files attached.

Since they are quite short, here are the contents:

class NestedClass1 {
    public Foo.Bar method1() { return null; }
}
class NestedClass2 {
    public Foo.Bar method2() { return null; }
}
class QualifiedName1 {
    public org.google.Test method1() { return null; }
}
class QualifiedName2 {
    public org.google.Test method2() { return null; }
}
class QualifiedNameGeneric {
    public org.google.Test&lt;A&gt; method() { return null; }
}</comment_text>
        </comment>
        <comment>
            <comment_id>2677918</comment_id>
            <comment_count>3</comment_count>
            <who>Davy Landman</who>
            <commenter_username>davy.landman</commenter_username>
            <when>2016-03-02 09:08:39 -0500</when>
            <comment_text>(In reply to Davy Landman from comment #0)

forgot to paste the output of the code:
Binding recovery single file:
Single class (nested)			=&gt; Success
Single class (qualified)		=&gt; Success
Single class (qualified-generic)	=&gt; Failed
Binding recovery multiple file:
Target 1st (nested)	=&gt; Success
Target 2nd (nested)	=&gt; Failed
Target 1st (qualified)	=&gt; Success
Target 2nd (qualified)	=&gt; Success</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488930</id>
        <developer>Sebastien Arod</developer>
        <developer_username>sebastien.arod</developer_username>
        <dup_id/>
        <creation_time>2016-03-03 05:43:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Completion wrongly insert generic type parameter after class name when using a static method if class was not imported yet</short_desc>
        <thetext>Steps to reproduce:

Given a project containing 2 classes in different packages:

    package completion.a;
    public class A&lt;T&gt; {

	private A() {

	}

	public static void whateverStaticMethods() {

	}

    }

    package completion.b;
    public class B {

	public void method() {
            A&lt;caretposition&gt;
	}
    }

If you press dot at the caret position it triggers completion and proposes completion.a.A.whateverStaticMethods which is great but if you use this completion you endup with class B that is not valid because it contains a extraneous &lt;T&gt;.

Class B then looks like this:

    package completion.b;

    import completion.a.A;

    public class B {

	public void method() {
		A&lt;T&gt;.whateverStaticMethods();
	}
    }


Note that this only happens if class A is not yet imported in the class B.

This is a pain when using libraries like guava that is using a lot of static factory method on generic types.</thetext>
    </bug>
    <bug>
        <id>488936</id>
        <developer>Thorsten Meinl</developer>
        <developer_username>thorsten</developer_username>
        <dup_id/>
        <creation_time>2016-03-03 07:41:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>EclipseFileManager cannot handle UNC paths</short_desc>
        <thetext>Created attachment 260062
Java snippet demonstrating the problem

If the source of a Java class is on an UNC path (e.g. \\vboxsrv\tmp\Test.java) then the compiler fails with "URI has an authority component" exception. The problem is in EclipseFileManager.getJavaFileForOutput. The attached snippet can be used to reproduce the error.</thetext>
    </bug>
    <bug>
        <id>489028</id>
        <developer>yac yac</developer>
        <developer_username>yac</developer_username>
        <dup_id/>
        <creation_time>2016-03-04 10:04:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>@Nonnull field should not trigger The @Nonnull field may not have been initialized when initialization happens in @PostConstruct</short_desc>
        <thetext>@Nonnull field should not trigger The @Nonnull field may not have been initialized when initialization happens in @PostConstruct

@ApplicationScoped
class  Foo  {
  @Nonnull Bar bar;

  @PostConstruct
  public void init() {
    bar = new Bar();
  }
}</thetext>
    </bug>
    <bug>
        <id>489101</id>
        <developer>Igor Fedorenko</developer>
        <developer_username>igor</developer_username>
        <dup_id/>
        <creation_time>2016-03-06 15:23:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>inconsistent error reporting with raw types</short_desc>
        <thetext>Created attachment 260119
small standalone example project that demonstrates the problem

There are several existing bugs that sound similar (bug 478346, bug 471595, bug 447613 or bug 441238, for example), but I can't tell for sure if they have the same root cause so decided to file new one just in case.

Consider these three binary types

    public class BRaw&lt;T&gt; {}

    public abstract class BGeneric&lt;V extends BRaw&gt; {
    
        protected class ListTableElement {}
    
        abstract protected ListTableElement getListTableElement();
    }
   
    public class BParameterized extends BGeneric&lt;BRaw&gt; {
        protected class EntityDefaultListElement extends ListTableElement {}
    
        @Override
        protected ListTableElement getListTableElement() {
            return new EntityDefaultListElement();
        }
    }

The following source compiles successfully or produces "Type mismatch: cannot convert from OUTER.A1.AN1 to BGeneric&lt;BRaw&gt;.ListTableElement" error depending on whether indicated class is commented out or not

    public class OUTER {
        // uncomment the class below to make the error go away
        // static abstract class A0 extends BGeneric&lt;BRaw&gt; {}
    
        static class A1 extends BParameterized {
            protected class AN1 extends EntityDefaultListElement {}
    
        @Override
        protected ListTableElement getListTableElement() {
            return new AN1(); // &lt;&lt; Type mismatch error
        }
      }
    }


Note that OUTER is needed only to control compilation order during the test; A0 and A1 do not have to be defined in the same compilation unit to trigger the problem.</thetext>
        <comment>
            <comment_id>2679281</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-06 18:00:01 -0500</when>
            <comment_text>The difference with / without A0 is disturbing indeed.

OTOH, for me personally, corner cases involving raw types have low priority, because (a) alignment with javac is not feasible due to known bugs in javac and (b) raw types are a legacy from 12 years ago and should definitely be avoided in 2016.</comment_text>
        </comment>
        <comment>
            <comment_id>2679466</comment_id>
            <comment_count>2</comment_count>
            <who>Igor Fedorenko</who>
            <commenter_username>igor</commenter_username>
            <when>2016-03-07 10:03:09 -0500</when>
            <comment_text>Yes, kinda agree, we can argue about virtues of raw types, but the main concern here is inconsistent error reporting. We use eclipse jdt compiler in a fairly large command line build (via takari-lifecycle maven plugin) and the build very infrequently fails if filesystem order happens to be just right. Very difficult to troubleshoot. We'll see if we can contribute a patch.</comment_text>
        </comment>
        <comment>
            <comment_id>2680551</comment_id>
            <comment_count>3</comment_count>
            <who>Igor Fedorenko</who>
            <commenter_username>igor</commenter_username>
            <when>2016-03-09 23:40:42 -0500</when>
            <comment_text>Regression test and proposed fix https://git.eclipse.org/r/#/c/68122/.

Here is what I believe happens. 

1. type hierarchy of A1 is constructed and BGeneric&lt;BRaw&gt; is registered with TypeSystem#hashedParameterizedTypes (via A1 -&gt; BParameterized -&gt; BGeneric&lt;BRaw&gt; hierarchy traversal). BRaw type parameter is represented as UnresolvedReferenceBinding at this point
2. ParameterizedTypeBinding from the previous step is cached in PackageBinding#knownTypes
3. ParameterizedTypeBinding is resolved, which changes hashCode used by TypeSystem#hashedParameterizedTypes (which is a bug and this is what proposed fix attempts to address)
4. when A1.AN1 type hierarchy is constructed, resolved parametrized type from PackageBinding#knownTypes is looked up and used to as lookup key in TypeSystem#hashedParameterizedTypes. Since hashCode changed, this lookup returns nothing and new mostly identical ParameterizedTypeBinding is created and returned.

Now there are two ParameterizedTypeBinding instances that represent BGeneric&lt;BRaw&gt;, one is used in A1, another in A1.AN1. Once instance has resolved RawTypeBinding parameter type, another instance has UnresolvedReferenceBinding type parameter. Since TypeBinding#isCompatibleWith implementation uses instance identity to compare types, it returns "false" for the two BGeneric&lt;BRaw&gt; instances, which results in the observed compilation failure.

The reason the code compiles in the presence of A0, is because BGeneric&lt;BRaw&gt; is resolved and cached in PackageBinding#knownTypes before A1 type hierarchy is constructed, so both A1 and A1.AN1 get the same BGeneric&lt;BRaw&gt; instance.

The proposed fix changes TypeSystem#hashedParameterizedTypes hashCode implementation to tolerate unresolved-&gt;resolved transition for parameterized type arguments. 

I ran all JDT tests with the changed code and didn't get any new failures (5 tests fail on my system regardless of my change). I also used changed jdt compiler in our real build and it fixed the problem there too.</comment_text>
        </comment>
        <comment>
            <comment_id>2680750</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-10 08:18:37 -0500</when>
            <comment_text>Thanks, Igor,

Your description makes sense at a cursory look.
I'm putting this on the radar for proper review in due time for 4.6.

BTW: with a proper "bug 489101" prefix in the commit comment Genie would have automatically linked bug and gerrit :)</comment_text>
        </comment>
        <comment>
            <comment_id>2698490</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-04-23 08:18:34 -0400</when>
            <comment_text>(In reply to Igor Fedorenko from comment #3)
&gt; 3. ParameterizedTypeBinding is resolved, which changes hashCode used by
&gt; TypeSystem#hashedParameterizedTypes (which is a bug and this is what
&gt; proposed fix attempts to address)

Thanks, makes perfect sense for explaining the bug, but ...

Traversing the history of TypeSystem.HashedParameterizedTypes.InternalParameterizedTypeBinding.hashCode() leads me to this comment:

(In reply to Sasikanth Bharadwaj from bug 434326 comment #56)
&gt; ... the hash computation needed a small
&gt; change, the id of the type parameters is also included in the hash
&gt; computation. Otherwise,
&gt; all parameterizations like List&lt;List&lt;String&gt;&gt;, List&lt;List&lt;List&lt;String&gt;&gt;&gt;
&gt; ended up with same hash code (hashcode for type binding is the compound name
&gt; of the type, which is the same for all the above cases) resulting in reduced
&gt; performance.

So, while the proposed fix doesn't cause any functional regressions, it is known to show a performance regression (removes a performance optimization).

Moving out of 4.6 as we need to carefully design a new strategy that makes both ends meet.</comment_text>
        </comment>
        <comment>
            <comment_id>2698547</comment_id>
            <comment_count>6</comment_count>
            <who>Igor Fedorenko</who>
            <commenter_username>igor</commenter_username>
            <when>2016-04-23 16:32:08 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #5)
&gt; Traversing the history of
&gt; TypeSystem.HashedParameterizedTypes.InternalParameterizedTypeBinding.
&gt; hashCode() leads me to this comment:
&gt; 
&gt; (In reply to Sasikanth Bharadwaj from bug 434326 comment #56)
&gt; &gt; ... the hash computation needed a small
&gt; &gt; change, the id of the type parameters is also included in the hash
&gt; &gt; computation. Otherwise,
&gt; &gt; all parameterizations like List&lt;List&lt;String&gt;&gt;, List&lt;List&lt;List&lt;String&gt;&gt;&gt;
&gt; &gt; ended up with same hash code (hashcode for type binding is the compound name
&gt; &gt; of the type, which is the same for all the above cases) resulting in reduced
&gt; &gt; performance.
&gt; 
&gt; So, while the proposed fix doesn't cause any functional regressions, it is
&gt; known to show a performance regression (removes a performance optimization).
&gt; 
&gt; Moving out of 4.6 as we need to carefully design a new strategy that makes
&gt; both ends meet.

Do you have a test or sample project where this performance degradation is visible? We are using this patch on pretty large body of code and didn't see anything measurable yet, so I'd like to understand the scenario better.</comment_text>
        </comment>
        <comment>
            <comment_id>2698550</comment_id>
            <comment_count>7</comment_count>
            <who>Igor Fedorenko</who>
            <commenter_username>igor</commenter_username>
            <when>2016-04-23 16:37:09 -0400</when>
            <comment_text>never mind, found https://bugs.eclipse.org/bugs/attachment.cgi?id=247716&amp;action=diff.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489247</id>
        <developer>Lars Vogel</developer>
        <developer_username>Lars.Vogel</developer_username>
        <dup_id/>
        <creation_time>2016-03-08 17:40:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Allow to configure Eclipse to show an info/warning/error for new Integer() or other statements</short_desc>
        <thetext>Using new Integer() is in most cases wrong and Integer.valueof(int) should be prefered.

See http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Integer.html#valueOf%28int%29

Would be nice if JDT otthers a configurable check for these situations.</thetext>
        <comment>
            <comment_id>2682763</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-15 19:31:53 -0400</when>
            <comment_text>*** Bug 489702 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489427</id>
        <developer>yac yac</developer>
        <developer_username>yac</developer_username>
        <dup_id/>
        <creation_time>2016-03-11 07:33:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null] Illegal redefinition of parameter P, inherited method from Parent does not constrain this parameter makes for poor usability of null analysis with 3rd party libraries</short_desc>
        <thetext>Illegal redefinition of parameter P, inherited method from Parent does not constrain this parameter makes for poor usability of null analysis with 3rd party libraries.

Situation is such that we have a

interface 3rdPartyLib {
  public void method(Param P)
}

where the lib is un-annotated, but it should be annotated with @NonNull.

and our implementation with package wide @javax.annotation.ParametersAreNonnullByDefault

which causes the above error.

The obvious solution would be to annotate the third party lib but that's practically unreasonable, as it is unreasonable to stop whatever we do and start annotating dependencies. Furthermore it is impractical as library provider may not want to include null annotations or take much time to merge the changes and also this creates repackaging burden.

Another "solution" would be to make what some people refer to as "quick fix" to make compiler happy is to just annotate the subtype with `@Nullable Param P`, but that is not really true. `null` is not really accepted there.

So far, for new code I have settled on moving the subtype into extra package that does not have ParametersAreNonnullByDefault but find that suboptimal as it creates needless package fragmentation, which would be especially an issue when annotating existing code.

We need a way to demote this error into a warning and then have a way to suppress it for cases where we know, the parent really takes @NonNull, just do not annotate it.</thetext>
        <comment>
            <comment_id>2681142</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-11 10:09:09 -0500</when>
            <comment_text>(In reply to yac yac from comment #0)
&gt; The obvious solution would be to annotate the third party lib

Before entering discussion let me ask: are you aware of JDT's support for "external annotations"? See http://help.eclipse.org/topic/org.eclipse.jdt.doc.user/tasks/task-using_external_null_annotations.htm</comment_text>
        </comment>
        <comment>
            <comment_id>2681151</comment_id>
            <comment_count>2</comment_count>
            <who>yac yac</who>
            <commenter_username>yac</commenter_username>
            <when>2016-03-11 10:31:37 -0500</when>
            <comment_text>I started investigating it more just after I filed this bug when I noticed it has an asistent to create the external annotations from within eclipse but so far the external annotation did not take effect for me. I have no idea why, attempted upgrade to 4.6.m5 and now it's even worse. I'll get back to this when I have more information.</comment_text>
        </comment>
        <comment>
            <comment_id>2681190</comment_id>
            <comment_count>3</comment_count>
            <who>yac yac</who>
            <commenter_username>yac</commenter_username>
            <when>2016-03-11 12:14:14 -0500</when>
            <comment_text>So far I have followed with new bug 489445.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489444</id>
        <developer>John Uckele</developer>
        <developer_username>john.h.uckele</developer_username>
        <dup_id/>
        <creation_time>2016-03-11 12:07:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[formatter] Chained method calls when using Stream API or builders should have different behavior from other method calls.</short_desc>
        <thetext>The problem:

There is currently no combination of settings that allow Eclipse to format this code in the following way:

     int someValue = new Object().toString().length();
     Stream.of("one", "two", "three", "four")
         .filter(e -&gt; e.length() &gt; 3)
         .peek(e -&gt; System.out.println("Filtered value: " + e))
         .map(String::toUpperCase)
         .peek(e -&gt; System.out.println("Mapped value: " + e))
         .collect(Collectors.toList());

On the first line of code, I really do want the method calls to be chained together with no line splits. This is especially true if I chain a couple of methods like this inside of an if statement.

On the second line of code, I really do want each stream call to be on it's own textual line, because despite being a single line of Java code, each textual line is a step in a process.

My current solutions are to let it format the first line like the second, the second line like the first, or place @formatter: off comments in my code whenever I use the Stream API. None of these solutions are ideal.

The proposed solution:

The Code Formatter has the option under Line Wrapping -&gt; Function calls -&gt; Qualified invocations to wrap or not (or only where necessary for line length).

An additional condition should be added which a user can customize, whether to split lines when the invoking instance and return type are the same type. Various builder libraries would automatically format one .withX(x) per line with this convention as well, and Stream objects do the right thing by default.

This is something I would feel comfortable tackling if the maintainers of the project are okay with me adding this sort of feature.</thetext>
        <comment>
            <comment_id>2681425</comment_id>
            <comment_count>1</comment_count>
            <who>Mateusz Matela</who>
            <commenter_username>mateusz.matela</commenter_username>
            <when>2016-03-12 13:36:01 -0500</when>
            <comment_text>Interesting idea, but I see one big obstacle: the formatter doesn't perform AST binding, so it doesn't know the types of variables nor return types of methods.
It's not impossible to add AST binding, but it would probably affect the performance quite badly.
Also, the feature can lead to some weird effects. For example, with automatic format on save turned on, if you save the code with a typo in a method name or a missing import, the formatter will not recognize the right pattern and will format the code one way, then with the problem solved it will reformat it another way.

In bug 303519, the initial proposition was to add a feature so that when the number of items to be wrapped exceeds a certain threshold, the formatter switches from "wrap where necessary" to "wrap all". How does that sound? It's much easier to implement :)

Have you considered using "Never join already wrapped lines"? This way you can manually fix line wrapping and it will not get reformatted.</comment_text>
        </comment>
        <comment>
            <comment_id>2681426</comment_id>
            <comment_count>2</comment_count>
            <who>Mateusz Matela</who>
            <commenter_username>mateusz.matela</commenter_username>
            <when>2016-03-12 13:37:54 -0500</when>
            <comment_text>(In reply to Mateusz Matela from comment #1)
&gt; In bug 303519, the initial proposition was to add a feature so that...
The actual bug for this is bug 365264.</comment_text>
        </comment>
        <comment>
            <comment_id>2681932</comment_id>
            <comment_count>3</comment_count>
            <who>John Uckele</who>
            <commenter_username>john.h.uckele</commenter_username>
            <when>2016-03-14 12:26:30 -0400</when>
            <comment_text>Thanks for the heads up about the current lack of AST binding.

I do think a threshold going from "wrap where necessary" to "wrap all" (or even just adding a "wrap all where necessary" style option which would wrap one item per textual line as soon as the code line reached wrapping length) is a good solution that sounds less involved than my solution. I'd still be curious to see how much work my proposed solution requires / how much performance impact there is, but it seems like a lower priority exploration given the simpler solution.

I would argue that if a typo in a method name or a missing import caused the formatting to change, that would actually be 'correct'.

Great suggestion on "Never join already wrapped lines". I can't speak for other users, but the reason I don't favor this solution is that I want the code itself to determine the formatting in a predictable way. I'd prefer to have a formatter that always does the same thing, regardless of when code has too many or too few line breaks.

In the existing bug you mention, it seems that the last activity on this was four years ago and there was once a patch for this. Is this something that is out in the wild somewhere or did this get shelved? It seems like a good solution, so if the only thing holding it back is someone implementing it, I'd be happy to take a swing at it.</comment_text>
        </comment>
        <comment>
            <comment_id>2682143</comment_id>
            <comment_count>4</comment_count>
            <who>Mateusz Matela</who>
            <commenter_username>mateusz.matela</commenter_username>
            <when>2016-03-14 19:00:09 -0400</when>
            <comment_text>(In reply to John Uckele from comment #3)
&gt; Thanks for the heads up about the current lack of AST binding. 
&gt; I'd still be
&gt; curious to see how much work my proposed solution requires / how much
&gt; performance impact there is

It's also a big change in API. Currently you just pass your code to the formatter as a String and it doesn't care about anything else (so it's portable). Now it would need a new mode that uses a java project with classpath.

&gt; In the existing bug you mention, it seems that the last activity on this was
&gt; four years ago and there was once a patch for this. Is this something that
&gt; is out in the wild somewhere or did this get shelved? It seems like a good
&gt; solution, so if the only thing holding it back is someone implementing it,
&gt; I'd be happy to take a swing at it.

This was implemented in initial patches for bug 303519 which tried to modify the old formatter, so it got ditched once the formatter was rewritten from scratch. So you can have a look at their proposition for changes in API, but the actual implementation must be completely new.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489499</id>
        <developer>olivia dietzel</developer>
        <developer_username>olivia.dietzel</developer_username>
        <dup_id/>
        <creation_time>2016-03-13 10:36:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][compiler] type mismatch from T to &lt;unknown&gt; when using lambda with a functional interface with multiple generic types</short_desc>
        <thetext>The following example does not compile in eclipse Mars and also in Neon (4.6.0M5).

The error message returned is: 
Type mismatch: cannot convert from Application.StringIdentifiableObject to &lt;unknown&gt;


However it compiles without problems on the command line using javac (1.8.0_66).

---
import java.io.Serializable;

public class Application {
    interface Identifier&lt;T extends Serializable&gt; {}
    interface IdentifiableObject&lt;T extends Serializable, OBJ extends Identifier&lt;T&gt;&gt; {}

    @FunctionalInterface
    interface IdentifiableObjectFactory&lt;T extends Serializable, OBJ extends IdentifiableObject&lt;T, ? extends Identifier&lt;T&gt;&gt;&gt; {
        OBJ create();
    }

    class StringIdentifier implements Identifier&lt;String&gt; {}
    class StringIdentifiableObject implements IdentifiableObject&lt;String, StringIdentifier&gt; {}

    class Repository {
        &lt;ID extends Serializable, IDENTIFIER extends Identifier&lt;ID&gt;, OBJ extends IdentifiableObject&lt;ID, IDENTIFIER&gt;&gt; OBJ create(final IdentifiableObjectFactory&lt;ID, OBJ&gt; factory) {
            return factory.create();
        }
    }

    public void testMethod() {
        Repository repository = new Repository();
        repository.create(() -&gt; new StringIdentifiableObject());
    }
}
---

The problematic line is 
repository.create(() -&gt; new StringIdentifiableObject());

If I do not use a lambda but the following:
repository.create(new IdentifiableObjectFactory&lt;String, StringIdentifiableObject&gt;() {
            @Override
            public StringIdentifiableObject create() {
                return new StringIdentifiableObject();
            }
        });

the compiler is happy again.</thetext>
    </bug>
    <bug>
        <id>489663</id>
        <developer>Jean-Marie HENAFF</developer>
        <developer_username>jmhenaff</developer_username>
        <dup_id/>
        <creation_time>2016-03-15 11:06:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Compilation error related file order on command line and Generics with source level 1.7</short_desc>
        <thetext>Created attachment 260313
sample code to reproduce the bug

I've attached a sample to reproduce.
Simply extract the sample and execute run.sh

It uses ecj-I20160314-2000.jar.

It does not happen if source level is set with -1.8.

source.txt contains the source files in an order that failed for me:

----------
1. WARNING in /ssd/Sample/src/com/test/M.java (at line 4)
	@SuppressWarnings("unchecked")
	                  ^^^^^^^^^^^
Unnecessary @SuppressWarnings("unchecked")
----------
----------
2. ERROR in /ssd/Sample/src/com/test/Test.java (at line 18)
	return new M(A.allOf(getPredicates(finders)));
	               ^^^^^
The method allOf(Iterable&lt;I&lt;? super T&gt;&gt;) in the type A is not applicable for the arguments (List&lt;I&lt;? super U&gt;&gt;)



Putting Test.java first does not produces this error.</thetext>
    </bug>
    <bug>
        <id>489821</id>
        <developer>Lukas Eder</developer>
        <developer_username>lukas.eder</developer_username>
        <dup_id/>
        <creation_time>2016-03-17 04:55:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[formatting] Javadoc formatting puts period on a new line if it is placed after a {@link} tag.</short_desc>
        <thetext>Consider the following code:


// print margin here: ---------------------------------------------------------|
/**
 * asdfasdfasdf asdfasdfasdf asdfasdfasdf asdfasdfasdf asdfasdfas {@link Object}.
 */
public interface Test {

}


The Javadoc exceeds the print margin (which is used for wrapping, when formatting Javadoc) by one extra character: the period "."

When formatting the above, the resulting code looks like this:


// print margin here: ---------------------------------------------------------|
/**
 * asdfasdfasdf asdfasdfasdf asdfasdfasdf asdfasdfasdf asdfasdfas {@link Object}
 * .
 */
public interface Test {

}


This is a bit annoying. It also doesn't happen when the last word before the period is an ordinary word, rather than a Javadoc tag:



// print margin here: ---------------------------------------------------------|
/**
 * asdfasdfasdf asdfasdfasdf asdfasdfasdf asdfasdfasdf asdfasdfas asdfasdfasdfas.
 */
public interface Test {

}



Formatting yields, correctly:




// print margin here: ---------------------------------------------------------|
/**
 * asdfasdfasdf asdfasdfasdf asdfasdfasdf asdfasdfasdf asdfasdfas
 * asdfasdfasdfas.
 */
public interface Test {

}</thetext>
    </bug>
    <bug>
        <id>489822</id>
        <developer>Lukas Eder</developer>
        <developer_username>lukas.eder</developer_username>
        <dup_id/>
        <creation_time>2016-03-17 05:08:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[javadoc] Wrong warning is emitted when referencing a method from Javadoc with a varargs of array parameter</short_desc>
        <thetext>The following code emits a wrong warning in Eclipse:



/**
 * Bla {@link #method(Object[]...)}.
 */
public class Test {
    public void method(Object[]... args) {}
}



The above signature is what is produced when using content assist. javac doesn't emit any warnings here, and the code looks correct to me. The following workaround prevents the problem:



/**
 * Bla {@link #method(Object[][])}.
 */</thetext>
    </bug>
    <bug>
        <id>489823</id>
        <developer>Lukas Eder</developer>
        <developer_username>lukas.eder</developer_username>
        <dup_id/>
        <creation_time>2016-03-17 05:10:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[assist] Javadoc {@link} autocompletion doesn't work correctly if there is a Warning in the Javadoc</short_desc>
        <thetext>Consider the following code:



/**
 * Bla {@link #method(Object[]...)}.
 *
 * Auto-complete here #
 */
public class Test {

    public void method(Object[]... args) {}
    public void method2(int arg) {}
}



I want to auto-complete the # sign to #method2(int), but it doesn't work. I'm only offered a single choice, the #method(Object[]...) method, which is erroneously flagged with a warning (see also https://bugs.eclipse.org/bugs/show_bug.cgi?id=489822)

When "fixing" the existing link like so:


/**
 * Bla {@link #method(Object[][])}.
 *
 * Auto-complete here #
 */
public class Test {

    public void method(Object[]... args) {}
    public void method2(int arg) {}
}


I can now auto-complete the # to all possible methods.</thetext>
        <comment>
            <comment_id>2683641</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-03-17 07:09:23 -0400</when>
            <comment_text>We don't get other proposals from jdt.core in the first case.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489880</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-03-17 15:21:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null] Extract Local Variable converts warning about free type variable to error</short_desc>
        <thetext>master

Have a 1.8 project with annotation-based null analysis enabled, and this class:

import java.util.List;

public abstract class NullProblemo {

    abstract List&lt;? extends Number&gt; getNumbers();

    void foo() {
        /*
         * Warning: Potential null pointer access: this expression has type
         * 'capture#2-of ? extends java.lang.Number', a free type variable that
         * may represent a '@Nullable' type
         */
        int a= getNumbers().get(0).intValue();

        Number number= getNumbers().get(0);
        /*
         * Error: Potential null pointer access: The variable number may be null
         * at this location
         */
        int b= number.intValue();
    }
}

Extracting "getNumbers().get(0)" into a local variable turns a warning into an error. Adding @NonNull to the "number" variable resolves the error and creates a warning similar to the inlined case.

Is it really OK to assume that "getNumbers().get(0)" is non-null in the inlined case? I would expect the same problem in both cases.

If you're sure the compilation makes sense like this, then we may have to think about adding support for such cases to the Extract Local Variable refactoring.</thetext>
        <comment>
            <comment_id>2684081</comment_id>
            <comment_count>1</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-03-17 15:37:42 -0400</when>
            <comment_text>Based on Stephan's suggestion I have prepared a quick fix to add @NonNull to the variable in such situations (see bug 489081), but it didn't make it into 4.6M6.

The best and cleanest way to actually fix the warning is to add @NonNullByDefault to the class which has effect on the type bound "extends Numbers" and thus declares the list contents as non-null (if this was the intention, otherwise you need to null-check the variable)</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489907</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-03-18 04:43:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] AIOOBE during code generation of a module-info with large number of package exports</short_desc>
        <thetext>Created attachment 260403
Sample module-info

The attached module-info.java has over hundred package exports and this is resulting in an AIOOBE during code generation. This could happen for requires and other sections of the module attribute too.

We should resize the contents array from time to time.</thetext>
        <comment>
            <comment_id>2684242</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-03-18 04:46:21 -0400</when>
            <comment_text>Created attachment 260404
Proposed fix

The test case need another look.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489940</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-03-18 09:58:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler] wrong error when overriding default interface method in 1.5 project</short_desc>
        <thetext>4.6 M6, source: bug 489878

- create a Java project with 1.5 compiler compliance
- add org.eclipse.jface from 4.6 M6 to the build path
- create this class:

package p;

import org.eclipse.jface.viewers.ArrayContentProvider;
import org.eclipse.jface.viewers.Viewer;

public class MyArrayContentProvider extends ArrayContentProvider {
    @Override
    public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
        super.inputChanged(viewer, oldInput, newInput);
    }
}

There's a compile error "The method inputChanged(Viewer, Object, Object) of type MyArrayContentProvider must override a superclass method".

I don't get this compile error with Javac:
C:\java\jdk8\bin\javac.exe -bootclasspath C:\java\jdk1.5.0_22\jre\lib\rt.jar -source 5 -target 5 -version -g -Xlint -cp C:\e\w\master\git\eclipse.platform.ui\bundles\org.eclipse.jface\bin -d C:\e\w\master\zz1.5\sunbin -sourcepath C:\e\w\master\zz1.5\src C:\e\w\master\zz1.5\src\p\MyArrayContentProvider.java

The checks before "this.scope.problemReporter().methodMustOverride(..)" in org.eclipse.jdt.internal.compiler.ast.MethodDeclaration#resolveStatements() should accept the method if it's a default method.</thetext>
        <comment>
            <comment_id>2684638</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-18 20:35:24 -0400</when>
            <comment_text>It's hard to find the exact JLS as of Java 5 these days, but this seems to match:

"... If a method declaration is annotated with the annotation @Override, but the method does not in fact override any method declared in a superclass, a compile-time error will occur.... Note that if a method overrides a method from 
a superinterface but not from a superclass, using @Override will cause a compile-time error. "


Counting a default method (which doesn't exist in Java 5) as a "method declared in a superclass" sound quite far fetched, if you ask me. Note, that JLS doesn't speak of abstract vs. concrete methods, just about where it is declared. A default method is concrete but it is still declared in an interface.

The error is not *wrong* by any interpretation of JLS that I can see.


Why, to begin with, should we explicitly support combining source code 1.5 with 1.8 super types? To me this doesn't sound like a healthy exercise.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489979</id>
        <developer>Olivier Lerone</developer>
        <developer_username>olivier.the.olive</developer_username>
        <dup_id/>
        <creation_time>2016-03-18 18:30:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Boolean NOT Unary NOT Operator in some circumstances causes "Compute launch button tooltip" and other issues</short_desc>
        <thetext>Created attachment 260417
Example Project for Reproduction

### Overview:

The boolean, unary NOT operator in some (extreme?) circumstances causes some exception in org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.optimizedBooleanConstant which causes issues further up in Eclipse.

I hope I was correct in filing this in the JDT bug tracker and not that of Eclipse. Else, please forgive me.

### Steps to Reproduce in Eclipse:

1) Import the attached project, which has been reduced and anonymised to the minimum of what I was able to use to reproduce the issue.

2) Open the file bugrepro/BugReproTest.java in the Editor by double clicking it in the Package hierarchy tree sidepane.

3) Mouse over the green run button.

4) Receive an "Compute launch button tooltip" error with vague information.
A full error log is available from the 'Error Log' view.

5) (Extra): Open the Run &gt; Run As... Menu, and notice that it is completely blank/empty (not even the 'none applicable' is there).

### Actual Results

An error message was received with a stack trace in the Error Log view.

### Expected Results

No such error should occur, and an option for running as Java Application should be visible (if main method present) or a grayed out '(none applicable)' pseudo-option should be in the Run &gt; Run As... menu.

### Build Date &amp; Hardware

Using build:
Version: Mars.2 Release (4.5.2)
Build id: 20160218-0600

Running Ubuntu 15.04 (x64)

`uname -a`
Linux spruce-GA-78LMT-USB3 3.19.0-47-generic #53-Ubuntu SMP Mon Jan 18 14:02:48 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux

Using Java JDK:
openjdk version "1.8.0_45-internal"
OpenJDK Runtime Environment (build 1.8.0_45-internal-b14)
OpenJDK 64-Bit Server VM (build 25.45-b02, mixed mode)

### Additional Builds and Platforms

None available for test.

### Additional Information

The bug is very finickity to reproduce, so I have attached a project which can be used to reproduce the error, while cutting out as much code as possible and anonymising it. The error log will follow in a new comment if possible, because the attachment form only seems to accept one attachment.</thetext>
        <comment>
            <comment_id>2684627</comment_id>
            <comment_count>1</comment_count>
            <who>Olivier Lerone</who>
            <commenter_username>olivier.the.olive</commenter_username>
            <when>2016-03-18 18:31:31 -0400</when>
            <comment_text>Created attachment 260418
Error log exported from Eclipse with Stack Trace</comment_text>
        </comment>
        <comment>
            <comment_id>2684628</comment_id>
            <comment_count>2</comment_count>
            <who>Olivier Lerone</who>
            <commenter_username>olivier.the.olive</commenter_username>
            <when>2016-03-18 18:35:42 -0400</when>
            <comment_text>Created attachment 260419
(Corrected) Eclipse Error Log with Stack Trace

Apologies for the prior attachment which was seemingly the entire log file, not the log for this single case.</comment_text>
        </comment>
        <comment>
            <comment_id>2684773</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-19 21:21:14 -0400</when>
            <comment_text>I can reproduce, although debugging the code that creates a sub menu is prone to freezing the computer ...

Anyway, the statement in question is

    pp.rs = (! (boolean) pp.rs)

inside this method

  public void abc() {
    Pqrs pp = new Pqrs();
    pp.rs = (! (boolean) pp.rs);
  }


During normal compilation all is fine, the qualified name reference pp.rs has resolved type j.l.Object.

But on the given call path from HierarchyResolver, the STB for Pqrs has no fields, hence 'rs' is a ProblemFieldBinding with no type. Apparently, one part of the machine thinks we don't need any details, but another part disagrees.

It should be possible to create a JUnit by just requesting the type hierarchy for type BugReproTest.

Anyone? :)</comment_text>
        </comment>
        <comment>
            <comment_id>2685550</comment_id>
            <comment_count>4</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-03-22 07:03:07 -0400</when>
            <comment_text>HierarchyResolver.accept(ISourceType[], PackageBinding, AccessRestriction) has this

CompilationUnitDeclaration unit =
		SourceTypeConverter.buildCompilationUnit(
			new ISourceType[] {sourceType}, // ignore secondary types, to improve laziness
			SourceTypeConverter.MEMBER_TYPE | (this.lookupEnvironment.globalOptions.sourceLevel &gt;= ClassFileConstants.JDK1_8 ? SourceTypeConverter.METHOD : 0), // need member types
			// no need for field initialization
			this.lookupEnvironment.problemReporter,
			result);
			
where it is explicitly excluding fields from the built type declaration, so the fields are not included in the parsed type declaration thereby resulting in this problem.  Including SourceTypeConverter.FIELD in the flags solves the problem. Could it be for performance reasons that fields were left out??</comment_text>
        </comment>
        <comment>
            <comment_id>2685902</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-22 17:01:51 -0400</when>
            <comment_text>(In reply to Sasikanth Bharadwaj from comment #4)
&gt; where it is explicitly excluding fields from the built type declaration, so
&gt; the fields are not included in the parsed type declaration thereby resulting
&gt; in this problem.  Including SourceTypeConverter.FIELD in the flags solves
&gt; the problem. Could it be for performance reasons that fields were left out??

I believe so. It seems like in former times the different use cases calling into the compiler paid great attention to performing only the minimal necessary work, and with Java getting more and more complex, this erodes to doing almost all the work almost all the time (see, e.g., the "&gt;= JDT1_8" part in the quoted snippet).

Regarding the issue at hand: I wouldn't expect a huge performance penalty from including fields of secondary types, but OTOH I believe compiling statements (which triggers the NPE in the first place) is beyond the point for creating a type hierarchy. Perhaps this is done in order to find local types? Perhaps we could prune the parse tree in scenarios like type hierarchy to discard all statements other than local type declarations?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490120</id>
        <developer>Joshua Ventura</developer>
        <developer_username>joshv</developer_username>
        <dup_id/>
        <creation_time>2016-03-21 17:01:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Allow importing containing classes for certain inner class names.</short_desc>
        <thetext>In the codebase I work with, names such as "Builder" are ubiquitous. We have a nested Builder class in practically half of all types. When performing refactors and using other code completion features, Eclipse chooses to import any class it needs to refer to, directly. This means that the first builder class we used is imported directly as "Builder," and any further builders are referred to as "com.some.really.long.package.name.ClassIAmBuilding.Builder" in each needed occurrence.

It would be great if Eclipse could import "ClassIAmBuilding" and then refer to the builder as "ClassIAmBuilding.Builder" in the code. Most commonly, this is used as return types or parameter types. This also happens when extracting locals, or declaring an undeclared variable being assigned.

I am happy to maintain a blacklist of class names, such as Builder, to never import directly. There are also some context clues available in the code to help in making this decision, such as referring to the type as "ClassIAmBuilding.Builder" elsewhere, but sometimes "elsewhere" means "in a different file" and so might be impractical. Another good metric for this is how many different classes have that name (I have so many different builder classes that eclipse sometimes locks up for a while populating "quick fix" suggestions—a small irony whose comedic value is usually lost on me when it happens). Still, I would be happy with the blacklist.</thetext>
        <comment>
            <comment_id>2689760</comment_id>
            <comment_count>1</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-04-01 20:08:08 -0400</when>
            <comment_text>Perhaps Eclipse could learn the blacklist from user behavior. For example, if you ever manually change the import of an inner class to be an import of its containing class, that class could automatically get added to the blacklist. If the user ever manually changes an import in the other direction, it could get removed from the blacklist. This blacklist could be remembered on a per-user basis.

We could populate an initial set of defaults by either examining the code base or hardcoding a list somewhere in an invisible preference.

Joshua: if you'd like to take a stab at implementing this, check out my guide for setting up Eclipse for platform UI development.

https://wiki.eclipse.org/Platform_UI/How_to_Contribute

Working on JDT is pretty much the same, except that you should select the "JDT" projects instead of the "Platform &gt; UI" project.</comment_text>
        </comment>
        <comment>
            <comment_id>2689761</comment_id>
            <comment_count>2</comment_count>
            <who>Sergey Prigogin</who>
            <commenter_username>eclipse.sprigogin</commenter_username>
            <when>2016-04-01 20:18:05 -0400</when>
            <comment_text>(In reply to Stefan Xenos from comment #1)
Auto-updating blacklist would be a good feature, but a static blacklist explicitly controlled from a preference page would be much easier to implement. It makes sense to start from that and add auto-updating later, when and if it becomes clear that a static list doesn't satisfy a significant number of users.</comment_text>
        </comment>
        <comment>
            <comment_id>2689762</comment_id>
            <comment_count>3</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-04-01 20:44:19 -0400</when>
            <comment_text>True, a static blacklist is better than what we have now and auto-updating could always be added later as a separate feature.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490154</id>
        <developer>leokom leokom</developer>
        <developer_username>lrozenblyum</developer_username>
        <dup_id/>
        <creation_time>2016-03-22 04:36:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[pull up] changes method visibility when unneeded</short_desc>
        <thetext>SCENARIO:

Let's have 4 classes Parent &lt;- Child1 &lt;- Child2 &lt;- Child3
Parent, Child1 are in package1
Child2, Child3 are in package2

package package1;

public class Parent {
protected void doSmth() {

}
}

package package1;

public class Child1 extends Parent {
}


package package2;

import package1.Child1;

class Child2 extends Child1 {


}


package package2;

class Child3 extends Child2 {
	private void inC() {
		doSmth();
	}

}

Being in Child3#inC Refactor -&gt; Pull up
Select package2.Child2 as target (usually it's preselected already)

Execute the refactoring

EXPECTED:
1) No warning 'The visibility of method 'package1.Parent.doSmth()' will be changed to public.
2) No actual change to public of this method. It will be still accessible via protected modifier.

ACTUALLY:
Warning exists.
protected doSmth() changed to public doSmth() unnecessarily

The issue is similar to https://bugs.eclipse.org/bugs/show_bug.cgi?id=399350
but doesn't depend on overriding a parent's method.</thetext>
    </bug>
    <bug>
        <id>490247</id>
        <developer>Paul Wagland</developer>
        <developer_username>paul</developer_username>
        <dup_id/>
        <creation_time>2016-03-23 04:26:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Javadoc support does not properly handle {@value Class#field}</short_desc>
        <thetext>See also: http://stackoverflow.com/a/36173010/97627

With the following test class, the displayed javadoc for test1 and test2 are expected to be the same, and they should both substitute in the value of the field. However, only one of them does, the version that accesses the value without the class descriptor. This is required if you want to access the value from another class, and should also work.

public class TestClass {
  /**
   * The value of this constant is {@value}.
   */
  // In Eclipse this shows: The value of this constant is "&lt;script&gt;".
  public static final String SCRIPT_START = "&lt;script&gt;";
  /**
   * Evaluates the script starting with {@value TestClass#SCRIPT_START}.
   */
  // In Eclipse this shows: Evaluates the script starting with {@value TestClass#SCRIPT_START}.
  public void test1() {
  /**
   * Evaluates the script starting with {@value #SCRIPT_START}.
   */
  // In Eclipse this shows: Evaluates the script starting with "&lt;script&gt;".
  public void test2() {
  }
}</thetext>
        <comment>
            <comment_id>2689928</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-04 02:38:27 -0400</when>
            <comment_text>I can't reproduce this on master. Manoj, could you give it a try please?

Paul, BTW, I am guessing that the syntax error in the code you gave is not intentional. Please confirm.</comment_text>
        </comment>
        <comment>
            <comment_id>2690023</comment_id>
            <comment_count>2</comment_count>
            <who>Paul Wagland</who>
            <commenter_username>paul</commenter_username>
            <when>2016-04-04 05:25:29 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #1)
&gt; Paul, BTW, I am guessing that the syntax error in the code you gave is not
&gt; intentional. Please confirm.

Correct! Both Test1 and Test2 are meant to be empty methods. This is just a cut and paste error generating the minimal test case. Sorry for the confusion.</comment_text>
        </comment>
        <comment>
            <comment_id>2690053</comment_id>
            <comment_count>3</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-04-04 06:23:14 -0400</when>
            <comment_text>Created attachment 260693
Screenshot showing the difference

(In reply to Jay Arthanareeswaran from comment #1)
&gt; I can't reproduce this on master. Manoj, could you give it a try please?
@Jay: I can see the behavior described in the bug with M5 Build id: I20160317-0200
Attaching the screenshots (both in the same file) of the observed behavior</comment_text>
        </comment>
        <comment>
            <comment_id>2690068</comment_id>
            <comment_count>4</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-04-04 07:08:19 -0400</when>
            <comment_text>(In reply to Manoj Palat from comment #3)
&gt; Created attachment 260693 [details]
&gt; Screenshot showing the difference
&gt; 
&gt; (In reply to Jay Arthanareeswaran from comment #1)
&gt; &gt; I can't reproduce this on master. Manoj, could you give it a try please?
&gt; @Jay: I can see the behavior described in the bug with M5 Build id:
&gt; I20160317-0200
Version Correction: M6 (not M5) - buildId is correct.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490403</id>
        <developer>Ed Willink</developer>
        <developer_username>ed</developer_username>
        <dup_id/>
        <creation_time>2016-03-24 19:09:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null] '@NonNull Integer' needs unchecked conversion to conform to '@NonNull Integer'</short_desc>
        <thetext>The repro below gives

Null type safety (type annotations): The expression of type '@NonNull Integer' needs unchecked conversion to conform to '@NonNull Integer'

on the keys[index] line. Problem goes away if loop removed.

import org.eclipse.jdt.annotation.NonNull;

public class TestNullInt {
	
	public void test() {
		@NonNull Integer[] keys = new @NonNull Integer[12];
		@NonNull Integer index = 0;
		for (int i = 0; i &lt; 10; i++) {
			keys[index] = index;
		}
	}
}</thetext>
        <comment>
            <comment_id>2686957</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-24 19:51:31 -0400</when>
            <comment_text>Confirming. This is broken.</comment_text>
        </comment>
        <comment>
            <comment_id>2698691</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-04-24 17:07:11 -0400</when>
            <comment_text>Bulk move: too late for 4.6 M7.

Very likely has to be moved out of 4.6 entirely.</comment_text>
        </comment>
        <comment>
            <comment_id>2705490</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-11 09:16:14 -0400</when>
            <comment_text>Not going to make it in 4.6. Moving out.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490412</id>
        <developer>David Williams</developer>
        <developer_username>david_williams</developer_username>
        <dup_id/>
        <creation_time>2016-03-24 20:40:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Dirty working tree: files/jars in JDT Core</short_desc>
        <thetext>+++ This bug was initially created as a clone of Bug #419506 +++

The latest dirt report still shows JDT Core is building a file in the working tree. Would be best to "build" this somewhere under /target to so it would be cleaned up automatically during builds or rebuilds. 


Entering 'eclipse.jdt.core'
?? org.eclipse.jdt.core/jdtCompilerAdapter.jar</thetext>
        <comment>
            <comment_id>2687032</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-03-25 06:51:18 -0400</when>
            <comment_text>(In reply to David Williams from comment #0)
&gt; +++ This bug was initially created as a clone of Bug #419506 +++
&gt; 
&gt; The latest dirt report still shows JDT Core is building a file in the
&gt; working tree. Would be best to "build" this somewhere under /target to so it
&gt; would be cleaned up automatically during builds or rebuilds. 
&gt; 
&gt; 
&gt; Entering 'eclipse.jdt.core'
&gt; ?? org.eclipse.jdt.core/jdtCompilerAdapter.jar

This file is inside the JARed org.eclipse.jdt.core.</comment_text>
        </comment>
        <comment>
            <comment_id>2688224</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-03-30 02:17:01 -0400</when>
            <comment_text>I have been looking at the pom files without any success for some time now. It will be great if someone who is familiar with Maven/Tycho takes this up or offer some clue. Is it all in the pom files (which I am beginning to doubt) or whether any of the old ant scripts or customBuildCallbacks are used here?</comment_text>
        </comment>
        <comment>
            <comment_id>2688227</comment_id>
            <comment_count>3</comment_count>
            <who>Mickael Istria - away until ...</who>
            <commenter_username>mistria</commenter_username>
            <when>2016-03-30 02:34:27 -0400</when>
            <comment_text>Since this file is rebuilt every time, it doesn't have to be committed on the Git repository, I believe it's only a matter of adding it to the .gitignore.</comment_text>
        </comment>
        <comment>
            <comment_id>2688233</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-03-30 02:50:01 -0400</when>
            <comment_text>(In reply to Mickael Istria from comment #3)
&gt; Since this file is rebuilt every time, it doesn't have to be committed on
&gt; the Git repository, I believe it's only a matter of adding it to the
&gt; .gitignore.

It's not part of the repository but it is built inside the checked out location and hence the bug.</comment_text>
        </comment>
        <comment>
            <comment_id>2688235</comment_id>
            <comment_count>5</comment_count>
            <who>Mickael Istria - away until ...</who>
            <commenter_username>mistria</commenter_username>
            <when>2016-03-30 02:53:11 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #4)
&gt; It's not part of the repository but it is built inside the checked out
&gt; location and hence the bug.

This is what has been specified in the build.properties file for years IIRC. What makes it suddenly a bug?</comment_text>
        </comment>
        <comment>
            <comment_id>2689886</comment_id>
            <comment_count>6</comment_count>
            <who>David Williams</who>
            <commenter_username>david_williams</commenter_username>
            <when>2016-04-03 17:22:45 -0400</when>
            <comment_text>(In reply to Mickael Istria from comment #5)
&gt; (In reply to Jay Arthanareeswaran from comment #4)
&gt; &gt; It's not part of the repository but it is built inside the checked out
&gt; &gt; location and hence the bug.
&gt; 
&gt; This is what has been specified in the build.properties file for years IIRC.
&gt; What makes it suddenly a bug?

It has been a bug ever since we started reporting or looking at "dirty working tree", and just got lost with some other jdt "dirt" which was fixed, so the report for this specific jar was "lost". 

Adding it to .gitignore solves part of the problem (the main part, probably) but ideally it would be created under "target" so that Tycho itself would clean it up -- and recreate it -- if it went to re-build jdt.core. 

I believe it is created by some ant script, as a combination of (copied) class files already built? Not sure why it is done that way, but assume there is not a radical solution (i.e. create it like a normal bundle) then I think the Tycho/Maven solution would be to copy/zip the files to ${buildDirectory}/resources (instead of ${basedir}) and then assuming it is part of another bundle to get Tycho to "recognize it" as such (at weird phases) then an addition to the pom of an "additional resources" step is required. If not obvious, I'm just outlining from memory, so a) could be wrong :) b) do not remember the exact names of the tasks. But I am pretty sure there are other examples in our build.</comment_text>
        </comment>
        <comment>
            <comment_id>2689890</comment_id>
            <comment_count>7</comment_count>
            <who>David Williams</who>
            <commenter_username>david_williams</commenter_username>
            <when>2016-04-03 18:07:21 -0400</when>
            <comment_text>(In reply to David Williams from comment #6)
&gt; But I am pretty
&gt; sure there are other examples in our build.

additionalFileSets 
is what I was thinking of. It doesn't seem like there are any similar examples in our build. We use it for some cases related to about.mappings and .api_descriptions, but not sure if or how you could apply this in your case. 
(Your case looks very complicated, as it is!) 

But, if interested, it is documented here: 
https://eclipse.org/tycho/sitedocs/tycho-packaging-plugin/package-plugin-mojo.html#additionalFileSets

with this short description: 
&lt;quote&gt;
Additional files to be included in the bundle jar. This can be used when bin.includes in build.properties is not flexible enough , e.g. for generated files. If conflicting, additional files win over bin.includes
&lt;/quote&gt;

Tycho "fixed" the behavior for us so that "if there was a conflict, then additional files win over bin.includes". bug 419849 (which as related to "about.mappings" looking like dirty files in working tree). Since the fix, we can not "copy" those files to 'target', and the build will take those modified files, instead of the ones in basedir, that we specify in build.properties.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490441</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-03-25 09:44:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[releng] JDT/Core sonar job fails due to duplicate o.e.j.annotation</short_desc>
        <thetext>I'd like to see the jacoco.exec as produced since bug 388956, but the JDT/Core job that would produce those, currently fails with

[ERROR] Failed to execute goal org.sonarsource.scanner.maven:sonar-maven-plugin:3.0.1:sonar (default-cli) on project eclipse.jdt.core: Project 'eclipse.jdt.core:eclipse.jdt.core' can't have 2 modules with the following key: org.eclipse.jdt:org.eclipse.jdt.annotation -&gt; [Help 1]
org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.sonarsource.scanner.maven:sonar-maven-plugin:3.0.1:sonar (default-cli) on project eclipse.jdt.core: Project 'eclipse.jdt.core:eclipse.jdt.core' can't have 2 modules with the following key: org.eclipse.jdt:org.eclipse.jdt.annotation

Maven is not capable to handle a situation that is perfectly legal in OSGi.
Let's see if we can exclude one version of that bundle from the execution of sonar-maven-plugin.</thetext>
        <comment>
            <comment_id>2687159</comment_id>
            <comment_count>1</comment_count>
            <who>Mickael Istria - away until ...</who>
            <commenter_username>mistria</commenter_username>
            <when>2016-03-25 10:36:24 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #0)
&gt; Maven is not capable to handle a situation that is perfectly legal in OSGi.
&gt; Let's see if we can exclude one version of that bundle from the execution of
&gt; sonar-maven-plugin.

Note that Maven is OK with that, here it's the sonar plugin which seems to be complaining.</comment_text>
        </comment>
        <comment>
            <comment_id>2687161</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-25 10:50:18 -0400</when>
            <comment_text>In https://hudson.eclipse.org/platform/job/eclipse.jdt.core-Gerrit/1133 I temporarily activated -P coverage in our regular gerrit job, to find out if this suffices to create the jacoco.exec.

BTW, I do have permissions to edit the job configuration for eclipse.jdt.core-Gerrit, but not for eclipse.jdt.core-SonarQube, not sure whether there's some deeper intention behind.</comment_text>
        </comment>
        <comment>
            <comment_id>2687167</comment_id>
            <comment_count>3</comment_count>
            <who>Mickael Istria - away until ...</who>
            <commenter_username>mistria</commenter_username>
            <when>2016-03-25 10:58:38 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #2)
&gt; In https://hudson.eclipse.org/platform/job/eclipse.jdt.core-Gerrit/1133 I
&gt; temporarily activated -P coverage in our regular gerrit job, to find out if
&gt; this suffices to create the jacoco.exec.

Yes, this would create the jacoco.exec files. And if you like it that way, it seems totally fine to me to get coverage for each Gerrit build, although I'm wondering whether it's really going to be useful.

&gt; BTW, I do have permissions to edit the job configuration for
&gt; eclipse.jdt.core-Gerrit, but not for eclipse.jdt.core-SonarQube, not sure
&gt; whether there's some deeper intention behind.

I just changed that.</comment_text>
        </comment>
        <comment>
            <comment_id>2687235</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-25 13:09:21 -0400</when>
            <comment_text>(In reply to Mickael Istria from comment #3)
&gt; (In reply to Stephan Herrmann from comment #2)
&gt; &gt; In https://hudson.eclipse.org/platform/job/eclipse.jdt.core-Gerrit/1133 I
&gt; &gt; temporarily activated -P coverage in our regular gerrit job, to find out if
&gt; &gt; this suffices to create the jacoco.exec.
&gt; 
&gt; Yes, this would create the jacoco.exec files.

Confirming: I'm looking at jacoco.exec successfully created by eclipse.jdt.core-Gerrit/1133

&gt; And if you like it that way,
&gt; it seems totally fine to me to get coverage for each Gerrit build, although
&gt; I'm wondering whether it's really going to be useful.

Point in favor: it doesn't seem to hurt: original #1132: 1hr 0min, retriggered with -P coverage: 1hr 2min
 
&gt; &gt; BTW, I do have permissions to edit the job configuration for
&gt; &gt; eclipse.jdt.core-Gerrit, but not for eclipse.jdt.core-SonarQube, not sure
&gt; &gt; whether there's some deeper intention behind.
&gt; 
&gt; I just changed that.

Thanks.</comment_text>
        </comment>
        <comment>
            <comment_id>2687353</comment_id>
            <comment_count>5</comment_count>
            <who>Mickael Istria - away until ...</who>
            <commenter_username>mistria</commenter_username>
            <when>2016-03-26 08:13:11 -0400</when>
            <comment_text>I tried to remove one of the annotation bundles from build using "-pl !org.eclipse.jdt.annotations_v1" but then Maven complains about the missing dependency.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490513</id>
        <developer>monica sabharwal</developer>
        <developer_username>monicasabharwal90</developer_username>
        <dup_id/>
        <creation_time>2016-03-28 06:03:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>eclipse-java-luna-SR1-win32 problem</short_desc>
        <thetext>eclipse-java-luna-SR1-win32 there is some problem with this version of eclipse. its working fine in my college pc's but now i have downloaded it on my lappy its not working</thetext>
        <comment>
            <comment_id>2687476</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-03-28 06:56:25 -0400</when>
            <comment_text>Can you please provide us more information on the problem you are facing and why you think this is a bug.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490664</id>
        <developer>Frederic Schelling</developer>
        <developer_username>f.schelling</developer_username>
        <dup_id/>
        <creation_time>2016-03-30 04:51:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Eclipse Java 8 Auto completion for Lambda expressions not working inside Switch statement</short_desc>
        <thetext>public class Testclass {
   public static void testMethod() {
      Consumer&lt;String&gt; consumer = s -&gt; {
         sysout         // Content assist works here
         int i = 1;
         switch (i) {
         case 1:
            sysout       // Content assist FAILS here
            break;
         }
      };
   }
}</thetext>
        <comment>
            <comment_id>2688404</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-03-30 09:20:16 -0400</when>
            <comment_text>A quick look shows the following exception is thrown:

java.lang.ArrayIndexOutOfBoundsException: Single cell array overflow
	at org.eclipse.jdt.internal.compiler.parser.Scanner.ungetToken(Scanner.java:1139)
	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.fallBackToSpringForward(AssistParser.java:1966)
	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.resumeAfterRecovery(AssistParser.java:2001)
	at org.eclipse.jdt.internal.codeassist.complete.CompletionParser.resumeAfterRecovery(CompletionParser.java:5118)
	at org.eclipse.jdt.internal.compiler.parser.Parser.resumeOnSyntaxError(Parser.java:12435)
	at org.eclipse.jdt.internal.codeassist.complete.CompletionParser.resumeOnSyntaxError(CompletionParser.java:5101)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11047)
	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.parseBlockStatements(AssistParser.java:1713)</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490698</id>
        <developer>Sergey Toshin</developer>
        <developer_username>stoshins</developer_username>
        <dup_id/>
        <creation_time>2016-03-30 11:14:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>ASTParser.createASTs() throws NullPointerException</short_desc>
        <thetext>Exact file which makes it crash is not available. It's a one from thousands
If you need any further information, please tell me.

Stacktrace:
org.eclipse.jdt.internal.compiler.ast.Annotation.isTypeUseCompatible(Annotation.java:1154)
org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypeFor(SourceTypeBinding.java:1756)
org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.getField(SourceTypeBinding.java:1173)
org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1327)
org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1273)
org.eclipse.jdt.internal.compiler.lookup.MethodScope.findField(MethodScope.java:417)
org.eclipse.jdt.internal.compiler.lookup.Scope.getField(Scope.java:2447)
org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.getOtherFieldBindings(QualifiedNameReference.java:752)
org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(QualifiedNameReference.java:1015)
org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:196)
org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:861)
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1016)
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:639)
org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:993)
ru.scanner.Main.main(Main.java:190)</thetext>
        <comment>
            <comment_id>2688534</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-03-30 12:09:13 -0400</when>
            <comment_text>Line number doesn't seem to match with what is there in master.

Can you please tell us which build you are using?</comment_text>
        </comment>
        <comment>
            <comment_id>2688780</comment_id>
            <comment_count>2</comment_count>
            <who>Sergey Toshin</who>
            <commenter_username>stoshins</commenter_username>
            <when>2016-03-31 04:13:48 -0400</when>
            <comment_text>org.eclipse.jdt.core_3.11.1.v20150902-1521

Where I can download the latest build? Thanks</comment_text>
        </comment>
        <comment>
            <comment_id>2688786</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-03-31 04:22:19 -0400</when>
            <comment_text>(In reply to Ivan Ivan from comment #2)
&gt; org.eclipse.jdt.core_3.11.1.v20150902-1521
&gt; 
&gt; Where I can download the latest build? Thanks

If you only need the plain SDK (not the EE package) then you can get the milestones builds or even our weekly integration builds from here:

http://download.eclipse.org/eclipse/downloads/</comment_text>
        </comment>
        <comment>
            <comment_id>2688839</comment_id>
            <comment_count>4</comment_count>
            <who>Sergey Toshin</who>
            <commenter_username>stoshins</commenter_username>
            <when>2016-03-31 06:04:34 -0400</when>
            <comment_text>New stack trace
org.eclipse.jdt.internal.compiler.ast.Annotation.isTypeUseCompatible(Annotation.java:1153)
org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypeFor(SourceTypeBinding.java:1790)
org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.getField(SourceTypeBinding.java:1207)
org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1338)
org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1284)
org.eclipse.jdt.internal.compiler.lookup.MethodScope.findField(MethodScope.java:417)
org.eclipse.jdt.internal.compiler.lookup.Scope.getField(Scope.java:2458)
org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.getOtherFieldBindings(QualifiedNameReference.java:752)
org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(QualifiedNameReference.java:1015)
org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:196)
org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:861)
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1016)
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:639)
org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:993)
ru.scanner.Main.main(Main.java:190)</comment_text>
        </comment>
        <comment>
            <comment_id>2688870</comment_id>
            <comment_count>5</comment_count>
            <who>Sergey Toshin</who>
            <commenter_username>stoshins</commenter_username>
            <when>2016-03-31 06:30:59 -0400</when>
            <comment_text>I hit a breakpoint and on this line annotation.resolvedType is null</comment_text>
        </comment>
        <comment>
            <comment_id>2689901</comment_id>
            <comment_count>6</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-04 00:30:05 -0400</when>
            <comment_text>Thanks Ivan, but I think we can make more progress when we know what code is causing trouble. Are you in a position to enable tracing and try out? Here's some info on how to do that:

https://wiki.eclipse.org/FAQ_How_do_I_use_the_platform_debug_tracing_facility</comment_text>
        </comment>
        <comment>
            <comment_id>2690167</comment_id>
            <comment_count>7</comment_count>
            <who>Sergey Toshin</who>
            <commenter_username>stoshins</commenter_username>
            <when>2016-04-04 10:36:02 -0400</when>
            <comment_text>Created attachment 260703
Crash

Hi, I have found 3 files which occur crash. Send them to createASTs(...)</comment_text>
        </comment>
        <comment>
            <comment_id>2690190</comment_id>
            <comment_count>8</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-04 11:08:55 -0400</when>
            <comment_text>(In reply to Ivan Ivan from comment #7)
&gt; Created attachment 260703 [details]
&gt; Crash
&gt; 
&gt; Hi, I have found 3 files which occur crash. Send them to createASTs(...)

Thanks, I can reproduce. Looks like a case invalid annotations causing trouble. Before we dive in, can you tell us if the annotation @b.a.a is unresolved in your set up too?</comment_text>
        </comment>
        <comment>
            <comment_id>2690203</comment_id>
            <comment_count>9</comment_count>
            <who>Sergey Toshin</who>
            <commenter_username>stoshins</commenter_username>
            <when>2016-04-04 11:31:37 -0400</when>
            <comment_text>Yes. It's a decompiled app which will probably contain huge amount of invalid code, but I believe it shouldn't lead to crash. Thanks</comment_text>
        </comment>
        <comment>
            <comment_id>2690219</comment_id>
            <comment_count>10</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-04 11:57:00 -0400</when>
            <comment_text>(In reply to Ivan Ivan from comment #9)
&gt; Yes. It's a decompiled app which will probably contain huge amount of
&gt; invalid code, but I believe it shouldn't lead to crash. Thanks

Fair enough it shouldn't crash. I was merely trying to understand the scenario further.

Stephan, what's your take? Is there a preferred point in the stack where we want to handle this?</comment_text>
        </comment>
        <comment>
            <comment_id>2691252</comment_id>
            <comment_count>11</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-04-06 12:25:20 -0400</when>
            <comment_text>Seems like all our ProblemBinding and MissingTypeBinding craft does not work for annotations? Maybe it should? Haven't yet looked at it.</comment_text>
        </comment>
        <comment>
            <comment_id>2707347</comment_id>
            <comment_count>12</comment_count>
            <who>Sergey Toshin</who>
            <commenter_username>stoshins</commenter_username>
            <when>2016-05-16 08:22:24 -0400</when>
            <comment_text>Hi!
Any updates?</comment_text>
        </comment>
        <comment>
            <comment_id>2714021</comment_id>
            <comment_count>13</comment_count>
            <who>Sergey Toshin</who>
            <commenter_username>stoshins</commenter_username>
            <when>2016-05-30 08:22:35 -0400</when>
            <comment_text>Any updates?</comment_text>
        </comment>
        <comment>
            <comment_id>2714128</comment_id>
            <comment_count>14</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-30 10:18:15 -0400</when>
            <comment_text>(In reply to Ivan Ivan from comment #13)
&gt; Any updates?

Too late for 4.6, but let's put it on the radar for 4.7 (and possibly 4.6.1).</comment_text>
        </comment>
        <comment>
            <comment_id>2727602</comment_id>
            <comment_count>15</comment_count>
            <who>Sergey Toshin</who>
            <commenter_username>stoshins</commenter_username>
            <when>2016-07-06 07:44:46 -0400</when>
            <comment_text>Hi!
Not yet fixed?</comment_text>
        </comment>
        <comment>
            <comment_id>2733882</comment_id>
            <comment_count>16</comment_count>
            <who>Alex Panchenko</who>
            <commenter_username>alex.panchenko</commenter_username>
            <when>2016-07-26 13:09:27 -0400</when>
            <comment_text>Happens in Neon too.

// SOURCE

package foo.bar;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import java.util.function.Predicate;

public class AnnotationError&lt;T&gt; {

	public enum P {
		AAA
	}

	@Target(FIELD)
	@Retention(RUNTIME)
	public @interface A {
		P value();
	}

	@Target(FIELD)
	@Retention(RUNTIME)
	public @interface FF {
	}

	public static class Bool extends AnnotationError&lt;Boolean&gt; {
	}

	@A(P.AAA)
	@FF
	public static final AnnotationError.Bool FOO = new AnnotationError.Bool();
}

// STACK TRACE

java.lang.NullPointerException: null
    at org.eclipse.jdt.internal.compiler.ast.Annotation.isTypeUseCompatible(Annotation.java:1153)
    at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypeFor(SourceTypeBinding.java:1790)
    at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.fields(SourceTypeBinding.java:934)
    at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.fields(ParameterizedTypeBinding.java:462)
    at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.getField(ParameterizedTypeBinding.java:647)
    at org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1338)
    at org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1284)
    at org.eclipse.jdt.internal.compiler.lookup.Scope.getBinding(Scope.java:2014)
    at org.eclipse.jdt.internal.compiler.lookup.BlockScope.getBinding(BlockScope.java:485)
    at org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(QualifiedNameReference.java:999)
    at org.eclipse.jdt.internal.compiler.ast.MemberValuePair.resolveTypeExpecting(MemberValuePair.java:89)
    at org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:829)
    at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:837)
    at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:705)
    at org.eclipse.jdt.internal.compiler.lookup.FieldBinding.getAnnotationTagBits(FieldBinding.java:312)
    at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypeFor(SourceTypeBinding.java:1736)
    at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.fields(SourceTypeBinding.java:934)
    at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.fields(ParameterizedTypeBinding.java:462)
    at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.getField(ParameterizedTypeBinding.java:647)
    at org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1338)
    at org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1284)
    at org.eclipse.jdt.internal.compiler.lookup.Scope.getBinding(Scope.java:2014)
    at org.eclipse.jdt.internal.compiler.lookup.BlockScope.getBinding(BlockScope.java:485)
    at org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(QualifiedNameReference.java:999)
    at org.eclipse.jdt.internal.compiler.ast.MemberValuePair.resolveTypeExpecting(MemberValuePair.java:89)
    at org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:829)
    at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:837)
    at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:705)
    at org.eclipse.jdt.internal.compiler.lookup.FieldBinding.getAnnotationTagBits(FieldBinding.java:312)
    at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypeFor(SourceTypeBinding.java:1736)
    at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.fields(SourceTypeBinding.java:934)
    at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.fields(ParameterizedTypeBinding.java:462)
    at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.getField(ParameterizedTypeBinding.java:647)
    at org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1338)
    at org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1284)
    at org.eclipse.jdt.internal.compiler.lookup.Scope.getBinding(Scope.java:2014)
    at org.eclipse.jdt.internal.compiler.ast.SingleNameReference.resolveType(SingleNameReference.java:987)
    at org.eclipse.jdt.internal.compiler.ast.MemberValuePair.resolveTypeExpecting(MemberValuePair.java:89)
    at org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:829)
    at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:837)
    at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:705)
    at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.getAnnotationTagBits(SourceTypeBinding.java:1022)
    at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.getAnnotationTagBits(ParameterizedTypeBinding.java:533)
    at org.eclipse.jdt.internal.compiler.ast.Annotation.isTypeUseCompatible(Annotation.java:1153)
    at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypeFor(SourceTypeBinding.java:1790)
    at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.fields(SourceTypeBinding.java:934)
    at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.fields(ParameterizedTypeBinding.java:462)
    at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.getField(ParameterizedTypeBinding.java:647)
    at org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1338)
    at org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1284)
    at org.eclipse.jdt.internal.compiler.lookup.Scope.getBinding(Scope.java:2014)
    at org.eclipse.jdt.internal.compiler.lookup.BlockScope.getBinding(BlockScope.java:485)
    at org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(QualifiedNameReference.java:999)
    at org.eclipse.jdt.internal.compiler.ast.MemberValuePair.resolveTypeExpecting(MemberValuePair.java:89)
    at org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:829)
    at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:837)
    at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:705)
    at org.eclipse.jdt.internal.compiler.lookup.FieldBinding.getAnnotationTagBits(FieldBinding.java:312)
    at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypeFor(SourceTypeBinding.java:1736)
    at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.fields(SourceTypeBinding.java:934)
    at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.fields(ParameterizedTypeBinding.java:462)
    at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.getField(ParameterizedTypeBinding.java:647)
    at org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1338)
    at org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1284)
    at org.eclipse.jdt.internal.compiler.lookup.MethodScope.findField(MethodScope.java:417)
    at org.eclipse.jdt.internal.compiler.lookup.BlockScope.getBinding(BlockScope.java:552)
    at org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(QualifiedNameReference.java:999)
    at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:684)
    at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve(ReturnStatement.java:342)
    at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
    at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:276)
    at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:278)
    at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
    at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
    at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
    at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
    at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
    at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
    at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:867)
    at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:141)
    at java.lang.Thread.run(Thread.java:745)</comment_text>
        </comment>
        <comment>
            <comment_id>2733941</comment_id>
            <comment_count>17</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-26 16:07:03 -0400</when>
            <comment_text>(In reply to Alex Panchenko from comment #16)
&gt; Happens in Neon too.

Thanks for the test case. This will facilitate analysis on our side.</comment_text>
        </comment>
        <comment>
            <comment_id>2735363</comment_id>
            <comment_count>18</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-29 18:08:29 -0400</when>
            <comment_text>(In reply to Alex Panchenko from comment #16)
&gt; Happens in Neon too.

Upon debugging I see that this case is different from comment 0 and comment 4. The new example finds an annotation without a resolved type, because of this unhappy re-entrance:
 
&gt; java.lang.NullPointerException: null
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.ast.Annotation.
&gt; isTypeUseCompatible(Annotation.java:1153)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.
&gt; resolveTypeFor(SourceTypeBinding.java:1790)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.
&gt; fields(SourceTypeBinding.java:934)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.
&gt; fields(ParameterizedTypeBinding.java:462)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.
&gt; getField(ParameterizedTypeBinding.java:647)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1338)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.lookup.Scope.findField(Scope.java:1284)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.lookup.Scope.getBinding(Scope.java:2014)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.lookup.BlockScope.getBinding(BlockScope.
&gt; java:485)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.
&gt; resolveType(QualifiedNameReference.java:999)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.ast.MemberValuePair.
&gt; resolveTypeExpecting(MemberValuePair.java:89)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:
&gt; 829)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.
&gt; java:837)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.
&gt; java:705)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.lookup.FieldBinding.
&gt; getAnnotationTagBits(FieldBinding.java:312)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.
&gt; resolveTypeFor(SourceTypeBinding.java:1736)
&gt;     at
&gt; org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.
&gt; fields(SourceTypeBinding.java:934)
...


=&gt; fields() is invoked for the same STB that is already being processed. This probably is the root cause for the NPE here. Fixing this doesn't cover the other examples.</comment_text>
        </comment>
        <comment>
            <comment_id>2735854</comment_id>
            <comment_count>19</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-31 09:13:10 -0400</when>
            <comment_text>Not for M1.

Since root causes differ between the given examples, we need to better understand both these causes, before we can provide an effective fix.</comment_text>
        </comment>
        <comment>
            <comment_id>2750247</comment_id>
            <comment_count>20</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-13 10:19:41 -0400</when>
            <comment_text>Looks like this will have to be moved out of M3.</comment_text>
        </comment>
        <comment>
            <comment_id>2770799</comment_id>
            <comment_count>21</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-28 02:45:58 -0400</when>
            <comment_text>Bulk change, moving out all bugs that couldn't make it to M3.</comment_text>
        </comment>
        <comment>
            <comment_id>2783086</comment_id>
            <comment_count>22</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-12-05 22:07:59 -0500</when>
            <comment_text>Moving out of M4 to a generic target M7 - keep in radar</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491090</id>
        <developer>Pascal Rapicault</developer>
        <developer_username>pascal</developer_username>
        <dup_id/>
        <creation_time>2016-04-05 10:13:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Completion should propose all types compatible with the expected argument</short_desc>
        <thetext>I have the following code
EObject eobject = ...;
eobject.eAdapters().add(new |);

When I hit the completion where the '|' is located, the only choice I get proposed with is the type of the argument. In this case I get proposed with an interface called Adapter (which is correct). 

However this is not super helpful because I know there are some subtypes that are more interesting to me and I can't see them. In this particular case, the completion should also show me the set of subtypes of Adapter like EContentAdapter, etc.</thetext>
        <comment>
            <comment_id>2690913</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-06 03:45:18 -0400</when>
            <comment_text>Pascal, there has to be something about your set-up; let's find out. What's the signature of the eAdapters() like? I have something like this and I get all relevant proposals including the sub types of Adapter.

class EObject&lt;T&gt; {
	public List&lt;T&gt; eAdapters() {
		return new ArrayList&lt;&gt;();
	}
}

Do you have a lambda somewhere in the code? Can you try pulling this into a small class?</comment_text>
        </comment>
        <comment>
            <comment_id>2692177</comment_id>
            <comment_count>2</comment_count>
            <who>Pascal Rapicault</who>
            <commenter_username>pascal</commenter_username>
            <when>2016-04-08 07:39:06 -0400</when>
            <comment_text>No lambdas, nothing too fancy. Just the code snippet I showed you.
Note that EObject is coming from EMF.core and Adapter from EMF.common.

I've been able to reproduce this again.</comment_text>
        </comment>
        <comment>
            <comment_id>2693277</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-12 00:50:04 -0400</when>
            <comment_text>(In reply to Pascal Rapicault from comment #2)
&gt; No lambdas, nothing too fancy. Just the code snippet I showed you.
&gt; Note that EObject is coming from EMF.core and Adapter from EMF.common.
&gt; 
&gt; I've been able to reproduce this again.

Will you be able to share that code where this happens? TIA!</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491282</id>
        <developer>Jeffery Yuan</developer>
        <developer_username>yuanyun.kenny</developer_username>
        <dup_id/>
        <creation_time>2016-04-07 17:16:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Easy way to search and locate specific jars</short_desc>
        <thetext>Sometimes, we want to locate one specific jar and look at its source code and check its implementation.

For example: I want to check jersey-spring3's code during trouble shooting. But it takes me a lot of time to find it. - because it's a multiple-modules projects, and there are a lot of jars and the order in dependencies is not sorted (for good reason - https://bugs.eclipse.org/bugs/show_bug.cgi?id=396589)

One approach is to add Jar Search like File or Java Search
User can search jar by name, or even search content in jars - if we attached source code(Maven can do this for us).</thetext>
    </bug>
    <bug>
        <id>491454</id>
        <developer>Roland Illig</developer>
        <developer_username>rillig</developer_username>
        <dup_id/>
        <creation_time>2016-04-11 12:59:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Necessary cast wrongly flagged as unnecessary</short_desc>
        <thetext>public class Tmp {

  static &lt;T&gt; T getValue() {
    return null;
  }

  public static void main(String[] args) {
    // String.valueOf((Object) getValue());
    String.valueOf(getValue());
  }
}


The above code calls String.valueOf(char[]), which is ok, since there are two candidate functions for a one-parameter Object call.

When I want to change this call to String.valueOf(Object), I can add a cast in front of the getValue() call.

But then, when cleaning up including “Remove unnecessary casts”, this cast is removed. It should stay though, since it is not unnecessary.

In general, is it possible that the cleanup actions compare the bytecode of the cleaned up classes before and after the change, to make sure nothing essential has been changed?</thetext>
        <comment>
            <comment_id>2693293</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-12 02:46:55 -0400</when>
            <comment_text>Moving to UI for investigation.</comment_text>
        </comment>
        <comment>
            <comment_id>2693331</comment_id>
            <comment_count>2</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-04-12 04:09:41 -0400</when>
            <comment_text>String.valueOf((Object) getValue()) invokes the String.valueOf(Object) method, so the cast is actually unnecessary and should be removed by the clean up.

String.valueOf(getValue()) in this example should also invoke String.valueOf(Object) method, which is the case when using JDK7. But it calls String.valueOf(char[]) if using JDK8. Looks like this is the issue that should be fixed. 

Moving back to JDT Core for analysis.</comment_text>
        </comment>
        <comment>
            <comment_id>2693340</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-12 04:34:53 -0400</when>
            <comment_text>(In reply to Noopur Gupta from comment #2)
&gt; String.valueOf(getValue()) in this example should also invoke
&gt; String.valueOf(Object) method, which is the case when using JDK7. But it
&gt; calls String.valueOf(char[]) if using JDK8. Looks like this is the issue
&gt; that should be fixed. 
&gt; 
&gt; Moving back to JDT Core for analysis.

This is the expected behavior according to bug 487118.</comment_text>
        </comment>
        <comment>
            <comment_id>2693351</comment_id>
            <comment_count>4</comment_count>
            <who>Roland Illig</who>
            <commenter_username>rillig</commenter_username>
            <when>2016-04-12 05:25:09 -0400</when>
            <comment_text>According to my understanding of “cleanup”, this should not be the expected behavior.

In the example code given in the first comment, when I remove the "//", I, as the programmer, have decided that I want to call getValue(), then cast the returned value to Object, and then call String.valueOf(Object).

Cleaning up code means to me that unnecessary syntactical elements are removed or beautified, and that the behavior of the code does not change.

But when the cast is removed, the selected String.valueOf method changes, which is unexpected to me.

Is there an general agreement on what “cleanup” means in the JDT context? Maybe it’s a different definition than mine.</comment_text>
        </comment>
        <comment>
            <comment_id>2693361</comment_id>
            <comment_count>5</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-04-12 05:42:22 -0400</when>
            <comment_text>(In reply to Roland Illig from comment #4)
&gt; But when the cast is removed, the selected String.valueOf method changes,
&gt; which is unexpected to me.

Correct, this is an issue (after bug 487118).

(In reply to Jay Arthanareeswaran from comment #3)
&gt; (In reply to Noopur Gupta from comment #2)
&gt; &gt; String.valueOf(getValue()) in this example should also invoke
&gt; &gt; String.valueOf(Object) method, which is the case when using JDK7. But it
&gt; &gt; calls String.valueOf(char[]) if using JDK8. Looks like this is the issue
&gt; &gt; that should be fixed. 
&gt; &gt; 
&gt; &gt; Moving back to JDT Core for analysis.
&gt; 
&gt; This is the expected behavior according to bug 487118.

Why is this not applicable to JDK7?

For the clean up issue, adding a breakpoint at compilationUnit.getProblems() in:

UnusedCodeFix.createCleanUp(CompilationUnit compilationUnit, boolean removeUnusedPrivateMethods, boolean removeUnusedPrivateConstructors, boolean removeUnusedPrivateFields, boolean removeUnusedPrivateTypes, boolean removeUnusedLocalVariables, boolean removeUnusedImports, boolean removeUnusedCast)

shows that CompilationUnit.getProblems() returns:
[Pb(181) Unnecessary cast from Object to Object]

which results in the clean up removing the cast.

CompilationUnit.getProblems() should not report the unnecessary cast problem in this case to fix this issue.</comment_text>
        </comment>
        <comment>
            <comment_id>2696603</comment_id>
            <comment_count>6</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-04-19 14:01:27 -0400</when>
            <comment_text>Sounds similar to the warning re redundant type arguments. In both cases the wrong warning enables a wrong quick fix.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491654</id>
        <developer>Ludovic WALLE</developer>
        <developer_username>walle</developer_username>
        <dup_id/>
        <creation_time>2016-04-14 03:53:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>javadoc comment on anonymous class blocks formatting, cleaning, import optimization, ...</short_desc>
        <thetext>Created attachment 260946
Class with javadoc comment on anonymous class.

When there is a javadoc comment on an anonymous class, formatting, cleaning, import optimization, ... do not work any more for whole file.
It works if javadoc comment is removed or converted to a simple comment (/*  */).</thetext>
        <comment>
            <comment_id>2694430</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-14 04:41:10 -0400</when>
            <comment_text>Can you please tell us which version of eclipse you are using? We fixed several bugs in this area in Neon and it is likely that your issue is one of them.

BTW, I can see formatting working as expected in the recent Neon build.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491810</id>
        <developer>arne anka</developer>
        <developer_username>eclipse-bugs</developer_username>
        <dup_id/>
        <creation_time>2016-04-15 10:41:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Renaming project does not update open editors</short_desc>
        <thetext>- active project with a couple of editors open with files inside that project
- Package Explorer -&gt; Project node -&gt; rmc -&gt; Refactor -&gt; Rename ...
- renaming apparently successfully, Project node changes name
- switch to currently inactive editor and see first white and then an error "Cannot determine URI for '/&lt;old project name&gt;/a/file'"

refactoring the proejct's name should, no doubt, update the currently open editors of said project.

stacktrace:

org.eclipse.core.runtime.CoreException: Cannot determine URI for '/&lt;old project name&gt;/a/file'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:238)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:112)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:559)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:478)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4233)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:237)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1480)
	at org.eclipse.ui.editors.text.TextEditor.doSetInput(TextEditor.java:169)
	at org.eclipse.ui.texteditor.AbstractTextEditor$19.run(AbstractTextEditor.java:3220)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:463)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:371)
	at org.eclipse.ui.internal.WorkbenchWindow$14.run(WorkbenchWindow.java:2181)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2177)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3238)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3265)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:361)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:319)
	at sun.reflect.GeneratedMethodAccessor72.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:898)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:879)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:121)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:345)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:162)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:104)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:73)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:55)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:129)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:971)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl$1.handleEvent(PartServiceImpl.java:99)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:186)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4633)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:85)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:59)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:171)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$9.widgetSelected(StackRenderer.java:1084)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4481)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1329)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1353)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1338)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1119)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3158)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1841)
	at org.eclipse.swt.custom.CTabFolder$1.handleEvent(CTabFolder.java:330)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4481)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1329)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3819)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3430)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:694)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:606)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1515)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1488)</thetext>
        <comment>
            <comment_id>2704100</comment_id>
            <comment_count>1</comment_count>
            <who>Ugur Ozdemir</who>
            <commenter_username>ugur.ozdemir</commenter_username>
            <when>2016-05-09 03:11:36 -0400</when>
            <comment_text>To reproduce the problem eclipse should be restarted before rename operation. I think the steps should be 

- active project with a couple of editors open with files inside that project
- restart Eclipse
- Package Explorer -&gt; Project node -&gt; rmc -&gt; Refactor -&gt; Rename ...
- renaming apparently successfully, Project node changes name
- switch to currently inactive editor and see first white and then an error "Cannot determine URI for '/&lt;old project name&gt;/a/file'"

Same problem is also in Luna (4.4.0) for delete operation. Somehow it is solved in Mars but couldnt find how</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491879</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-04-18 02:42:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[formatter] Generated comment is not formatted properly</short_desc>
        <thetext>This used to work fine in Eclipse 4.4.2. Broken since Eclipse 4.5.

public @interface A1 {

}

New &gt; Annotation:
- Select 'A1' as Enclosing type in 'New Annotation Type' wizard
- Give name as 'A2'
- Check 'Generate comments'
- Press Finish.

Results in:

public @interface A1 {

	/**
		 * @author noopur
		 *
		 */
	public @interface A2 {

	}

}

=&gt; The generated comment is not formatted properly.

Formatter is invoked at NewTypeWizardPage#createType, line: 2232.</thetext>
        <comment>
            <comment_id>2696082</comment_id>
            <comment_count>1</comment_count>
            <who>Mateusz Matela</who>
            <commenter_username>mateusz.matela</commenter_username>
            <when>2016-04-18 16:07:45 -0400</when>
            <comment_text>You probably won't like it, but here's my interpretation :)

If the javadoc should be formatted, then the CodeFormatter.F_INCLUDE_COMMENTS flag should be turned on.

Before 4.5 the formatter used to fix indentation of comment lines even when comment formatting was disabled, which IMO was too aggressive. Currently, formatter only moves comment lines to the right if their indentation is too small. Even with this more loose behavior there are complaints about it, see bug 472964.

Formatter gets this code for formatting:
/**
	 * @author mati
	 *
	 */
	public @interface A2 {
	
	}
So it can interpret it like the caller wants to have additional indentation in the comment in all but the first line.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491998</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-04-19 09:05:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[impl] Suspecious looking code in LookupEnvironment.createWildcard(ReferenceBinding, int, TypeBinding, TypeBinding[], int)</short_desc>
        <thetext>(In reply to Till Brychcy from bug 485988 comment #6)
&gt; While examining this, I've found some suspicious looking code: it looks like
&gt; in LookupEnvironment.createWildcard(ReferenceBinding, int, TypeBinding,
&gt; TypeBinding[], int), the type annotations from the GenericType are passed to
&gt; typeSystem.getWildcard as annotations for the Wildcard (but I think this is
&gt; never actually executed for an annotated GenericType). Or have I
&gt; misunderstood something?

This code was introduced via Bug 455180, and indeed there's a significant difference between createParameterizedType(), createRawType() (both look good) versus createWildcard(), where genericType plays a different role.</thetext>
    </bug>
    <bug>
        <id>492059</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-04-20 03:37:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Move project org.eclipse.jdt.core.tests.binaries to 1.7</short_desc>
        <thetext>The idea is to limit the requirements of too many runtimes in a developer environment. The triggering point was bug 490012, which made me realize we could do away with dependency on 1.4 altogether.

If anyone has reasons not to do this, please let me know.</thetext>
        <comment>
            <comment_id>2696781</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-20 03:39:11 -0400</when>
            <comment_text>Created attachment 261105
Patch to up the BREE and bundle version</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492161</id>
        <developer>Ales Krestan</developer>
        <developer_username>akrestan</developer_username>
        <dup_id/>
        <creation_time>2016-04-21 06:24:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>ecj does not compile Java 8 code where javac does</short_desc>
        <thetext>Created attachment 261146
code to reproduce the bug

As per the attached Java source compilation results with ecj 4.5.2 and javac JDK 1.8.0_92 differ</thetext>
        <comment>
            <comment_id>2697569</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-21 06:32:28 -0400</when>
            <comment_text>Same behavior can be seen on master too.</comment_text>
        </comment>
        <comment>
            <comment_id>2697593</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-04-21 07:27:13 -0400</when>
            <comment_text>ecj reports:

----------
1. ERROR in /tmp/A.java (at line 19)
        return data.stream().map(rowMapper::map).collect(Collectors.toList());
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Type mismatch: cannot convert from List&lt;Row&lt;capture#1-of ? extends T&gt;&gt; to List&lt;Row&lt;T&gt;&gt;
----------
1 problem (1 error)


See also https://bugs.openjdk.java.net/browse/JDK-8016207</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492219</id>
        <developer>Marco Descher</developer>
        <developer_username>marco</developer_username>
        <dup_id/>
        <creation_time>2016-04-22 01:26:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Show compiler warning for method with Optional return value returning null</short_desc>
        <thetext>The following method should IMHO show a warning, if not even an error

	public Optional&lt;?&gt; method() {
		// someCode
		return null;
	}
	

It is clearly the intention of the coder, NOT to return null here. So there should be a warning (if not an Error) that return null is not the intended behaviour.</thetext>
        <comment>
            <comment_id>2698038</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-22 02:36:55 -0400</when>
            <comment_text>I don't know if I am missing something obvious, but what makes you think the method can't return null or that the user doesn't intend to return null?</comment_text>
        </comment>
        <comment>
            <comment_id>2698040</comment_id>
            <comment_count>2</comment_count>
            <who>Marco Descher</who>
            <commenter_username>marco</commenter_username>
            <when>2016-04-22 02:40:43 -0400</when>
            <comment_text>That the return value of this method is Optional&lt;?&gt;. Does this not express, that I am definitely not going for a possible null return value?

For me the Optional stuff is a design decision opposite to using possible null return values, guarding with @Nullable @NonNull annotations etc.</comment_text>
        </comment>
        <comment>
            <comment_id>2698070</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-22 04:39:58 -0400</when>
            <comment_text>Sorry, didn't notice you had marked this as enhancement. Let's see if we can take it up during 4.7.</comment_text>
        </comment>
        <comment>
            <comment_id>2698146</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-04-22 08:32:48 -0400</when>
            <comment_text>When using Optional I see two options for static analysis:

Full solution: If you want to achieve safety without using null annotations then *every* mention of null should be regarded as an error. All occurrences of null must be eliminated or replaced with Optional.empty().

Small solution: Every mention of Optional&lt;X&gt; is interpreted as '@NonNull Optional&lt;X&gt;' plus using an .eea to distinguish which operations of Optional accept/produce null vs. null-free operations.

Actually, a properly annotations type Optional should perfectly blend with @NonNullByDefault on each and every package.

Anything smaller than the "small solution" doesn't seem to make much sense to me. WDYT?</comment_text>
        </comment>
        <comment>
            <comment_id>2698163</comment_id>
            <comment_count>5</comment_count>
            <who>Marco Descher</who>
            <commenter_username>marco</commenter_username>
            <when>2016-04-22 08:56:02 -0400</when>
            <comment_text>Sounds very promising to me!

The full solution should IMHO be opt-in as otherwise the user might be irritated, no?

Do you think that the small solution should only be active if Null-Pointer Analysis is active, or should it be independent of this?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492287</id>
        <developer>Alex Blewitt</developer>
        <developer_username>alex.blewitt</developer_username>
        <dup_id/>
        <creation_time>2016-04-22 17:44:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Using StringBuffer.append(a + b) should generate a warning</short_desc>
        <thetext>There are a number of places in existing Java code that are written as:

import java.util.Date;
public class Test {
  public static void main(String args[]) throws Exception {
    StringBuffer buffer = new StringBuffer();
    buffer.append("foo" + new Date() + "bar");
  }
}

(see also bug 492230)

This will result in two StringBuffers being initialised; one to perform the implicit String concatenation, and the other initialised explicitly on the first line.

We should generate a warning when this occurs and offer a quick-fix to re-write this as:

buffer.append("foo").append(new Date()).append("bar");</thetext>
        <comment>
            <comment_id>2698444</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-04-23 02:14:42 -0400</when>
            <comment_text>Moving to JDT Core for consideration.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492365</id>
        <developer>Ahmed Ashour</developer>
        <developer_username>asashour</developer_username>
        <dup_id/>
        <creation_time>2016-04-25 08:50:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler][null] Wrong warning: "Potential null pointer access: The variable abc may be null at this location " with logical or</short_desc>
        <thetext>Build id: 20160218-0600

For the below code, I believe the second logical or (||) should not consider 'potential null pointer access'.


    public void test() {

        A a = null;

        if (Boolean.TRUE.equals(false)) {// this can be any condition
            a = new A();
        }

        if (a instanceof B) {
            System.out.println(a.toString()); // no warning here, which is fine
        }

        if (a instanceof B || a instanceof C) {
            System.out.println(a.toString()); // potential null pointer access: The variable a my be null at this location
        }
    }

    static class A {}

    static class B extends A {}
    static class C extends A {}</thetext>
        <comment>
            <comment_id>2699001</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-04-25 11:17:31 -0400</when>
            <comment_text>Thanks, I can reproduce (the variant in comment 0, adjusting the title accordingly :) ).</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492473</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-04-26 13:15:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][compiler] report error against clone() default method</short_desc>
        <thetext>Also ecj is affected by https://bugs.openjdk.java.net/browse/JDK-8154588 
which, however, doesn't yet have a Fix Version set.

When Srikanth fixes this in javac, we should do similarly for ecj.</thetext>
    </bug>
    <bug>
        <id>492671</id>
        <developer>arne anka</developer>
        <developer_username>eclipse-bugs</developer_username>
        <dup_id/>
        <creation_time>2016-04-28 12:15:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>frequent lagging apparently due to NPE in JavaSearchScope</short_desc>
        <thetext>while typing in a Java class in the JDT editor, i frequently experience annoying lags -- even though the file in question has only 163 lines.

checking the .log shows

!ENTRY org.eclipse.core.runtime 4 0 2016-04-28 17:44:41.793
!MESSAGE Invalid input url:platform:/plugin/org.eclipse.cdt.debug.ui/icons/obj16/exec_view_obj.gif
!STACK 0
java.io.IOException: Unable to resolve plug-in "platform:/plugin/org.eclipse.cdt.debug.ui/icons/obj16/exec_view_obj.gif".
        at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.parse(PlatformURLPluginConnection.java:65)
        at org.eclipse.core.internal.runtime.FindSupport.find(FindSupport.java:290)
        at org.eclipse.core.runtime.FileLocator.find(FileLocator.java:152)
        at org.eclipse.jface.resource.URLImageDescriptor.getFilePath(URLImageDescriptor.java:215)
        at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:283)
        at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:224)
        at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:202)
        at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImageFromURI(SWTPartRenderer.java:225)
        at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImage(SWTPartRenderer.java:236)
        at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.createTab(StackRenderer.java:877)
        at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.processContents(LazyStackRenderer.java:139)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
        at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
        at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:151)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
        at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
        at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:151)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
        at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
        at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:49)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
        at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
        at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer$1.handleEvent(LazyStackRenderer.java:72)
        at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
        at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:186)
        at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
        at org.eclipse.swt.widgets.Display.syncExec(Display.java:4633)
        at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
        at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
        at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197)
        at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
        at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
        at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
        at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
        at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
        at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
        at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
        at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:85)
        at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:59)
        at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
        at org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl.setSelectedElement(PerspectiveStackImpl.java:135)
        at org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl.setSelectedElement(PerspectiveStackImpl.java:1)
        at org.eclipse.ui.internal.WorkbenchPage.setPerspective(WorkbenchPage.java:4034)
        at org.eclipse.ui.internal.Workbench.activate(Workbench.java:3124)
        at org.eclipse.ui.internal.Workbench.showPerspective(Workbench.java:3146)
        at org.eclipse.ui.internal.Workbench.showPerspective(Workbench.java:3113)
        at org.eclipse.debug.internal.ui.launchConfigurations.PerspectiveManager.switchToPerspective(PerspectiveManager.java:390)
        at org.eclipse.debug.internal.ui.launchConfigurations.PerspectiveManager$4.runInUIThread(PerspectiveManager.java:471)
        at org.eclipse.debug.internal.ui.launchConfigurations.PerspectiveManager$MyUIJob$1.run(PerspectiveManager.java:229)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3794)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3433)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127)
        at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018)
        at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)
        at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:694)
        at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
        at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:606)
        at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
        at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139)
        at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
        at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
        at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)
        at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)
        at org.eclipse.equinox.launcher.Main.run(Main.java:1515)
        at org.eclipse.equinox.launcher.Main.main(Main.java:1488)

!ENTRY org.eclipse.jface 4 0 2016-04-28 17:44:41.794
!MESSAGE Unable to resolve plug-in "platform:/plugin/org.eclipse.cdt.debug.ui/icons/obj16/exec_view_obj.gif".
!STACK 0
java.io.IOException: Unable to resolve plug-in "platform:/plugin/org.eclipse.cdt.debug.ui/icons/obj16/exec_view_obj.gif".
        at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.parse(PlatformURLPluginConnection.java:65)
        at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.resolve(PlatformURLPluginConnection.java:77)
        at org.eclipse.core.internal.boot.PlatformURLHandler.openConnection(PlatformURLHandler.java:69)
        at org.eclipse.osgi.internal.url.URLStreamHandlerProxy.openConnection(URLStreamHandlerProxy.java:114)
        at java.net.URL.openConnection(URL.java:979)
        at org.eclipse.core.internal.runtime.PlatformURLConverter.toFileURL(PlatformURLConverter.java:34)
        at org.eclipse.core.runtime.FileLocator.toFileURL(FileLocator.java:207)
        at org.eclipse.jface.resource.URLImageDescriptor.getFilePath(URLImageDescriptor.java:219)
        at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:283)
        at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:224)
        at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:202)
        at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImageFromURI(SWTPartRenderer.java:225)
        at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImage(SWTPartRenderer.java:236)
        at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.createTab(StackRenderer.java:877)
        at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.processContents(LazyStackRenderer.java:139)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
        at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
        at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:151)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
        at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
        at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:151)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
        at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
        at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:49)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
        at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
        at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer$1.handleEvent(LazyStackRenderer.java:72)
        at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
        at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:186)
        at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
        at org.eclipse.swt.widgets.Display.syncExec(Display.java:4633)
        at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
        at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
        at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197)
        at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
        at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
        at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
        at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
        at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
        at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
        at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
        at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:85)
        at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:59)
        at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
        at org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl.setSelectedElement(PerspectiveStackImpl.java:135)
        at org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl.setSelectedElement(PerspectiveStackImpl.java:1)
        at org.eclipse.ui.internal.WorkbenchPage.setPerspective(WorkbenchPage.java:4034)
        at org.eclipse.ui.internal.Workbench.activate(Workbench.java:3124)
        at org.eclipse.ui.internal.Workbench.showPerspective(Workbench.java:3146)
        at org.eclipse.ui.internal.Workbench.showPerspective(Workbench.java:3113)
        at org.eclipse.debug.internal.ui.launchConfigurations.PerspectiveManager.switchToPerspective(PerspectiveManager.java:390)
        at org.eclipse.debug.internal.ui.launchConfigurations.PerspectiveManager$4.runInUIThread(PerspectiveManager.java:471)
        at org.eclipse.debug.internal.ui.launchConfigurations.PerspectiveManager$MyUIJob$1.run(PerspectiveManager.java:229)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3794)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3433)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127)
        at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018)
        at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)
        at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:694)
        at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
        at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:606)
        at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
        at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139)
        at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
        at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
        at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)
        at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)
        at org.eclipse.equinox.launcher.Main.run(Main.java:1515)
        at org.eclipse.equinox.launcher.Main.main(Main.java:1488)

!ENTRY org.eclipse.core.runtime 4 0 2016-04-28 17:44:41.794
!MESSAGE Invalid input url:platform:/plugin/org.eclipse.cdt.debug.ui/icons/obj16/exec_view_obj.gif
!STACK 0
java.io.IOException: Unable to resolve plug-in "platform:/plugin/org.eclipse.cdt.debug.ui/icons/obj16/exec_view_obj.gif".
        at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.parse(PlatformURLPluginConnection.java:65)
        at org.eclipse.core.internal.runtime.FindSupport.find(FindSupport.java:290)
        at org.eclipse.core.runtime.FileLocator.find(FileLocator.java:152)
        at org.eclipse.jface.resource.URLImageDescriptor.getStream(URLImageDescriptor.java:140)
        at org.eclipse.jface.resource.URLImageDescriptor.getImageData(URLImageDescriptor.java:105)
        at org.eclipse.jface.resource.URLImageDescriptor.getImageData(URLImageDescriptor.java:100)
        at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:270)
        at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:291)
        at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:224)
        at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:202)
        at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImageFromURI(SWTPartRenderer.java:225)
        at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImage(SWTPartRenderer.java:236)
        at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.createTab(StackRenderer.java:877)
        at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.processContents(LazyStackRenderer.java:139)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
        at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
        at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:151)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
        at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
        at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:151)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
        at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
        at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:49)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:654)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:746)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:717)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:711)
        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:695)
        at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
        at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer$1.handleEvent(LazyStackRenderer.java:72)
        at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
        at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:186)
        at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
        at org.eclipse.swt.widgets.Display.syncExec(Display.java:4633)
        at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
        at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
        at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197)
        at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
        at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
        at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
        at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
        at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
        at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
        at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
        at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:85)
        at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:59)
        at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
        at org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl.setSelectedElement(PerspectiveStackImpl.java:135)
        at org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl.setSelectedElement(PerspectiveStackImpl.java:1)
        at org.eclipse.ui.internal.WorkbenchPage.setPerspective(WorkbenchPage.java:4034)
        at org.eclipse.ui.internal.Workbench.activate(Workbench.java:3124)
        at org.eclipse.ui.internal.Workbench.showPerspective(Workbench.java:3146)
        at org.eclipse.ui.internal.Workbench.showPerspective(Workbench.java:3113)
        at org.eclipse.debug.internal.ui.launchConfigurations.PerspectiveManager.switchToPerspective(PerspectiveManager.java:390)
        at org.eclipse.debug.internal.ui.launchConfigurations.PerspectiveManager$4.runInUIThread(PerspectiveManager.java:471)
        at org.eclipse.debug.internal.ui.launchConfigurations.PerspectiveManager$MyUIJob$1.run(PerspectiveManager.java:229)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3794)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3433)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127)
        at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018)
        at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)
        at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:694)
        at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
        at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:606)
        at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
        at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139)
        at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
        at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
        at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)
        at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)
        at org.eclipse.equinox.launcher.Main.run(Main.java:1515)
        at org.eclipse.equinox.launcher.Main.main(Main.java:1488)

!ENTRY org.eclipse.jdt.ui 4 10001 2016-04-28 17:57:46.678
!MESSAGE Internal Error
!STACK 0
java.lang.NullPointerException
        at org.eclipse.jdt.internal.core.search.JavaSearchScope.getPath(JavaSearchScope.java:474)
        at org.eclipse.jdt.internal.core.search.JavaSearchScope.getPath(JavaSearchScope.java:490)
        at org.eclipse.jdt.internal.core.search.JavaSearchScope.getPath(JavaSearchScope.java:490)
        at org.eclipse.jdt.internal.core.search.JavaSearchScope.encloses(JavaSearchScope.java:463)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.encloses(MatchLocator.java:776)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2325)
        at org.eclipse.jdt.internal.core.search.matching.MemberDeclarationVisitor.visit(MemberDeclarationVisitor.java:214)
        at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.traverse(LambdaExpression.java:680)
        at org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse(MessageSend.java:1039)
        at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.traverse(ConstructorDeclaration.java:635)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2399)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2953)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2965)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2667)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1850)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1259)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1300)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1432)
        at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:122)
        at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232)
        at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516)
        at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584)
        at org.eclipse.jdt.internal.corext.callhierarchy.CallerMethodWrapper.findChildren(CallerMethodWrapper.java:155)
        at org.eclipse.jdt.internal.corext.callhierarchy.MethodWrapper.performSearch(MethodWrapper.java:302)
        at org.eclipse.jdt.internal.corext.callhierarchy.MethodWrapper.doFindChildren(MethodWrapper.java:233)
        at org.eclipse.jdt.internal.corext.callhierarchy.MethodWrapper.getCalls(MethodWrapper.java:85)
        at org.eclipse.jdt.internal.ui.callhierarchy.DeferredMethodWrapper.getCalls(DeferredMethodWrapper.java:65)
        at org.eclipse.jdt.internal.ui.callhierarchy.DeferredMethodWrapper.fetchDeferredChildren(DeferredMethodWrapper.java:79)
        at org.eclipse.ui.progress.DeferredTreeContentManager$1.run(DeferredTreeContentManager.java:232)
        at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 10001 2016-04-28 17:57:53.594
!MESSAGE Internal Error
!STACK 0
java.lang.NullPointerException
        at org.eclipse.jdt.internal.core.search.JavaSearchScope.getPath(JavaSearchScope.java:474)
        at org.eclipse.jdt.internal.core.search.JavaSearchScope.getPath(JavaSearchScope.java:490)
        at org.eclipse.jdt.internal.core.search.JavaSearchScope.getPath(JavaSearchScope.java:490)
        at org.eclipse.jdt.internal.core.search.JavaSearchScope.encloses(JavaSearchScope.java:463)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.encloses(MatchLocator.java:776)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2325)
        at org.eclipse.jdt.internal.core.search.matching.MemberDeclarationVisitor.visit(MemberDeclarationVisitor.java:214)
        at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.traverse(LambdaExpression.java:680)
        at org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse(MessageSend.java:1039)
        at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.traverse(ConstructorDeclaration.java:635)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2399)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2953)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2965)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2667)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1850)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1259)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1300)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1432)
        at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:122)
        at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232)
        at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516)
        at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584)
        at org.eclipse.jdt.internal.corext.callhierarchy.CallerMethodWrapper.findChildren(CallerMethodWrapper.java:155)
        at org.eclipse.jdt.internal.corext.callhierarchy.MethodWrapper.performSearch(MethodWrapper.java:302)
        at org.eclipse.jdt.internal.corext.callhierarchy.MethodWrapper.doFindChildren(MethodWrapper.java:233)
        at org.eclipse.jdt.internal.corext.callhierarchy.MethodWrapper.getCalls(MethodWrapper.java:85)
        at org.eclipse.jdt.internal.ui.callhierarchy.DeferredMethodWrapper.getCalls(DeferredMethodWrapper.java:65)
        at org.eclipse.jdt.internal.ui.callhierarchy.DeferredMethodWrapper.fetchDeferredChildren(DeferredMethodWrapper.java:79)
        at org.eclipse.ui.progress.DeferredTreeContentManager$1.run(DeferredTreeContentManager.java:232)
        at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)



why the CDT appears here, eludes me -- but i got used to CDT meddling everywhere no matter whether a CDT project is being edited or not (after all, those inexplicable Workbench rebuilds tend to suddenly open a CDT console which one get not rid of unless restarting eclipse).</thetext>
        <comment>
            <comment_id>2701065</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-04-28 12:25:08 -0400</when>
            <comment_text>Moving to JDT Core for the NPE:

java.lang.NullPointerException
        at org.eclipse.jdt.internal.core.search.JavaSearchScope.getPath(JavaSearchScope.java:474)
...</comment_text>
        </comment>
        <comment>
            <comment_id>2703496</comment_id>
            <comment_count>2</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-05-05 12:54:22 -0400</when>
            <comment_text>Can you provide a test case?</comment_text>
        </comment>
        <comment>
            <comment_id>2703667</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-06 04:44:38 -0400</when>
            <comment_text>The NPE looks to be caused by a broken Java element parent-child structure. But can't do much without a testcase.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492745</id>
        <developer>Wolfgang Zitzelsberger</developer>
        <developer_username>w.zitzelsberger</developer_username>
        <dup_id/>
        <creation_time>2016-04-29 15:02:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>JavaFX Modules/Packages not accessible/available</short_desc>
        <thetext>Using Build Y20160324-1000 with JDK9b111
When trying to add JavaFX classes they are not available for some reason. I.e. import javafx.application.Application; cannot be resolved.</thetext>
        <comment>
            <comment_id>2744569</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-29 06:11:07 -0400</when>
            <comment_text>This is probably same as bug 493761. Can you please try the work around (-addmods) that is suggested there?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492838</id>
        <developer>Michael Vorburger</developer>
        <developer_username>mike</developer_username>
        <dup_id/>
        <creation_time>2016-05-02 13:13:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][compiler][inference] method not applicable for arguments, goes away on simple refactor to local variable (in an expression which javac 1.8 allows)</short_desc>
        <thetext>This is a similar rant to my earlier bug 490001, but with an interesting twist:

Neon Milestone 6 (4.6.0M6) Build id: 20160329-0659 chokes on the following generics, in a project using Java 8 level, which works in javac because there is mvn CLI build which digs this, and IDEA according to other users:

this.substatements = ImmutableList.copyOf(Collections2.transform(substatementsToBuild, StmtContextUtils.buildEffective()));

saying: The method transform(Collection&lt;F&gt;, Function&lt;? super F,T&gt;) in the type Collections2 is not applicable for the arguments (Collection&lt;StatementContextBase&lt;?,?,?&gt;&gt;, Function&lt;StmtContext&lt;?,?,? extends EffectiveStatement&lt;?,?&gt;&gt;,EffectiveStatement&lt;?,?&gt;&gt;)

If interested, you should be to reproduce this in a complete WS quite easily, by using my https://github.com/vorburger/opendaylight-eclipse-setup and provisioning (just) the yangtools project.  Check out current git revision 31d5ed0c664e8fbd793538c4e4546204847c779e just to be sure we're talking about the same thing, and the error shown above will appear in line 94 of org.opendaylight.yangtools.yang-parser-impl/src/main/java/org/opendaylight/yangtools/yang/parser/stmt/rfc6020/effective/EffectiveStatementBase.java

Stephan I recall your "javac is known to have long standing bugs in this area, and reverse engineering these bugs will get us nowhere. The goal in implementing a Java compiler is to be compliant with JLS." from bug 490001, BUT here is the interesting twist on this one:

If you mark "StmtContextUtils.buildEffective()" and do a Refactor &gt; Extract Local Variable, it will turn the above into this below, and on this it doesn't choke anymore:

Function&lt;StmtContext&lt;?, ?, ? extends EffectiveStatement&lt;?, ?&gt;&gt;, EffectiveStatement&lt;?, ?&gt;&gt; buildEffective = StmtContextUtils.buildEffective();
this.substatements = ImmutableList.copyOf(Collections2.transform(substatementsToBuild, buildEffective));

My point being: If Refactoring "knows" about the correct (horrible...) generic here, shouldn't &amp; couldn't the type inference that's underlying the generics stuff be smart enough to also dig this, without requiring factoring out to an explicit variable ?

If there are other open bugs about this / something related to this, do link.  I had a look around but there are so many open generic related bugs (wow!) that it's hard to see what is what.


PS: I'll just be honest and just admit that I do actually understand this scary horrible looking generic - it's part of an API of a product I'm trying to get my head around (and haven't yet..).  From the little I understand, there are perhaps way too many &lt;?, ?, ?&gt; instead of &lt;? extends ...&gt; all over here? Thoughts welcome. Addressing this, project wide, is probably a major undertaking. Be that as it may, it would still seem "nice" if Eclipse would handle this code which javac &amp; IDEA do.</thetext>
        <comment>
            <comment_id>2701991</comment_id>
            <comment_count>1</comment_count>
            <who>Michael Vorburger</who>
            <commenter_username>mike</commenter_username>
            <when>2016-05-02 13:18:05 -0400</when>
            <comment_text>&gt; reproduce this in a complete WS quite easily (...)
&gt; Check out current git revision 31d5ed0c664e8fbd793538c4e4546204847c779e 

careful, https://git.opendaylight.org/gerrit/#/c/38289/ will work around this.</comment_text>
        </comment>
        <comment>
            <comment_id>2702076</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-02 16:34:04 -0400</when>
            <comment_text>(In reply to Michael Vorburger from comment #0)
&gt; Stephan I recall your "javac is known to have long standing bugs in this
&gt; area, and reverse engineering these bugs will get us nowhere. The goal in
&gt; implementing a Java compiler is to be compliant with JLS." from bug 490001,

thanks for the quotation, so I don't have to repeat myself :)

&gt; BUT here is the interesting twist on this one:
&gt; 
&gt; If you mark "StmtContextUtils.buildEffective()" and do a Refactor &gt; Extract
&gt; Local Variable, it will turn the above into this below, and on this it
&gt; doesn't choke anymore:
&gt; 
&gt; Function&lt;StmtContext&lt;?, ?, ? extends EffectiveStatement&lt;?, ?&gt;&gt;,
&gt; EffectiveStatement&lt;?, ?&gt;&gt; buildEffective = StmtContextUtils.buildEffective();
&gt; this.substatements =
&gt; ImmutableList.copyOf(Collections2.transform(substatementsToBuild,
&gt; buildEffective));

This may not be your main point, but: It is a known effect of Java 8 target typing, that additional type hints from declaring an intermediate local variable can push inference towards the intended solution, where otherwise it fails.
 
&gt; My point being: If Refactoring "knows" about the correct (horrible...)
&gt; generic here, shouldn't &amp; couldn't the type inference that's underlying the
&gt; generics stuff be smart enough to also dig this, without requiring factoring
&gt; out to an explicit variable ?

"could", yes, probably.

"should" is to be decided by JLS authors, not Eclipse committers.


This doesn't yet rule out that ecj has a bug here.
To prove a bug, it will require to demonstrate *how* exactly inference is supposed to find a valid solution based on JLS chap. 18. Unfortunately, such demonstration is a painfully complex task. Showing the opposite - that not finding a solution is correct - is even harder. Just saying ...</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492953</id>
        <developer>Juanma Arjona</developer>
        <developer_username>jmarjona</developer_username>
        <dup_id/>
        <creation_time>2016-05-04 03:56:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Type Hierarchy fails</short_desc>
        <thetext>Type Hierarchy fails and doesn't show superclasses and subclasses

-- Configuration Details --
Product: Eclipse 4.5.2.20160218-0600 (org.eclipse.epp.package.jee.product)
Installed Features:
 org.eclipse.jdt 3.11.2.v20160212-1500</thetext>
        <comment>
            <comment_id>2702777</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-04 04:52:39 -0400</when>
            <comment_text>Can you please provide more information on your problem? Does this happen on any specific project or source file? Do you see anything (such as exception traces) in the log file?</comment_text>
        </comment>
        <comment>
            <comment_id>2702801</comment_id>
            <comment_count>2</comment_count>
            <who>Juanma Arjona</who>
            <commenter_username>jmarjona</commenter_username>
            <when>2016-05-04 05:27:00 -0400</when>
            <comment_text>It happens all the time in all types with subtypes! It's perhaps a duplicate of bug 393192, but it still occurs in the latest version of Eclipse Mars.2 ...

There is no trace about that y the log file.

If I open the same project in the same workspace in Eclipse Helios, it works perfectly .. It's not a problem of the Project.</comment_text>
        </comment>
        <comment>
            <comment_id>2702814</comment_id>
            <comment_count>3</comment_count>
            <who>Juanma Arjona</who>
            <commenter_username>jmarjona</commenter_username>
            <when>2016-05-04 05:40:51 -0400</when>
            <comment_text>Created attachment 261450
Captures about the error</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492975</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-05-04 07:05:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[test][compiler] create a test infrastructure for running ecj standalone</short_desc>
        <thetext>Need a test infrastructure where the ecj standalone is used in the command line using the exported ecj.jar to mimic user scenarios
ref bug 492858 comment 4 for a possible case.</thetext>
    </bug>
    <bug>
        <id>493017</id>
        <developer>Pooja Kailay</developer>
        <developer_username>poojakailay</developer_username>
        <dup_id/>
        <creation_time>2016-05-04 13:10:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>NullPointerException at jdt.internal.compiler.ast.DoStatement</short_desc>
        <thetext>I get this error on the first line of a class definition at the package declaration line.

java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.DoStatement.doesNotCompleteNormally(DoStatement.java:235)
	at org.eclipse.jdt.internal.compiler.ast.Block.doesNotCompleteNormally(Block.java:158)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.analyzeShape(LambdaExpression.java:742)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isPotentiallyCompatibleWith(LambdaExpression.java:765)
	at org.eclipse.jdt.internal.compiler.lookup.ConstraintExpressionFormula.reduce(ConstraintExpressionFormula.java:61)
	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:844)
	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.reduce(InferenceContext18.java:857)
	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.solve(InferenceContext18.java:808)
	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod18(ParameterizedGenericMethodBinding.java:234)
	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:82)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:743)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2822)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:893)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:707)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:662)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
 
 
Session Data:
eclipse.buildId=4.5.0.I20150603-2000
java.version=1.8.0_91
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product
 
This is a continuation of log file 
Created Time: 2016-05-03 17:26:22.591</thetext>
        <comment>
            <comment_id>2703217</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-04 18:58:43 -0400</when>
            <comment_text>(In reply to Pooja Kailay from comment #0)
&gt; I get this error on the first line of a class definition at the package
&gt; declaration line.

that position only indicates we don't have a proper position for reporting.

Could you try to isolate a minimal source example that triggers this? Looking at the stack trace we basically know that we're looking for a lambda containing a do-while loop. Are you able to locate that in the affected class?</comment_text>
        </comment>
        <comment>
            <comment_id>2703352</comment_id>
            <comment_count>2</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-05-05 06:49:34 -0400</when>
            <comment_text>Possible duplicate of bug 470232 fixed in 4.6 and 4.5.1. Could you try with latest milestone of 4.6 or 4.5.2 to see if this error still occurs?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>493176</id>
        <developer>George Lindholm</developer>
        <developer_username>George.Lindholm</developer_username>
        <dup_id/>
        <creation_time>2016-05-06 19:57:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Error logged when file deleted</short_desc>
        <thetext>What steps will reproduce the problem?
1. Delete file
2. 
3. 


-- Error Details --
Date: Fri May 06 16:44:36 PDT 2016
Message: Could not move: W:\Perforce\lindholm\FEATURE_UPGRADE_JB\sis\libs\exact4j\src\test\java\com\exact\ews\exhaustive\UBCBaseTestCase.java.
Severity: Error
Product: Eclipse SDK 4.5.2.v20160212-1500 (org.eclipse.sdk.ide)
Plugin: org.eclipse.core.filesystem
Session Data:
eclipse.buildId=4.5.2.M20160212-1500
java.version=1.8.0_77
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -clean -data W:/workspace

This is a continuation of log file W:\workspace\.metadata\.bak_0.log
Created Time: 2016-05-06 16:44:36.252

Exception Stack Trace:
org.eclipse.core.runtime.CoreException: File not found: W:\Perforce\lindholm\FEATURE_UPGRADE_JB\sis\libs\exact4j\src\test\java\com\exact\ews\exhaustive\UBCBaseTestCase.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:49)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:391)
	at org.eclipse.core.filesystem.provider.FileStore.copyFile(FileStore.java:221)
	at org.eclipse.core.filesystem.provider.FileStore.copy(FileStore.java:144)
	at org.eclipse.core.internal.filesystem.local.LocalFile.copy(LocalFile.java:120)
	at org.eclipse.core.filesystem.provider.FileStore.move(FileStore.java:412)
	at org.eclipse.core.internal.filesystem.local.LocalFile.move(LocalFile.java:371)
	at org.eclipse.core.internal.localstore.BlobStore.addBlob(BlobStore.java:54)
	at org.eclipse.core.internal.localstore.HistoryStore2.addState(HistoryStore2.java:95)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:118)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:57)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:151)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:109)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:351)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:358)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:810)
	at com.perforce.team.ui.refactor.DeleteManager.delete(DeleteManager.java:109)
	at com.perforce.team.ui.refactor.MoveDeleteManager.deleteFolder(MoveDeleteManager.java:64)
	at org.eclipse.team.internal.core.MoveDeleteManager.deleteFolder(MoveDeleteManager.java:62)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1830)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:781)
	at org.eclipse.ltk.core.refactoring.resource.DeleteResourceChange.perform(DeleteResourceChange.java:168)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:278)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.access$0(DynamicValidationStateChange.java:1)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange$1.run(DynamicValidationStateChange.java:113)
	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2241)
	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5409)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.perform(DynamicValidationStateChange.java:116)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:278)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.access$0(DynamicValidationStateChange.java:1)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange$1.run(DynamicValidationStateChange.java:113)
	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2241)
	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5409)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.perform(DynamicValidationStateChange.java:116)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:278)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation$1.run(PerformChangeOperation.java:258)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2241)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:306)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:92)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:218)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2241)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:119)
Caused by: java.io.FileNotFoundException: W:\Perforce\lindholm\FEATURE_UPGRADE_JB\sis\libs\exact4j\src\test\java\com\exact\ews\exhaustive\UBCBaseTestCase.java (The system cannot find the file specified)
	at java.io.FileInputStream.open0(Native Method)
	at java.io.FileInputStream.open(FileInputStream.java:195)
	at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:382)
	... 53 more

-- Error Details --
Date: Fri May 06 16:44:36 PDT 2016
Message: File not found: W:\Perforce\lindholm\FEATURE_UPGRADE_JB\sis\libs\exact4j\src\test\java\com\exact\ews\exhaustive\UBCBaseTestCase.java.
Severity: Error
Product: Eclipse SDK 4.5.2.v20160212-1500 (org.eclipse.sdk.ide)
Plugin: org.eclipse.core.filesystem
Exception Stack Trace:
java.io.FileNotFoundException: W:\Perforce\lindholm\FEATURE_UPGRADE_JB\sis\libs\exact4j\src\test\java\com\exact\ews\exhaustive\UBCBaseTestCase.java (The system cannot find the file specified)
	at java.io.FileInputStream.open0(Native Method)
	at java.io.FileInputStream.open(FileInputStream.java:195)
	at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:382)
	at org.eclipse.core.filesystem.provider.FileStore.copyFile(FileStore.java:221)
	at org.eclipse.core.filesystem.provider.FileStore.copy(FileStore.java:144)
	at org.eclipse.core.internal.filesystem.local.LocalFile.copy(LocalFile.java:120)
	at org.eclipse.core.filesystem.provider.FileStore.move(FileStore.java:412)
	at org.eclipse.core.internal.filesystem.local.LocalFile.move(LocalFile.java:371)
	at org.eclipse.core.internal.localstore.BlobStore.addBlob(BlobStore.java:54)
	at org.eclipse.core.internal.localstore.HistoryStore2.addState(HistoryStore2.java:95)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:118)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.recursiveKeepHistory(DeleteVisitor.java:113)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:57)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:151)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:109)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:351)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:358)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:810)
	at com.perforce.team.ui.refactor.DeleteManager.delete(DeleteManager.java:109)
	at com.perforce.team.ui.refactor.MoveDeleteManager.deleteFolder(MoveDeleteManager.java:64)
	at org.eclipse.team.internal.core.MoveDeleteManager.deleteFolder(MoveDeleteManager.java:62)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1830)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:781)
	at org.eclipse.ltk.core.refactoring.resource.DeleteResourceChange.perform(DeleteResourceChange.java:168)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:278)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.access$0(DynamicValidationStateChange.java:1)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange$1.run(DynamicValidationStateChange.java:113)
	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2241)
	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5409)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.perform(DynamicValidationStateChange.java:116)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:278)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.access$0(DynamicValidationStateChange.java:1)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange$1.run(DynamicValidationStateChange.java:113)
	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2241)
	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5409)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.perform(DynamicValidationStateChange.java:116)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:278)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation$1.run(PerformChangeOperation.java:258)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2241)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:306)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:92)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:218)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2241)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:119)</thetext>
    </bug>
    <bug>
        <id>493433</id>
        <developer>Florian Lasinger</developer>
        <developer_username>florian</developer_username>
        <dup_id/>
        <creation_time>2016-05-11 10:10:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Call Hierarchy not showing callers when called via method reference and the method is defined in an interface</short_desc>
        <thetext>import java.util.stream.IntStream;
public class CallerHierarchyExample {
    interface Interface {
        void method(int i);
    }
    class Implementation implements Interface {
        public void method(int i) {}
    }
    void caller() {
        Interface pred = new Implementation();
        IntStream.range(0, 3).forEach(pred::method);
    }
}


Call Hierarchy on Implementation#method shows no callers.
Call Hierarchy on Interface#method shows caller() as single caller.
Refactorings work fine.


For me personally, this is a major issue because I will usually invoke the Call Hierarchy on the implementation and not on the interface.</thetext>
    </bug>
    <bug>
        <id>493969</id>
        <developer>alexander vladimirov</developer>
        <developer_username>alcobass</developer_username>
        <dup_id/>
        <creation_time>2016-05-19 01:46:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>"Organize imports" works incorrect after moving files on FS</short_desc>
        <thetext>file A is in package org.test.pack1
file B is using file A 

Then I move file A between packages (from pack1 to pack2) in mc, not in eclipse. 
Then I change package declaration of file A (package org.test.pack1 -&gt; package org.test.pack2), so file A doesn'r have errors
Then I press Control-Shift-O in file B, i still have "import org.test.pack1.A" instead of "import org.test.pack2.A"

If I manually remove "import org.test.pack1.A" from file B and then again organize imports, "import org.test.pack2.A" is added as expected, so the problem is for removing imports


-- Configuration Details --
Product: Eclipse 4.6.0.20160505-1302 (org.eclipse.epp.package.java.product)
Installed Features:
 org.eclipse.jdt 3.12.0.v20160428-0800</thetext>
    </bug>
    <bug>
        <id>494198</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-05-20 13:35:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>avoid unspec'd signature encoding in LVTT</short_desc>
        <thetext>As discussed in http://stackoverflow.com/questions/37268391/strange-entry-in-localvariabletypetable-when-compiling-with-eclipse-compile ecj emits an unexpected signature "!*" into a LocalVariableTypeTable when a local variable has a capture type.

Apparently, JVMS does not expect this situation, which, however, can easily occur in Java 8.

Either JVMS 4.7.14 [1] should distinguish real type variables from type variables representing a capture, as to exclude the latter from generating an LVTT entry. Note, that this would require recursive matching, because the capture could occur as a nested type argument.

Or JVMS 4.7.9.1 [2] should define an encoding for captures.

For the time being, ecj may want to avoid this contention one way or the other.

javac seems to go the former route, whereas ecj currently has its own encoding "!", which btw. was introduced during the initial update to Java 5.

[1] http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.14
[2] http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.9.1</thetext>
        <comment>
            <comment_id>2724790</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-28 07:11:11 -0400</when>
            <comment_text>*** Bug 496862 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
        <comment>
            <comment_id>2782430</comment_id>
            <comment_count>2</comment_count>
            <who>Juan Martín Sotuyo Dodero</who>
            <commenter_username>jmsotuyo</commenter_username>
            <when>2016-12-02 13:23:36 -0500</when>
            <comment_text>This issue is actually causing trouble with FindBugs / SpotBugs. Those tools parse the metadata to obtain generics info, but they parse it according to spec. The unspec'd signatures are right now producing an error, and even if ignored, would affect the quality of the reports.

Users of the FindBugs eclipse plugin are therefore having a hard time.

For instance, when using lambdas such as:

public interface HasUniqueKey&lt;Key&gt; {
  Key getInternId();
}

public class Util {
  public static List&lt;Integer&gt; toIntegerList(List&lt;? extends HasUniqueKey&lt;Integer&gt;&gt; entities) {
    return entities.stream().map(m -&gt; m.getInternId()).collect(Collectors.toList());
  }
}


The following errors occurred during analysis:
  Error parsing signature !+LHasUniqueKey&lt;Ljava/lang/Integer;&gt;;
    java.lang.IllegalStateException: Invalid method signature: '(!+LHasUniqueKey&lt;Ljava/lang/Integer;&gt;;)V' : !+LHasUniqueKey&lt;Ljava/lang/Integer;&gt;;)V 
      At edu.umd.cs.findbugs.ba.generic.GenericSignatureParser$ParameterSignatureIterator.next(GenericSignatureParser.java:120)
      At edu.umd.cs.findbugs.ba.generic.GenericSignatureParser$ParameterSignatureIterator.next(GenericSignatureParser.java:45)
      At edu.umd.cs.findbugs.ba.generic.GenericSignatureParser.getNumParameters(GenericSignatureParser.java:184)
      At edu.umd.cs.findbugs.ba.generic.GenericUtilities.getType(GenericUtilities.java:263)
      At edu.umd.cs.findbugs.ba.type.TypeFrameModelingVisitor.getLocalVariable(TypeFrameModelingVisitor.java:827)
      At edu.umd.cs.findbugs.ba.type.TypeFrameModelingVisitor.handleLoadInstruction(TypeFrameModelingVisitor.java:889)
      At edu.umd.cs.findbugs.ba.AbstractFrameModelingVisitor.visitALOAD(AbstractFrameModelingVisitor.java:452)
      At org.apache.bcel.generic.ALOAD.accept(ALOAD.java:56)
      At edu.umd.cs.findbugs.ba.AbstractFrameModelingVisitor.analyzeInstruction(AbstractFrameModelingVisitor.java:84)
      At edu.umd.cs.findbugs.ba.type.TypeFrameModelingVisitor.analyzeInstruction(TypeFrameModelingVisitor.java:197)
      At edu.umd.cs.findbugs.ba.type.TypeAnalysis.transferInstruction(TypeAnalysis.java:406)
      At edu.umd.cs.findbugs.ba.type.TypeAnalysis.transferInstruction(TypeAnalysis.java:86)
      At edu.umd.cs.findbugs.ba.AbstractDataflowAnalysis.transfer(AbstractDataflowAnalysis.java:135)
      At edu.umd.cs.findbugs.ba.type.TypeAnalysis.transfer(TypeAnalysis.java:414)
      At edu.umd.cs.findbugs.ba.type.TypeAnalysis.transfer(TypeAnalysis.java:86)
      At edu.umd.cs.findbugs.ba.Dataflow.execute(Dataflow.java:376)
      At edu.umd.cs.findbugs.classfile.engine.bcel.TypeDataflowFactory.analyze(TypeDataflowFactory.java:83)
      At edu.umd.cs.findbugs.classfile.engine.bcel.TypeDataflowFactory.analyze(TypeDataflowFactory.java:43)
      At edu.umd.cs.findbugs.classfile.impl.AnalysisCache.analyzeMethod(AnalysisCache.java:369)
      At edu.umd.cs.findbugs.classfile.impl.AnalysisCache.getMethodAnalysis(AnalysisCache.java:322)
      At edu.umd.cs.findbugs.classfile.engine.bcel.CFGFactory.analyze(CFGFactory.java:160)
      At edu.umd.cs.findbugs.classfile.engine.bcel.CFGFactory.analyze(CFGFactory.java:65)
      At edu.umd.cs.findbugs.classfile.impl.AnalysisCache.analyzeMethod(AnalysisCache.java:369)
      At edu.umd.cs.findbugs.classfile.impl.AnalysisCache.getMethodAnalysis(AnalysisCache.java:322)
      At edu.umd.cs.findbugs.ba.ClassContext.getMethodAnalysis(ClassContext.java:1005)
      At edu.umd.cs.findbugs.ba.ClassContext.getMethodAnalysisNoDataflowAnalysisException(ClassContext.java:990)
      At edu.umd.cs.findbugs.ba.ClassContext.getCFG(ClassContext.java:303)
      At edu.umd.cs.findbugs.detect.BuildNonnullReturnDatabase.analyzeMethod(BuildNonnullReturnDatabase.java:87)
      At edu.umd.cs.findbugs.detect.BuildNonnullReturnDatabase.considerMethod(BuildNonnullReturnDatabase.java:76)
      At edu.umd.cs.findbugs.detect.BuildNonnullReturnDatabase.visitClassContext(BuildNonnullReturnDatabase.java:67)
      At edu.umd.cs.findbugs.DetectorToDetector2Adapter.visitClass(DetectorToDetector2Adapter.java:76)
      At edu.umd.cs.findbugs.FindBugs2.analyzeApplication(FindBugs2.java:1089)
      At edu.umd.cs.findbugs.FindBugs2.execute(FindBugs2.java:283)
      At edu.umd.cs.findbugs.gui2.BugLoader.doAnalysis(BugLoader.java:101)
      At edu.umd.cs.findbugs.gui2.AnalyzingDialog$AnalysisThread.run(AnalyzingDialog.java:275)</comment_text>
        </comment>
        <comment>
            <comment_id>2782434</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-02 13:33:17 -0500</when>
            <comment_text>(In reply to Juan Martín Sotuyo Dodero from comment #2)
&gt; This issue is actually causing trouble with FindBugs / SpotBugs. Those tools
&gt; parse the metadata to obtain generics info, but they parse it according to
&gt; spec. The unspec'd signatures are right now producing an error, and even if
&gt; ignored, would affect the quality of the reports.

Yes, I planned to address this for 4.7, but be warned: I already put more an my plate than I will be able to chew :(

Until this is fixed in Eclipse by skipping the unspecified situation, FindBugs could do the same: when encountering the unspecified signature just ignore the entry.</comment_text>
        </comment>
        <comment>
            <comment_id>2782438</comment_id>
            <comment_count>4</comment_count>
            <who>Juan Martín Sotuyo Dodero</who>
            <commenter_username>jmsotuyo</commenter_username>
            <when>2016-12-02 13:46:47 -0500</when>
            <comment_text>That's our plan for SpotBugs. We will skip it silently for backwards compatibility. Still it's a great news that you are planning to address it so soon.

I really hope you are able to ship it.

Thanks for your effort.</comment_text>
        </comment>
        <comment>
            <comment_id>2782514</comment_id>
            <comment_count>5</comment_count>
            <who>Andrey Loskutov</who>
            <commenter_username>loskutov</commenter_username>
            <when>2016-12-02 17:36:37 -0500</when>
            <comment_text>I think this is not an enhancement, more a bug?</comment_text>
        </comment>
        <comment>
            <comment_id>2782518</comment_id>
            <comment_count>6</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-02 17:58:33 -0500</when>
            <comment_text>(In reply to Andrey Loskutov from comment #5)
&gt; I think this is not an enhancement, more a bug?

With all due respect: no :)

We just filled a gap in JVMS with one implementation option that is more unfortunate for downstream projects than other options would be.

JVMS requests that we generate an entry, but it doesn't define an encoding for it.

We will replace our unfortunate implementation with one that is obviously a "bug", but doesn't cause harm.

Calling the current state a "Bug" would say: JVMS told us to do differently, but it doesn't.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>494204</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-05-20 15:00:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Various exceptions caused by incomplete switch statement</short_desc>
        <thetext>I was reducing a class that triggered StackOverflowError and while doing so, the exception changed from SOE to NPE to ArrayStoreException.

Here's the minimal version:
//---
interface IStatus {
	int getSeverity();
}
interface ILog {
	void log(IStatus status);
}
public class C {
    private static ILog test() {
        return new ILog() {
            @Override
            public void log(IStatus status) {
                switch (status.getSeverity()) { // here
                case
                }
            }
        };
    }
}

//---

hovering over "getSeverity()" results in:

java.lang.ArrayStoreException
	at java.lang.System.arraycopy(Native Method)
	at org.eclipse.jdt.internal.codeassist.select.SelectionParser.buildMoreCompletionContext(SelectionParser.java:148)
	at org.eclipse.jdt.internal.codeassist.select.SelectionParser.attachOrphanCompletionNode(SelectionParser.java:114)
	at org.eclipse.jdt.internal.codeassist.select.SelectionParser.updateRecoveryState(SelectionParser.java:1546)
	at org.eclipse.jdt.internal.compiler.parser.Parser.resumeOnSyntaxError(Parser.java:12420)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11047)
	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.parseBlockStatements(AssistParser.java:1713)
	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.parseBlockStatements(AssistParser.java:1551)
	at org.eclipse.jdt.internal.codeassist.impl.Engine.parseBlockStatements(Engine.java:340)
	at org.eclipse.jdt.internal.codeassist.impl.Engine.parseBlockStatements(Engine.java:303)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:981)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:163)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:377)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:371)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:121)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:631)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:627)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)</thetext>
        <comment>
            <comment_id>2710293</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-20 15:04:03 -0400</when>
            <comment_text>Slightly extended version:

//---

interface IStatus {
	int getSeverity();
	int OK = 0;
}
interface ILog {
	void log(IStatus status);
}
public class C {
    private static ILog test() {
        return new ILog() {
            @Override
            public void log(IStatus status) {
                int severity = IStatus.OK;
                switch (status.getSeverity()) { // here
                case
                }
            }
            
        };
    }
}
// ---

again hovering on getSeverity() gives now (same as bug 472572?) :

java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor0(Scope.java:2355)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor(Scope.java:2336)
	at org.eclipse.jdt.internal.compiler.ast.Statement.findConstructorBinding(Statement.java:440)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveTypeForQualifiedAllocationExpression(QualifiedAllocationExpression.java:566)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveType(QualifiedAllocationExpression.java:287)
	at org.eclipse.jdt.internal.compiler.ast.SwitchStatement.resolve(SwitchStatement.java:467)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1276)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveTypeForQualifiedAllocationExpression(QualifiedAllocationExpression.java:502)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveType(QualifiedAllocationExpression.java:287)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:986)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:163)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:377)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:371)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:121)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:631)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:627)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)</comment_text>
        </comment>
        <comment>
            <comment_id>2710319</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-20 15:46:26 -0400</when>
            <comment_text>It seems the common root cause is the following cyclic AST structure:

MethodDeclaration ("test")
+ statements[0] = QualifiedAllocationExpression (id=42)
  + anonymousType
    + methods[0] = MethodDeclaration("log")
      + statements[1] = SwitchStatement
        + expression = QualifiedAllocationExpression (id=42)

This was taken from a comment 1.

With comment 0 we don't even get that far, as the parser itself already falls over its broken stack structure.

I currently can't reproduce the SOE, but given this AST structure, SOE is the only thing that does *not* surprise me :p</comment_text>
        </comment>
        <comment>
            <comment_id>2710321</comment_id>
            <comment_count>3</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-05-20 15:50:32 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/73328</comment_text>
        </comment>
        <comment>
            <comment_id>2710327</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-20 16:02:38 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #3)
&gt; New Gerrit change created: https://git.eclipse.org/r/73328

Tests witnessing the ArrayStoreException, NPE, and the underlying mess in parser stacks.</comment_text>
        </comment>
        <comment>
            <comment_id>2710330</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-20 16:10:07 -0400</when>
            <comment_text>*** Bug 472572 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
    </bug>
    <bug>
        <id>494209</id>
        <developer>Raffi Khatchadourian</developer>
        <developer_username>raffi.khatchadourian</developer_username>
        <dup_id/>
        <creation_time>2016-05-20 15:45:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>org.eclipse.jdt.core.IType.resolveType(String) could support array types</short_desc>
        <thetext>Suppose B is a resolvable type in type A. Suppose aType is the IType instance for A. Then, aType.resolveType("B") returns non-null. However, aType.resolveType("B[]") returns null. Technically, if B is resolvable in A, then I should be able to declare an array of type B in A. As such, aType.resolveType("B[]") should return a non-null value.

-- Configuration Details --
Product: Eclipse 4.5.2.20160218-0600 (org.eclipse.epp.package.committers.product)
Installed Features:
 org.eclipse.jdt 3.11.2.v20160212-1500</thetext>
        <comment>
            <comment_id>2710326</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-20 16:01:13 -0400</when>
            <comment_text>I changed the title to better match the classification as an enhancement, because the contract of IType.resolveType(String) makes no promise about handling array types. "B[]" should not be considered as a type name. "[]" is a type constructor, which, applied to "B", creates a new type.

I don't think that this request fits well into the given API, I can't even see a good way how a resolved type for "B[]" could be answered as String[][].
So you shouldn't hold your breath waiting for this to be implemented.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>494215</id>
        <developer>Sergey Prigogin</developer>
        <developer_username>eclipse.sprigogin</developer_username>
        <dup_id/>
        <creation_time>2016-05-20 21:44:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Bogus Javadoc warning for a package protected class</short_desc>
        <thetext>To reproduce create a package protected class with a link to its method in Javadoc:

/**
 * {@link #method()} - Bogus warning: Javadoc: 'protected' visibility for malformed doc comments hides this 'default' reference
 */
class A {
    public void method() {}
}</thetext>
    </bug>
    <bug>
        <id>494225</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-05-21 06:01:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Entries in LVT and LVTT missing for unused locals inside lambda</short_desc>
        <thetext>If a local variable inside a lambda is unused, even when compiling with -g and -preserveAllLocals, no entries are generated into LocalVariableTable and LocalVariableTypeTable</thetext>
        <comment>
            <comment_id>2710434</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-05-21 06:18:38 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/73347</comment_text>
        </comment>
        <comment>
            <comment_id>2710435</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-21 06:20:07 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #1)
&gt; New Gerrit change created: https://git.eclipse.org/r/73347

Failing test

Interestingly, LVT is generated for the first of two unused locals, but not for the last. Additionally pc positions are slightly of for those unused locals.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>494226</id>
        <developer>Olivier Cailloux</developer>
        <developer_username>olivier.cailloux</developer_username>
        <dup_id/>
        <creation_time>2016-05-21 06:26:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][inference] Wrong generic method type inferred with return and own interface</short_desc>
        <thetext>This code shows an error in eclipse at "return getMyPar1()". eclipse says "Type mismatch: cannot convert from Test.MyPar&lt;capture#2-of ? extends Object&gt; to Test.MyPar&lt;? extends V&gt;".

---
public class Test {
	static public interface MyPar&lt;V&gt; {
		// nothing
	}
	public &lt;V&gt; MyPar&lt;? extends V&gt; getMyPar1() {
		return null;
	}
	public &lt;V&gt; MyPar&lt;? extends V&gt; getMyPar2() {
		return getMyPar1();

	}
}
---

Interestingly, the following code shows no error.

---
import java.util.Set;

public class TestWithSet {
	public &lt;V&gt; Set&lt;? extends V&gt; getSet1() {
		return null;
	}
	public &lt;V&gt; Set&lt;? extends V&gt; getSet2() {
		return getSet1();

	}
}
---</thetext>
        <comment>
            <comment_id>2710437</comment_id>
            <comment_count>1</comment_count>
            <who>Olivier Cailloux</who>
            <commenter_username>olivier.cailloux</commenter_username>
            <when>2016-05-21 06:31:28 -0400</when>
            <comment_text>Tested with 4.5.0 and 4.5.2.</comment_text>
        </comment>
        <comment>
            <comment_id>2710438</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-21 06:45:55 -0400</when>
            <comment_text>Thanks, I can reproduce and the difference between the two examples is suspicious, indeed.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>494718</id>
        <developer>Paul Crockett</developer>
        <developer_username>paulcrockettuk</developer_username>
        <dup_id/>
        <creation_time>2016-05-27 04:14:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>NPE in Scope.getMethod while compiling Java</short_desc>
        <thetext>Created attachment 262049
Debug output and error event details

I believe I am experiencing the same, or at least very similar, bug as reported here: https://bugs.eclipse.org/bugs/show_bug.cgi?id=490636


Error event details:

Errors running builder 'Java Builder' on project 'report'.

java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2816)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isPotentiallyCompatibleWith(ReferenceExpression.java:1003)
	at org.eclipse.jdt.internal.compiler.lookup.ConstraintExpressionFormula.reduce(ConstraintExpressionFormula.java:61)


eclipse.buildId=4.5.2.M20160212-1500
java.version=1.8.0_77
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_GB
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product -debug


I have captured the debug output as described, but it doesn't show the NPE so I'm not sure how you can work out which class triggers the exception.

The NPE occurs quite frequently, and always on the same project (report) with the same stack trace. The build still completes successfully after the exception, so the error is mostly just an annoyance.

The error usually occurs when a build is performed after I switch branches in git, or another project is opened or closed. It does not occur when I do a clean and rebuild.

The attached file contains the eclipse debug output, plus the error event details appended at the end.</thetext>
        <comment>
            <comment_id>2720199</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-14 04:28:34 -0400</when>
            <comment_text>Like I said in bug 490636 comment #3, you could try the tracing on. Without what source is causing this, it is difficult to make progress on this.</comment_text>
        </comment>
        <comment>
            <comment_id>2720332</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-14 08:33:49 -0400</when>
            <comment_text>From the stack trace in the attachment I see (ignoring a line number offset of 2 at Scope.java:2816, should be 2814):

RE.isPotentiallyCompatibleWith() is probably called before resolveType(). If resolveType() would have produced a null this.receiverType, this would have caused an NPE already there (against lhs before the assignment).

I assume the line number offset is caused by using the groovy variant of JDT/Core. This could potentially imply, that some relevant fixes from JDT are not present in your installation.

@Jay, did you see the tracing output in attachment 262049? Is that not what you expected following bug 490636 comment #3? Unfortunately, the tracing output includes no timestamps, otherwise we might have guessed where in the sequence of events the NPE happened, since we do have the timestamp of the NPE.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495317</id>
        <developer>Raffi Khatchadourian</developer>
        <developer_username>raffi.khatchadourian</developer_username>
        <dup_id/>
        <creation_time>2016-06-02 11:43:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Have org.eclipse.jdt.core.dom.ASTNode.copySubtree(AST, ASTNode) copy bindings</short_desc>
        <thetext>I have noticed that org.eclipse.jdt.core.dom.ASTNode.copySubtree(AST, ASTNode) does not copy bindings from the source ASTNode in the cast that the source AST was built using bindings. This is an enhancement request to copy over bindings as well as the subtree structure.


-- Configuration Details --
Product: Eclipse 4.5.2.20160218-0600 (org.eclipse.epp.package.committers.product)
Installed Features:
 org.eclipse.jdt 3.11.2.v20160212-1500</thetext>
    </bug>
    <bug>
        <id>495439</id>
        <developer>Raffi Khatchadourian</developer>
        <developer_username>raffi.khatchadourian</developer_username>
        <dup_id/>
        <creation_time>2016-06-03 16:51:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.canBeAccessedFrom(IMember, IType, ITypeHierarchy) contains incorrect stub check</short_desc>
        <thetext>The method org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.canBeAccessedFrom(IMember, IType, ITypeHierarchy) checks if a stub exists that corresponds to the given IMember:

if (member instanceof IMethod) {
				final IMethod method = (IMethod) member;
				final IMethod stub = target.getMethod(method.getElementName(), method.getParameterTypes());
				if (stub.exists())
					return true;
					
However, the code that looks up the stub in the target naively assumes that the receiver of the method is of the target type. However, the receiver can be any type, or, it could even be a static method. For example, a static method defined in a different type with the same name and parameters would pass as a stub when it actually isn't.

					

-- Configuration Details --
Product: Eclipse 4.5.2.20160218-0600 (org.eclipse.epp.package.committers.product)
Installed Features:
 org.eclipse.jdt 3.11.2.v20160212-1500</thetext>
    </bug>
    <bug>
        <id>495560</id>
        <developer>Raffi Khatchadourian</developer>
        <developer_username>raffi.khatchadourian</developer_username>
        <dup_id/>
        <creation_time>2016-06-06 15:21:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Searching for references to method java.util.EventListenerProxy.getListener() in java.awt.event.AWTEventListenerProxy.eventDispatched(AWTEvent) returns no results</short_desc>
        <thetext>I am using the SearchEngine API to search for references to the method java.util.EventListenerProxy.getListener() within the scope of method java.awt.event.AWTEventListenerProxy.eventDispatched(AWTEvent). This method, i.e., eventDispatched(AWTEvent) in Java 8, has a single call to getListener(), but, somehow, the match never gets accepted. I have included some debugging information below:

Pattern: MethodReferencePattern: java.util.eventlistenerproxy.getlistener() --&gt; t, exact match, case insensitive, generic full match, fine grain: none
Scope: JavaSearchScope on [
	eventDispatched(AWTEvent) {key=Ljava/awt/event/AWTEventListenerProxy;.eventDispatched(Ljava/awt/AWTEvent;)V} [in AWTEventListenerProxy [in [Working copy] AWTEventListenerProxy.java [in java.awt.event [in src [in java8]]]]]
]

I believe that the problem is in the MatchLocator ctor. The sourceType.getOuterMostLocalContext() returns null for source type: class EventListenerProxy.

-- Configuration Details --
Product: Eclipse 4.5.2.20160218-0600 (org.eclipse.epp.package.committers.product)
Installed Features:
 org.eclipse.jdt 3.11.2.v20160212-1500</thetext>
        <comment>
            <comment_id>2717687</comment_id>
            <comment_count>1</comment_count>
            <who>Raffi Khatchadourian</who>
            <commenter_username>raffi.khatchadourian</commenter_username>
            <when>2016-06-06 15:22:55 -0400</when>
            <comment_text>As a regression, when I do the search manually from the IDE (i.e., using the search dialog), I cannot set the scope to a single method (as far as I know). I set it to the enclosing project, and it seems to work.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495563</id>
        <developer>Raffi Khatchadourian</developer>
        <developer_username>raffi.khatchadourian</developer_username>
        <dup_id/>
        <creation_time>2016-06-06 15:52:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Array creation reference AST (CreationReference) nodes are not resolving method bindings</short_desc>
        <thetext>I am unable to resolve the method binding for CreationReference nodes that correspond to array creation references even for ASTs for which bindings are resolved. For example, suppose that `reference` refers to the array creation reference node representing int[]::new:

CreationReference reference = (CreationReference) node;
IMethodBinding binding = reference.resolveMethodBinding();

Here, binding will be null even though I have requested that the AST resolve bindings.

-- Configuration Details --
Product: Eclipse 4.5.2.20160218-0600 (org.eclipse.epp.package.committers.product)
Installed Features:
 org.eclipse.jdt 3.11.2.v20160212-1500</thetext>
    </bug>
    <bug>
        <id>495570</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-06-07 01:50:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] Include since() attribute of @Deprecated in error reporting</short_desc>
        <thetext>A new attribute, since(), has been added to @Deprecated in Java 9. This indicates since when a program element is deprecated. It would be nice to include this in the analysis.

A case in example is the usage or "new Integer()" etc. Now that these constructors have been deprecated in Java 9 all such cases are reported regardless of the compliance.</thetext>
    </bug>
    <bug>
        <id>495689</id>
        <developer>glenn cheng</developer>
        <developer_username>yachingcheng</developer_username>
        <dup_id/>
        <creation_time>2016-06-08 09:13:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>memory leak, cpu utilization high, STOP button in console window stay red all the time</short_desc>
        <thetext>Running on Ubuntu 16.04 with 16GB ram. 8x Intel Core, i7-6700 CPU @ 3.4GHz.
java version "1.8.0_92"
Java(TM) SE Runtime Environment (build 1.8.0_92-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.92-b14, mixed mode)

 
report by command top

Eclipse Mars 2 - 4.5.2 IDE running by itself without open any file uses average 52% - 60% CPU. MEM% increase from 3.2% to 4.0% in one hour. Come back from weekend it used up 96% memory. STOP button in console windows stays RED all the time.

compare with earlier version Luna

Eclipse Luna service release - 4.4.2 IDE running by itself without open any file uses average 0.3% - 0.7% CPU. MEM% increase from 2.8% to 3% in twenty four hours.</thetext>
        <comment>
            <comment_id>2719177</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-10 00:41:31 -0400</when>
            <comment_text>Hi, is this plain Eclipse that you have or have you installed any other plugins? Are you in a position to do run it with some profiling and see where the memory goes?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495760</id>
        <developer>Jacob Fancher</developer>
        <developer_username>fancher.jacob</developer_username>
        <dup_id/>
        <creation_time>2016-06-08 18:38:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][inference] Inference fails to determine method call result type when mixing raw and generic types</short_desc>
        <thetext>I see there are a lot of similar bugs, so this may be a duplicate. I could not find one documenting this precise issue though.

Say you have this method:

static &lt;T&gt; T[] toArray(Iterable&lt;? extends T&gt; i, Class&lt;T&gt; c) {
  return null;
}

The following does not compile:

String s = toArray(new ArrayList(), String.class)[0];

This does work, however:

String[] arr = toArray(new ArrayList(), String.class)

Of course, it also works if you parameterize the ArrayList constructor call or the toArray call itself.

The provided reproducer compiles successfully in:
4.6 with Source Level 1.7
4.5.2
4.4
javac 1.8.0_11</thetext>
        <comment>
            <comment_id>2719137</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-09 18:42:05 -0400</when>
            <comment_text>At first look JDT's answers look correct to me, because:

(1) Inference of the first toArray() invocation requires unchecked conversions, hence the result type is erased to Object[]. Dereference into the array yields Object -&gt; not compatible with String. Note that toArray() is treated as a standalone expression here, due to the array dereference.

(2) Inference of the second toArray() invocation is inferred using target type "String[]", which is found to be solvable. -&gt; No error.

I recently got the impression, that perhaps (2) should also be a reject, because inference success doesn't necessarily say that the solution is valid(?).

As you mention that javac accepts these, we should sift through recent javac bugs; I seem to recall s.t. mentioning the erasure rule that applies here.</comment_text>
        </comment>
        <comment>
            <comment_id>2719628</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-11 08:27:18 -0400</when>
            <comment_text>This is the result of inference:

Type Bounds:
	TypeBound  T#0 = java.lang.String

Inference did use unchecked conversion, so the following applies (JLS 18.5.2):

"If unchecked conversion was necessary for the method to be applicable during constraint set reduction in §18.5.1, then the parameter types of the invocation type of m are obtained by applying θ' to the parameter types of m's type, and the return type and thrown types of the invocation type of m are given by the erasure of the return type and thrown types of m's type."

m: T[] toArray(Iterable&lt;? extends T&gt;, Class&lt;T&gt;) 
m's return type: T[]
erasure of m's return type: Object[]

Ergo: "toArray(..)[0]" has type Object, which is not compatible with String.


The fact that javac accepts this is explained by https://bugs.openjdk.java.net/browse/JDK-8135087
In that JDK bug, Dan discusses the fact that this is a longstanding bug in javac, the option to instead change the JLS and the dangers such a change would bring. The JDK bug is currently targeted at version 9, so perhaps we will see some movement in the next few months.</comment_text>
        </comment>
        <comment>
            <comment_id>2719629</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-11 08:32:03 -0400</when>
            <comment_text>Here's one more twist:

For the example 
    String[] arr = toArray(new ArrayList(), String.class)
invocation type inference actually fails. So this should be rejected, too.

Inference indeed produces a ProblemMethodBinding.
Only when about to report this problem, it is silently ignored inside ProblemReporter.invalidMethod(). This return was added on behalf of bug 437444 and carries a reference to GRT1_8.testBug430296.

For consistent behavior, this should be changed to actually reporting the error. While improving consistency of ecj and compatibility of ecj with JLS, this would increase the gap between javac and ecj. I'm putting this on hold to wait if javac will be fixed in this area any time soon (= well within our 4.7 time frame).</comment_text>
        </comment>
        <comment>
            <comment_id>2757336</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-29 11:48:21 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #2)
&gt; The fact that javac accepts this is explained by
&gt; https://bugs.openjdk.java.net/browse/JDK-8135087
&gt; In that JDK bug, Dan discusses the fact that this is a longstanding bug in
&gt; javac, the option to instead change the JLS and the dangers such a change
&gt; would bring. The JDK bug is currently targeted at version 9, so perhaps we
&gt; will see some movement in the next few months.

On 2016-09-01 this was changed fix version 9 to tbd_major.

Could be related to the fact that originally that was the cut-off date for Java 9 (before further deferral).</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495767</id>
        <developer>Niraj Modi</developer>
        <developer_username>niraj.modi</developer_username>
        <dup_id/>
        <creation_time>2016-06-09 02:32:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[Windows] Exception with latest YBuild with IBM Java 9</short_desc>
        <thetext>Created attachment 262329
Win64_Eclipse_YBuild_IBM_JDK9_Error

Steps to reproduce:
1. Download below YBuild, I tried Windows 64 bit build:
http://download.eclipse.org/eclipse/downloads/drops4/Y20160513-1000/

2. Specify below IBM JDK9 as JRE for your Java project:
ibm-java-sdk-ea-90-win-x86_64

3. An error dialog popup with below message:
An internal error has occurred during: "Initializing Java Tooling"
(Refer attachment)

4. Could see below exception trace in the logs:
!ENTRY org.eclipse.core.jobs 4 2 2016-06-09 11:55:22.060
!MESSAGE An internal error occurred during: "Initializing Java Tooling".
!STACK 0
java.nio.file.FileSystemNotFoundException: C:\1_Eclipse\_Setups\ibm-java-sdk-ea-90-win-x86_64\sdk\lib\ext\lib\modules\bootmodules.jimage
	at jdk.internal.jrtfs.JrtFileSystem.checkExists(JrtFileSystem.java:87)
	at jdk.internal.jrtfs.JrtFileSystem.&lt;init&gt;(JrtFileSystem.java:102)
	at jdk.internal.jrtfs.JrtFileSystemProvider.newFileSystem(JrtFileSystemProvider.java:85)
	at java.nio.file.FileSystems.newFileSystem(Unknown Source)
	at org.eclipse.jdt.internal.compiler.util.JrtFileSystem.initialize(JRTUtil.java:187)
	at org.eclipse.jdt.internal.compiler.util.JrtFileSystem.&lt;init&gt;(JRTUtil.java:172)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(JRTUtil.java:115)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:144)
	at org.eclipse.jdt.internal.core.JavaProject.loadModulesInJimage(JavaProject.java:707)
	at org.eclipse.jdt.internal.core.JavaProject.computePackageFragmentRoots(JavaProject.java:630)
	at org.eclipse.jdt.internal.core.JavaProject.computePackageFragmentRoots(JavaProject.java:785)
	at org.eclipse.jdt.internal.core.JavaProject.computePackageFragmentRoots(JavaProject.java:749)
	at org.eclipse.jdt.internal.core.JavaProject.buildStructure(JavaProject.java:474)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.Openable.openAncestors(Openable.java:505)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:241)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:316)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:302)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.getKind(PackageFragmentRoot.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.validateCompilationUnit(CompilationUnit.java:1046)
	at org.eclipse.jdt.internal.core.CompilationUnit.validateExistence(CompilationUnit.java:1340)
	at org.eclipse.jdt.internal.core.Openable.exists(Openable.java:207)
	at org.eclipse.jdt.internal.corext.util.OpenTypeHistory.getContainerTimestamp(OpenTypeHistory.java:349)
	at org.eclipse.jdt.internal.corext.util.OpenTypeHistory.internalCheckConsistency(OpenTypeHistory.java:309)
	at org.eclipse.jdt.internal.corext.util.OpenTypeHistory.checkConsistency(OpenTypeHistory.java:239)
	at org.eclipse.jdt.internal.ui.JavaPlugin.initializeAfterLoad(JavaPlugin.java:424)
	at org.eclipse.jdt.internal.ui.InitializeAfterLoadJob$RealJob.run(InitializeAfterLoadJob.java:37)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)</thetext>
        <comment>
            <comment_id>2718733</comment_id>
            <comment_count>1</comment_count>
            <who>Niraj Modi</who>
            <commenter_username>niraj.modi</commenter_username>
            <when>2016-06-09 02:35:56 -0400</when>
            <comment_text>Possible reason for failure:
It seems the locaiton of 'lib\modules' directory seems different, Eclipse tries to find 'bootmodules.jimage' it below location:
C:\1_Eclipse\_Setups\ibm-java-sdk-ea-90-win-x86_64\sdk\lib\ext\lib\modules\bootmodules.jimage

Whereas the file is at below location in IBM JDK9:
C:\1_Eclipse\_Setups\ibm-java-sdk-ea-90-win-x86_64\sdk\lib\modules\bootmodules.jimage</comment_text>
        </comment>
        <comment>
            <comment_id>2719266</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-10 05:40:51 -0400</when>
            <comment_text>Niraj, I see the last Y build failed and the one you are using is quite old. Could you try the feature patch and apply it on top of the Neon build?

I think in the more recent versions, we don't look for bootmodules.jimage any more.</comment_text>
        </comment>
        <comment>
            <comment_id>2756987</comment_id>
            <comment_count>3</comment_count>
            <who>Chandrakala MS</who>
            <commenter_username>chandra-ms</commenter_username>
            <when>2016-09-29 04:00:35 -0400</when>
            <comment_text>I 'm unable to compile a module with eclipse-SDK-Y20160908-1000-win32-x86_64 and IBM Java9 build, it fails with - &lt;JAVA_HOME&gt;/lib/modules in the greetings project cannot be read or is not a valid ZIP file. 

However,I 'm able to work around this issue by removing this file and explicitly adding jrt-fs.jar</comment_text>
        </comment>
        <comment>
            <comment_id>2760624</comment_id>
            <comment_count>4</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-05 02:35:28 -0400</when>
            <comment_text>(In reply to comment #3)
&gt; I 'm unable to compile a module with eclipse-SDK-Y20160908-1000-win32-x86_64 and
&gt; IBM Java9 build, it fails with - &lt;JAVA_HOME&gt;/lib/modules in the greetings
&gt; project cannot be read or is not a valid ZIP file.
&gt; 
&gt; However,I 'm able to work around this issue by removing this file and explicitly
&gt; adding jrt-fs.jar
I'm curious how you were able to work around this issue - I keep getting an exception whenever I try to use the IBM jdk9 with a project which suggests that something is wrong either with the VM or the way we are using it. And the project is unusable, can't do anything with it. Below is the exception I see. Did you also see something similar?

java.lang.NoSuchMethodError: java.nio.ByteBuffer.limit(I)Ljava/nio/ByteBuffer;
	at jdk.internal.jimage.BasicImageReader.slice(BasicImageReader.java:186)
	at jdk.internal.jimage.BasicImageReader.intBuffer(BasicImageReader.java:193)
	at jdk.internal.jimage.BasicImageReader.&lt;init&gt;(BasicImageReader.java:132)
	at jdk.internal.jimage.ImageReader.&lt;init&gt;(ImageReader.java:89)
	at jdk.internal.jimage.ImageReader.open(ImageReader.java:99)
	at jdk.internal.jimage.ImageReader.open(ImageReader.java:116)
	at jdk.internal.jrtfs.JrtFileSystem.openImage(JrtFileSystem.java:75)
	at jdk.internal.jrtfs.JrtFileSystem.&lt;init&gt;(JrtFileSystem.java:87)
	at jdk.internal.jrtfs.JrtFileSystemProvider.newFileSystem(JrtFileSystemProvider.java:122)
	at java.nio.file.FileSystems.newFileSystem(FileSystems.java:336)
	at org.eclipse.jdt.internal.compiler.util.JrtFileSystem.initialize(JRTUtil.java:186)
	at org.eclipse.jdt.internal.compiler.util.JrtFileSystem.&lt;init&gt;(JRTUtil.java:171)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(JRTUtil.java:114)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:143)
	at org.eclipse.jdt.internal.core.JavaProject.loadModulesInJimage(JavaProject.java:708)
...</comment_text>
        </comment>
        <comment>
            <comment_id>2764632</comment_id>
            <comment_count>5</comment_count>
            <who>Chandrakala MS</who>
            <commenter_username>chandra-ms</commenter_username>
            <when>2016-10-10 03:52:20 -0400</when>
            <comment_text>Which Java build are you using? I have used IBM Java9 beta1 build. To work around,
I removed lib/modules and added jrt-fs.jar in the build on installed JREs</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495856</id>
        <developer>Andreas Huber</developer>
        <developer_username>andreas.huber</developer_username>
        <dup_id/>
        <creation_time>2016-06-10 04:55:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[resource] Add annotation to clarify ownership of returned resources to improve analysis of 'potential resources leaks'</short_desc>
        <thetext>Eclipse documentation on resource leak analysis states:
If a method obtains a resource via a method call rather than by a new expression, it may or may not be responsible; any problems are only flagged as potential resource leaks.

It would be nice if methods that return resources could be annotated with @MustClose or @DontClose. (Maybe you find better names for these...).

If a method is annotated with @MustClose, it would mean that the method transfers ownership of the resource to the caller. So eclipse can do its analysis and report any problem as a 'resource leak' instead of a 'potential resource leak', so the problem will show up even if 'potential resource leaks' are ignored.

If a method is annotated with @DontClose, it would mean that the method does not transfer ownership of the resource to the caller. So eclipse can skip analysis of this resource and won't report a 'potential resource leak' where there is actually none.

What do you think of this feature?</thetext>
        <comment>
            <comment_id>2719258</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-10 05:27:54 -0400</when>
            <comment_text>Hmmm... Interesting.

Although I think it is too much work for less return, let's hear from Stephan and others.</comment_text>
        </comment>
        <comment>
            <comment_id>2744448</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-28 13:27:16 -0400</when>
            <comment_text>*** Bug 500381 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
        <comment>
            <comment_id>2744449</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-28 13:31:40 -0400</when>
            <comment_text>Research publications provide many approaches for specifying and checking ownership of objects. These would be of tremendous help not only for resource leak analysis.

The choice which approach to adopt is not trivial, in particular in regard to transfer of ownership.</comment_text>
        </comment>
        <comment>
            <comment_id>2744450</comment_id>
            <comment_count>4</comment_count>
            <who>Olivier Cailloux</who>
            <commenter_username>olivier.cailloux</commenter_username>
            <when>2016-08-28 13:38:58 -0400</when>
            <comment_text>I think the proposed solution (in the original description) makes sense, generally speaking, and I would be happy to see it implemented.

However, AFAIU, it does not solve the problem when using APIs not under the responsability of the developer.

As an illustration, the problem happens with servlet programming when using the methods getOutputStream or getWriter of (Http)ServletResponse (see http://docs.oracle.com/javaee/7/api/javax/servlet/ServletResponse.html and Bug 500381). The proposed solution does not apply to that case, as it is impossible for the developer to annotate those methods in (Http)ServletResponse.

A more general solution (as hinted in Comment 3) would be most welcome, if at all possible.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495953</id>
        <developer>Till Brychcy</developer>
        <developer_username>register.eclipse</developer_username>
        <dup_id/>
        <creation_time>2016-06-12 17:47:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Type bounds may lead to wrong error about inconsistent type hierarchy</short_desc>
        <thetext>(Noted while examining bug 495635)

DESCRIPTION:
With each of the following interfaces in a separate .java-File:

public interface AU1RegKey&lt;O extends AURegObject&lt;O&gt;&gt; extends AURegBase&lt;O&gt; {
}
--
public interface AURegBase&lt;O extends AURegObject&lt;O&gt;&gt; extends AURegType&lt;O&gt; {
}
--
public interface AURegObject&lt;O extends AURegObject&lt;O&gt;&gt;
    extends AU1RegKey&lt;O&gt; {
}
--
public interface AURegType&lt;O extends AURegObject&lt;O&gt;&gt; {
}

After  a clean build, the following errors appear:
----------
1. ERROR in A1URegKey.java (at line 1)
	public interface A1URegKey&lt;O extends AURegObject&lt;O&gt;&gt; extends AURegBase&lt;O&gt; {
	                 ^^^^^^^^^
The hierarchy of the type A1URegKey is inconsistent
----------
1. ERROR in AURegObject.java (at line 2)
	extends A1URegKey&lt;O&gt; {
	        ^^^^^^^^^
Cycle detected: a cycle exists in the type hierarchy between AURegObject&lt;O&gt; and A1URegKey&lt;O&gt;
----------


ANALYSIS:
The relevant extraction of the stack when the inconsistent hierarchy is reported is as follows: (Note the // -comments)

org.eclipse.jdt.internal.compiler.lookup.ClassScope.detectHierarchyCycle(org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding, org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding, org.eclipse.jdt.internal.compiler.ast.TypeReference) line: 1285	
org.eclipse.jdt.internal.compiler.lookup.ClassScope.detectHierarchyCycle(org.eclipse.jdt.internal.compiler.lookup.TypeBinding, org.eclipse.jdt.internal.compiler.ast.TypeReference) line: 1195   // superType=A1URegKey&lt;O&gt;	
[…]
org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperInterfaces() line: 1052	
org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchyWithoutMembers() line: 1172 // ClassScope=AURegObject&lt;O&gt;
org.eclipse.jdt.internal.compiler.lookup.ClassScope.detectHierarchyCycle(org.eclipse.jdt.internal.compiler.lookup.TypeBinding, 
[…]
org.eclipse.jdt.internal.compiler.lookup.ClassScope(org.eclipse.jdt.internal.compiler.lookup.Scope).connectTypeVariables(org.eclipse.jdt.internal.compiler.ast.TypeParameter[], boolean) line: 827	
org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchyWithoutMembers() line: 1175   // ClassScope=AURegType&lt;O&gt;
org.eclipse.jdt.internal.compiler.lookup.ClassScope.detectHierarchyCycle(org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding, 
[…]
org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperInterfaces() line: 1052	          
org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchyWithoutMembers() line: 1172   // ClassScope=AURegBase&lt;O&gt;
org.eclipse.jdt.internal.compiler.lookup.ClassScope.detectHierarchyCycle(org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding, 
[…]
org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperInterfaces() line: 1052	
org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy() line: 1114   // ClassScope=A1URegKey&lt;O&gt;
[…]
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings() line: 249	
[…]

So the problem is as follows: starting from A1URegKey&lt;O&gt;, connectSuperInterfaces() is recursively invoked until at AURegType&lt;O&gt;, which has no super interface, connectTypeVariables is invoked. This invokes connectSuperInterfaces for AURegObject which finds that isHierarchyBeingActivelyConnected() is true for A1URegKey&lt;0&gt; and an error is reported.
Some kind of detection that connectTypeVariables is involved is missing.</thetext>
    </bug>
    <bug>
        <id>495954</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-06-12 23:55:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] Implement Milling Project coin (JEP 213)</short_desc>
        <thetext>JEP 213 talks about project coin, a collection of small features:

http://openjdk.java.net/jeps/213

There are already bugs for individual items in the list. This is the umbrella bug to track them all.</thetext>
    </bug>
    <bug>
        <id>495956</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-06-13 00:07:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Deactivate tests at lower compliance levels</short_desc>
        <thetext>Now that we have added one more compliance level to the compiler and the test suite, the number of tests has gone over 80K. Naturally the tests take ever so longer and will impact our Gerrit work flow too.

Hence I am mooting the option of deactivating certain compliance levels for tests, let's say 1.3 and 1.4, perhaps more. However, I have proof or statistic to back that people don't compile at this level. I would like this to be discussed and taken up during our 1.9 work.</thetext>
        <comment>
            <comment_id>2719900</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-13 09:48:53 -0400</when>
            <comment_text>I don't have statistics either, but from a test-coverage-p.o.v. wouldn't it make sense to keep 1.4, and instead drop 1.5? Differences between 1.5 and 1.6 are far smaller than differences between 1.4 and 1.5.
So, I'm proposing to *keep*:
  1.4 1.6 1.7 1.8 9
Next candidate to drop could be either of 1.4 (if really nobody uses that anymore) or 1.6 (subsumed by 1.7 tests).

So this is my developers p.o.v., it OTOH we make an official statement that support for 1.4- is no longer maintained, that would of course override my reasoning.</comment_text>
        </comment>
        <comment>
            <comment_id>2720139</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-14 02:12:35 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #1)
&gt; I don't have statistics either, but from a test-coverage-p.o.v. wouldn't it
&gt; make sense to keep 1.4, and instead drop 1.5? Differences between 1.5 and
&gt; 1.6 are far smaller than differences between 1.4 and 1.5.
&gt; So, I'm proposing to *keep*:
&gt;   1.4 1.6 1.7 1.8 9

I agree with this logic.


&gt; So this is my developers p.o.v., it OTOH we make an official statement that
&gt; support for 1.4- is no longer maintained, that would of course override my
&gt; reasoning.

May be we should explore the option of running the tests at left out levels only for I/M builds and not for Gerrit/N-build/Locally?</comment_text>
        </comment>
        <comment>
            <comment_id>2720297</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-14 07:23:04 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #2)
&gt; May be we should explore the option of running the tests at left out levels
&gt; only for I/M builds and not for Gerrit/N-build/Locally?

Great idea!</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495976</id>
        <developer>Frank Benoit</developer>
        <developer_username>frank.benoit.ext</developer_username>
        <dup_id/>
        <creation_time>2016-06-13 06:29:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Autocomplete shall show enum values for enum parameters</short_desc>
        <thetext>Using 4.6RC3:

Given this code:

enum State { ON, OFF; }
public void take( State state ) {}

public void test() {
    take(&lt;cursor&gt;)
}

When the cursor is in the marked location, the auto completion or Ctrl-space should give the available values for selection. E.g. i choose "ON", it expands to:
    take(State.ON)&lt;cursor&gt;

The needed import for the enum might be imported.</thetext>
        <comment>
            <comment_id>2720177</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-14 04:00:03 -0400</when>
            <comment_text>This behavior has been the same forever. Marking as enhancement.</comment_text>
        </comment>
        <comment>
            <comment_id>2720228</comment_id>
            <comment_count>2</comment_count>
            <who>Frank Benoit</who>
            <commenter_username>frank.benoit.ext</commenter_username>
            <when>2016-06-14 05:01:32 -0400</when>
            <comment_text>yes, it was meant as enhancement request.
Thanks</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495987</id>
        <developer>Peter Larsen</developer>
        <developer_username>pebl</developer_username>
        <dup_id/>
        <creation_time>2016-06-13 08:41:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Missing semicolon havoc project</short_desc>
        <thetext>I can reproduce the following every time, but I dont have a small test example.
Nor am I allowed to give the src or access to it, so it already a bad bug report.

In a project without any errors, I can remove a semicolon for a field decl
&lt;pre&gt;
package octoshape.a.b.c;
public class D extends ...{
	...
	private StreamingToOT checkSoftEvict
&lt;/pre&gt;
This causes an error "Syntax error, insert ";" to complete FieldDeclaration" as 
expected.

However a lot of other java files suddenly also gets errors.
It seems most of them are related in some way, others I dont see the direct connection. They all marked with the following errors starting with the first line

&lt;pre&gt;
Multiple markers at this line
	- octoshape.x.y.z cannot be resolved 
	 to a type
	- Syntax error on token "package", assert expected
&lt;/pre&gt;

Then continues with 

&lt;pre&gt;
	- octoshape.build.BuildFlags cannot be resolved to a 
	 variable
	- Syntax error on token "import", throw expected
&lt;/pre&gt;


Adding the semicolon does not make the wrong errors go away, only the correct about missing semicolon. I can clean and rebuild to make them go away.</thetext>
        <comment>
            <comment_id>2777304</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-18 02:36:41 -0500</when>
            <comment_text>Hmm.. clearly there's something wrong, but not sure if we can do anything until we get a reproducible test case.</comment_text>
        </comment>
        <comment>
            <comment_id>2786892</comment_id>
            <comment_count>2</comment_count>
            <who>Jon Gorrono</who>
            <commenter_username>jpgorrono</commenter_username>
            <when>2016-12-16 01:03:56 -0500</when>
            <comment_text>I have this trouble from time to time... and one of those times is right now.

I did a project wide search and replace of import lines in many files to refactor from old deprecated types to new ones. No type refactoring that I know of... so did this with text search and replace..... now all the package declarations are not recognized (same error as above)... cleaning workspace, removing and replacing source dir's do not help

I can resolve on a file-by-file basis by removing (cutting) package declaration, then saving and building, then replacing (pasting) declaration, saving and building..... 1000's of files &lt;cough&gt;&lt;cough&gt;

My search and replace searched for one whole import line (e.g., import org.apache.spark.sql.DataFrame;) with two import lines ("import ...Dataset&lt;Row&gt;;\nimport ....Row;")</comment_text>
        </comment>
        <comment>
            <comment_id>2787161</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-16 14:47:38 -0500</when>
            <comment_text>(In reply to Jon Gorrono from comment #2)
&gt; I have this trouble from time to time... and one of those times is right now.

First, may we ask you to backup your workspace showing the error for experiments? This isn't by chance open source, so you could share your workspace?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496062</id>
        <developer>Gerard Paligot</developer>
        <developer_username>gerard.paligot</developer_username>
        <dup_id/>
        <creation_time>2016-06-14 04:23:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Missing fixes in the artifact published on maven central</short_desc>
        <thetext>Recently (25-Feb-2016), an artifact has been deployed on Maven Central (this one: http://search.maven.org/#artifactdetails%7Corg.eclipse.jdt.core.compiler%7Cecj%7C4.5.1%7Cjar).

This is the version 4.5.1. Unfortunately, this version doesn't have some fixes like this one https://bugs.eclipse.org/bugs/show_bug.cgi?id=464496 but marked as fixed for a previous version.

That could be awesome to publish a good version of JDT Core in Maven Central with all fixes about the version 4.5.1 and publish higher versions too.

For my open source project, we need it because we use versions published on https://repo.eclipse.org/content/repositories/eclipse-staging but you remove old versions when you publish a new one.

So, we have some artifacts published on Maven Central which doesn't work anymore because Maven doesn't find your artifact...</thetext>
        <comment>
            <comment_id>2720303</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-14 07:35:33 -0400</when>
            <comment_text>Related: bug 476650 - bug 484004

Let's see, which of those gets atttention first.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496137</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-06-14 16:41:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler][batch] support INFO problem severity?</short_desc>
        <thetext>I was trying to construct a test case using the batch compiler, where distinguishing WARNING vs. INFO problems would be relevant, when I noticed that this is not currently possible.

org.eclipse.jdt.internal.compiler.batch.Main.Logger.logProblem(CategorizedProblem, int, int, char[]) only ever prints "ERROR" or "WARNING".

While it would be trivial to add a "INFO" branch, for symmetry this would also call for a -info set of CLI options, which then might be overkill? Hence the question mark in the bug title.

Anyone have an opinion on this?</thetext>
    </bug>
    <bug>
        <id>496163</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-06-15 05:55:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] IJavaElement APIs for module-info.java/.class</short_desc>
        <thetext>How should we represent module-info.java/.class in the IJavaElement APIs?

http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html#jigsaw-2.1 says:

module-info.class uses a new access_flags value ACC_MODULE and is named &lt;module-name&gt;/module-info
  - unlike the package-info.class (which uses an ACC_INTERFACE named &lt;package-name&gt;.package-info), the module-info is strictly spoken not one of the existing types
  - new Module_attribute that contains infos about requires/exports/uses/provides
  - NO annotations are supported in a module-info file

=&gt; To avoid changes to the IJavaElement hierarchy, I think we should just pretend the module-info.class is an interface as well.

ITypeRoot should get two new APIs to avoid things like org.eclipse.jdt.internal.corext.util.JavaModelUtil#isPackageInfo(ICompilationUnit):

boolean isPackageInfo();
boolean isModuleInfo();</thetext>
    </bug>
    <bug>
        <id>496338</id>
        <developer>Liam Schramm</developer>
        <developer_username>schrammlb2</developer_username>
        <dup_id/>
        <creation_time>2016-06-17 20:06:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Eclipse enters deadlock when running a project or making a new project</short_desc>
        <thetext>When I try to run a project, the cursor immediately enters the loading state indefinitely. Although scrollover menus still work, all buttons/click events become unresponsive, including the window's "close" button. 

When creating a new project, no loading bar appears. Eclipse stays on the 'create project' screen indefinitely. When I press the red button to stop, edge around the button disappears as if it has been pressed, but Eclipse remains stuck on the 'create project' screen. If I try to exit Eclipse, it warns me that it's still busy and I must tell it to stop its current process before I can exit. 

These problems have persisted through 2 reinstallations.</thetext>
        <comment>
            <comment_id>2721808</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-18 09:11:43 -0400</when>
            <comment_text>We need more information about where it is stuck.

Please see https://wiki.eclipse.org/How_to_report_a_deadlock on how to provide that information.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496339</id>
        <developer>Austin Habba</developer>
        <developer_username>austin1habba</developer_username>
        <dup_id/>
        <creation_time>2016-06-17 20:16:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>NPE in QualifiedNameReference.optimizedBooleanConstant() at line 913</short_desc>
        <thetext>What steps will reproduce the problem?
1. 
2. 
3. 


-- Error Details --
Date: Fri Jun 17 19:14:29 CDT 2016
Message: Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
Severity: Error
Product: Eclipse 4.6.0.20160601-1520 (org.eclipse.epp.package.java.product)
Plugin: org.eclipse.jdt.ui
Session Data:
eclipse.buildId=4.6.0.I20160525-2000
java.version=1.8.0_91
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -cleanPersistedState
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -cleanPersistedState -clean

Exception Stack Trace:
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.optimizedBooleanConstant(QualifiedNameReference.java:913)
	at org.eclipse.jdt.internal.compiler.ast.WhileStatement.doesNotCompleteNormally(WhileStatement.java:300)
	at org.eclipse.jdt.internal.compiler.ast.Block.doesNotCompleteNormally(Block.java:158)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.resolveType(LambdaExpression.java:434)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.cachedResolvedCopy(LambdaExpression.java:880)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:804)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4784)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4751)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor0(Scope.java:2374)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor(Scope.java:2337)
	at org.eclipse.jdt.internal.compiler.ast.Statement.findConstructorBinding(Statement.java:440)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:471)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:252)
	at org.eclipse.jdt.internal.compiler.ast.Statement.resolveCase(Statement.java:415)
	at org.eclipse.jdt.internal.compiler.ast.SwitchStatement.resolve(SwitchStatement.java:520)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1075)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205)
	... 16 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.optimizedBooleanConstant(QualifiedNameReference.java:913)
	at org.eclipse.jdt.internal.compiler.ast.WhileStatement.doesNotCompleteNormally(WhileStatement.java:300)
	at org.eclipse.jdt.internal.compiler.ast.Block.doesNotCompleteNormally(Block.java:158)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.resolveType(LambdaExpression.java:434)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.cachedResolvedCopy(LambdaExpression.java:880)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:804)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4784)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4751)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor0(Scope.java:2374)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor(Scope.java:2337)
	at org.eclipse.jdt.internal.compiler.ast.Statement.findConstructorBinding(Statement.java:440)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:471)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:252)
	at org.eclipse.jdt.internal.compiler.ast.Statement.resolveCase(Statement.java:415)
	at org.eclipse.jdt.internal.compiler.ast.SwitchStatement.resolve(SwitchStatement.java:520)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1075)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)


-- Error Details --
Date: Fri Jun 17 19:14:29 CDT 2016
Message: java.lang.NullPointerException
Severity: Error
Product: Eclipse 4.6.0.20160601-1520 (org.eclipse.epp.package.java.product)
Plugin: org.eclipse.jdt.core
Exception Stack Trace:
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.optimizedBooleanConstant(QualifiedNameReference.java:913)
	at org.eclipse.jdt.internal.compiler.ast.WhileStatement.doesNotCompleteNormally(WhileStatement.java:300)
	at org.eclipse.jdt.internal.compiler.ast.Block.doesNotCompleteNormally(Block.java:158)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.resolveType(LambdaExpression.java:434)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.cachedResolvedCopy(LambdaExpression.java:880)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:804)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4784)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4751)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor0(Scope.java:2374)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor(Scope.java:2337)
	at org.eclipse.jdt.internal.compiler.ast.Statement.findConstructorBinding(Statement.java:440)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:471)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:252)
	at org.eclipse.jdt.internal.compiler.ast.Statement.resolveCase(Statement.java:415)
	at org.eclipse.jdt.internal.compiler.ast.SwitchStatement.resolve(SwitchStatement.java:520)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1075)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)


-- Error Details --
Date: Fri Jun 17 19:14:29 CDT 2016
Message: java.lang.NullPointerException
Severity: Error
Product: Eclipse 4.6.0.20160601-1520 (org.eclipse.epp.package.java.product)
Plugin: org.eclipse.jdt.core
Exception Stack Trace:
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.optimizedBooleanConstant(QualifiedNameReference.java:913)
	at org.eclipse.jdt.internal.compiler.ast.WhileStatement.doesNotCompleteNormally(WhileStatement.java:300)
	at org.eclipse.jdt.internal.compiler.ast.Block.doesNotCompleteNormally(Block.java:158)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.resolveType(LambdaExpression.java:434)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.cachedResolvedCopy(LambdaExpression.java:880)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:804)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4784)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4751)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor0(Scope.java:2374)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor(Scope.java:2337)
	at org.eclipse.jdt.internal.compiler.ast.Statement.findConstructorBinding(Statement.java:440)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:471)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:252)
	at org.eclipse.jdt.internal.compiler.ast.Statement.resolveCase(Statement.java:415)
	at org.eclipse.jdt.internal.compiler.ast.SwitchStatement.resolve(SwitchStatement.java:520)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1075)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)</thetext>
        <comment>
            <comment_id>2721810</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-18 09:17:44 -0400</when>
            <comment_text>Could you please try to create a reproducing example?

Hints: we are looking for a piece of code with the following nested structure (according to the stack trace):

method
+ switch
  + local variable declaration
    + "new" expression (in the initialization of the variable)
      + argument is a lambda
        + lambda body is a block
          + while
            + some qualified name

When the exception occurs: does your code contain compile errors?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496604</id>
        <developer>Hollis Waite</developer>
        <developer_username>hwaite</developer_username>
        <dup_id/>
        <creation_time>2016-06-22 23:25:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>"Use lambda where possible" cleanup fails when functional interface initialized before referenced member</short_desc>
        <thetext>"Use lambda where possible" cleanup converts

public class Test {
  private final Object mObj;
  private Consumer mConsumer = new Consumer() {
    public void accept(Object pParam) {mObj.toString();}
  };
  Test() {mObj = "";}
}

to

public class Test {
  private final Object mObj;
  private Consumer mConsumer = pParam -&gt; mObj.toString();
  Test() {mObj = "";}
}

Output code fails with error "The blank final field mObj may not have been initialized".</thetext>
    </bug>
    <bug>
        <id>496616</id>
        <developer>Oliver Gierke</developer>
        <developer_username>ogierke</developer_username>
        <dup_id/>
        <creation_time>2016-06-23 04:40:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Fields generated for new constructor quick fix should be final</short_desc>
        <thetext>The Neon release introduces a new quick fix for constructors taking parameters to suggest to assign those fields to fields [0]. It would be cool if there was a way to make these fields final to promote immutability.

[0] https://www.eclipse.org/neon/noteworthy/#_create_new_fields_from_method_parameters</thetext>
    </bug>
    <bug>
        <id>496786</id>
        <developer>Alessandro Nistico</developer>
        <developer_username>alienisty</developer_username>
        <dup_id/>
        <creation_time>2016-06-26 07:27:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Eclipse compiler accepts invalid syntax without error</short_desc>
        <thetext>The following Java code is accepted without errors by eclipse:

public class EclipseParserBug {
  private static void copy(boolean[] src, boolean[] dst) {
    long start=System.nanoTime();
    IntStream.range(0, src.length).parallel().forEach(i -&gt; dst[i] = src[i]))); 	  
    System.out.println("Copy took: " + (System.nanoTime() - start));
  }
}

which is compiled in the following byte code:

// Compiled from EclipseParserBug.java (version 1.8 : 52.0, super bit)
public class EclipseParserBug {
  
  // Method descriptor #6 ()V
  // Stack: 1, Locals: 1
  public EclipseParserBug();
    0  aload_0 [this]
    1  invokespecial java.lang.Object() [8]
    4  return
      Line numbers:
        [pc: 0, line: 1]
      Local variable table:
        [pc: 0, pc: 5] local: this index: 0 type: EclipseParserBug
  
  // Method descriptor #15 ([Z[Z)V
  // Stack: 2, Locals: 4
  private static void copy(boolean[] src, boolean[] dst);
    0  invokestatic java.lang.System.nanoTime() : long [16]
    3  lstore_2 [start]
    4  return
      Line numbers:
        [pc: 0, line: 3]
        [pc: 4, line: 8]
      Local variable table:
        [pc: 0, pc: 5] local: src index: 0 type: boolean[]
        [pc: 0, pc: 5] local: dst index: 1 type: boolean[]
        [pc: 4, pc: 5] local: start index: 2 type: long
}

which is also incorrect.

Note how only the first line of the source code has been compiled, despite having debug information for the rest.

It seems like a very corner case but it could lead to very sneaky and hard to find bugs.</thetext>
        <comment>
            <comment_id>2725166</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-28 18:18:27 -0400</when>
            <comment_text>The bug happens all the way back to our first version supporting Java 8.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496789</id>
        <developer>Ralf Hauser</developer>
        <developer_username>hauser</developer_username>
        <dup_id/>
        <creation_time>2016-06-26 08:22:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Errors running builder 'Java Builder' on project '...'</short_desc>
        <thetext>Errors occurred during the build.
Errors running builder 'Java Builder' on project 'xyz'.
-1

and the log says:

&lt;&lt;!ENTRY org.eclipse.core.resources 4 2 2016-06-26 14:17:09.808
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.core.resources".
!STACK 0
java.lang.ArrayIndexOutOfBoundsException: -1
        at org.eclipse.jdt.internal.compiler.parser.Parser.consumeEmptyStatement(Parser.java:3308)
        at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6614)
        at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11112)
        at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:11717)
        at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12016)
        at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:11973)
        at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.traverse(ConstructorDeclaration.java:638)
        at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12110)
        at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11175)
        at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11211)
        at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.parseStatements(ConstructorDeclaration.java:530)
        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:874)
        at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10150)
        at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:847)
        at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:141)
        at java.lang.Thread.run(Thread.java:745)
&gt;&gt;

see also Bug 471217

Version: Mars.2 Release (4.5.2)
Build id: 20160218-0600</thetext>
        <comment>
            <comment_id>2724152</comment_id>
            <comment_count>1</comment_count>
            <who>Ralf Hauser</who>
            <commenter_username>hauser</commenter_username>
            <when>2016-06-26 10:52:10 -0400</when>
            <comment_text>https://blog.pdark.de/2011/09/02/restoring-a-corrupted-workspace-in-eclipse/ helped to fix it.

Had to check it out of svn again

The worst was the lost breakpoints.</comment_text>
        </comment>
        <comment>
            <comment_id>2725153</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-28 17:37:11 -0400</when>
            <comment_text>We'd need a source snippet that triggered this exception.

Hint: consumeEmptyStatement() corresponds to an extra ';', like, e.g.:
   while (check())
       ;

Can you identify that location in your code (inside some constructor)?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496821</id>
        <developer>Jilles van Gurp</developer>
        <developer_username>incoming</developer_username>
        <dup_id/>
        <creation_time>2016-06-27 07:02:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>call hierarchy for static methods is broken, sometimes</short_desc>
        <thetext>public static Contact from(JsonObject c) {
        if(c==null) {
            throw new IllegalStateException("json is empty");
        }
        return new Contact(c);
    }

    public Contact deepClone() {
        return Contact.from(getJsonObject().deepClone());
    }

In this bit of code, the call hierarchy for the from method in both eclipse Neon (osx, just updated this morning) and Mars shows no results. This is incorrect, the method in question is in fact used in many dozens of places in the same project and even in the same class. 

I can see the call hierarchy is working for some static methods in the same project but never for this one. This particular class is implementing several interfaces, with default methods. But aside from that I can't see anything that is special about this class. I've observed the same problem in several other places. The method has loads of similarly named static methods in other classes (it's a pattern we use a lot). I've also seen rename functionality on static methods being a bit wonky; possibly for the same reason. Sometimes it works, sometimes it doesn't.

I've been trying to create a test case for this but can't reproduce this outside of our project: it always fails on this method in this project and loads of other static methods but not all. This means it is somehow related to this project. Some kind of combination of stuff is causing call hierarchy to go wonky here. I've seen similar issues closed with a worksforme, including e.g. #433462. So, I'd thought I at least report that something is going on here. 

I'd be happy to assist debugging if needed.</thetext>
        <comment>
            <comment_id>2724785</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-28 06:54:25 -0400</when>
            <comment_text>call hierarchy internally uses search for finding callers, so it would be interesting to see if search for references (Ctrl+Shift+G) works for the method in question. If it doesn't I could think of an inconsistent index as the cause, so: does the problem remain after Project &gt; Clean ... ?

Sure a reproducing example would make a huge difference here.
So if recreating the problem in a small problem was not successful, it would be could if you could go the opposite direction: create a full copy of your project, and try removing stuff until the problem disappears.

Alternatively, would you be willing to create a JDT development workspace (e.g., using Oomph) and connect a debugger to the Eclipse instance where the bug occurs? If so, I could send further hints.</comment_text>
        </comment>
        <comment>
            <comment_id>2781388</comment_id>
            <comment_count>2</comment_count>
            <who>Jilles van Gurp</who>
            <commenter_username>incoming</commenter_username>
            <when>2016-11-30 07:23:41 -0500</when>
            <comment_text>Sorry for my slow response. This is still broken for me in the latest Neon. I've actually completely rebuilt my workspace so that was not it. Cleaning or refreshing eclipse doesn't work either.

However, I stumbled on a work around that may point to a solution.

If I go to filters -&gt; search in, and disable Application Libraries, it works. As soon as I renable that, it breaks again.

Given the comment by Stephan Herman, I suspect the issue is that including Application Libraries generates so many intermediate but invalid results that it just stops searching before finding any valid results. Find references in workspace definitely finds a ton of stuff. I've no idea how this is implemented but I'd suggest never dropping any results coming project sources and treating the other 3 as nice to have but optional. 99% of the time I use this I couldn't care less about anything but my own code in the same project.

BTW. In my search on Google on this issue, most links seem to land me to stackoverflow where apparently a lot of people are struggling with this. Search for "eclipse call hierarchy not working static" produces several examples of this. 

Given that and the number of issues related to this that are either still in the new state or closed as won't fix or can't reproduce in the issue tracker, there definitely seem to be many open issues with call hierarchy that are possibly/likely. Maybe a good idea to track these in one issue to gather information?

If helpful, I can try attaching a debugger or output some logs. I don't really use oomph and would prefer not to wipe out my workspace.</comment_text>
        </comment>
        <comment>
            <comment_id>2782700</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-04 23:36:32 -0500</when>
            <comment_text>Copying Manoj for comments, as he is our expert on search.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496861</id>
        <developer>Greg Fraley</developer>
        <developer_username>gsfraley</developer_username>
        <dup_id/>
        <creation_time>2016-06-27 12:58:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][content assist] A first Java enum value that takes lambda parameters in the constructor do not support Content Assist inside the lambda, if there is a block in the lambda</short_desc>
        <thetext>The title covers the bulk of the issue.  One thing to note is that highlighting still works as expected.  Here is an example snippet of affected code:

public enum MyEnum
{
	ONE(() -&gt; {
		return "One!".toUpperCase();
	}),
	
	TWO(() -&gt; {
		return "Two!".toUpperCase();
	});
	
	private MyEnum(Supplier&lt;String&gt; supplier)
	{ }
}

In that example, the ONE value has no Content Assist inside the lambda block.  Content Assist works in any following values (TWO in this instance), or if the first value is not a blocked lambda:

ONE(() -&gt; "One!".toUpperCase)</thetext>
        <comment>
            <comment_id>2724797</comment_id>
            <comment_count>1</comment_count>
            <who>Andreas Sewe</who>
            <commenter_username>andreas.sewe</commenter_username>
            <when>2016-06-28 07:30:52 -0400</when>
            <comment_text>(In reply to Greg Fraley from comment #0)
&gt; The title covers the bulk of the issue.  One thing to note is that
&gt; highlighting still works as expected.  Here is an example snippet of
&gt; affected code:

Hi Greg. Thank you for the very detailed bug report! Much appreciated.

This problem also occurs with Eclipse Code Recommenders *not* installed; I can reproduce with a plain Eclipse 4.6 SDK from [1].

Hence, this seems to be an issue with the core Java Development Tools (which Code Recommenders extends).

I'm reassigning this bug to the JDT team.

[1] &lt;http://download.eclipse.org/eclipse/downloads/drops4/R-4.6-201606061100/&gt;</comment_text>
        </comment>
        <comment>
            <comment_id>2724805</comment_id>
            <comment_count>2</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-06-28 07:47:21 -0400</when>
            <comment_text>It also does not work in this case:

	TWO(() -&gt; {	Str|
		return "Two!".toUpperCase();
	});

Moving to JDT/Core as no proposals are returned for these cases.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496869</id>
        <developer>Rostyslav Smirnov</developer>
        <developer_username>rostyslav_smirnov</developer_username>
        <dup_id/>
        <creation_time>2016-06-27 14:32:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Compiler cannot infer types when mixing generic and raw types</short_desc>
        <thetext>Created attachment 262732
Test

Code that is using both generic and raw types fails to compile with Eclipse 4.6 Neon, but compiles with Oracle Java compiler and Eclipse 4.5 Mars.

Test cases attached.

Raw types can come from third party library, one shouldn't have to abandon generics to use them.</thetext>
        <comment>
            <comment_id>2724800</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-28 07:41:50 -0400</when>
            <comment_text>The example is rejected since the fix for Bug 473657.

I'm quite certain that this change is correct.


When comparing the compiler against javac, the first thing that comes to my mind is: javac is known to have a fundamental flaw in handling raw types during type inference: https://bugs.openjdk.java.net/browse/JDK-8026527
JDT has invested significant efforts in emulating that javac bug, but due to lack of precise description of the extent of that bug, it is impossible to 100% accurately reproduce javac's behavior in this regard.


Until proven wrong (by rigorous argumentation based on JLS), I'll claim that ecj is correct in this regard. I may be wrong, but I personally will not invest my spare time in further investigation. Anybody?


PS: We all know JLS 4.8: "The use of raw types is allowed only as a concession to compatibility of legacy code. The use of raw types in code written after the introduction of generics into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types."
In that light I'd also wonder about the vitality of a library that hasn't adjusted to the introduction of generics more than a decade ago - but that's only one piece in the puzzle. I personally see more good in improving support for Java 8 code, rather than 1.4.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496896</id>
        <developer>Ralf Ellner</developer>
        <developer_username>ellner</developer_username>
        <dup_id/>
        <creation_time>2016-06-28 04:18:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[search][refactoring] Moving a class to another package does not update imports in classes in the same package but located in other projects</short_desc>
        <thetext>Created attachment 262744
Sample projects

I'm using Eclipse 4.4 with JDT 3.10.1 but the bug is also present in Neon (4.6) with JDT 3.12.0. I created two sample projects to reproduce the problem.

Project "API" contains two classes both located in package "com.foo": an empty class "APIClass" and an empty class "APIExtension" that extends "APIClass".

Project "Impl" contains a single class "ImplClass" located in the same package "com.foo" that uses "APIClass":

package com.foo;

public class ImplClass {

	public APIClass aField;
	
}

Project "Impl" includes "API" on its buildpath. In the example I have declared a field of type APIClass but the problem also exists if you use APIClass, e.g., as type parameter, and method parameter type.

All classes are in the same package. Thus, no import com.foo.APIClass is required in "ImplClass" and "APIExtension".

If you move APIClass to another package, e.g., com.bar, the class "APIExtension" (in the same project) is correctly updated with an additional import com.bar.APIClass. However, "ImplClass" (in another project) is not updated and does no longer compile unless you add the import manually.</thetext>
        <comment>
            <comment_id>2724832</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-06-28 08:25:58 -0400</when>
            <comment_text>This used to work in Eclipse 3.8.1.

The issue is that "ImplClass" is not returned in the references result for "APIClass" anymore by SearchEngine#search in RefactoringSearchEngine#internalSearch.

It can also be seen by invoking Ctrl+Shift+G on "APIClass".</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497053</id>
        <developer>Sebastian Baumhekel</developer>
        <developer_username>sebastian.baumhekel</developer_username>
        <dup_id/>
        <creation_time>2016-06-30 03:20:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null][1.8] @NonNullByDefault affects fields even if DefaultLocation.FIELD is excluded</short_desc>
        <thetext>Nullpointer analysis seems to raise warnings inconsistently.
Please see my example class below this text.

The class has set the @NonNullByDefault annotation, which leads to null checks for all fields in eclipse.
The instance field "o" is annotated as being nullable.
In every test function the field is set to a new object and so is never null after that.

The function "testFails" executes some dummy code and then accesses the field resulting in the error "Potential null pointer access: The field o is specified as @Nullable".
For multi-threaded environments this could be correct as the field could have been accessed in between, but for a single-thread environment this is wrong.

But even for the multi-threaded environment the next one is still wrong:
Function "testOk2" first does the assignment and then immediately accesses the field. In multi-threading another thread could have set the field to null between these two lines - but Eclipse shows no warning at all.

So both cases seem to be inconsistent.
Regarding a plain null analysis, I would expect Eclipse to not show any warnings for "testFails".
If it would take multi-threading into account, I would expect "testOk2" to raise the same error as "testFails". But this would also lead to a bloat of code (copying to local variable etc.) for non-threadsafe code.

Example class showing the behavior:
-----------------------------------

package de.test;

import javax.annotation.Nullable;

import org.eclipse.jdt.annotation.NonNullByDefault;

@NonNullByDefault
public class NullTest
{
	@Nullable
	private Object o;

	public String testFails()
	{
		//the object is no more null here
		o=new Object();
		//do something in between to decouple assignment and access
		int i=5;
		//"Potential null pointer access: The field o is specified as @Nullable"
		return o.toString();
	}
	
	public String testOk()
	{
		//the object is no more null here
		o=new Object();
		//do something in between to decouple assignment and access
		int i=5;
		//o ist still not null...
		assert o!=null;
		//no warning
		return o.toString();
	}
	
	public String testOk2()
	{
		//the object is no more null here
		o=new Object();
		//do nothing in between
		//no warning
		return o.toString();
	}
	
}
-----------------------------------</thetext>
        <comment>
            <comment_id>2725746</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-30 05:32:18 -0400</when>
            <comment_text>Before going into details: have you seen the following section in help?
  http://help.eclipse.org/topic/org.eclipse.jdt.doc.user/tasks/task-using_null_annotations.htm%23fields

What are your compiler settings? Did you enable "syntactic mull analysis for fields"?

FYI, here's a background text which I wrote during development: https://wiki.eclipse.org/JDT_Core/Null_Analysis/Options#Risks_of_flow_analysis_for_fields one key point being: concurrency is not the only risk to validity of local flow analysis.</comment_text>
        </comment>
        <comment>
            <comment_id>2725832</comment_id>
            <comment_count>2</comment_count>
            <who>Sebastian Baumhekel</who>
            <commenter_username>sebastian.baumhekel</commenter_username>
            <when>2016-06-30 07:34:42 -0400</when>
            <comment_text>Yes I did enable syntactic null analysis for fields and also inherit null annotations.

My compiler settings are:
----
Null pointer access: Error
Potential null pointer access: Warning

I use the following annotations:
@Nullable: javax.annotation.Nullable (JDK)
@NonNull: javax.annotation.Nonnull (JDK)
@NonNullByDefault: org.eclipse.jdt.annotation.NonNullByDefault (standard eclipse)
----

Thanks for the background on the analysis. I did not see that part of the help while looking for a solution.

A bit below your linked section is exactly the point: http://help.eclipse.org/neon/index.jsp?topic=/org.eclipse.jdt.doc.user/tasks/task-using_null_annotations.htm%23syntactic_analysis

It states that the compiler forgets the previous check and that is what happens.
A result would be to do an according "assert variable!=null;" before every access to one of its methods - which results in a lot of bloated code.
I worked around that by removing the NonNullByDefault annotation from the class and then marking each method individually.
Which still bloats the declaration, but at least does not clutter the code.

I noticed that issue when I moved from an own annotation to the eclipse NonNullByDefault one.
What I need is an annotation turning all parameters and return values into NonNull while leaving the rest as is.
NonNullByDefault unfortunately seems to ignore the limiting of things to apply it to.
During analysis this one still gets applied to fields:
----
@NonNullByDefault({ DefaultLocation.PARAMETER, DefaultLocation.RETURN_TYPE })
----

There should be an annotation to explicitly exclude a field, parameter, return type or whole class from the analysis - regardless whether the rest of the class is checked. It could be handled just like calls to the standard JDK are handled: as the JDK classes have no annotations set, it is just ignored.

So there is still a way to go, but I believe in using annotations to enable smart checks by the IDE on the code. Because that prevents errors in your own code without introducing a lot of checks in the compiled class.</comment_text>
        </comment>
        <comment>
            <comment_id>2725846</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-30 08:05:52 -0400</when>
            <comment_text>Thanks for reading the documentation :)

(In reply to Sebastian Baumhekel from comment #2)
&gt; It states that the compiler forgets the previous check and that is what
&gt; happens.
&gt; A result would be to do an according "assert variable!=null;" before every
&gt; access to one of its methods - which results in a lot of bloated code.

We typically recommend another strategy: fetch the field into a local variable, check that local for null and flow analysis will have no doubts about it further down. You don't even need "syntactic analysis". Locals are "owned" by the enclosing method and *much* better amenable to flow analysis. We even have a quick fix for this :)


&gt; During analysis this one still gets applied to fields:
&gt; ----
&gt; @NonNullByDefault({ DefaultLocation.PARAMETER, DefaultLocation.RETURN_TYPE })
&gt; ----

That would be a bug. This:

//---
@NonNullByDefault({ DefaultLocation.PARAMETER, DefaultLocation.RETURN_TYPE })
class Fields {
  String f;
  String test() {
    return f;
  }
}
//---

reports:
----------
1. WARNING in /tmp/Fields.java (at line 7)
        return f;
               ^
Null type safety (type annotations): The expression of type 'String' needs unchecked conversion to conform to '@NonNull String'
----------

=&gt; f is seen as unannotated.
Do you have an example demonstrating the contrary?


&gt; There should be an annotation to explicitly exclude a field, parameter,
&gt; return type or whole class from the analysis - regardless whether the rest
&gt; of the class is checked. It could be handled just like calls to the standard
&gt; JDK are handled: as the JDK classes have no annotations set, it is just
&gt; ignored.

Actually excluding from analysis would cut big holes into analysis. What we do is: consider as unannotated, what I typically describe as "legacy". That's what raises the "unchecked conversion" kind of warning, to clearly distinguish from situations where we are more sure about an actual problem.

As you mention unannotated JDK: have you seen this: http://help.eclipse.org/topic/org.eclipse.jdt.doc.user/tasks/task-using_external_null_annotations.htm ?</comment_text>
        </comment>
        <comment>
            <comment_id>2725867</comment_id>
            <comment_count>4</comment_count>
            <who>Sebastian Baumhekel</who>
            <commenter_username>sebastian.baumhekel</commenter_username>
            <when>2016-06-30 08:38:28 -0400</when>
            <comment_text>Thanks for guiding me into the right direction ;-)

Yes, that is what Eclipse proposed to me.
But I'd like to avoid creating additional local variables on the stack if possible.
As the origin of this issue is library code heavily used in our internal projects, I need to keep an eye on the memory footprint of at least some of the functions.
I just want to increase the depth of possible null verifications to reduce individual null checks in the code where possible without adding additional overhead.

Your example reports for me:
"The @Nonnull field f may not have been initialized"

I am using maven for this library with that annotation specific dependency:
----
		&lt;dependency&gt;
		    &lt;groupId&gt;org.eclipse.jdt&lt;/groupId&gt;
		    &lt;artifactId&gt;org.eclipse.jdt.annotation&lt;/artifactId&gt;
		    &lt;version&gt;2.0.0&lt;/version&gt;
		    &lt;scope&gt;provided&lt;/scope&gt;
		&lt;/dependency&gt;
----

I just thought it might be easier to introduce one or two exceptions in a class for the check instead of dropping the whole NonNullByDefault and having to add all the Nullable/NonNull annotations.

At the moment I'm unsure if external annotations for the JDK would work in my setup as maven manages all dependencies in the project.
But I'm also perfectly fine if null verification just covers my own code.</comment_text>
        </comment>
        <comment>
            <comment_id>2725872</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-30 08:51:56 -0400</when>
            <comment_text>(In reply to Sebastian Baumhekel from comment #4)
&gt; Thanks for guiding me into the right direction ;-)
&gt; 
&gt; Yes, that is what Eclipse proposed to me.
&gt; But I'd like to avoid creating additional local variables on the stack if
&gt; possible.

As you say "on the stack" this sounds a bit like premature optimization. How many additional bytes do you expect on the runtime stack at any given point in time? Tens? Maybe even hundrets of bytes? :) Local variables don't even create any GC issue.


&gt; Your example reports for me:
&gt; "The @Nonnull field f may not have been initialized"
&gt; 
&gt; I am using maven for this library with that annotation specific dependency:
&gt; ----
&gt; 		&lt;dependency&gt;
&gt; 		    &lt;groupId&gt;org.eclipse.jdt&lt;/groupId&gt;
&gt; 		    &lt;artifactId&gt;org.eclipse.jdt.annotation&lt;/artifactId&gt;
&gt; 		    &lt;version&gt;2.0.0&lt;/version&gt;
&gt; 		    &lt;scope&gt;provided&lt;/scope&gt;
&gt; 		&lt;/dependency&gt;
&gt; ----

This I cannot reproduce. A self-contained project showing this error would help. I'm changing the bug title to focus on this issue.

&gt; I just thought it might be easier to introduce one or two exceptions in a
&gt; class for the check instead of dropping the whole NonNullByDefault and
&gt; having to add all the Nullable/NonNull annotations.

As a last resort you could still add @NonNullByDefault({}) to any declaration.</comment_text>
        </comment>
        <comment>
            <comment_id>2725935</comment_id>
            <comment_count>6</comment_count>
            <who>Sebastian Baumhekel</who>
            <commenter_username>sebastian.baumhekel</commenter_username>
            <when>2016-06-30 10:05:41 -0400</when>
            <comment_text>You are right regarding premature optimization, but the functions I thought of are already fairly optimized as they were reworked after a performance analysis.
Though there are just a few of them, I picked these corner cases first to check if I can apply the analysis to them.
Normal application code is clearly something different, though I would favor less complex code with less workarounds were possible.

Nevertheless I see null analysis as an additional check during development and I would not want to have it introduce workarounds in my code, which are just there to circumvent some of its behavior.
It is like a Unit test, which is used during development, but stays out of the way in production mode.
For example my threadsafe classes sometimes rely on synchronized blocks, which guarantee that there is only one thread assigning the variable and accessing it in a block of code.
The current null analysis would tell me here that the field could be null though it actually never could be null at this point.
The complexity of such scenarios is far above what JDT might be able to handle at this point and also it is not really necessary to handle such cases at all.
That's the reason why I would like use the NonNullByDefault annotation just on parameters and return types.
Therefore I will try to create a sample project for you, but it may take some time to do that (I tested the other samples inside an existing internal library project).</comment_text>
        </comment>
        <comment>
            <comment_id>2726105</comment_id>
            <comment_count>7</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-30 16:36:22 -0400</when>
            <comment_text>(In reply to Sebastian Baumhekel from comment #6)
&gt; Nevertheless I see null analysis as an additional check during development
&gt; and I would not want to have it introduce workarounds in my code, which are
&gt; just there to circumvent some of its behavior.

For toy examples it may be easy to see that such local variables may not be needed, but in complex situations local variables not only silence warnings/errors but they do so by actually avoiding the underlying risk of NPE. Getting into the habit of preferring locals over field access can make your code safer.

&gt; For example my threadsafe classes sometimes rely on synchronized blocks,
&gt; [..]
&gt; The complexity of such scenarios is far above what JDT might be able to
&gt; handle at this point and also it is not really necessary to handle such
&gt; cases at all.

Yes, analysing thread synchronization would be a different animal from what we have in JDT.

&gt; That's the reason why I would like use the NonNullByDefault annotation just
&gt; on parameters and return types.

that's a reasonable choice

&gt; Therefore I will try to create a sample project for you, but it may take
&gt; some time to do that (I tested the other samples inside an existing internal
&gt; library project).

thanks</comment_text>
        </comment>
        <comment>
            <comment_id>2726170</comment_id>
            <comment_count>8</comment_count>
            <who>Sebastian Baumhekel</who>
            <commenter_username>sebastian.baumhekel</commenter_username>
            <when>2016-07-01 02:23:40 -0400</when>
            <comment_text>Yes, but I try to keep this code concise and I do synchronization of the assignment and accesses, so there is no need to pull the instance variable in a local variable.
This is just a source of bugs if you consider this case:
----
	  class Local{
		int a;
		
		void test()
		{
			//pull the instance variable into a local one
			int a2=this.a;
			//...do something in between...
			//adjust the variable for the next run
			a2++;
			//and just forgetting to store it back in the instance!
			//this.a=a2;
		}
	  }
----
For a short function you might spot the mistake, for a larger one you are out of luck...
So it might be a good workaround, but it is definitely not for me ;-)

So for the example project:
I just tried to create a simple Java project, but there it works.
Also a maven dependency seems to work.

Basically I tracked it down to the fact that if you select "Use default annotations for null specifications" is checked, everything works fine (excluding fields as expected).
But if you change the null annotations of @Nullable and @NonNull to the JDK ones and still leave the @NonNullByDefault annotation on "org.eclipse.jdt.annotation.NonNullByDefault", it does no more not respect the parameters of @NonNullByDefault.
And I explicitly need to exclude fields as there actually are fields, which get set up by another framework (UiBinder of GWT) - and they are guaranteed to be never null after construction or construction will fail at all.

I am a fan of the standard annotations as they are actually also respected by other tools like FindBugs.
Though unfortunately there is nothing for "parameters and return types are non null by default" in the JDK.</comment_text>
        </comment>
        <comment>
            <comment_id>2726653</comment_id>
            <comment_count>9</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-03 18:09:43 -0400</when>
            <comment_text>(In reply to Sebastian Baumhekel from comment #8)
&gt; Basically I tracked it down to the fact that if you select "Use default
&gt; annotations for null specifications" is checked, everything works fine
&gt; (excluding fields as expected).
&gt; But if you change the null annotations of @Nullable and @NonNull to the JDK
&gt; ones and still leave the @NonNullByDefault annotation on
&gt; "org.eclipse.jdt.annotation.NonNullByDefault", it does no more not respect
&gt; the parameters of @NonNullByDefault.

Yes, with this configuration I can reproduce. Thanks!

Without having debugged this, my gut feeling is: this combination is broken because org.eclipse.jdt.annotation.NonNullByDefault in version 2.x expects NonNull and Nullable to be type annotations (@Target(TYPE_USE) whereas those you used are "old" declaration annotations (or even worse, I have seen variants of them that don't even specify a @Target).
It that guess is correct, we should report this somehow to the user ...


&gt; I am a fan of the standard annotations as they are actually also respected
&gt; by other tools like FindBugs.

The question, which annotations to use, has been discussed in several forums. See, e.g., http://stackoverflow.com/questions/35892063/which-nonnull-java-annotation-to-use/35896657 where Michael Ernst, spec lead of JSR 308 (type annotations), has given a good answer on the notion of "standard annotations".</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497096</id>
        <developer>Yauheniy Ratkevich</developer>
        <developer_username>evser11</developer_username>
        <dup_id/>
        <creation_time>2016-06-30 09:47:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Field name proposal</short_desc>
        <thetext>Eclipse proposes for me class name instead of a field name.


-- Configuration Details --
Product: Eclipse 4.6.0.20160613-1800 (org.eclipse.epp.package.jee.product)
Installed Features:
 org.eclipse.jdt 3.12.0.v20160606-1100</thetext>
        <comment>
            <comment_id>2725917</comment_id>
            <comment_count>1</comment_count>
            <who>Yauheniy Ratkevich</who>
            <commenter_username>evser11</commenter_username>
            <when>2016-06-30 09:48:13 -0400</when>
            <comment_text>Created attachment 262831
screenshot

See the screenshot that clarifies everything.</comment_text>
        </comment>
        <comment>
            <comment_id>2725928</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-30 09:55:39 -0400</when>
            <comment_text>I don't think we ever propose field names, method names or things like that. What you see is just a list of types that are available in this context, not necessarily useful there.

Noopur, can you confirm please?</comment_text>
        </comment>
        <comment>
            <comment_id>2725941</comment_id>
            <comment_count>3</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-06-30 10:11:31 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #2)
&gt; I don't think we ever propose field names, method names or things like that.
&gt; What you see is just a list of types that are available in this context, not
&gt; necessarily useful there.
&gt; 
&gt; Noopur, can you confirm please?

We propose field names of kind org.eclipse.jdt.core.CompletionProposal.VARIABLE_DECLARATION.

@Yauheniy, can you please provide a standalone example to reproduce the bug?</comment_text>
        </comment>
        <comment>
            <comment_id>2725951</comment_id>
            <comment_count>4</comment_count>
            <who>Yauheniy Ratkevich</who>
            <commenter_username>evser11</commenter_username>
            <when>2016-06-30 10:42:46 -0400</when>
            <comment_text>(In reply to Noopur Gupta from comment #3)
&gt; (In reply to Jay Arthanareeswaran from comment #2)
&gt; &gt; I don't think we ever propose field names, method names or things like that.
&gt; &gt; What you see is just a list of types that are available in this context, not
&gt; &gt; necessarily useful there.
&gt; &gt; 
&gt; &gt; Noopur, can you confirm please?
&gt; 
&gt; We propose field names of kind
&gt; org.eclipse.jdt.core.CompletionProposal.VARIABLE_DECLARATION.
&gt; 
&gt; @Yauheniy, can you please provide a standalone example to reproduce the bug?

What do you mean "standalone"?

Just start typing field declaration:
private MyClass [here something commmon, that spells like any class and press CTRL+SPACE and you will see that it proposes for you class names].

BUT!! If I type it with semicolon - everything works fine! But who will type semicolon first and then field name?
private MyClass ;|
//move your cursor
private MyClass |;
//start typing and press ctrl+space, it works and proposes "myClass/class/etc."


Is it clear for you? Try it yourself and you will understand, what I'm talking about.</comment_text>
        </comment>
        <comment>
            <comment_id>2725953</comment_id>
            <comment_count>5</comment_count>
            <who>Yauheniy Ratkevich</who>
            <commenter_username>evser11</commenter_username>
            <when>2016-06-30 10:45:20 -0400</when>
            <comment_text>(In reply to Noopur Gupta from comment #3)
&gt; (In reply to Jay Arthanareeswaran from comment #2)
&gt; &gt; I don't think we ever propose field names, method names or things like that.
&gt; &gt; What you see is just a list of types that are available in this context, not
&gt; &gt; necessarily useful there.
&gt; &gt; 
&gt; &gt; Noopur, can you confirm please?
&gt; 
&gt; We propose field names of kind
&gt; org.eclipse.jdt.core.CompletionProposal.VARIABLE_DECLARATION.
&gt; 
&gt; @Yauheniy, can you please provide a standalone example to reproduce the bug?

See the screenshot. It should propose for me "localizationService" in this case.

I saw this problem not only in this specific project and even in the previous versions of Eclipse.</comment_text>
        </comment>
        <comment>
            <comment_id>2726025</comment_id>
            <comment_count>6</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-30 12:17:48 -0400</when>
            <comment_text>Just to second Noopur's request for a "standalone example": when I have this in my editor:

//---
public class FieldCompletion {
	private FieldCompletion |
}
//---

and hit Ctrl+Space I get the to expected proposals "completion" and "fieldCompletion".

So, perhaps s.t. is different in your context, perhaps s.t. at some location of your file which you are not showing. Can you please show an entire file? If that doesn't let us reproduce we will ask about a self-contained project etc. ...</comment_text>
        </comment>
        <comment>
            <comment_id>2726462</comment_id>
            <comment_count>7</comment_count>
            <who>Yauheniy Ratkevich</who>
            <commenter_username>evser11</commenter_username>
            <when>2016-07-01 14:46:13 -0400</when>
            <comment_text>Created attachment 262865
STEP BY STEP Screenshots</comment_text>
        </comment>
        <comment>
            <comment_id>2726463</comment_id>
            <comment_count>8</comment_count>
            <who>Yauheniy Ratkevich</who>
            <commenter_username>evser11</commenter_username>
            <when>2016-07-01 14:48:08 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #6)
&gt; Just to second Noopur's request for a "standalone example": when I have this
&gt; in my editor:
&gt; 
&gt; //---
&gt; public class FieldCompletion {
&gt; 	private FieldCompletion |
&gt; }
&gt; //---
&gt; 
&gt; and hit Ctrl+Space I get the to expected proposals "completion" and
&gt; "fieldCompletion".
&gt; 
&gt; So, perhaps s.t. is different in your context, perhaps s.t. at some location
&gt; of your file which you are not showing. Can you please show an entire file?
&gt; If that doesn't let us reproduce we will ask about a self-contained project
&gt; etc. ...

See attachments.
It reproduces when you have any method below this field and if you typing without a semicolon.</comment_text>
        </comment>
        <comment>
            <comment_id>2726490</comment_id>
            <comment_count>9</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-01 18:40:20 -0400</when>
            <comment_text>OK, all it takes to reproduce the problem is this:

//---
public class Main {
	private LinkageError |
	
	@Override
	public String toString() {
		return "";
	}
}
//---

(sreenshots aren't really the best way to share Java code...)


And here's what makes the difference between attachment 262831, comment 6 on the one hand and successful reproduction of the problem on the other hand: *when followed by an annotated method declaration* the incomplete field declaration is somehow understood as part of the subsequent method declaration. To witness: toString() has this error:

The method toString in type Main can only set one of public / protected / private

Now, while the field declaration is incomplete we obviously have a syntax error. Code completion depends on smart recovery at that error. Things work fine even with an unannotated method declaration, only when also adding the annotation, syntax recovery gets confused.

Technically, we seem to end up seeing a list of modifiers:
  private LinkageError @Override public

most of this is *syntactically OK*, only one token, LinkageError, is syntactically wrong, so dropping this single token is the simplest recovery. After such error recovery there is no hint anymore that completion should produce a field name.


I'm not sure if tweaking the heuristics of syntax recovery for this case is feasible. OTOH, the fact that the @Override annotations makes the difference between desired and undesired recovery could give a hint.


Last note: even in the bad case I see only one class name proposed: Main. That is: part of the problem can still not be reproduced just by following the steps. Not sure if this is worth pursuing.</comment_text>
        </comment>
        <comment>
            <comment_id>2726540</comment_id>
            <comment_count>10</comment_count>
            <who>Yauheniy Ratkevich</who>
            <commenter_username>evser11</commenter_username>
            <when>2016-07-02 08:56:30 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #9)
&gt; OK, all it takes to reproduce the problem is this:
&gt; 
&gt; //---
&gt; public class Main {
&gt; 	private LinkageError |
&gt; 	
&gt; 	@Override
&gt; 	public String toString() {
&gt; 		return "";
&gt; 	}
&gt; }
&gt; //---
&gt; 
&gt; (sreenshots aren't really the best way to share Java code...)
&gt; 
&gt; 
&gt; And here's what makes the difference between attachment 262831 [details],
&gt; comment 6 on the one hand and successful reproduction of the problem on the
&gt; other hand: *when followed by an annotated method declaration* the
&gt; incomplete field declaration is somehow understood as part of the subsequent
&gt; method declaration. To witness: toString() has this error:
&gt; 
&gt; The method toString in type Main can only set one of public / protected /
&gt; private
&gt; 
&gt; Now, while the field declaration is incomplete we obviously have a syntax
&gt; error. Code completion depends on smart recovery at that error. Things work
&gt; fine even with an unannotated method declaration, only when also adding the
&gt; annotation, syntax recovery gets confused.
&gt; 
&gt; Technically, we seem to end up seeing a list of modifiers:
&gt;   private LinkageError @Override public
&gt; 
&gt; most of this is *syntactically OK*, only one token, LinkageError, is
&gt; syntactically wrong, so dropping this single token is the simplest recovery.
&gt; After such error recovery there is no hint anymore that completion should
&gt; produce a field name.
&gt; 
&gt; 
&gt; I'm not sure if tweaking the heuristics of syntax recovery for this case is
&gt; feasible. OTOH, the fact that the @Override annotations makes the difference
&gt; between desired and undesired recovery could give a hint.
&gt; 
&gt; 
&gt; Last note: even in the bad case I see only one class name proposed: Main.
&gt; That is: part of the problem can still not be reproduced just by following
&gt; the steps. Not sure if this is worth pursuing.


"sreenshots aren't really the best way to share Java code..." 
I'm sorry, just wanted to show you position of cursor and popup window as is.


Nevertheless it's not the right way to interpret it.
&gt; Technically, we seem to end up seeing a list of modifiers:
&gt;   private LinkageError @Override public

I think if it takes not really much time, it's really a good idea to fix it. This behaviour is unexpeceted. 

BTW: It reproduces also when field is followed by annotated another one.

	private Exception exc| //HERE THE SAME, wrong completion.
	
	@Deprecated
	private LinkageError linkageError;</comment_text>
        </comment>
        <comment>
            <comment_id>2726541</comment_id>
            <comment_count>11</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-02 09:30:54 -0400</when>
            <comment_text>(In reply to Yauheniy Ratkevich from comment #10)
&gt; Nevertheless it's not the right way to interpret it.
&gt; &gt; Technically, we seem to end up seeing a list of modifiers:
&gt; &gt;   private LinkageError @Override public
&gt; 
&gt; I think if it takes not really much time, it's really a good idea to fix it.
&gt; This behaviour is unexpeceted. 

Let me just note, that this is not the explicit decision of any engineer to interpret the broken syntax as shown. It's the answer from a sophisticated heuristic-based algorithm. Tweaking that algorithm is a very delicate issue, so "if it takes not really much time" is s.t. we cannot know in advance.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497118</id>
        <developer>Stefan Xenos</developer>
        <developer_username>sxenos</developer_username>
        <dup_id/>
        <creation_time>2016-06-30 14:47:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Add the new index test cases to the main JUnit suite</short_desc>
        <thetext>The unit tests for the new index currently aren't running as part of the main suite. We should enable them so they run as part of the regular regression tests.</thetext>
    </bug>
    <bug>
        <id>497142</id>
        <developer>Yauheniy Ratkevich</developer>
        <developer_username>evser11</developer_username>
        <dup_id/>
        <creation_time>2016-07-01 06:32:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Make ability to not propose class names from a non-capital letter.</short_desc>
        <thetext>Make ability to not propose class names from a non-capital letter.
For example do not propose class with such names: "mySystemClass".


-- Configuration Details --
Product: Eclipse 4.6.0.20160613-1800 (org.eclipse.epp.package.jee.product)
Installed Features:
 org.eclipse.jdt 3.12.0.v20160606-1100</thetext>
        <comment>
            <comment_id>2726449</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-01 13:39:38 -0400</when>
            <comment_text>Are you requesting this as a filter for completion (Ctrl+Space)?
If so, why should classes with such names not be referenced?
Isn't the creation of such classes the problem, not referencing?</comment_text>
        </comment>
        <comment>
            <comment_id>2726456</comment_id>
            <comment_count>2</comment_count>
            <who>Yauheniy Ratkevich</who>
            <commenter_username>evser11</commenter_username>
            <when>2016-07-01 14:17:33 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #1)
&gt; Are you requesting this as a filter for completion (Ctrl+Space)?
&gt; If so, why should classes with such names not be referenced?
&gt; Isn't the creation of such classes the problem, not referencing?

I don't mean to forbid referencing to such classes forever, I mean just to have an ability to do it.
I'll explain: I have one project which has really lots of dependencies and lots of SYSTEM classes are starting from a lower case (not like Java convention). They are named in a such way, because they are low-level or working with some hardware or just not intended to work with them.
(see attchments).</comment_text>
        </comment>
        <comment>
            <comment_id>2726457</comment_id>
            <comment_count>3</comment_count>
            <who>Yauheniy Ratkevich</who>
            <commenter_username>evser11</commenter_username>
            <when>2016-07-01 14:18:41 -0400</when>
            <comment_text>Created attachment 262863
Example</comment_text>
        </comment>
        <comment>
            <comment_id>2726458</comment_id>
            <comment_count>4</comment_count>
            <who>Yauheniy Ratkevich</who>
            <commenter_username>evser11</commenter_username>
            <when>2016-07-01 14:19:00 -0400</when>
            <comment_text>Created attachment 262864
Example2</comment_text>
        </comment>
        <comment>
            <comment_id>2726711</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-07-04 04:02:38 -0400</when>
            <comment_text>You have probably thought about this, if not you should explore other ways of filtering those out, perhaps they all come from particular packages so they can 'not' be proposed? Just thinking aloud.</comment_text>
        </comment>
        <comment>
            <comment_id>2726723</comment_id>
            <comment_count>6</comment_count>
            <who>Yauheniy Ratkevich</who>
            <commenter_username>evser11</commenter_username>
            <when>2016-07-04 04:32:17 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #5)
&gt; You have probably thought about this, if not you should explore other ways
&gt; of filtering those out, perhaps they all come from particular packages so
&gt; they can 'not' be proposed? Just thinking aloud.

There are many packages that contains such classes. Of course I may filter such classes just by adding filter: [a-z]*
But it's just my small proposal...</comment_text>
        </comment>
        <comment>
            <comment_id>2726725</comment_id>
            <comment_count>7</comment_count>
            <who>Yauheniy Ratkevich</who>
            <commenter_username>evser11</commenter_username>
            <when>2016-07-04 04:33:15 -0400</when>
            <comment_text>(In reply to Yauheniy Ratkevich from comment #6)
&gt; (In reply to Jay Arthanareeswaran from comment #5)
&gt; &gt; You have probably thought about this, if not you should explore other ways
&gt; &gt; of filtering those out, perhaps they all come from particular packages so
&gt; &gt; they can 'not' be proposed? Just thinking aloud.
&gt; 
&gt; There are many packages that contains such classes. Of course I may filter
&gt; such classes just by adding filter: [a-z]*
&gt; But it's just my small proposal...

Here I should add 26 (a-z) filters, because Type Filter field doesn't support regexp value.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497146</id>
        <developer>Sandor Pinter</developer>
        <developer_username>sandor.pinter</developer_username>
        <dup_id/>
        <creation_time>2016-07-01 07:59:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[javadoc] Problem with some tag names containing dots and digits</short_desc>
        <thetext>Try to format the following java class with the default eclipse formatter:

package codeFormat;

public class test {

	/**
	 * Test comment
	 * 
	 * @response.representation.200.doc test doc
	 * @response.representation.200.example test example
	 */
 	public void test()  {
	}
	
}

After code formatting, the tag '@response.representation.200.example' is moved to the end of the previous line:

	/**
	 * Test comment
	 * 
	 * @response.representation.200.doc test
	 *                                  doc @response.representation.200.example
	 *                                  test example
	 */

Expected: the formatting should not change the layout at all.
Because the tag is not at the beginning of the line, the code generators (WADL in this case) which relies on these tags won't realize that tag, the tag will be the part of the provious tag's value</thetext>
        <comment>
            <comment_id>2726317</comment_id>
            <comment_count>1</comment_count>
            <who>Sandor Pinter</who>
            <commenter_username>sandor.pinter</commenter_username>
            <when>2016-07-01 08:02:45 -0400</when>
            <comment_text>Created attachment 262851
BeforeFormatting</comment_text>
        </comment>
        <comment>
            <comment_id>2726318</comment_id>
            <comment_count>2</comment_count>
            <who>Sandor Pinter</who>
            <commenter_username>sandor.pinter</commenter_username>
            <when>2016-07-01 08:03:50 -0400</when>
            <comment_text>Created attachment 262852
AfterFormatting</comment_text>
        </comment>
        <comment>
            <comment_id>2726321</comment_id>
            <comment_count>3</comment_count>
            <who>Sandor Pinter</who>
            <commenter_username>sandor.pinter</commenter_username>
            <when>2016-07-01 08:06:06 -0400</when>
            <comment_text>I have attached two files to this bug. One (BeforeFormatting) is basically the expected layout of the file, and the second one (AfterFormatting) is the file content after the formatting of the file is done. There should be no differences between the two files</comment_text>
        </comment>
        <comment>
            <comment_id>2726596</comment_id>
            <comment_count>4</comment_count>
            <who>Mateusz Matela</who>
            <commenter_username>mateusz.matela</commenter_username>
            <when>2016-07-03 08:20:55 -0400</when>
            <comment_text>The actual problem is in the javadoc compiler - it doesn't recognize these tags properly (hover over the method name to see a tooltip with the broken javadoc description).
Interestingly, it works fine with tags containing dots and digits, bug fails if there's a dot followed directly by a digit.</comment_text>
        </comment>
        <comment>
            <comment_id>2726692</comment_id>
            <comment_count>5</comment_count>
            <who>Sandor Pinter</who>
            <commenter_username>sandor.pinter</commenter_username>
            <when>2016-07-04 03:10:31 -0400</when>
            <comment_text>Created attachment 262884
BeforeFormatting2</comment_text>
        </comment>
        <comment>
            <comment_id>2726693</comment_id>
            <comment_count>6</comment_count>
            <who>Sandor Pinter</who>
            <commenter_username>sandor.pinter</commenter_username>
            <when>2016-07-04 03:11:06 -0400</when>
            <comment_text>Created attachment 262885
AfterFormatting2</comment_text>
        </comment>
        <comment>
            <comment_id>2726694</comment_id>
            <comment_count>7</comment_count>
            <who>Sandor Pinter</who>
            <commenter_username>sandor.pinter</commenter_username>
            <when>2016-07-04 03:13:34 -0400</when>
            <comment_text>Please see the last attachements. The rule when it does not work is not so simple, as in most of the cases it works fine. It seems, it does not work if the the number and a dot is followed by the letter 'e', or 'd'.</comment_text>
        </comment>
        <comment>
            <comment_id>2726717</comment_id>
            <comment_count>8</comment_count>
            <who>Mateusz Matela</who>
            <commenter_username>mateusz.matela</commenter_username>
            <when>2016-07-04 04:10:04 -0400</when>
            <comment_text>(In reply to Sandor Pinter from comment #7)
&gt; It seems, it does not work if
&gt; the the number and a dot is followed by the letter 'e', or 'd'.

Now I see it's even weirder than that. Some examples:
@aaa.aa.2.c - OK
@aaa.aa.2.d - WRONG
@aaa.aa.2.e - WRONG
@aaa.aa.2.f - WRONG
@aaa.aa.2.g - OK

@aaa.a.2.d - OK
@aa.aa.2.d - WRONG
@aaaaa.2.d - OK
@a.a.aa.2.d - WRONG
@a.a.a..a.2.d - WRONG
@a.a...a.2.d - OK</comment_text>
        </comment>
        <comment>
            <comment_id>2733837</comment_id>
            <comment_count>9</comment_count>
            <who>Sandor Pinter</who>
            <commenter_username>sandor.pinter</commenter_username>
            <when>2016-07-26 11:02:40 -0400</when>
            <comment_text>One more comment what I have realized:
Under Preferences/Java/Editor/Save Action I have enabled 'Format edited lines' under the 'Format source code' action. If this save action was selected, Eclipse re-formats the lines which contains the problematic tags, even if I don't edit those lines.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497183</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-07-02 14:11:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>overload resolution wrongly applies erasure (?)</short_desc>
        <thetext>See https://bugs.openjdk.java.net/browse/JDK-8148464 for a situation that ecj accepts, while according to Dan ambiguity should be reported.

Here's the example:
//---
public interface GenericInterface&lt;V&gt; {
  void setValue(V value);
}
public interface TypedInterface {
  void setValue(Boolean value);
}
public interface CombinedInterface extends GenericInterface&lt;Boolean&gt;, TypedInterface {
  default void set(boolean value) {
    setValue(Boolean.valueOf(value));
  }
} 
//---

both methods *would* collapse to being the same method, if generic instantiations should be used. However, 15.12.2.5 requires comparison of erasures instead.
- more than one maximally specific method (both are setValue(Boolean)),
- different erasures (setValue(Boolean) vs. setValue(Object))
=&gt; ambiguity

I don't have an intuitive explanation why this code is not kosher, but we should comply with JLS.</thetext>
    </bug>
    <bug>
        <id>497354</id>
        <developer>Edward Poot</developer>
        <developer_username>edwardmp</developer_username>
        <dup_id/>
        <creation_time>2016-07-05 17:31:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>ArrayIndexOutOfBoundsException in ParameterizedGenericMethodBinding.java</short_desc>
        <thetext>I'm encountering the following ArrayIndexOutOfBoundsException using JDT Core 3.12.0.v20160516-2131

SEVERE: Servlet.service() for servlet [Jersey Web Application] in context with path [/aevas] threw exception [java.lang.ArrayIndexOutOfBoundsException: -1] with root cause
java.lang.ArrayIndexOutOfBoundsException: -1
        at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod18(ParameterizedGenericMethodBinding.java:214)
        at org.eclipse.jdt.internal.compiler.ast.MessageSend.isCompatibleWith(MessageSend.java:991)
        at org.eclipse.jdt.internal.compiler.lookup.ConstraintExpressionFormula.reduce(ConstraintExpressionFormula.java:69)
        at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:949)
        at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.reduce(InferenceContext18.java:870)
        at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.solve(InferenceContext18.java:821)
        at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod18(ParameterizedGenericMethodBinding.java:238)
        at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:84)
        at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:743)
        at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
        at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
        at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
        at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:697)
        at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:684)
        at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:636)
        at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:636)
        at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
        at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
        at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
        at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
        at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
        at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:867)
        at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1016)
        at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:639)
        at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:993)
        at eu.sig.aevas.invokedlibrarymethods.java.InvokedLibraryMethodsExtractorJava.createASTForSourceFile(InvokedLibraryMethodsExtractorJava.java:58)

I am narrowing done the exact source code parsed and will update this message with more info to reproduce the issue.</thetext>
    </bug>
    <bug>
        <id>497417</id>
        <developer>Xuanchi Yu</developer>
        <developer_username>yuxuanchiadm</developer_username>
        <dup_id/>
        <creation_time>2016-07-06 13:50:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][compiler][inference] Eclipse 4.6 generics bug cause CCE</short_desc>
        <thetext>Code to reproduce bug:

class JavaGenericsBug {
	static class A&lt;T&gt; {
		T t;

		A() {

		}

		A(T t) {
			this.t = t;
		}
	}

	static class B&lt;T1 extends A&lt;T2&gt;, T2&gt; {
		T1 t1;

		B(T1 t1, T2 t2) {
			this.t1 = t1;
			this.t1.t = t2;
		}

		&lt;NT2&gt; B&lt;T1, NT2&gt; copyTo(NT2 nt2) {
			return new B&lt;T1, NT2&gt;(t1, nt2);
		}
	}

	public static void main(String args[]) {
		B&lt;A&lt;Integer&gt;, Integer&gt; b = new B&lt;A&lt;Integer&gt;, Integer&gt;(new A&lt;Integer&gt;(), 12450);
		Integer boom = b.copyTo("BOOM!!").t1.t;
		System.out.print(boom);
	}
}

Code on top will cause ClassCastException with no any type cast. And can be compiled without warning.</thetext>
        <comment>
            <comment_id>2728014</comment_id>
            <comment_count>1</comment_count>
            <who>Xuanchi Yu</who>
            <commenter_username>yuxuanchiadm</commenter_username>
            <when>2016-07-06 14:05:12 -0400</when>
            <comment_text>This is clearly to understand what happened. When try to give a type variable a wildcard type. Compiler dose not fully check the type of wildcard. On this example. Compiler dose not checked whether the wildcard type is compatible with another type variable if them have constraint.</comment_text>
        </comment>
        <comment>
            <comment_id>2728278</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-07 07:16:52 -0400</when>
            <comment_text>Interesting, T1, when used as a type argument, is not within the bound of T1, when seen as a type parameter.

This is not a regression, ecj accepts this code ever since the introduction of generics.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497473</id>
        <developer>Miroslav Petrovic</developer>
        <developer_username>black.uprise</developer_username>
        <dup_id/>
        <creation_time>2016-07-07 06:41:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Ctrl + Shift + T doesnt work when any js file is opened in editor</short_desc>
        <thetext>Ctrl + Shit + T  (lookup of the class)

doesnt work when any js file is opened in editor</thetext>
        <comment>
            <comment_id>2753193</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-20 08:29:58 -0400</when>
            <comment_text>Which perspective?</comment_text>
        </comment>
        <comment>
            <comment_id>2753443</comment_id>
            <comment_count>2</comment_count>
            <who>Miroslav Petrovic</who>
            <commenter_username>black.uprise</commenter_username>
            <when>2016-09-20 15:27:11 -0400</when>
            <comment_text>In Java perspective</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497599</id>
        <developer>Liam Miller-Cushon</developer>
        <developer_username>cushon</developer_username>
        <dup_id/>
        <creation_time>2016-07-09 01:36:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Custom CodeFormatter and snippet javadoc formatting</short_desc>
        <thetext>Created attachment 262997
A CodeFormatter plugin that demonstrates the issue

The CodeFormatter extension point doesn't support making non-whitespace changes to javadoc when formatting snippets.

For example, when the `Generate Constructor using Fields...` refactoring is run with generated javadoc enabled, it formats a snippet like:

```
/**
 */public Hello(int x){super();this.x=x;}
```

And then rewrites the leading "/**\n */" to include the appropriate `@param` tags as a second step.

If a custom CodeFormatter changes the leading "/**\n */", e.g. to:

```
/**
 *
 */
```

Then the location of the leading comment is lost, and the generated javadoc defaults to being inserted at the end of the snippet.

Is this a bug? I expected the snippet formatting logic to tolerate non-whitespace changes inside javadoc.

Demo:

The attached zip file contains a CodeFormatter implementation that does nothing but rewrite leading "/**\n */" comments.

* extract codeformatterdemo.zip and open the project
* run it as an Eclipse Application
* create a Java project, and add a simple class:

```
public class Hello {
int x;
}
```

* enable the custom formatter: Java &gt; Code Style &gt; Formatter &gt; Formatter implementation &gt; Demo Java Formatter
* select the class name and run: Source &gt; Generate Constructor using Fields...
* check `Generate constructor comments`

```
public class Hello {
/**
 *
 */public Hello(int x){super();this.x=x;}/**
 * @param x
 */

int x;
}
```</thetext>
    </bug>
    <bug>
        <id>497609</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-07-09 16:02:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Stop marking anonymous classes as final when JDK-8161009 is resolved</short_desc>
        <thetext>In https://bugs.openjdk.java.net/browse/JDK-8161009 Dan surprisingly proposed to drop a useful line from the spec in favor of long standing behavior of javac (and ecj).

When JDK-8161009 is resolved we should then stop internally marking anonymous classes as final. 

While focus in related JDK-bugs is on not incompatibly changing serialization, in my understanding this will also affect castability, i.e., the JLS change will likely imply that this bogus program:

//---
class Test231 implements Test231i {
  void foo() {
    new Object() {
      Test231i bar() {
        return (Test231i)this;
      }
    };
  }
}

interface Test231i { }
//---

should be accepted. Currently we correctly report:

----------
1. ERROR in /tmp/Test231.java (at line 10)
        return (Test231i)this;
               ^^^^^^^^^^^^^^
Cannot cast from new Object(){} to Test231i
----------

Also javac rejects this program.

Let's watch the discussion in JDK-8161009</thetext>
    </bug>
    <bug>
        <id>497718</id>
        <developer>Yosef Bart</developer>
        <developer_username>ybart90</developer_username>
        <dup_id/>
        <creation_time>2016-07-11 20:39:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Calling private static method from subclass instance overload</short_desc>
        <thetext>abstract class Test {
    
    private static void bar(int arg) {
    }

    abstract void bar();
    
    static class Foo extends Test {
        @Override
        void bar() {
            bar(1);
        }
    }
}

The above snippet compiles in eclipse, but throws the following error in javac (1.8.0_65-b17):

error: no suitable method found for bar(int)
            bar(1);
            ^
    method Test.bar() is not applicable
      (actual and formal argument lists differ in length)
    method Foo.bar() is not applicable
      (actual and formal argument lists differ in length)

I'm not sure which behavior is correct.</thetext>
        <comment>
            <comment_id>2729705</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-12 06:29:03 -0400</when>
            <comment_text>Thanks for the test case.

If you qualify the method call like this:
   Test.bar(1);
also javac will agree that this method is accessible.

It seems to be an issue of shadowing not detected by ecj, read: if Foo.bar() shadows Test.bar(int) then the latter cannot be referred to using the simple name "bar". 

I don't think that inheritance plays a role here (private methods are never inherited). If it were a case of inheritance, we'd be speaking of hiding of an inherited static method by an instance method, for which I don't readily see any rule in the spec.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497849</id>
        <developer>Tobias Gierke</developer>
        <developer_username>tobias.gierke</developer_username>
        <dup_id/>
        <creation_time>2016-07-13 11:30:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Code compiles in eclipse but fails to compile in Oracle JDK (incompatible types: inferred type does not conform to upper bound(s))</short_desc>
        <thetext>Created attachment 263092
Tiny Maven project showing the bug

The following code compiles fine in Eclipse Neon but fails to compile on Oracle JDK (tested with 1.8.65, 1.8.74 and 1.8.92) ; I attached a tiny Maven project that exhibits the bug.


---------------------------------------------------------------------

import junit.framework.TestCase;
import java.io.Serializable;
import java.util.Map;
import java.util.function.Function;

public class CompilerBug extends TestCase {

        public interface IServiceCheck {
                public enum Type { A,B }
        }

        public static class Host {}

        public static class Controller
        {
                public &lt;T&gt; T doWithCheckStates(Function&lt;Map&lt;Host, Map&lt;IServiceCheck.Type,Map&lt;String,Serializable&gt;&gt;&gt;,T&gt; visitor) {
                        return null;
                }
        }

        public void doStuff() {

                final Controller c = new Controller();
                final Host host = new Host();
                assertEquals( null , c.doWithCheckStates( state -&gt; state.get( host ) ) );</thetext>
        <comment>
            <comment_id>2730233</comment_id>
            <comment_count>1</comment_count>
            <who>Tobias Gierke</who>
            <commenter_username>tobias.gierke</commenter_username>
            <when>2016-07-13 11:31:47 -0400</when>
            <comment_text>Sorry, copy'paste swallowed two braces...this is the whole source:

-------------------------------------------
import junit.framework.TestCase;
import java.io.Serializable;
import java.util.Map;
import java.util.function.Function;

public class CompilerBug extends TestCase {

        public interface IServiceCheck {
                public enum Type { A,B }
        }

        public static class Host {}

        public static class Controller
        {
                public &lt;T&gt; T doWithCheckStates(Function&lt;Map&lt;Host, Map&lt;IServiceCheck.Type,Map&lt;String,Serializable&gt;&gt;&gt;,T&gt; visitor) {
                        return null;
                }
        }

        public void doStuff() {

                final Controller c = new Controller();
                final Host host = new Host();
                assertEquals( null , c.doWithCheckStates( state -&gt; state.get( host ) ) );
        }
}</comment_text>
        </comment>
        <comment>
            <comment_id>2730236</comment_id>
            <comment_count>2</comment_count>
            <who>Tobias Gierke</who>
            <commenter_username>tobias.gierke</commenter_username>
            <when>2016-07-13 11:40:20 -0400</when>
            <comment_text>Changing

assertEquals( null , c.doWithCheckStates( state -&gt; state.get( host ) ) );

to

assertEquals( (Object) null , c.doWithCheckStates( state -&gt; state.get( host ) ) );

fixes the compilation error.</comment_text>
        </comment>
        <comment>
            <comment_id>2730247</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-13 12:00:28 -0400</when>
            <comment_text>Do you have any indication, why rejecting should be the correct answer by the compiler?</comment_text>
        </comment>
        <comment>
            <comment_id>2730276</comment_id>
            <comment_count>4</comment_count>
            <who>Tobias Gierke</who>
            <commenter_username>tobias.gierke</commenter_username>
            <when>2016-07-13 14:09:33 -0400</when>
            <comment_text>Sorry for writing such a terse bug report, I was in a hurry to leave work :)

The compiler complains:

jdt_bug/src/main/java/CompilerBug.java:[26,57] incompatible types: inferred type does not conform to upper bound(s)
inferred: java.util.Map&lt;CompilerBug.IServiceCheck.Type,java.util.Map&lt;java.lang.String,java.io.Serializable&gt;&gt;
upper bound(s): java.lang.String,java.lang.Object

The ambiguity seems to be caused by the various overloaded assertEquals() methods in the JUnit base class.

According to Eclipse the failing line calls assertEquals(Object,Object) (which in absence of any type hint on the NULL value seems to make sense) but for some reason the JDK thinks it tries to call assertEquals(String,Object).</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497866</id>
        <developer>Paul Benedict</developer>
        <developer_username>pbenedict</developer_username>
        <dup_id/>
        <creation_time>2016-07-13 15:11:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] Rename default package to unnamed package</short_desc>
        <thetext>When creating a type in the wizard, if I blank out the package, the warning message states "The use of the default package is discouraged". However, what's being called the "default package" is a colloquialism. The JLS has always called it the "unnamed package". Provided below is a link to such wording in JLS 6 [1], but you can find it in any prior JLS too.

Since Java 9 is introducing the concept of an unnamed module [2], this is likely the right time to align terminology so both are "unnamed". Wherever "default package" displays in Eclipse (labels, tool tips, help, etc.), it should be replaced with "unnamed package".

[1] https://docs.oracle.com/javase/specs/jls/se6/html/packages.html#7.4.2
[2] http://openjdk.java.net/projects/jigsaw/spec/sotms/#the-unnamed-module</thetext>
        <comment>
            <comment_id>2731931</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-19 15:05:59 -0400</when>
            <comment_text>Likely, unless the following proposal gains traction: http://mail.openjdk.java.net/pipermail/jigsaw-dev/2016-July/008417.html</comment_text>
        </comment>
        <comment>
            <comment_id>2751288</comment_id>
            <comment_count>2</comment_count>
            <who>Wayne Beaton</who>
            <commenter_username>wayne</commenter_username>
            <when>2016-09-15 10:55:57 -0400</when>
            <comment_text>Is that package required? Can we just eliminate it and display the content as direct children of the source package?

I've always regarded the default package as something to avoid or a place to put quick hacks (though it's so easy to just specify a package in the wizard, I almost never do this). The module-info.java file in the Java 9 support is, however, something that a great many source folders will have as a fully correct and standard state; having that file in the "default" or "unnamed" package just feels weird (see Bug 501507).</comment_text>
        </comment>
        <comment>
            <comment_id>2751337</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-15 12:24:25 -0400</when>
            <comment_text>(In reply to Wayne Beaton from comment #2)
&gt; Is that package required? Can we just eliminate it and display the content
&gt; as direct children of the source package?

I believe we should separate two concerns here:

(1) compilation units (holding classes or interfaces) always belong to a package,
  "A compilation unit that has no package declaration is part of an unnamed package. " (JLS 7.4.2)

(2) module declarations happen to inhabit the same space but I see no mentioning of modules being members of a package. It seems that module-info is legally member of a package but that fact is never used in any specification. Instead the qualified name of a module is direct part of the module declaration.

For (1) I don't see any leeway, each type must indirectly (via the compilation unit) be member of a package. Note the fine print, that JLS allows for multiple unnamed packages (with no visibility between them), which further indicates that saying "the default package" is misleading to say the least.


Matters around (2) aren't sufficiently well defined atm to make any clear cut.

&gt; I've always regarded the default package as something to avoid or a place to
&gt; put quick hacks (though it's so easy to just specify a package in the
&gt; wizard, I almost never do this). The module-info.java file in the Java 9
&gt; support is, however, something that a great many source folders will have as
&gt; a fully correct and standard state; having that file in the "default" or
&gt; "unnamed" package just feels weird (see Bug 501507).

Source folder is not a concept of JLS, so if a compilation unit must be contained in something, legally it has to be a package. With many module-infos (for different modules) it no longer makes *any* sense to speak of *the default package*. Each module will have (at least) one unnamed package of its own.

Interestingly, while putting classes into an unnamed package is discouraged (aside from quick hacks as you mention), putting module-info.java into an unnamed package seems to be *recommended*.

As for the visualization, putting traditional compilation units into an unnamed package is good. For module-info.java we will probably make an exception and show it as a direct child of the source folder (thereby mildly violating that what may become the spec).</comment_text>
        </comment>
        <comment>
            <comment_id>2751345</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-15 12:40:42 -0400</when>
            <comment_text>Re-reading the "spec" for module declarations I found a few more glitches, see bug 501517.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497899</id>
        <developer>Jelle Raaijmakers</developer>
        <developer_username>jelle</developer_username>
        <dup_id/>
        <creation_time>2016-07-14 07:48:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Duplicate search results and broken linking with nested Maven modules</short_desc>
        <thetext>When searching in files of a Maven project with nested submodules, duplicate search results are shown. Also, "Link with Editor" in a hierarchical project layout breaks when selecting the search result from the parent module.

I've created a small test case to show the issue:
https://github.com/GMTA/eclipse-duplicate-search-results

To reproduce:
1. Clone the project mentioned above
2. Start Eclipse Neon in the JEE view in an empty workspace
3. Import both Maven modules into your workbench
4. Go to Search &gt; File... and search for the text "find me"
5. Observe the duplicate match: one for the submodule, and one for the parent project (issue #1)
6. Choose Projects Presentation &gt; Hierarchical
7. Enable Link with Editor
8. Double click on the result from the parent module
9. Observe that the associated file is not selected in the tree (issue #2)</thetext>
    </bug>
    <bug>
        <id>497905</id>
        <developer>Tomasz Stanczak</developer>
        <developer_username>tomasz</developer_username>
        <dup_id/>
        <creation_time>2016-07-14 08:43:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][compiler][inference] generics: 'method not applicable for the arguments', javac and ecj 1.7 are ok</short_desc>
        <thetext>During the migration of our code base from java 1.7 to 1.8 we've got an error message "The method ... is not applicable for the arguments" on several code locations, all following the same pattern in usage of generics. 

For a Minimal, Complete, and Verifiable example see below.

We are currently using mostly Eclipse Mars (4.5.2) on Windows 7, but could confirm the behavior with Neon (4.6), too. Javac as well as ecj with 1.7 compliance level can both compile our code without an error.

I have been reading through other defects marked as "1.8 compiler inference" but they all seem different:

* 430686 is verified fixed
* 440019 has to do with scalar types
* 492838, 448793 have to do with wildcards

Here is the example:

public class ComplexInterfaceTest {

  public static class Foo {}
  
  public interface Bar {
    void print();
  }

  public static class SubFooBar extends Foo implements Bar {
    public void print() {
      System.out.println(this.getClass().getSimpleName());
    }
  }
  
  public static class FooBar&lt;T extends Foo &amp; Bar&gt; {
    public static &lt;T extends Foo &amp; Bar&gt; FooBar&lt;T&gt; makeFooBar() {
      return new FooBar&lt;&gt;();
    }
    
    public void create(T value) {
      value.print();
      return;
    }
  }
  
  public static class Base&lt;T extends Foo&gt; {}
  
  public static class Subclass extends Base&lt;SubFooBar&gt; {
    public void doSomething(SubFooBar value) {
//      FooBar.&lt;SubFooBar&gt;makeFooBar().create(value);
      FooBar.makeFooBar().create(value);
    }
  }
  
  public static void main(String[] args) {
    new Subclass().doSomething(new SubFooBar());
  }
  
}

By switching the commented out lines in doSomething method I can make it compile, so I have a workaround. Still the error message seems not right, as the class SubFooBar extends Foo and implements Bar, so it fulfills the contract of "&lt;T extends Foo &amp; Bar&gt;", which is required in "&lt;T extends Foo &amp; Bar&gt; FooBar&lt;T&gt; makeFooBar()", so actually T IMO should be bound to SubFooBar.

So I think it might be worth a look, it seems like quite a few similar bugs in ecj could be resolved by today. It may as well be a bug in javac, which is interesting to know, too.

Because I may have missed or misunderstood some of the defects, as I can't always follow explanations based on details of inner workings of the ecj compiler, please bear with me.</thetext>
        <comment>
            <comment_id>2730640</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-14 15:14:39 -0400</when>
            <comment_text>Thanks for report and explanation.

I have no ready answer what's right or wrong in this case, but ...

(In reply to Tomasz Stanczak from comment #0)
&gt; By switching the commented out lines in doSomething method I can make it
&gt; compile, so I have a workaround. Still the error message seems not right, as
&gt; the class SubFooBar extends Foo and implements Bar, so it fulfills the
&gt; contract of "&lt;T extends Foo &amp; Bar&gt;", which is required in "&lt;T extends Foo &amp;
&gt; Bar&gt; FooBar&lt;T&gt; makeFooBar()", so actually T IMO should be bound to SubFooBar.

The last conclusion looks wrong to me.

This:
   FooBar.makeFooBar()
is a "standalone expression", since no target type exists to steer type inference. Everything right of the next '.' must be type checked *after* T has been inferred.

Just from looking at makeFooBar() a compiler cannot guess  T to stand for SubFooBar. Note that there may be arbitrary many classes in the world, that fullfil the bounds of T, so inference has to stick to the intersection type "Foo &amp; Bar".

It's the next part that needs further scrutiny: if T = "Foo &amp; Bar", why shouldn't 'value' of type SubFooBar be compatible to create's parameter?</comment_text>
        </comment>
        <comment>
            <comment_id>2730644</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-14 15:36:56 -0400</when>
            <comment_text>I see in http://stackoverflow.com/questions/38374408/java-8-generics-the-method-is-not-applicable-for-the-arguments-in-eclipse that Holger came to the same conclusion is my comment 1 :)</comment_text>
        </comment>
        <comment>
            <comment_id>2730762</comment_id>
            <comment_count>3</comment_count>
            <who>Tomasz Stanczak</who>
            <commenter_username>tomasz</commenter_username>
            <when>2016-07-15 03:50:38 -0400</when>
            <comment_text>Thank you for your effort! I take it that my reasoning was erroneous, yet the code should have been compiled nevertheless. That’s comforting :-). We’ll be looking into this issue at 4.7 again (or anytime you ask for it).</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498022</id>
        <developer>Stefan Ocke</developer>
        <developer_username>stefan.ocke</developer_username>
        <dup_id/>
        <creation_time>2016-07-17 11:07:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Annotation Processing: No type annotations returned for annotation values that are arrays of classes</short_desc>
        <thetext>Hello,

it's easier for me to directly point to the code that seems to be wrong. I try to eyplain the consequences afterwards:

In org.eclipse.jdt.internal.compiler.lookup.UnresolvedAnnotationBinding#getElementValuePairs , there is code which resolves UnresolvedReferenceBindings for annotation values that are classes:

Object value = pair.getValue();
if (value instanceof UnresolvedReferenceBinding) {
  pair.setValue(((UnresolvedReferenceBinding) value.
						resolve(this.env, false));}

However, here it is assumed, that the annotation value is single valued. but if the annotation value is an array, nothing gets resolved here.

This has in turn some consequences like getting an empty array when asking for the type annotations of those (unresolved) types.

A note aside:
I noticed this bug earlier (years ago. sorry for not reporting), but with Eclipse Neon (or earlier?) , it got worse for me.  It seems to me,in earlier versions, if the array only contained only one element it worked, since pair.getValue was not really an array then, but indeed an UnresolvedReferenceBinding.</thetext>
        <comment>
            <comment_id>2731232</comment_id>
            <comment_count>1</comment_count>
            <who>Stefan Ocke</who>
            <commenter_username>stefan.ocke</commenter_username>
            <when>2016-07-18 03:24:58 -0400</when>
            <comment_text>See here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/tree/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnresolvedAnnotationBinding.java#n53</comment_text>
        </comment>
        <comment>
            <comment_id>2731236</comment_id>
            <comment_count>2</comment_count>
            <who>Stefan Ocke</who>
            <commenter_username>stefan.ocke</commenter_username>
            <when>2016-07-18 03:34:32 -0400</when>
            <comment_text>I have just seen the following code comment there: 

"// do nothing for UnresolvedAnnotationBinding-s, since their
// content is only accessed through get* methods"

I am not sure what this means. Maybe it was expected here, that UnresolvedAnnotationBinding-s are in some wrapped list and get resolved when they are retrieved from this list.

However, this is not the case. They are an array and this array never gets resolved.

I should also mention that I did the debugging with BinaryTypeBindings. That is, the annotation and the annotation values classes are from some "other" project than the one where annotation processing takes place.

I am currently not sure if the same issue (or a different one) occurs in case of SourceTypeBindings.</comment_text>
        </comment>
        <comment>
            <comment_id>2733625</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-07-25 21:57:23 -0400</when>
            <comment_text>Not sure I can take this up during Oxygen, but will keep it on my radar.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498048</id>
        <developer>Juraj Wagner</developer>
        <developer_username>juraj.wagner</developer_username>
        <dup_id/>
        <creation_time>2016-07-18 06:38:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Imports not resolved correctly with generics and inner classes (v2)</short_desc>
        <thetext>Observed on:
Version: Neon Release (4.6.0)
Build id: 20160613-1800
Oracle JDK 1.8.0_92

Observed behavior:
After refactoring of classes we run into an issue that is very similar to that reported in #294057 with one alternation.

Take following example:

IModel.java

package model;
import model.IModel.IModelListener;
public interface IModel&lt;L extends IModelListener&gt; 
{
  public interface IModelListener {
  }
}

IListModel.java

package model;
import model.IListModel.IListModelListener;
public interface IListModel&lt;T&gt; extends IModel&lt;IListModelListener&gt;
{
  public interface IListModelListener extends IModelListener {
  }
}

The class IListModel is compiled by Eclipse but not by javac8:
  model/IListModel.java:[5,53] cannot find symbol
    symbol:   class IModelListener
    location: interface model.IListModel&lt;T&gt;

Adding the missing model.IModel.IModelListener import fixes the javac compilation issue with Eclipse viewing the import as unnecessary.

One additional quirk we have been observing for some time is that while in case of IListModel being not parametrized by &lt;T&gt; Eclipse is able to resolve the imports it does so every 2nd time, i.e. if odd invocations of Organize Imports add model.IModel.IModelListener import, even invocations remove it. Should this be report as a separate bug?</thetext>
        <comment>
            <comment_id>2731709</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-19 05:40:17 -0400</when>
            <comment_text>Do you have any hints on why we should reject that program?

Note that the following *is* accepted by javac, too:

//---
package model;
import model.IListModel.IListModelListener;
public interface IListModel&lt;T&gt; extends IModel&lt;IListModelListener&gt;
{
  public interface IListModelListener extends IModel.IModelListener {
  }
  IModelListener getListener();
}
//---

Two things shown:
(1) an import is not really needed, qualifying the inner with its outer (from same package) makes javac happy.
(2) in other positions like method return type also javac believes that IModelListener is visible in this scope.

With this in mind javac's error message in comment 0 seems to be the odd one out, if you ask me.


Yet another hint: alternatively, removing the type argument from "extends IModel" makes javac happy, too. For references to IModelListener the type argument of IModel should have no influence, since IModelListener as in interface is implicitly static and thus has no connection to IModel's type parameter.</comment_text>
        </comment>
        <comment>
            <comment_id>2732658</comment_id>
            <comment_count>2</comment_count>
            <who>Juraj Wagner</who>
            <commenter_username>juraj.wagner</commenter_username>
            <when>2016-07-21 10:03:30 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #1)
&gt; Do you have any hints on why we should reject that program?

The code sample in this report is in essence identical to that from bug #294057. Removing the type parameter &lt;T&gt; from the declaration of IListModel will result in Eclipse treating the missing import as an error. Why does the presence of the type parameter &lt;T&gt; make any difference?

Not knowing any better, I assume that the presence of the type parameter &lt;T&gt; must not make any difference. Thus unless #294057 is undone, Eclipse should reject the code.

&gt; Note that the following *is* accepted by javac, too:
&gt; 
&gt; //---
&gt; package model;
&gt; import model.IListModel.IListModelListener;
&gt; public interface IListModel&lt;T&gt; extends IModel&lt;IListModelListener&gt;
&gt; {
&gt;   public interface IListModelListener extends IModel.IModelListener {
&gt;   }
&gt;   IModelListener getListener();
&gt; }
&gt; //---
&gt; 
&gt; Two things shown:
&gt; (1) an import is not really needed, qualifying the inner with its outer
&gt; (from same package) makes javac happy.
&gt; (2) in other positions like method return type also javac believes that
&gt; IModelListener is visible in this scope.
&gt; 
&gt; With this in mind javac's error message in comment 0 seems to be the odd one
&gt; out, if you ask me.
&gt; 
&gt; 
&gt; Yet another hint: alternatively, removing the type argument from "extends
&gt; IModel" makes javac happy, too. For references to IModelListener the type
&gt; argument of IModel should have no influence, since IModelListener as in
&gt; interface is implicitly static and thus has no connection to IModel's type
&gt; parameter.

I took the time and read parts of the JLS. After reading §6.3 I do not understand why IModel.IModelListener in the interface body makes a difference, after all IModelListener is in scope of declaration of IListModel. Not seeing any other argument I agree with your assessment.

One more thing I would be happy to have explained is why in this case:

import model.IModel.IModelListener;
public interface IListModel extends IModel&lt;IListModel.IListModelListener&gt;
{
	public interface IListModelListener extends IModelListener {
	}
}

Eclipse requires the import of IModelListener. IModelListener is in scope of declaration of IListModel so a single-type-import declaration seems to be unnecessary.</comment_text>
        </comment>
        <comment>
            <comment_id>2733589</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-25 16:13:38 -0400</when>
            <comment_text>(In reply to Juraj Wagner from comment #2)
&gt; One more thing I would be happy to have explained is why in this case:
&gt; 
&gt; import model.IModel.IModelListener;
&gt; public interface IListModel extends IModel&lt;IListModel.IListModelListener&gt;
&gt; {
&gt; 	public interface IListModelListener extends IModelListener {
&gt; 	}
&gt; }
&gt; 
&gt; Eclipse requires the import of IModelListener. IModelListener is in scope of
&gt; declaration of IListModel so a single-type-import declaration seems to be
&gt; unnecessary.

Debugging that case it seems the reason for rejecting that variant is purely technical.

Details:
--------
ClassScope.findSuperType() is invoked for "IListModel extends IModel&lt;IListModelListener&gt;"

To resolve "IModel&lt;IListModelListener&gt;" we first need to resolve the type argument, i.e., invoke TypeReference.resolveTypeArgument() for "IListModelListener".

After finding the binding for "IListModelListener" we need to test for a hierarchy cycle, i.e., invoke ClassScope.detectHierarchyCycle() for "IListModelListener"

In this course we need to resolve the super types of "IListModelListener", i.e., "IModelListener".

During attempt to resolve "IModelListener" we navigate to the enclosing type "IListModel" and search its member types.

At this point, however, "IListModel" doesn't yet have any super types connected (this has just started in the first frame mentioned above). =&gt; Inherited member "IModelListener" is not found.

=&gt; Boom. 


Two things to check:
- Does JLS define a relationship between scoping and cycle detection, as our implementation has?

- If accepting is OK by JLS, then we may want to pull out the actual cycleChecking from resolving and defer it to the end of ClassScope.connectTypeHierarchy() or even later. See ClassScope#deferredBoundChecks for a related precedent.</comment_text>
        </comment>
        <comment>
            <comment_id>2739374</comment_id>
            <comment_count>4</comment_count>
            <who>Juraj Wagner</who>
            <commenter_username>juraj.wagner</commenter_username>
            <when>2016-08-11 13:45:12 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #3)

&gt; 
&gt; Two things to check:
&gt; - Does JLS define a relationship between scoping and cycle detection, as our
&gt; implementation has?

Sections 8.1.4., 9.1.3. define when a class depends on itself and that this is a compile-time error. I did not find a section that would define when a compiler is expected to detect such compile-time errors, i.e. what cycle detection must occur.

It would seem that this is left up to the implementer.

&gt; 
&gt; - If accepting is OK by JLS, then we may want to pull out the actual
&gt; cycleChecking from resolving and defer it to the end of
&gt; ClassScope.connectTypeHierarchy() or even later. See
&gt; ClassScope#deferredBoundChecks for a related precedent.

If what I wrote above is correct then the import is not required by the specification.

Worth noting is that javac in JDK 9 build 130 does no longer require import of IModelListener. This might be due to JEP 216: Process Import Statements Correctly.

One more comment (not sure whether this is known). While looking at JEP 216 I had a peek into JDK-8041994 and to my surprise Eclipse compiles to example, which seems to me to be in violation with JLS 8.1.4.</comment_text>
        </comment>
        <comment>
            <comment_id>2739376</comment_id>
            <comment_count>5</comment_count>
            <who>Juraj Wagner</who>
            <commenter_username>juraj.wagner</commenter_username>
            <when>2016-08-11 14:06:15 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #3)

Looking just on Eclipse's behavior I find it in following case inconsistent:

package model;
import model.IListModel.IListModelListener;
public interface IListModel&lt;T&gt; extends IModel&lt;IListModelListener&gt;
{
  public interface IListModelListener extends IModelListener {
  }
}

Why is the import of IModelListener not needed anymore? What has the parameter type T have to do with the resolution of IListModelListener?

When I compare this to:

import model.IModel.IModelListener;
public interface IListModel&lt;T&gt; extends IModel&lt;IListModel.IListModelListener&gt;
{
	public interface IListModelListener extends IModelListener {
	}
}

where the import is always required, my head explodes :)</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498053</id>
        <developer>Peter Vadasz</developer>
        <developer_username>P.Vadasz</developer_username>
        <dup_id/>
        <creation_time>2016-07-18 07:56:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Type mismatch in eclipse neon and java 1.8, while using generics, works in javac</short_desc>
        <thetext>I have created a deepcopy for ImmutableMap (from guava 19.0), the code compiles fine in javac but fails in neon. A bit more lightweight example with only Strings that still fails:

public static Map&lt;String, Map&lt;String, Map&lt;String, String&gt;&gt;&gt; deepCopy(Map&lt;String, Map&lt;String, Map&lt;String, String&gt;&gt;&gt; original) {
		return ImmutableMap.copyOf(Maps.transformValues(original, m -&gt;
				ImmutableMap.copyOf(Maps.transformValues(m,
						ImmutableMap::copyOf))));
	}

In neon the result:
Type mismatch: cannot convert from ImmutableMap&lt;String,Object&gt; to Map&lt;String,Map&lt;String,Map&lt;String,String&gt;&gt;&gt;

Strange that it works for two levels with similar copy, only fails on the third level, so this simply works in javac and neon too:
public static Map&lt;String, Map&lt;String, String&gt;&gt; compilingDeepCopy(Map&lt;String, Map&lt;String, String&gt;&gt; original) {
		return ImmutableMap.copyOf(Maps.transformValues(original,
						input -&gt; ImmutableMap.copyOf(input)));
	}</thetext>
    </bug>
    <bug>
        <id>498055</id>
        <developer>Christoph Schneegans</developer>
        <developer_username>christoph</developer_username>
        <dup_id/>
        <creation_time>2016-07-18 08:43:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Code templates do not work in anonymous nested class after a return statement</short_desc>
        <thetext>Consider the following Java source code:

public class Test {
	Object X = new Object() {
		Object x() {
			if (System.currentTimeMillis() &lt; 0) {
			    sys
				return new Object() {
				};
			} else {
			    sys
				return null;
			}
		}
	};
}

When you hit Ctrl+Space after the first "sys" statement, Eclipse will show a list of code proposals, including the well-known templates "sysout", "syserr" and "systrace. This is the expected behavior.

However, when you hit Ctrl+Space after the second "sys" statement, the pop-up menu does not contain any templates, but simply says "No Default Proposals".

-- Configuration Details --
Product: Eclipse 4.6.0.20160613-1800 (org.eclipse.epp.package.jee.product)
Installed Features:
 org.eclipse.jdt 3.12.0.v20160606-1100</thetext>
    </bug>
    <bug>
        <id>498084</id>
        <developer>Chris Hubick</developer>
        <developer_username>chris</developer_username>
        <dup_id/>
        <creation_time>2016-07-18 14:18:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null] Incorrect null type safety warning for method reference with autoboxing of primitive return type</short_desc>
        <thetext>This is like bug 407414, but for method references...

&gt; import java.util.*;
&gt; import java.util.function.*;
&gt; 
&gt; import org.eclipse.jdt.annotation.*;
&gt; 
&gt; @NonNullByDefault
&gt; public class Test {
&gt; 
&gt;   protected static final &lt;K,V&gt; V cache(final Map&lt;K,V&gt; cache, final V value, final Function&lt;V,K&gt; keyFunction) {
&gt;     cache.put(keyFunction.apply(value), value);
&gt;     return value;
&gt;   }
&gt; 
&gt;   public static final void main(final String[] args) {
&gt;     Map&lt;Integer,String&gt; cache = new HashMap&lt;&gt;();
&gt;     cache(cache, "test", String::length); // Warning: Null type safety at method return type: Method descriptor Function&lt;String,Integer&gt;.apply(String) promises '@NonNull Integer' but referenced method provides 'int'
&gt;   }
&gt; 
&gt; }</thetext>
    </bug>
    <bug>
        <id>498174</id>
        <developer>Alain Pannetier</developer>
        <developer_username>alain.pannetier</developer_username>
        <dup_id/>
        <creation_time>2016-07-20 01:57:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Failed refectoring rolls back a lot of changes</short_desc>
        <thetext>In java editors, failed rename refactoring brings you back several changes back.

The workaround is to go back to the local history and restore your last saved editor state.  But this is a bit "surptising".

I can't reproduce this bug easily but it hapenned several times alread. I upgraded to Neon in the hope this would be fixed. It would seem it is not.</thetext>
    </bug>
    <bug>
        <id>498288</id>
        <developer>JA MA</developer>
        <developer_username>jm088658</developer_username>
        <dup_id/>
        <creation_time>2016-07-21 10:22:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>test class with same name as main class not allowed</short_desc>
        <thetext>Eclipse will not allow me to define a class in the test classpath (src/test/resources) with the same name as a class in the main compile classpath (src/main/resources). 

This is perfectly legal and supported by build tools and other IDEs (IntelliJ IDEA for example). The reason I need to do this is to override certain (Spring configuration) classes for testing purposes.</thetext>
    </bug>
    <bug>
        <id>498498</id>
        <developer>Marek Stanulewicz</developer>
        <developer_username>marek.stanulewicz</developer_username>
        <dup_id/>
        <creation_time>2016-07-26 10:47:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][search][call hierarchy] No usage for lambdas</short_desc>
        <thetext>Created attachment 263316
call hierarchy

import java.util.Arrays;
import java.util.List;

public class EclipseLambdaProblem {

	private void bar() {
		System.out.println(this);
	}

	public static void main(String[] args) {
		List&lt;EclipseLambdaProblem&gt; problems = Arrays.asList(new EclipseLambdaProblem());
		problems.forEach(p -&gt; p.bar());
	}

}

Call hierarchy on bar method correctly shows usage in accept, and for accept there is no usage shown.
This issue was already present in mars.</thetext>
        <comment>
            <comment_id>2733932</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-26 15:40:46 -0400</when>
            <comment_text>Thanks, I can reproduce.

Interestingly, when placing the cursor on the arrow (-&gt;) Call Hierarchy correctly shows lots of callers of accept().

From this it seems not to be a search issue per se, but a matter of what seed you use for search. Moving to JDT/UI for investigation / comments.</comment_text>
        </comment>
        <comment>
            <comment_id>2734146</comment_id>
            <comment_count>2</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-07-27 06:54:37 -0400</when>
            <comment_text>org.eclipse.jdt.internal.corext.callhierarchy.CallerMethodWrapper.findChildren(IProgressMonitor progressMonitor) invokes SearchEngine to find the children of the current IMember.

In case of comment #0, the IMember is LambdaMethod:
accept(EclipseLambdaProblem) (not open) [in &lt;lambda #1&gt; [in main(String[]) [in EclipseLambdaProblem...

The case where call hierarchy is invoked on "-&gt;" (comment #1) is different, where the IMember is ResolvedBinaryMethod (obtained from text selection via ICodeAssist.codeSelect):
void accept(T) {key=Ljava/util/function/Consumer&lt;LEclipseLambdaProblem;&gt;;.accept(LEclipseLambdaProblem;)V} [in Consumer [in Consumer.class...

Seeding with LambdaMethod, which is obtained as the caller of #bar in the first step from SearchMatch.getElement() in MethodReferencesSearchRequestor, looks fine.

The SearchEngine does not return any result for accept(EclipseLambdaProblem) when LambdaMethod is used.

The problem could be with the details in LambdaMethod (compared to ResolvedBinaryMethod), or while creating the SearchPattern with LambdaMethod in SearchPattern#createPattern, or later in SearchEngine#search while using that SearchPattern.

Moving back to JDT/Core for further comments.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498527</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-07-26 16:20:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[impl] avoid cast pattern that breaks JIT of Oracle JVM</short_desc>
        <thetext>Our method TypeConverter.decodeType() is affected by https://bugs.openjdk.java.net/browse/JDK-8154831 causing Eclipse to crash.

In bug 493669 comment 9 Ed made suggestions how this could possibly be avoided.</thetext>
    </bug>
    <bug>
        <id>498530</id>
        <developer>Sylvain Laurent</developer>
        <developer_username>slaurent</developer_username>
        <dup_id/>
        <creation_time>2016-07-26 16:43:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][null] null not correctly inferred as @Nullable String</short_desc>
        <thetext>Created attachment 263322
reproducer for eclipse 4.6

As suggested by Stephan Herrmann in Bug 490339, I'm opening a new ticket for an incorrect type inference : 

given this method :
public static &lt;T&gt; T optionalGetOrElse(final Optional&lt;@NonNull T&gt; opt, final T orElse) 

then in the following call 
String nullableString = NullCheckUtils.optionalGetOrElse(opt, null);

eclipse 4.6 complains about "null" passed as 2nd argument : 
Null type mismatch: required '@NonNull String' but the provided value is null

It's OK if we explicitly cast to (@Nullable String).

See attached reproducer</thetext>
        <comment>
            <comment_id>2733986</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-26 17:35:25 -0400</when>
            <comment_text>Thanks. Putting this on our radar.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498534</id>
        <developer>Luke Hutchison</developer>
        <developer_username>luke.hutch</developer_username>
        <dup_id/>
        <creation_time>2016-07-26 22:01:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>JavaModelException while refactoring with directory shared between projects</short_desc>
        <thetext>I have directories shared between multiple projects. When I try to refactor things in one project (e.g. renaming a class), the refactoring fails with out of sync errors, even if I hit F5 to sync each project before the refactoring.

Related report:

https://dev.eclipse.org/recommenders/community/aeri/v2/#!/submissions/ULC2K2nJXBq9HU17BsNnb2FQH5I0LjJbg3RRmjmfI7dpjC2Iq6bbZIfSGHqvUtL0

This was auto-resolved as a duplicate of Bug 464754, but the cause was entirely different.</thetext>
    </bug>
    <bug>
        <id>498535</id>
        <developer>Luke Hutchison</developer>
        <developer_username>luke.hutch</developer_username>
        <dup_id/>
        <creation_time>2016-07-26 22:02:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>JavaModelException while refactoring with directory shared between projects</short_desc>
        <thetext>I have directories shared between multiple projects. When I try to refactor things in one project (e.g. renaming a class), the refactoring fails with out of sync errors, even if I hit F5 to sync each project before the refactoring.

Related report:

https://dev.eclipse.org/recommenders/community/aeri/v2/#!/submissions/ULC2K2nJXBq9HU17BsNnb2FQH5I0LjJbg3RRmjmfI7dpjC2Iq6bbZIfSGHqvUtL0

This was auto-resolved as a duplicate of Bug 464754, but the cause was entirely different.</thetext>
    </bug>
    <bug>
        <id>498577</id>
        <developer>Dave Brosius</developer>
        <developer_username>dbrosius</developer_username>
        <dup_id/>
        <creation_time>2016-07-27 09:19:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Unused parameters on default interface methods are flagged</short_desc>
        <thetext>create an interface as

public interface Foo {
  
    default void bar(Baz b) {
    }
}

class Baz {
}

Eclipse will complain that Baz b is unused, which is true, but it doesn't seem right that one would complain about a parameter in an interface, even if it were default.</thetext>
        <comment>
            <comment_id>2734227</comment_id>
            <comment_count>1</comment_count>
            <who>Dave Brosius</who>
            <commenter_username>dbrosius</commenter_username>
            <when>2016-07-27 09:27:31 -0400</when>
            <comment_text>as a corrolary, unused exceptions are also flagged, which also seems wrong.</comment_text>
        </comment>
        <comment>
            <comment_id>2735234</comment_id>
            <comment_count>2</comment_count>
            <who>Marvin  Fröhlich</who>
            <commenter_username>qudus</commenter_username>
            <when>2016-07-29 11:29:46 -0400</when>
            <comment_text>Just wanted to report the same. So, I can confirm this.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498986</id>
        <developer>Andrey Loskutov</developer>
        <developer_username>loskutov</developer_username>
        <dup_id/>
        <creation_time>2016-08-01 08:46:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[releng] Dirty git status after build in eclipse.jdt.core</short_desc>
        <thetext>I'm trying to build JDT as part of the SDK build and I see that after the (failed) build "git status" reports:

Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

        org.eclipse.jdt.compiler.tool.tests/Y.class
        org.eclipse.jdt.core/jdtCompilerAdapter.jar

Ideally this should not happen, build should not create "untracked" files - they either should be deleted if they are temporary artifacts, or ignored. 
I will post a patch with modified .gitignore file in a moment.</thetext>
        <comment>
            <comment_id>2736147</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-08-01 08:56:22 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/78257</comment_text>
        </comment>
        <comment>
            <comment_id>2736217</comment_id>
            <comment_count>2</comment_count>
            <who>Alexander Kurtakov</who>
            <commenter_username>akurtakov</commenter_username>
            <when>2016-08-01 12:15:59 -0400</when>
            <comment_text>I really believe these files should be produced in target/ instead of gitignoring them.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499019</id>
        <developer>Clement Guillaume</developer>
        <developer_username>clement</developer_username>
        <dup_id/>
        <creation_time>2016-08-02 01:58:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Publish JDT Core Batch Compiler ecj to Maven Central</short_desc>
        <thetext>The JDT compiler is used in many projects outside of eclipse.
I learned that none of the artifacts on maven central is the official one.
Here are two of them and their usages by other projects.
https://mvnrepository.com/artifact/org.eclipse.jdt.core.compiler/ecj/usages
https://mvnrepository.com/artifact/org.eclipse.tycho/org.eclipse.jdt.core/usages

I would appreciate if an artifact could be published to maven central by the eclipse project team, if possible as soon as a new version of the eclipse ide is released.
It, then, could be used in plexus-compiler-eclipse* (a maven plugin that allows to build with eclipse compiler).

* https://github.com/codehaus-plexus/plexus-compiler/tree/master/plexus-compilers/plexus-compiler-eclipse</thetext>
    </bug>
    <bug>
        <id>499197</id>
        <developer>Steven Schlansker</developer>
        <developer_username>stevenschlansker</developer_username>
        <dup_id/>
        <creation_time>2016-08-04 19:59:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Wildcard type inference for method reference fails</short_desc>
        <thetext>This code compiles with javac 1.8.0_101 and IntelliJ but not with Eclipse 4.6.0:

https://gist.github.com/stevenschlansker/1a85215249708e325e0baa42e9d7d8bb

It's unclear to me exactly how enum-like recursive type declarations (Config&lt;C extends Config&lt;C&gt;) should interact with wildcards (Entry&lt;? extends Config&lt;?&gt;&gt;), but the differing behavior from javac is inconvenient...</thetext>
        <comment>
            <comment_id>2737522</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-05 07:25:03 -0400</when>
            <comment_text>Created attachment 263478
self-contained compilable source code

Adding the full source code including necessary imports.

I agree that differences between compilers are "inconvenient".

Unfortunately, type inference involving wildcards and captures is one of the hardest to get right, with a prominent javac bug [1] still unresolved 3 years later.

I also tried javac from a Java 9 early access build, because they have some improvements in this area, but still not the same result as ecj.

This doesn't rule out a bug in ecj, but just the analysis for each of these cases is a huge effort, so please don't hold your breath waiting for a fix.


[1] https://bugs.openjdk.java.net/browse/JDK-8016207</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499261</id>
        <developer>Jörg Hohwiller</developer>
        <developer_username>joerg.hohwiller</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 07:38:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler] compiler error with invocation of overridden method in interface with method generic</short_desc>
        <thetext>In ValueConverter:
https://github.com/m-m-m/util/blob/master/core/src/main/java/net/sf/mmm/util/value/api/ValueConverter.java#L22

I had to remove this method:

  /**
   * {@inheritDoc}
   *
   * @see #convert(Object, Object, GenericType)
   */
  @Override
  &lt;T extends TARGET&gt; T convert(SOURCE value, Object valueSource, Class&lt;T&gt; targetClass) throws ValueException;

In order to make this line compile in Eclipse:
https://github.com/m-m-m/util/blob/master/core/src/main/java/net/sf/mmm/util/lang/base/StringUtilImpl.java#L483

It worked with Oracle Compiler using maven but failed in Eclipse.
As a workaround I removed the overridden method that only adds a JavaDoc hint.
However, this is IMHO a bug in Eclipse (with Neon Build id: 20160613-1800 when 1.8 is active).

https://github.com/m-m-m/util/commit/4f6594388c09c54488a22e7e22726ee96170785a

In case you really care: I discovered a lot of problems and differences in Oracle and Eclipse compliler here:
https://github.com/m-m-m/util/issues/166

Oracle does not care and just ignores my bug reports even though I created isolated tests that prove the bug. Hopefully Eclipse community cares better...</thetext>
        <comment>
            <comment_id>2737874</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-07 06:57:50 -0400</when>
            <comment_text>Minimal example:

//---
import java.lang.reflect.Type;

interface SimpleValueConverter&lt;SOURCE, TARGET&gt; {
	&lt;T extends TARGET&gt; T convert(SOURCE value, Class&lt;T&gt; targetClass);
}

interface ValueConverter&lt;SOURCE, TARGET&gt; extends SimpleValueConverter&lt;SOURCE, TARGET&gt; {
	@Override
	&lt;T extends TARGET&gt; T convert(SOURCE value, Class&lt;T&gt; targetClass);
}

interface GenericType&lt;T&gt; extends Type { }

public class StringUtilImpl {
	public &lt;E&gt; E fromSeparatedString(ValueConverter&lt;? super String, ? super E&gt; converter, Class&lt;E&gt; type) {
		return converter.convert("", type);
	}
}
//---

Reports:----------
1. ERROR in /tmp/bug/repro/src/StringUtilImpl.java (at line 16)
        return converter.convert("", type);
                         ^^^^^^^
The method convert(capture#1-of ? super String, Class&lt;E&gt;) is ambiguous for the type ValueConverter&lt;capture#1-of ? super String,capture#2-of ? super E&gt;
----------
1 problem (1 error)

Only happens at -1.8.


What's particularly strange: a method conflicts with its own override.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499267</id>
        <developer>Jörg Hohwiller</developer>
        <developer_username>joerg.hohwiller</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 09:21:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler][warnings] Deprecation warnings even when @SupressWarnings("deprecation") is present</short_desc>
        <thetext>The general idea of warnings should be to indicate that something is wrong and needs attention.
However, Eclipse compiler renders deprecation warnings way to verbose.
First of all if a type is deprecated that I implement then the implementation should not get deprecation warnings for that.
As a workaround I have to add @SupressWarnings("deprecation") to my implementation what is not really nice but OK.

The main problem is that Eclipse still reports deprecation warnings if I have {@link} tags in JavaDoc pointing to deprecated methods. These should be suppressed by @SupressWarnings("deprecation"). 

However, I additionally need to add @SuppressWarnings("javadoc") to each such method. This could also be considered as a workaround but this one is really painful. Not only that it is pointless clutter but also because it disables the entire javadoc validation what is not my intention.

Expected behaviour: @SuppressWarnings("deprecation") should suppress all deprecation warnings.</thetext>
    </bug>
    <bug>
        <id>499326</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-08-07 09:05:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler] error reporting depends on order of compilation units</short_desc>
        <thetext>Observable in a workspace with the examples from NullTypeAnnotationTest.testBug497698():

//---
package test;

import org.eclipse.jdt.annotation.NonNullByDefault;

@NonNullByDefault
public class And {
	public static void createAnd() {
		Or.create();
	}
}
//---
package test;

import org.eclipse.jdt.annotation.NonNullByDefault;

@NonNullByDefault
public class Or&lt;D, V&gt; {
	public static &lt;V&gt; Or&lt;V&gt; create() {
		return new Or&lt;V, V&gt;(); 
	}
}
//---


1. Full build:
  -&gt; 1 Error against return type of Or.create() =&gt; OK
2. Edit and save Or.java
  -&gt; Additional Error appears against And.java:
   "The method create() is undefined for the type Or"

If resolveTypesFor() is triggered by methods() (2) we recognize the return problem and drop this method from STB#methods.

If, OTOH, resolveTypesFor() is first triggered by getMethods(char[]) (1), we call methods() in a state where the type reference is already resolved (to the unparameterized STB), thus hiding the return problem -&gt; we keep the method and no error is reported at the call site.

To demonstrate that this is not an issue of compiler vs. reconciler simply batch-compile both classes 

1.
ecj -classpath path-to-o.e.j.annotation.jar test/And.java test/Or.java
-&gt; 1 error

2.
ecj -classpath path-to-o.e.j.annotation.jar test/Or.java test/And.java
-&gt; 2 errors</thetext>
    </bug>
    <bug>
        <id>499355</id>
        <developer>satya kalali</developer>
        <developer_username>edigasatya</developer_username>
        <dup_id/>
        <creation_time>2016-08-08 07:28:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Is SearchPattern.createPattern(...) works with vararg methods?</short_desc>
        <thetext>SearchPattern pattern = SearchPattern.createPattern(method, IJavaSearchConstants.METHOD,IJavaSearchConstants.REFERENCES, R_EXACT_MATCH);
            new SearchEngine().search(pattern, new SearchParticipant[] { getDefaultSearchParticipant() }, scope,
                    requestor, null);

here method: de.test.aktivstrg.TestSparteEigen.test(java.land.String[])


My method is vararg method ,need to find all method references in the workspace, but in the result  I can see only references with one argument. could you help me with this?

For Exaple:
Var arg method:public static void test(String...criteria){
        //
    }

It has two references in workspace: 

public void testwithsingleparameter(){
        TestSparteEigen.test("satya");
    }


    public void testwithmutipleparameter(){
        TestSparteEigen.test("satya","kalali");
    }


I got the below result:
public void testwithsingleparameter(){
        TestSparteEigen.test("satya");
    }</thetext>
        <comment>
            <comment_id>2738786</comment_id>
            <comment_count>1</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-08-10 01:14:19 -0400</when>
            <comment_text>(In reply to satya kalali from comment #0)
Please try the following:


MethodPattern pattern = (MethodPattern)  SearchPattern.createPattern(method, IJavaSearchConstants.METHOD,IJavaSearchConstants.REFERENCES, R_EXACT_MATCH);
pattern.varargs = true;//use this pattern to search.
 new SearchEngine().search(pattern, new SearchParticipant[] { getDefaultSearchParticipant() }, scope,
                    requestor, null);</comment_text>
        </comment>
        <comment>
            <comment_id>2739299</comment_id>
            <comment_count>2</comment_count>
            <who>satya kalali</who>
            <commenter_username>edigasatya</commenter_username>
            <when>2016-08-11 10:38:00 -0400</when>
            <comment_text>Many Thanks Manoj,Now I can see all references.

could you also please  help me with below question? 

below is the method: 

de.allianz.abs.adag.vertrag.leben.navi.gen.vertrag.navigationservice.VertragNavigationService.hspEigen(de.allianz.abs.adag.vertrag.leben.navi.base.ComparableAttributeFilter.CompareType, java.lang.String[])

here CompareType is ENUM.


MethodPattern pattern = (MethodPattern)  SearchPattern.createPattern(method, IJavaSearchConstants.METHOD,IJavaSearchConstants.REFERENCES, R_EXACT_MATCH);

pattern.varargs = true;

 new SearchEngine().search(pattern, new SearchParticipant[] {getDefaultSearchParticipant() }, scope, requestor, null);


1) Above code working fine in eclipse Kepler
Version: Kepler Service Release 1
Build id: 20130911-2042

2) but same code not working in eclipse Mars
Version: Mars.1 Release (4.5.1)
Build id: 20150924-1200

I have tried below  method signature in Mars Eclipse. Nothing is working fine.

de.allianz.abs.adag.vertrag.leben.navi.gen.vertrag.navigationservice.VertragNavigationService.hspEigen(de.allianz.abs.adag.vertrag.leben.navi.base.ComparableAttributeFilter.CompareType, java.lang.String[])

de.allianz.abs.adag.vertrag.leben.navi.gen.vertrag.navigationservice.VertragNavigationService.hspEigen(de.allianz.abs.adag.vertrag.leben.navi.base.ComparableAttributeFilter.CompareType, String[])

de.allianz.abs.adag.vertrag.leben.navi.gen.vertrag.navigationservice.VertragNavigationService.hspEigen(CompareType, String[])

de.allianz.abs.adag.vertrag.leben.navi.gen.vertrag.navigationservice.VertragNavigationService.hspEigen(CompareType, String...)

de.allianz.abs.adag.vertrag.leben.navi.gen.vertrag.navigationservice.VertragNavigationService.hspEigen(CompareType, java.lang.String...)



could please let me know what I missed in this case. please see below enum class also.

public class ComparableAttributeFilter {
	public enum CompareType {
		EQUAL,NOT}
}</comment_text>
        </comment>
        <comment>
            <comment_id>2740472</comment_id>
            <comment_count>3</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-08-16 09:28:23 -0400</when>
            <comment_text>Extracting a test case from your comment 2, the search for references yield correct results - the test case which I used is given below:
enum CompareType {
	EQUAL,NOT}

class X {
	public void foo(CompareType ct, String s) {}
	public void foo(CompareType ct, String ... s) {}
	
	public static void main(String[] args) {
		X x = new X();
		CompareType ct = CompareType.EQUAL;
		String s = null;
		
		x.foo(ct, s);
		x.foo(ct, s, s);
		x.foo(ct, s, s, s);
	}
}

I've tested with the Neon release. If you find a problem with Neon release, I would request you to post a self-contained test case that reproduces the issue.</comment_text>
        </comment>
        <comment>
            <comment_id>2740890</comment_id>
            <comment_count>4</comment_count>
            <who>satya kalali</who>
            <commenter_username>edigasatya</commenter_username>
            <when>2016-08-17 08:09:02 -0400</when>
            <comment_text>Hi Manoj,
Please find the below test cas, here enum is inside the class.

 public class BOSample{
	 public enum ComapreType {
		NOT,EQUAL;
		}

}

public class SampleTest {
public static void comapreTest(ComapreType comapre,String...criteria){
	//
}
}

public class SampleToolTest {
public void test(){
	SampleTest.comapreTest(ComapreType.EQUAL, "satya");
	SampleTest.comapreTest(ComapreType.EQUAL, "satya","kalali");
}
}



IJavaSearchScope scope = createJavaSearchScope(packages.toArray(new IPackageFragment[packages.size()]));
			
MethodPattern pattern = (MethodPattern)  SearchPattern.createPattern(method, IJavaSearchConstants.METHOD,IJavaSearchConstants.REFERENCES, R_EXACT_MATCH);
pattern.varargs = true;
new SearchEngine().search(pattern, new SearchParticipant[] { getDefaultSearchParticipant() }, scope, requestor, null);

Here method  is: sampletest.SampleTest.comapreTest(SampleTest.BOSample.ComapreType, java.lang.String[])

No search references I have found.

I have to use Mars Eclipse IDE because my development IDE is Eclipse  Mars. could you please check search references for above test case?</comment_text>
        </comment>
        <comment>
            <comment_id>2746300</comment_id>
            <comment_count>5</comment_count>
            <who>satya kalali</who>
            <commenter_username>edigasatya</commenter_username>
            <when>2016-09-02 00:08:05 -0400</when>
            <comment_text>Could you please reply for comment 4?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499388</id>
        <developer>Stefan Xenos</developer>
        <developer_username>sxenos</developer_username>
        <dup_id/>
        <creation_time>2016-08-08 18:53:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>MatchLocator.createBinaryMethodHandle returns null for methods with synthetic arguments</short_desc>
        <thetext>I was investigating a test failure in the newindex branch when I encountered this bug in MatchLocator.

The bug:

MatchLocator sometimes compares "argumentTypeNames" against the generic signature (which is optional and doesn't include synthetic arguments), and sometimes compares it against the method descriptor (which always includes the synthetic arguments).

That means that the method returns a different result based on whether or not the generic signature is present.

One of the callers, MatchLocator.createHandle, always includes the synthetic arguments when it calls createBinaryMethodHandle. That means that, at least for that caller, it would be correct to always use the method descriptor rather than the generic signature.

I discovered this by including generic signatures in the .class files used by JavaSearchBugsTest.testBug123679. Presumably this failure means that some JDT search results will be omitted when searching for references to the constructors of inner classes when those constructors make use of generics.</thetext>
    </bug>
    <bug>
        <id>499589</id>
        <developer>Clovis Seragiotto</developer>
        <developer_username>clovis.seragiotto</developer_username>
        <dup_id/>
        <creation_time>2016-08-12 05:02:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null][1.8] Implement DefaultLocation.ARRAY_CONTENTS</short_desc>
        <thetext>Missing warning (about redundant type annotation):

import static org.eclipse.jdt.annotation.DefaultLocation.*;
import org.eclipse.jdt.annotation.*;

class MissingWarning {
	@NonNullByDefault({ PARAMETER, ARRAY_CONTENTS })
	static void bar(@NonNull String [] array) { &lt;---- missing warning
		x(array[0]);
	}
	
	static void x(String s) { System.out.println(s); }
}

Bogus Warning ("the expression of type 'String' needs unchecked conversion to conform to '@NonNull String')

@NonNullByDefault({ PARAMETER, ARRAY_CONTENTS })
class BogusWarning{
	static void foo(String [] array) {
		x(array[0]); // &lt;----- bogus warning
	}
	
	static void x(String s) { System.out.println(s); }
}</thetext>
        <comment>
            <comment_id>2739962</comment_id>
            <comment_count>1</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-08-14 10:21:57 -0400</when>
            <comment_text>DefaultLocation.ARRAY_CONTENTS is not implemented yet.

A comment for Binding.DefaultLocationArrayContents says:
* TODO: this constant is not yet used, due to difficulty to discern these annotations between SE5 / SE8</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499596</id>
        <developer>Clovis Seragiotto</developer>
        <developer_username>clovis.seragiotto</developer_username>
        <dup_id/>
        <creation_time>2016-08-12 06:23:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null][1.8] Bogus warning with NonNullByDefault</short_desc>
        <thetext>In the following class, one gets the warning: "The nullness annotation is redundant with a default that applies to this location", which is right.

import static org.eclipse.jdt.annotation.DefaultLocation.*;
import org.eclipse.jdt.annotation.*;
import java.util.*;

class Foo {
	@NonNullByDefault({ PARAMETER, RETURN_TYPE, FIELD, TYPE_PARAMETER, TYPE_BOUND, TYPE_ARGUMENT, ARRAY_CONTENTS })
	static Collection&lt;String[]&gt; from(@NonNull String @NonNull [] @NonNull... elements) { // &lt;-- warning here, ok
		return Collections.singleton(elements[0]); &lt;-- warning here if any @NonNull is removed
	}
}

If, however, any of the redundant @NonNull annotations is removed, one gets another warning about null type safety ("the expression needs unchecked conversion")</thetext>
        <comment>
            <comment_id>2739925</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-13 17:46:53 -0400</when>
            <comment_text>Here's what I see in HEAD:

As shown in comment 0 the return statement has this warning:

Null type safety (type annotations): The expression of type 'Set&lt;String @NonNull[]&gt;' needs unchecked conversion to conform to '@NonNull Collection&lt;String @NonNull[]&gt;', corresponding supertype is 'Collection&lt;String @NonNull[]&gt;'

This concerns the toplevel type Set. This can be fixed using an external @NonNull annotation on the return of Collections.singleton().

After that, removing either the second or third annotation in the line above, makes a new warning appear:

Null type safety (type annotations): The expression of type '@NonNull String []' needs unchecked conversion to conform to 'String @NonNull[]'

Not only is this warning wrong, also showing the same warning in both cases looks bogus.

Next when I replace the @NNBD by spelling out:

   Collection&lt;@NonNull String @NonNull[]&gt; from(..)

I get no warning even with the second annotation on the parameter removed.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499648</id>
        <developer>Atsushi Nakagawa</developer>
        <developer_username>atnak</developer_username>
        <dup_id/>
        <creation_time>2016-08-14 21:54:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>"Never join already wrapped lines" counterintuitive for ternary operators</short_desc>
        <thetext>Regarding to ternary operators  (`a ? b : c`), the Formatter option "Never join already wrapped lines" *does not appear to do anything*.

My Line wrapping is configured like so:
[x] Never join already wrapped lines
[x] Prefer wrapping outer expressions

Expressions &gt; Conditionals:
Line wrapping policy: [Wrap all elements, every element on new line]
[ ] Force split, even if line shorter than maximum line width
[x] Wrap before operators


This results in:

```
// 1. This line shorter than maximum line width:
return argument ? 100000 : 20000;
// Is formatted to: (as expected)
return argument ? 100000 : 20000;

```

```
// 2. This line shorter than maximum line width:
return argument ?
    100000 : 20000;
// Is formatted to: (Not expected!)
return argument ? 100000 : 20000;

```

```
// 3. This line shorter than maximum line width:
return argument
    ? 100000 : 20000;
// Is formatted to:
return argument
    ? 100000
    : 20000;
```

The result for 2 is unexpected because this is what "Never join already wrapped lines" was thought to counter.</thetext>
        <comment>
            <comment_id>2740618</comment_id>
            <comment_count>1</comment_count>
            <who>Mateusz Matela</who>
            <commenter_username>mateusz.matela</commenter_username>
            <when>2016-08-16 14:23:55 -0400</when>
            <comment_text>In example 2 the formatter did not respect the existing wrap, because it was on the other side of the operator. Do you want the formatter to keep inconsistent wraps?

"Wrap all elements, every element on new line" means the formatter should either keep everything in one line if possible, or wrap all elements. So "never join..." doesn't make a lot of sense with this assumption. Current interpretation of "never join.." is that if there's at least one wrap, then all elements are wrapped (as you see with example 3).
It seems the behavior you want is achieved with policy "Wrap where necessary", isn't it?</comment_text>
        </comment>
        <comment>
            <comment_id>2742052</comment_id>
            <comment_count>2</comment_count>
            <who>Atsushi Nakagawa</who>
            <commenter_username>atnak</commenter_username>
            <when>2016-08-19 20:00:55 -0400</when>
            <comment_text>&gt; Do you want the formatter to keep inconsistent wraps?

Yes is ultimately the answer to this.  What it comes down to is that I was after the ability to keep two styles:

Style 1:
```
int some_variable = something_really_long_here ?
        a_call_foo_method() : a_call_bar_method();
```

Style 2:
```
int some_variable = something_really_long_here
        ? (a_call__foo_method() ? 1000 : 2000)
        : a_call_bar_method() + 30000;
```

However, I did some more testing and found that the formatter will always proactively join lines that are wrapped inconsistently to the "Wrap before operators" option.   Style 1 is joined if "Wrap before operators" is checked and Style 2 if not.

This does not appear to be affected by the choice for "Line wrapping policy" nor "Never join already wrapped lines" and was/can be the cause of initial confusion.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499649</id>
        <developer>Kevin Phillips</developer>
        <developer_username>kmecpp</developer_username>
        <dup_id/>
        <creation_time>2016-08-14 22:08:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Autocomplete not working in enum parameters</short_desc>
        <thetext>Autocomplete does not work inside an enum parameter. Encountered originally when using an anonymous class as a parameter but it doesn't work at all.

public enum EclipseTest {

	TEST1(/*Doesn't work in here*/),

	TEST2(new Interface() {
            //Doesn't work in here
	});

	EclipseTest(Interface i) {
	}

	public static interface Interface {

	}

}</thetext>
        <comment>
            <comment_id>2740312</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-16 02:58:12 -0400</when>
            <comment_text>I see what you mean in TEST(). For e.g., the following doesn't produce any assists:

	TEST1(new Inter|),

But I don't see what's broken in case of TEST2(...). Can you give some examples please?</comment_text>
        </comment>
        <comment>
            <comment_id>2740457</comment_id>
            <comment_count>2</comment_count>
            <who>Kevin Phillips</who>
            <commenter_username>kmecpp</commenter_username>
            <when>2016-08-16 08:57:51 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #1)
&gt; I see what you mean in TEST(). For e.g., the following doesn't produce any
&gt; assists:
&gt; 
&gt; 	TEST1(new Inter|),
&gt; 
&gt; But I don't see what's broken in case of TEST2(...). Can you give some
&gt; examples please?

Ah sorry I wasn't clear. Basically any code inside the created interface doesn't work either. It's pretty much the same bug, I just wanted to make sure that both would get fixed.

Here's a better example for TEST2:

	TEST2(new Interface() {

		@Override
		public void method() {
			new Inter| //Not working
		}

	});</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499673</id>
        <developer>George Forman</developer>
        <developer_username>gforman44</developer_username>
        <dup_id/>
        <creation_time>2016-08-15 12:00:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>enabling warning/error for 'unused method parameter' didn't work</short_desc>
        <thetext>The Java compiler did not give me a warning about the unused parameter in this test code

	public static double difference(double x, double y) {
		return x - x;
	}

even after I turned on the warning:

Windows / Preferences / Java / Compiler / Errors/Warnings / Unnecessary code / 
"Value of method parameter is not used" := WARNING  (also tried ERROR)
 (Also tried unchecking "ignore in overriding and implementing methods")
 
Note that this was using my *general* profile.  When I repeated the setting using the *project-specific configuration* I then got the warning.  

(Glad I kept digging to get this to work-- it found 3, no 4 bugs in my code instantly.)   

I propose that this should be either INFO or WARNING as the default for new installations.



-- Configuration Details --
Product: Eclipse 4.6.0.20160613-1800 (org.eclipse.epp.package.jee.product)
Installed Features:
 org.eclipse.jdt 3.12.0.v20160606-1100</thetext>
    </bug>
    <bug>
        <id>499675</id>
        <developer>J. Zufallig</developer>
        <developer_username>wearyofallthiscrap</developer_username>
        <dup_id/>
        <creation_time>2016-08-15 12:33:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Global compiler settings ignored after restarting, defaults to 1.4 even though 1.8 displayed</short_desc>
        <thetext>Created attachment 263596
screenshot #1, workspace settings correct

We have a standard Java project working under Eclipse.  There are no plugins installed, just the basic "Java devel stuff" Eclipse package.  There is no Maven or other special build tool involved; the "real" build is more complicated and happens elsewhere, Eclipse is just used as a convenient and useful development environment for part of the project.

Nearly all settings are managed at the workspace level.  Only one project-specific setting existed, and everything worked fine.  Then we tried turning off the project-specific override.  Everything still worked fine.  Then we exited Eclipse, and nothing has worked since.

Attachment #1 (ebug_workspace_compliance) shows the workspace's Java -&gt; Compiler screen.  Everything is correct, including source = 1.8 and compliance = 1.8.  It's not shown, but the "Installed JREs" correctly default to the JavaSE-1.8 Standard VM.

Attachment #2 (ebug_project_compliance) shows the project's Java Compiler screen.  Everything is *supposed* to be inherited from the workspace, but incorrectly is defaulting to 1.4.  Clicking the "Configure Workspace Settings..." link brings up correct workspace settings for 1.8 as before.  Obviously, trying to build the project fails with parse errors.

Clicking *any* of the sub-entries (Building, Errors/Warnings, etc) shows the correct "everything is disabled because project-specific settings are disabled" state.  But clicking back on the project's Java Compiler screen then *changes* to the screen in attachment #3 (ebug_project_compliance_after_subentries).  Nothing has been changed -- only looking at different preferences -- but the screen is now displaying "use compliance from execution environment" and claiming 1.8 source compatibility.

Building still fails, because it's still actually using 1.4 instead of 1.8 as it claims.

Enabling project-specific settings and forcing a build works.  After that, disabling the project-specific settings goes back to defaulting to 1.4 even though there is nothing anywhere saying "use 1.4".

Bug 349697 may be related, but that's from four years ago.  Similar bugs have been reported on other sites, but were always tracked down to an incorrect Maven or Ant setting, and there is no such tool involved here.  It doesn't make a difference whether Eclipse itself is started with a -vm option or not; it only has the Java 1.8 environment to use for launching, and it does, but then screws up choosing its compiler.

I've no idea what magical state has been lost in exiting and re-launching Eclipse, but workspace settings are simply being ignored.  Maintaining project-specific settings isn't viable in the long term.</thetext>
        <comment>
            <comment_id>2740179</comment_id>
            <comment_count>1</comment_count>
            <who>J. Zufallig</who>
            <commenter_username>wearyofallthiscrap</commenter_username>
            <when>2016-08-15 12:33:53 -0400</when>
            <comment_text>Created attachment 263597
screenshot #2, project settings broken defaults</comment_text>
        </comment>
        <comment>
            <comment_id>2740180</comment_id>
            <comment_count>2</comment_count>
            <who>J. Zufallig</who>
            <commenter_username>wearyofallthiscrap</commenter_username>
            <when>2016-08-15 12:34:39 -0400</when>
            <comment_text>Created attachment 263598
screenshot #3, project settings updated after clicking elsewhere, but ignored</comment_text>
        </comment>
        <comment>
            <comment_id>2740199</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-15 14:02:35 -0400</when>
            <comment_text>I can reproduce using a fresh workspace (much to my own surprise).</comment_text>
        </comment>
        <comment>
            <comment_id>2740211</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-15 14:39:27 -0400</when>
            <comment_text>When this happened for me, the per workspace compiler settings were almost empty at
  .metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.jdt.core.prefs

Toggling the compliance to 1.7 -&gt; OK -&gt; then back to 1.8 fixed that file and all behaves well from thereon.

It seems for a fresh workspace, Eclipse pretends the default compliance to be 1.8, whereas no per-workspace compliance has been set (causing the built-in default of 1.4 to apply).

IIRC, the 1.8 default is determined based on the available VMs. Perhaps the result of investigating available VMs just isn't persisted? This could explain why initially all was well and restart - failing to find persisted settings - entered the bad state.</comment_text>
        </comment>
        <comment>
            <comment_id>2740236</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-15 15:23:02 -0400</when>
            <comment_text>In the good case, when the first Java project is created in a fresh workspace, per-workspace compliance settings are persisted in this call chain:

JavaCore.setOptions(Hashtable&lt;String,String&gt;) line: 5784
JavaRuntime.updateCompliance(IVMInstall) line: 2817
JavaRuntime.initializeVMs() line: 2776
JavaRuntime.getDefaultVMId() line: 548
JavaRuntime.getDefaultVMInstall() line: 493
NewJavaProjectWizardPageOne$JREGroup.getDefaultJVMName() line: 564
NewJavaProjectWizardPageOne$JREGroup.getDefaultJVMLabel() line: 598
NewJavaProjectWizardPageOne$JREGroup.&lt;init&gt;(NowJavaProjectWizardPageOne) line: 403
NewJavaProjectWizardPageOne.&lt;init&gt;() line: 1055
...

Afterwards the file
  
.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.jdt.core.prefs
has this content:

eclipse.preferences.version=1
org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
org.eclipse.jdt.core.compiler.compliance=1.8
org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
org.eclipse.jdt.core.compiler.source=1.8

Either on some workspaces a project can be created without going through this path, or there exists another path that will later remove the per-workspace compliance settings.



All this non-deterministic trouble with compliance settings much reminds me of bug 482991.</comment_text>
        </comment>
        <comment>
            <comment_id>2740273</comment_id>
            <comment_count>6</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-15 17:08:31 -0400</when>
            <comment_text>Fragments of a theory how writing the settings file could be bypassed:

During JavaRuntime.initializeVMs() and inside JavaRuntime.updateCompliance() if 'isDefault' is set to false we will *not* write compliance related default settings.

This would require that the following two got out of sync:
  JavaCore.getOptions()
  BundleDefaultsScope.INSTANCE.getNode(JavaCore.PLUGIN_ID)

In the good case, both are initialized from JavaCorePreferenceInitializer.initializeDefaultPreferences()

Inside there we eventually call
  defaultPreferences.put(optionName, (String)entry.getValue())

Inside put we eventually call
  DefaultPreferences.internalPut(String, String)

Here preferences are propagated to the bundle defaults "if (isInitializingBundleDefaults())"

Forcing the latter method to return false while processing any compliance related option will trigger the bug.

Looking at the call chain from JavaCore.start() leading up to JavaCorePreferenceInitializer.initializeDefaultPreferences() I don't see how this could get broken, but maybe sync between options and preferences get's broken somehow after the fact ...</comment_text>
        </comment>
        <comment>
            <comment_id>2740279</comment_id>
            <comment_count>7</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-15 17:24:16 -0400</when>
            <comment_text>I have to give up for now, partly because I never again saw the bug occur without my intervention in the debugger.q

Anyone trying this may want to use this:
- launch into a fresh workspace
- open the wizard for creating a new Java project
- at this point look for .metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.jdt.core.prefs
  - if it contains compliance settings, abort and start over ...


Anyway, I believe setting per-workspace compliance first to 1.7 then back to 1.8 is a viable workaround ...</comment_text>
        </comment>
        <comment>
            <comment_id>2740638</comment_id>
            <comment_count>8</comment_count>
            <who>J. Zufallig</who>
            <commenter_username>wearyofallthiscrap</commenter_username>
            <when>2016-08-16 15:08:15 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #7)
&gt; Anyway, I believe setting per-workspace compliance first to 1.7 then back to
&gt; 1.8 is a viable workaround ...

OP here, I can confirm that this works for me, including surviving a restart of Eclipse.  Thank you for all the time you've spent on this!</comment_text>
        </comment>
        <comment>
            <comment_id>2740661</comment_id>
            <comment_count>9</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-16 16:04:45 -0400</when>
            <comment_text>(In reply to J. Zufallig from comment #8)
&gt; (In reply to Stephan Herrmann from comment #7)
&gt; &gt; Anyway, I believe setting per-workspace compliance first to 1.7 then back to
&gt; &gt; 1.8 is a viable workaround ...
&gt; 
&gt; OP here, I can confirm that this works for me, including surviving a restart
&gt; of Eclipse.  Thank you for all the time you've spent on this!

Thanks for confirming.

Still a way to go to reliable functioning.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499714</id>
        <developer>Clovis Seragiotto</developer>
        <developer_username>clovis.seragiotto</developer_username>
        <dup_id/>
        <creation_time>2016-08-16 03:47:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Inconsistent interpretation of NonNullByDefault applied to return types</short_desc>
        <thetext>import org.eclipse.jdt.annotation.*;

interface Type&lt;@Nullable K&gt; {
    @NonNullByDefault(DefaultLocation.RETURN_TYPE)
    K get();
	
    class U implements Type&lt;@Nullable String&gt; {
        @Override public String get() {	// &lt;-- I get the error "The default '@NonNull' conflicts with the inherited '@Nullable' annotation", so @NonNull was applied and "K get() was interpreted as "@NonNull K get()"
            return ""; 
        }		
    }

    static &lt;@Nullable T&gt; void x(Type&lt;T&gt; t) {
        t.get().toString(); // &lt;-- I get the warning "Potential null pointer access", so "K get()" was NOT interpreted as "@NonNull K get()"
    }
}</thetext>
        <comment>
            <comment_id>2740355</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-16 04:35:56 -0400</when>
            <comment_text>I no longer see this with latest Oxygen build. Perhaps fixed with a recent fix. Need to dig out the bug number.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499719</id>
        <developer>Alexey Ulyanov</developer>
        <developer_username>lexxsol</developer_username>
        <dup_id/>
        <creation_time>2016-08-16 04:12:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>alt+shift+L shows error if before .stream().map(...) exists</short_desc>
        <thetext>Created attachment 263607
Screenshot of error described in Example 2

Checked in last Eclipse 4.7 and 4.4.

Alt+Shift+L shortcut extracts local variable from selected piece of code. it is working fine even if current line is not ended with semicolon.
Example 1:

	private void noErrorNoLambda(List&lt;Container&gt; list) {
		list.size()
	}
You are able to extract list.size() piece of code to local variable here if you just select it and run Alt+Shift+L. Note that line is not ended with semicolon.


But if .stream().map(...) is run before in scope of current method then extracting local variable shortcut is throwing error if current line is not ended with semicolon.

Example 2:
	private void errorWithLambda(List&lt;Container&gt; list) {
		Stream&lt;Long&gt; map = list.stream().map(o-&gt;o.getId());
		list.size()
	}
You are not able to extract list.size() to local variable using Alt+Shift+L shortcut by selecting list.size() piece of code if line is not ended with semicolon (please check attached screenshot)

But if you add semicolon at the end of list.size() and select it again and press Alt+Shift+L it will work as expected.

I noticed that map() method executed in lambda expression is culprit</thetext>
    </bug>
    <bug>
        <id>499738</id>
        <developer>Andreas Sewe</developer>
        <developer_username>andreas.sewe</developer_username>
        <dup_id/>
        <creation_time>2016-08-16 08:15:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Enrich IllegalArgumentsExceptions with information about actual arguments</short_desc>
        <thetext>Dear JDT team,

I am currently triaging Bug 471266 and Bug 472010, which is made difficult as the methods in org.eclipse.jdt.internal.compiler.util.Util only throw IAEs without information about the actual arguments.

Would you, like you did for Bug 471270, accept a patch that remedies this situation? If so, for which branch should I submit it to Gerrit? master? R4_6_maintenance?

Best wishes,

Andreas</thetext>
        <comment>
            <comment_id>2740541</comment_id>
            <comment_count>1</comment_count>
            <who>Andreas Sewe</who>
            <commenter_username>andreas.sewe</commenter_username>
            <when>2016-08-16 11:10:30 -0400</when>
            <comment_text>It turns out org.eclipse.jdt.internal.compiler.util.Util is not the only candidate; a lot of methods in org.eclipse.jdt.core.Signature suffer from similar problems. I propose to enrich all their IAEs in one go.</comment_text>
        </comment>
        <comment>
            <comment_id>2740544</comment_id>
            <comment_count>2</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-08-16 11:11:42 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/79140</comment_text>
        </comment>
        <comment>
            <comment_id>2740580</comment_id>
            <comment_count>3</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-08-16 12:40:52 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/79146</comment_text>
        </comment>
        <comment>
            <comment_id>2740884</comment_id>
            <comment_count>4</comment_count>
            <who>Andreas Sewe</who>
            <commenter_username>andreas.sewe</commenter_username>
            <when>2016-08-17 08:03:01 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #3)
&gt; New Gerrit change created: https://git.eclipse.org/r/79146

Incorporated some helpful feedback by Stephan Herrmann and created a change for the master branch. Can someone please review?

The change in comment 2 I created for the R4_6_maintenance branch can IMHO be abandoned; as Stephan explained, in JDT changes are made to the master branch and then cherry picked onto a version branch, not the other way around.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499766</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-08-16 12:04:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Improve solution from bug 497698</short_desc>
        <thetext>During backport review for bug 497698 we discovered some room for improvements, that should go only into master. In particular see bug 497698 comment 20</thetext>
    </bug>
    <bug>
        <id>499789</id>
        <developer>Marcel Konopka</developer>
        <developer_username>mk</developer_username>
        <dup_id/>
        <creation_time>2016-08-16 17:08:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>loop in lambda makes it ambiguous</short_desc>
        <thetext>When i use a loop in a lambda that could be used as Consumer or Function it becomes ambiguous. This happens when the loop is the last statement.

Everything works fine if compiled directly with javac.

Here is a minimal example:

public class Test {
    public static class A{
        public void a(Consumer&lt;Object&gt; task){
        }

        public &lt;R&gt; R a(Function&lt;Object, R&gt; task){
            return null;
        }
    }

    public static void main(String[] args) {
        A a = new A();

        //okay
        a.a(task -&gt; {
        });

        //not okay: 
        //"The method a(Consumer&lt;Object&gt;) is ambiguous for the type Test.A"
        a.a(task -&gt; {
            for (int i = 0; i &lt; 1; i++) {
            }
        });

        //okay
        a.a(task -&gt; {
            for (int i = 0; i &lt; 1; i++) {
            }
            ;
        });
    }
}</thetext>
        <comment>
            <comment_id>2740694</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-16 17:20:19 -0400</when>
            <comment_text>I can reproduce, also with other kinds of loops.

Apparently we fail to see that the lambda is not value compatible.</comment_text>
        </comment>
        <comment>
            <comment_id>2740948</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-17 09:45:18 -0400</when>
            <comment_text>SO discussion: http://stackoverflow.com/questions/38972060/for-loop-in-lambda-makes-it-ambiguous</comment_text>
        </comment>
        <comment>
            <comment_id>2744900</comment_id>
            <comment_count>3</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-08-30 01:09:40 -0400</when>
            <comment_text>LE.isPotentiallyCompatibleWith() does a rudimentary shape analysis on an as yet unresolved lambda causing all the loop statements to answer true in doesNotCompleteNormally() (because cst == null). While dealing with unresolved statements, we cannot accurately say whether the lambda is value compatible or not, so we should probably use cachedResolvedCopy() with anyTargetOk set to true to determine the shape of the lambda, and may be fall back on the simple minded analysis if this fails</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499794</id>
        <developer>Rob Lewis</developer>
        <developer_username>groblewis</developer_username>
        <dup_id/>
        <creation_time>2016-08-17 00:09:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Breaking up a long string constant causes editor anomaly</short_desc>
        <thetext>I have a String variable set to equal a very long String literal, enclosed in quotes (and containing many backslash-escaped quote characters). 

String myString = "lots and lots of text including many backslash-escaped quote characters"; 

I am breaking it up into smaller pieces in my source code, which are concatenated to create the whole string. In the editor, I find a place to break the string, type " then + then &lt;return&gt; then ". 

String myString = "First part of text "+
    "next part of text"+ // etc. 

Sometimes this works fine to restart the string on the next line. Often, however, the newly-created line begins with TWO quote marks in a row, generating an error condition. If I delete the second, spurious quote mark, everything is OK. 


-- Configuration Details --
Product: Eclipse 4.6.0.20160613-1800 (org.eclipse.epp.package.java.product)
Installed Features:
 org.eclipse.platform 4.6.0.v20160606-1342
 
 P.S. May I say that your bug report form is very hostile to users who aren't intimately familiar with the Eclipse project? How on earth am I supposed to know what to enter for the "Product" and "Component" fields?</thetext>
        <comment>
            <comment_id>2740722</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-17 00:44:07 -0400</when>
            <comment_text>Rob, have you tried just pressing a return? That should take care of breaking the string into a separate line. This works for me every single time. And I believe this is the right way to do it.</comment_text>
        </comment>
        <comment>
            <comment_id>2740736</comment_id>
            <comment_count>2</comment_count>
            <who>Rob Lewis</who>
            <commenter_username>groblewis</commenter_username>
            <when>2016-08-17 03:13:17 -0400</when>
            <comment_text>Wow, who knew?! 

Seems to work great. Thanks! 

But doing it the way I described shouldn't cause problems, should it?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499817</id>
        <developer>Christian Schwarz</developer>
        <developer_username>chriss.dev</developer_username>
        <dup_id/>
        <creation_time>2016-08-17 06:29:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>The JDT compiler allows different return types for the same method name and parameters</short_desc>
        <thetext>Created attachment 263631
The java project to reproduce this bug.

The following test case compiles fine JDT core version 3.10.2.v20150220-1634 but it should not complile.

public class Test {

    public  static &lt;T&gt; T foo(Matcher&lt;T&gt; p){
        return null;
    }
    
    public static long foo(Matcher&lt;Long&gt; p){
        return 0;
    }
    
    public  static int foo(Matcher&lt;Integer&gt; p){
        return 0;
    }
}

To reproduce it do the following:
 - create a new java project with execution enviroment J2SE-1.5
 - go to the project properies and set the compiler compliance level to "1.6"
 - now the above code compiles

The installed JRE was to one of JDK1.8.0_25</thetext>
    </bug>
    <bug>
        <id>499856</id>
        <developer>rajeev akotkar</developer>
        <developer_username>rajeev.akotkar</developer_username>
        <dup_id/>
        <creation_time>2016-08-17 13:31:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Terminate button is not clickable in Ubuntu</short_desc>
        <thetext>I have tried Mars R as well Neon R Eclipse for JEE developers and I am using Ubuntu version 16.04.The terminate button here is not clickable  ,even after termination  stops it is not going grey.</thetext>
        <comment>
            <comment_id>2741198</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-18 01:01:03 -0400</when>
            <comment_text>Is it the terminate button from the console view?

Can you please elaborate on the bug or provide steps to reproduce the same?</comment_text>
        </comment>
        <comment>
            <comment_id>2741205</comment_id>
            <comment_count>2</comment_count>
            <who>rajeev akotkar</who>
            <commenter_username>rajeev.akotkar</commenter_username>
            <when>2016-08-18 01:51:47 -0400</when>
            <comment_text>I created a simple main program.
Ran the same and the execution was completed at program got terminated,the status of terminate button didnt change to grey.

Since it was stillshowing as RED square I tried to click on it.
it was not clickable.</comment_text>
        </comment>
        <comment>
            <comment_id>2741206</comment_id>
            <comment_count>3</comment_count>
            <who>rajeev akotkar</who>
            <commenter_username>rajeev.akotkar</commenter_username>
            <when>2016-08-18 01:54:16 -0400</when>
            <comment_text>Created attachment 263641
terminate buuton</comment_text>
        </comment>
        <comment>
            <comment_id>2741214</comment_id>
            <comment_count>4</comment_count>
            <who>rajeev akotkar</who>
            <commenter_username>rajeev.akotkar</commenter_username>
            <when>2016-08-18 02:23:09 -0400</when>
            <comment_text>It is clickable and works fine in debug mode.But doesnt grey out while the execution is terminated(stopped)</comment_text>
        </comment>
        <comment>
            <comment_id>2741261</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-18 04:49:39 -0400</when>
            <comment_text>Sarika, any idea what might be going on? Or do you need more information to proceed.

Rajeev, we don't yet have enough details to proceed on this. I am not even sure if this is a problem with the Java run time or a problem with the IDE. Ideally we need a reproducible steps to investigate. Also, can you look at the the log file and let us know if you find anything in interesting there?</comment_text>
        </comment>
        <comment>
            <comment_id>2742129</comment_id>
            <comment_count>6</comment_count>
            <who>rajeev akotkar</who>
            <commenter_username>rajeev.akotkar</commenter_username>
            <when>2016-08-21 02:21:27 -0400</when>
            <comment_text>I went through the logs and havent found anything relevant to the context.
Steps to reproduce would be :

1.open eclipse
2,create a java project.
3.Create a class with a main method.
4.Write a simple System.out.println("hello world");
5.run the program.
6.the program would run and get terminated.
7.Observe the terminate button,it is not grayed out.it is still showing red colored square.</comment_text>
        </comment>
        <comment>
            <comment_id>2742130</comment_id>
            <comment_count>7</comment_count>
            <who>rajeev akotkar</who>
            <commenter_username>rajeev.akotkar</commenter_username>
            <when>2016-08-21 02:35:02 -0400</when>
            <comment_text>Created attachment 263689
terminate button not greying out after program terminates</comment_text>
        </comment>
        <comment>
            <comment_id>2743515</comment_id>
            <comment_count>8</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-25 04:45:09 -0400</when>
            <comment_text>What version of Eclipse are you using? Could you try with a more recent one? Also try a different version of JRE if that's possible.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499907</id>
        <developer>Mike Young</developer>
        <developer_username>michael_young</developer_username>
        <dup_id/>
        <creation_time>2016-08-18 09:16:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>FusionDebug plugin, eclipse throws an unhandled "nullpointer" exception.</short_desc>
        <thetext>Created attachment 263650
Eclipse Neon always throws us this dialogue box for this issue. Stack trace "first" is the original, "Second" is what we are currently having.

We have updated our FusionDebug product to install and work on Eclipse Neon (for Java Developers). We tested working and (purposefully)faulty connections on eclipse JUNO, LUNA, MARS &amp; NEON. Everything worked fine on all versions, except the faulty connections on NEON. When we make a faulty configuration in our plugin, Eclipse NEON throws an un-handled "nullpointer" exception. 

However, we have tried to resolve this issue by making changes in our code but without any positive result.

We have released our FusionDebug version now after extensive customer demands, but we have had to warn them about this issue in eclipse NEON.

Below I have attached a zip that contains two stack traces and a screenshot of the issue in the UI. The "First" stack trace is the one we got when we first discovered the issue while the "Second" stack trace is the one we have after modification to code on our side. 

We always get the same dialogue error whenever we mis-configure the debug port that the application server is listening to. 

Thank you in advance.

Mike - FusionReactor engineer</thetext>
        <comment>
            <comment_id>2741448</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-18 11:15:19 -0400</when>
            <comment_text>If I understand correctly, everything in com.integral.fusiondebug is *your* code, right?

In Error-stacktrace-first.png (why a png? ascii text is so much easier to share) I see an NPE in fusiondebug code.

To me this looks like a bug in fusiondebug. How could this possibly be a bug in JDT? Please explain. What is your expectation: who should handle the faulty connection and how? What connection is that anyway?</comment_text>
        </comment>
        <comment>
            <comment_id>2742206</comment_id>
            <comment_count>2</comment_count>
            <who>Mike Young</who>
            <commenter_username>michael_young</commenter_username>
            <when>2016-08-22 04:19:29 -0400</when>
            <comment_text>Created attachment 263694
Eclipse Mars dialogue

Hello,

     In the second stack trace, by "fix" I mean we added code to catch our null pointer exception, and instead deliberately throw the ConnectException. Despite this the Eclipse dialogue still displays a null pointer exception.

In previous version of eclipse this would show a ConnectException with the stack trace being the dialogue content. So this issue seems specific to eclipse Neon.

Here is a dialogue box from mars showing the ConnectException - this is what we were expecting to happen in Eclipse Neon.

Looking forward to your responce

Mike</comment_text>
        </comment>
        <comment>
            <comment_id>2743511</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-25 04:41:33 -0400</when>
            <comment_text>Hi Mike, could you respond to Stephan's question about the connection you are talking about? What is the connection and what does it connect and with what?</comment_text>
        </comment>
        <comment>
            <comment_id>2744500</comment_id>
            <comment_count>4</comment_count>
            <who>Mike Young</who>
            <commenter_username>michael_young</commenter_username>
            <when>2016-08-29 04:11:59 -0400</when>
            <comment_text>Hi all

     It is jdwp style debug connection to a ColdFusion based application server (ColdFusion/Lucee/Railo). The plugin is for live debugging java or cf code on application servers. It connects eclipse to whichever class the user wants to debug if it exists.

Looking forward to your response,

Mike</comment_text>
        </comment>
        <comment>
            <comment_id>2744573</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-29 06:22:51 -0400</when>
            <comment_text>I would like to believe this is not an Eclipse problem, or at the very least not a JDT issue. Copying Sarika from debug in case she has some idea about this.</comment_text>
        </comment>
        <comment>
            <comment_id>2744577</comment_id>
            <comment_count>6</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-08-29 06:35:51 -0400</when>
            <comment_text>Looks like even if you have fixed by catching the NPE and throwing ConnectException, NPE is still reaching Eclipse Debug component.

You can put a breakpoint on Line 885 in org.eclipse.debug.internal.core.LaunchConfiguration to see which exception is coming back to Eclipse.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499955</id>
        <developer>Cheng-Yu Pai</developer>
        <developer_username>mail4charliepai</developer_username>
        <dup_id/>
        <creation_time>2016-08-18 21:04:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Diamond operator causes conversions to nest interfaces incorrectly</short_desc>
        <thetext>There's a regression regarding Diamond operators, lambdas, and interfaces.

The following java code does not compile in Eclipse Neon (4.6) but compiles and rusn perfectly in Luna (4.4.2) and javac:

import java.util.function.Function;

public class Test {

	public static void main(String[] args) {
		foo(new Data(), new FunctionContainerImpl&lt;&gt;(a -&gt; "test"));
	}

	public static &lt;A extends Data&gt; void foo(A data, FunctionContainer&lt;A&gt; container) {
		System.out.println(container.get(data, data));
	}

	interface FunctionContainer&lt;A extends Data&gt; {
		boolean get(A a, A b);
	}

	public static class Data {
	}

	public static class FunctionContainerImpl&lt;A extends Data, T extends Comparable&lt;T&gt;&gt;
			implements FunctionContainer&lt;A&gt; {

		private Function&lt;A, T&gt; getComparable;

		public FunctionContainerImpl(Function&lt;A, T&gt; getComparable) {
			this.getComparable = getComparable;
		}

		@Override
		public boolean get(A a, A b) {
			return getComparable.apply(a).compareTo(getComparable.apply(b)) == 0;
		}
	}
}


Error in eclipse says:
Type mismatch: cannot convert from String to Comparable&lt;Comparable&lt;T&gt;&gt;

It should be Comparable&lt;T&gt;, not Comparable&lt;Comparable&lt;T&gt;&gt;.</thetext>
        <comment>
            <comment_id>2777314</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-18 03:05:26 -0500</when>
            <comment_text>As of 4.7 M3 this is no longer an issue. Please try with a newer build.

Now I will try and find out which commit fixed this.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500032</id>
        <developer>Gan Ming</developer>
        <developer_username>xyuu</developer_username>
        <dup_id/>
        <creation_time>2016-08-20 21:38:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>java.lang.ArrayIndexOutOfBoundsException: 1</short_desc>
        <thetext>What steps will reproduce the problem?
1. 
2. 
3. 


-- Error Details --
Date: Sun Aug 21 09:34:29 CST 2016
Message: Errors running builder 'Java Builder' on project 'spring-security-config'.
Severity: Error
Product: Spring Tool Suite 3.8.0.201606301029-RELEASE (org.springsource.sts.ide)
Plugin: org.eclipse.jdt.core
Session Data:
eclipse.buildId=3.8.0.201606301029-RELEASE-e46
java.version=1.8.0_102
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

Exception Stack Trace:
java.lang.ArrayIndexOutOfBoundsException: 1
	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.boundCheck(ParameterizedTypeBinding.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference.checkBounds(ParameterizedQualifiedTypeReference.java:85)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference.checkBounds(ParameterizedQualifiedTypeReference.java:78)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference.checkBounds(ParameterizedQualifiedTypeReference.java:70)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.checkParameterizedTypeBounds(ClassScope.java:903)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.checkParameterizedTypeBounds(ClassScope.java:912)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.checkParameterizedTypes(CompilationUnitScope.java:240)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:255)
	at org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:843)
	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:385)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:431)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:417)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:368)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:179)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:305)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:61)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:256)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:180)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:735)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:301)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:304)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:360)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:383)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:144)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:235)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)</thetext>
        <comment>
            <comment_id>2742145</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-21 07:50:26 -0400</when>
            <comment_text>Several issues with this report:

This version 
   eclipse.buildId=3.8.0.201606301029-RELEASE-e46
indicates that you are not using an original distribution from Eclipse.org but a variant patched for STS.

Please tell us the exact version number of plugin org.eclipse.jdt.core better understand which software exactly you are running. Seeing the 201606... time stamp this should be s.t. like 3.12.0.v201606 ... tentatively setting version to 4.6 (=jdt 3.12) but the 3.8.0 prefix above makes me wonder.

Target milestones are set by developers, not reporters (unless you provide a good quality patch :) ).

Importance 'blocker' is probably inappropriate (all compiler bugs are very important for those affected, but marking all as blockers doesn't help prioritize).

To actually perform any investigation we need a reproducing example (source code). Could you please provide such?

It may be our lucky day, because the exception looks very similar to bug 496675, which has been fixed in master and is pending for backport to 4.6.1, but line numbers don't match, likely due to source changes made for STS.

You are invited to test a 4.7 M1 build of Eclipse SDK, but obviously we cannot make any statement about when our fix becomes available via STS.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500116</id>
        <developer>Jonatan Stenbacka</developer>
        <developer_username>jonatan.stenbacka</developer_username>
        <dup_id/>
        <creation_time>2016-08-23 06:47:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Problems during content assist when invoking method with constructor call</short_desc>
        <thetext>When I'm trying to get content assist when I'm invoking a method in the same call as the constructor call. I get a "Problems During Content Assist" error dialog with the following content: "The 'org.eclipse.jdt.ui.TemplateProposalComputer' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension has thrown a runtime exception. To aviod this message, disable the 'org.eclipse.jdt.ui' plug-in or disable the 'Template Proposals' category on the content assist preference page." (Please excuse any minor spelling mistakes in the quote above. Couldn't copy the text from the dialog.)

The call I'm describing can e.g. look like this: "new Thread().". When I type the dot, I get the error.

I've tried reinstalling and updating Eclipse, without resolving the issue.

Here's the log:

!ENTRY org.eclipse.recommenders.completion.rcp 4 2 2016-08-23 12:30:04.981
!MESSAGE Exception during code completion.
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor0(Scope.java:2356)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor(Scope.java:2337)
	at org.eclipse.jdt.internal.compiler.ast.Statement.findConstructorBinding(Statement.java:440)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveTypeForQualifiedAllocationExpression(QualifiedAllocationExpression.java:566)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveType(QualifiedAllocationExpression.java:287)
	at org.eclipse.jdt.internal.codeassist.complete.CompletionOnMemberAccess.resolveType(CompletionOnMemberAccess.java:56)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1283)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveTypeForQualifiedAllocationExpression(QualifiedAllocationExpression.java:502)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveType(QualifiedAllocationExpression.java:287)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:410)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveTypeForQualifiedAllocationExpression(QualifiedAllocationExpression.java:330)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveType(QualifiedAllocationExpression.java:287)
	at org.eclipse.jdt.internal.codeassist.complete.CompletionOnMemberAccess.resolveType(CompletionOnMemberAccess.java:56)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:276)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:600)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1928)
	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:131)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:357)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:345)
	at org.eclipse.recommenders.completion.rcp.CompletionContextFunctions$InternalCompletionContextFunction.compute(CompletionContextFunctions.java:403)
	at org.eclipse.recommenders.completion.rcp.RecommendersCompletionContext.get(RecommendersCompletionContext.java:325)
	at org.eclipse.recommenders.completion.rcp.RecommendersCompletionContext.get(RecommendersCompletionContext.java:333)
	at org.eclipse.recommenders.completion.rcp.RecommendersCompletionContext.doGetCoreContext(RecommendersCompletionContext.java:132)
	at org.eclipse.recommenders.completion.rcp.RecommendersCompletionContext.getCompletionNode(RecommendersCompletionContext.java:115)
	at org.eclipse.recommenders.internal.constructors.rcp.ConstructorCompletionSessionProcessor.isCompletionRequestSupported(ConstructorCompletionSessionProcessor.java:216)
	at org.eclipse.recommenders.internal.constructors.rcp.ConstructorCompletionSessionProcessor.startSession(ConstructorCompletionSessionProcessor.java:87)
	at org.eclipse.recommenders.completion.rcp.processable.IntelligentCompletionProposalComputer.fireStartSession(IntelligentCompletionProposalComputer.java:304)
	at org.eclipse.recommenders.completion.rcp.processable.IntelligentCompletionProposalComputer.computeCompletionProposals(IntelligentCompletionProposalComputer.java:170)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:337)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:331)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:288)
	at org.eclipse.jface.text.contentassist.ContentAssistant$3.run(ContentAssistant.java:1931)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1928)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:565)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$16(CompletionProposalPopup.java:560)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:494)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:487)
	at org.eclipse.jface.text.contentassist.ContentAssistant$AutoAssistListener$1.run(ContentAssistant.java:371)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4203)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3819)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:687)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)</thetext>
        <comment>
            <comment_id>2742713</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-08-23 07:35:42 -0400</when>
            <comment_text>Can you provide a code snippet to reproduce the issue?</comment_text>
        </comment>
        <comment>
            <comment_id>2742749</comment_id>
            <comment_count>2</comment_count>
            <who>Jonatan Stenbacka</who>
            <commenter_username>jonatan.stenbacka</commenter_username>
            <when>2016-08-23 08:29:35 -0400</when>
            <comment_text>Sadly no. The problem seems to be limited to one specific .java-file even. Not even other .java-files in the same package have the same issue.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500157</id>
        <developer>Dirk Fauth</developer>
        <developer_username>dirk.fauth</developer_username>
        <dup_id/>
        <creation_time>2016-08-23 15:20:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Wrong "Dead code" warning</short_desc>
        <thetext>In one of my Java source files [1] I get a "Dead code" warning for a line of code that is definitely not dead and executed at runtime.

Seems to be related to null analysis. The field that is checked is initialized with null and set within a nested for loop. I tried to set the value in the outer for loop and the warning vanishes. If I set the value only in the inner for loop (which is the required scenario) the warning appears.

[1] http://git.eclipse.org/c/nattable/org.eclipse.nebula.widgets.nattable.git/tree/org.eclipse.nebula.widgets.nattable.core/src/org/eclipse/nebula/widgets/nattable/fillhandle/FillHandleLayerPainter.java</thetext>
        <comment>
            <comment_id>2743170</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-24 06:31:03 -0400</when>
            <comment_text>Could you please tell us which exact code location triggers the problem.
Obviously, an isolated example would be ideal for investigation.</comment_text>
        </comment>
        <comment>
            <comment_id>2743247</comment_id>
            <comment_count>2</comment_count>
            <who>Dirk Fauth</who>
            <commenter_username>dirk.fauth</commenter_username>
            <when>2016-08-24 09:30:26 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #1)
&gt; Could you please tell us which exact code location triggers the problem.
&gt; Obviously, an isolated example would be ideal for investigation.

Sorry, I thought I posted the line numbers.

The warning is raised on line 378.
The fillHandleCell variable is set on line 302. This code is exactly executed once at the end of the for loop. So it is definitely no dead code.

I tried to provoke the warning with a similar isolated code, but I am not able to reproduce the issue this way. I really don't understand which side effect causes that warning.</comment_text>
        </comment>
        <comment>
            <comment_id>2743787</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-25 12:45:30 -0400</when>
            <comment_text>(In reply to Dirk Fauth from comment #2)
&gt; (In reply to Stephan Herrmann from comment #1)
&gt; &gt; Could you please tell us which exact code location triggers the problem.
&gt; &gt; Obviously, an isolated example would be ideal for investigation.
&gt; 
&gt; Sorry, I thought I posted the line numbers.
&gt; 
&gt; The warning is raised on line 378.
&gt; The fillHandleCell variable is set on line 302.

Thanks

&gt; I tried to provoke the warning with a similar isolated code, but I am not
&gt; able to reproduce the issue this way. I really don't understand which side
&gt; effect causes that warning.

mh, investigation will not be easy then ...</comment_text>
        </comment>
        <comment>
            <comment_id>2783884</comment_id>
            <comment_count>4</comment_count>
            <who>Frank Benoit</who>
            <commenter_username>frank.rene.benoit</commenter_username>
            <when>2016-12-07 09:24:35 -0500</when>
            <comment_text>Hello Dirk, hello Stephan,

I have also such a dead code warning, also when working with the null analysis. 

And i have SonarLint active, perhaps it is related to it. Dirk, do you have use SonarLint too?

However, closed and rebuild with another Eclipse 4.6.1 without SonarLint, warning is gone. Back to Eclipse with SonarLint, the project clean, the warning stays away. :-/

I there a way to get helpful information? logs or something?

Frank</comment_text>
        </comment>
        <comment>
            <comment_id>2784075</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-07 14:29:57 -0500</when>
            <comment_text>Fankly, I have no idea how SonarLint interacts with JDT. You?</comment_text>
        </comment>
        <comment>
            <comment_id>2784077</comment_id>
            <comment_count>6</comment_count>
            <who>Dirk Fauth</who>
            <commenter_username>dirk.fauth</commenter_username>
            <when>2016-12-07 14:32:31 -0500</when>
            <comment_text>No I don't use SonarLint. 

I have used an old workspace in a committers version of the IDE. 

Could it be an issue with older workspaces?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500211</id>
        <developer>Thomas Watson</developer>
        <developer_username>tjwatson</developer_username>
        <dup_id/>
        <creation_time>2016-08-24 10:38:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] Help does not work if JDT Java 9 beta is installed (ClassLoader#getResourceAsStream(..) returns null)</short_desc>
        <thetext>Ultimately this probably is not a JDT bug, but I'm starting here to make the team aware.  If you install the JDT Java 9 beta the help system will not come up.  It will report an HTTP 500 error.  Depending on the browser used you may get a small hint at the issue which simply states: java.lang.AbstractMethodError

I debugged the error and got a stacktrace with more info:

java.lang.AbstractMethodError: org/eclipse/jdt/internal/compiler/env/ICompilationUnit.module()[C
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.&lt;init&gt;(CompilationUnitDeclaration.java:109)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11725)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11705)
	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:10119)
	at org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:815)
	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:385)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:431)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:417)
	at org.apache.jasper.compiler.JDTJavaCompiler.compile(JDTJavaCompiler.java:494)
	at org.apache.jasper.compiler.Compiler.generateClass(Compiler.java:384)
	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:453)
	at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:625)
	at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:374)
	at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:492)
	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:378)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)

The jasper bundle included from orbit (org.apache.jasper.glassfish_2.2.2.v201501141630) imports the internal packages from JDT.  It appears that ICompilationUnit had a new method module() added.  The jasper implementation of this interface does not provide the module() method.</thetext>
        <comment>
            <comment_id>2743318</comment_id>
            <comment_count>1</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-08-24 12:13:55 -0400</when>
            <comment_text>These dependencies of Jasper are a huge mess because Jasper's JDTJavaCompiler illegally implements 2 internal jdt.core interfaces, see bug 442310.

When I added org.eclipse.jdt.internal.compiler.ast to the optional imports (to get the CompilationUnitDeclaration from the latest jdt.core), the next problem was:

java.lang.AbstractMethodError: org.apache.jasper.compiler.JDTJavaCompiler$1CompilationUnit.module()[C
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.module(CompilationUnitDeclaration.java:788)
...
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:417)
	at org.apache.jasper.compiler.JDTJavaCompiler.compile(JDTJavaCompiler.java:494)
	at org.apache.jasper.compiler.Compiler.generateClass(Compiler.java:384)
	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:453)
	at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:625)
...


org.apache.jasper.compiler.JDTJavaCompiler$1CompilationUnit is a class that implements org.eclipse.jdt.internal.compiler.env.ICompilationUnit. We can't fix the Jasper classes in Orbit.

Without a fix in Jasper, the only choice we have is to keep the used interfaces stable, even though they are internal. The other affected interface is org.eclipse.jdt.internal.compiler.env.INameEnvironment. While we could probably survive the ICompilationUnit changes by turning the new methods into default methods, this won't work for INameEnvironment.

I don't have a good idea how to solve this.</comment_text>
        </comment>
        <comment>
            <comment_id>2743429</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-25 01:04:57 -0400</when>
            <comment_text>(In reply to Markus Keller from comment #1)
&gt; I don't have a good idea how to solve this.

when we eventually move to compliance 1.8 (most likely in Oxygen M2), we could take a look at adding those methods as default.</comment_text>
        </comment>
        <comment>
            <comment_id>2747043</comment_id>
            <comment_count>3</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-09-05 12:06:57 -0400</when>
            <comment_text>I've implemented the default methods in the two affected interfaces with http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=8d3656f24c3e874f200c42da415930e5a37a16ba

After that, Help works again when running with Java 8.

When running with Java 9, there's a new problem:
java.lang.ClassLoader#getResourceAsStream(String) has been broken and returns null in latest JDK9 previews. See
http://openjdk.java.net/projects/jigsaw/spec/issues/#ClassFilesAsResources and
https://bugs.openjdk.java.net/browse/JDK-8154401

The effect is that the JSP compiler doesn't find the required .class files for classes from the base module:

org.apache.jasper.JasperException: PWC6033: Error in Javac compilation for JSP||PWC6199: Generated servlet error:|The type java.util.List cannot be resolved. It is indirectly referenced from required .class files||PWC6199: Generated servlet error:|The type java.lang.String cannot be resolved. It is indirectly referenced from required .class files||[..]
	at org.apache.jasper.compiler.DefaultErrorHandler.javacError(DefaultErrorHandler.java:129)
	at org.apache.jasper.compiler.ErrorDispatcher.javacError(ErrorDispatcher.java:299)
	at org.apache.jasper.compiler.Compiler.generateClass(Compiler.java:392)
	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:453)
	at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:625)
	at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:374)
	at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:492)
	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:378)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)
	at org.eclipse.equinox.jsp.jasper.JspServlet.service(JspServlet.java:155)
[..]

Typical stacktrace at the point of failure:
	at org.apache.jasper.compiler.JDTJavaCompiler$1.findType(JDTJavaCompiler.java:345)
	at org.apache.jasper.compiler.JDTJavaCompiler$1.findType(JDTJavaCompiler.java:315)
	at org.eclipse.jdt.internal.compiler.env.INameEnvironment.findType(INameEnvironment.java:47)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:180)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:156)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:102)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:217)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getType(PackageBinding.java:159)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findType(Scope.java:1932)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3260)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2952)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:51)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:495)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:586)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:582)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference.internalResolveLeafType(ParameterizedQualifiedTypeReference.java:224)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference.internalResolveType(ParameterizedQualifiedTypeReference.java:200)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference.resolveType(ParameterizedQualifiedTypeReference.java:460)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:582)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypeFor(SourceTypeBinding.java:1770)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.fields(SourceTypeBinding.java:939)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.internalFaultInTypeForFieldsAndMethods(SourceTypeBinding.java:908)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:904)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:458)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:860)
	at org.eclipse.jdt.internal.compiler.Compiler.processCompiledUnits(Compiler.java:550)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:462)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:417)
	at org.apache.jasper.compiler.JDTJavaCompiler.compile(JDTJavaCompiler.java:494)
	at org.apache.jasper.compiler.Compiler.generateClass(Compiler.java:384)
	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:453)
	at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:625)
	at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:374)
	at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:492)
	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:378)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)
	at org.eclipse.equinox.jsp.jasper.JspServlet.service(JspServlet.java:155)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)</comment_text>
        </comment>
        <comment>
            <comment_id>2747082</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-05 14:06:23 -0400</when>
            <comment_text>(In reply to Markus Keller from comment #3)
&gt; I've implemented the default methods in the two affected interfaces with
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
&gt; ?id=8d3656f24c3e874f200c42da415930e5a37a16ba

compliance update via this commit will probably create merge conflicts with similar change in master, right?</comment_text>
        </comment>
        <comment>
            <comment_id>2747746</comment_id>
            <comment_count>5</comment_count>
            <who>Kevin Quinn</who>
            <commenter_username>kevin.quinn</commenter_username>
            <when>2016-09-07 05:30:04 -0400</when>
            <comment_text>We have experienced this issue with our Help and Java 1.8.0_101. How do i get this to work ? Do i  wait for a fix in next release of eclipse ?</comment_text>
        </comment>
        <comment>
            <comment_id>2748506</comment_id>
            <comment_count>6</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-09-08 10:30:18 -0400</when>
            <comment_text>(In reply to Kevin Quinn from comment #5)
&gt; We have experienced this issue with our Help and Java 1.8.0_101. How do i
&gt; get this to work ? Do i  wait for a fix in next release of eclipse ?

JDK 8 support has been fixed with Luna SR2 (bug 442310). I've just verified that Help works fine with Eclipse SDK Neon (4.6) and JDK 1.8.0_102.

The problem when running with Java 8 in a BETA_JAVA9 preview build has been fixed with 4.7.0.Y20160901-1000, which is available from the http://download.eclipse.org/eclipse/updates/4.7-Y-builds update site.

The remaining problem only happens when running with a Java 9 EA build that suffers from the Jigsaw bug https://bugs.openjdk.java.net/browse/JDK-8154401

If Help doesn't work for you in a non-beta Neon (4.6) or Oxygen (4.7) build, then that would be a different issue.</comment_text>
        </comment>
        <comment>
            <comment_id>2748596</comment_id>
            <comment_count>7</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-09-08 12:26:05 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #4)
&gt; compliance update via this commit will probably create merge conflicts with
&gt; similar change in master, right?

No, the change is identical to the change in master and should therefore not cause any merge conflicts. I just merged master into BETA_JAVA9, which confirmed that. The only conflicts I had were other files (partially due to bad previous conflict resolutions).</comment_text>
        </comment>
        <comment>
            <comment_id>2748689</comment_id>
            <comment_count>8</comment_count>
            <who>Kevin Quinn</who>
            <commenter_username>kevin.quinn</commenter_username>
            <when>2016-09-08 16:14:14 -0400</when>
            <comment_text>Thanks for you feedback much appreciated we are using the DITA-OT to build a eclipse standalone info-center for our documentation. All worked great until latest version of Java and we were using eclipse-SDK-4.2-win32.zip and eclipse-SDK-4.2-linux-gtk.tar.gz. 

Now i have replaced with equivalent 4.6 version to resolve this issue with Help and Java version 1.8 however not when i run my startup script it gives error.

java -classpath plugins\org.eclipse.help.base_3.6.100.v201206081400.jar org.eclipse.help.standalone.Infocenter -product opwv.infocenter.poc -plugincustomization plugins/opwv.infocenter/plugin_customization.ini -command start -eclipsehome . -port 9091
Error: Could not find or load main class org.eclipse.help.standalone.Infocenter</comment_text>
        </comment>
        <comment>
            <comment_id>2748711</comment_id>
            <comment_count>9</comment_count>
            <who>Kevin Quinn</who>
            <commenter_username>kevin.quinn</commenter_username>
            <when>2016-09-08 16:41:02 -0400</when>
            <comment_text>I got windows help working now after reading your documentation I updated my startup script to point to correct base version. 

java -classpath plugins\org.eclipse.help.base_4.1.0.v20160606-1100.jar org.eclipse.help.standalone.Infocenter -product opwv.infocenter.poc -plugincustomization plugins/opwv.infocenter/plugin_customization.ini -command start -eclipsehome . -port 9091

only issue i have now is the machines we run our linux help files on have yet to upgrade to 1.8 Java and eclipsse.ini has:

-vmargs
-Dosgi.requiredJavaVersion=1.8
-Xms256m
-Xmx1024m</comment_text>
        </comment>
        <comment>
            <comment_id>2749521</comment_id>
            <comment_count>10</comment_count>
            <who>Kevin Quinn</who>
            <commenter_username>kevin.quinn</commenter_username>
            <when>2016-09-12 06:28:05 -0400</when>
            <comment_text>Has anyone tested this fix on Linux. I installed Java(TM) SE Runtime Environment (build 1.8.0_102-b14)

build target calls eclipse-SDK-4.6-linux-gtk-x86_64.tar.gz 

however when I install infocenter I get error

"HTTP ERROR: 500

Problem accessing /help/index.jsp. Reason:

    PWC6033: Error in Javac compilation for JSP

PWC6199: Generated servlet error:
The type java.io.ObjectInputStream cannot be resolved. It is indirectly referenced from required .class files"</comment_text>
        </comment>
        <comment>
            <comment_id>2749564</comment_id>
            <comment_count>11</comment_count>
            <who>Kevin Quinn</who>
            <commenter_username>kevin.quinn</commenter_username>
            <when>2016-09-12 07:24:31 -0400</when>
            <comment_text>Rerun now appear to get standalone infocenter on Linux but our customizations (generated from DITA-OT) don't come through. Something for me to resolve :)

!SESSION 2016-09-12 11:51:47.487 -----------------------------------------------
eclipse.buildId=4.6.0.I20160606-1100
java.version=1.8.0_102
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_GB
Framework arguments:  -application org.eclipse.help.base.infocenterApplication -product opwv.infocenter.poc -plugincustomization plugins/opwv.infocenter/plugin_customization.ini
Command-line arguments:  -os linux -ws gtk -arch x86_64 -application org.eclipse.help.base.infocenterApplication -data /stminfohub/./workspace -product opwv.infocenter.poc -plugincustomization plugins/opwv.infocenter/plugin_customization.ini

!ENTRY org.eclipse.equinox.app 0 0 2016-09-12 11:52:15.903
!MESSAGE Product opwv.infocenter.poc could not be found.
!SESSION 2016-09-12 12:03:07.272 -----------------------------------------------
eclipse.buildId=4.6.0.I20160606-1100
java.version=1.8.0_102
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_GB
Framework arguments:  -application org.eclipse.help.base.infocenterApplication -product opwv.infocenter.poc -plugincustomization plugins/opwv.infocenter/plugin_customization.ini
Command-line arguments:  -os linux -ws gtk -arch x86_64 -application org.eclipse.help.base.infocenterApplication -data /stminfohub/./workspace -product opwv.infocenter.poc -plugincustomization plugins/opwv.infocenter/plugin_customization.ini

!ENTRY org.eclipse.equinox.app 0 0 2016-09-12 12:03:16.202
!MESSAGE Product opwv.infocenter.poc could not be found.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500242</id>
        <developer>wang willard</developer>
        <developer_username>willardshibao</developer_username>
        <dup_id/>
        <creation_time>2016-08-24 23:14:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>hot code reeplace fails status</short_desc>
        <thetext>Strictly speaking, this is a suggestion, not a bug. When the server is running, I modified the code, then will pop up a dialog box telling me hot code replacement failure, then I have to click on the dialog handle, it is quite annoying, I might want to continue to run the server, modifying the code until I reboot the server . I think if there is a better solution to tell the programmer hot code replacement fail better, for example, appears in the status bar to show the hot code replaced successfully or failed,rather than having to deal with the dialog box. Thank you</thetext>
        <comment>
            <comment_id>2743432</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-25 01:25:02 -0400</when>
            <comment_text>Is this specific to running servers or happens when debugging a Java program too?</comment_text>
        </comment>
        <comment>
            <comment_id>2743435</comment_id>
            <comment_count>2</comment_count>
            <who>wang willard</who>
            <commenter_username>willardshibao</commenter_username>
            <when>2016-08-25 01:30:33 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #1)
&gt; Is this specific to running servers or happens when debugging a Java program
&gt; too?

when debugging a Java application</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500312</id>
        <developer>Stefan Dijkstra</developer>
        <developer_username>s.dijkstra</developer_username>
        <dup_id/>
        <creation_time>2016-08-26 02:31:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Renaming package or moving class does not update import statements when project is depended on indirectly</short_desc>
        <thetext>Situation: Project A depends on project B and exports it. Project C does not directly depend on B, but does depend on A so it gains access to all classes in B indirectly.
Action: I rename a package "com.foo" inside B to "com.bar".
Expectation: I expect all import statements in C that reference classes in B's "com.foo" to be updated to "com.bar".
Error: The import statements are not updated and cause compile errors.

Workaround 1: I can remove the old import statements manually, and then use "Organize Imports" to insert the correct ones.
Workaround 2: I can add to project C an explicit dependency on project B. Now, renaming a package or moving a class in B do update the import statements in C correctly.

Note: The exact same thing happens when moving a class in B from one package to another: the import statements are not updated.
Note: I did make sure the checkbox "Update references .." was checked in the "Rename" and "Move" refactoring dialog windows.

-- Configuration Details --
Product: Eclipse 4.6.0.20160613-1800 (org.eclipse.epp.package.java.product)
Installed Features:
 org.eclipse.jdt 3.12.0.v20160606-1100</thetext>
    </bug>
    <bug>
        <id>500325</id>
        <developer>Tushar Phadke</developer>
        <developer_username>tushar_phadke</developer_username>
        <dup_id/>
        <creation_time>2016-08-26 07:32:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8] Eclipse failed to compile Java 8 code against Scala library types.</short_desc>
        <thetext>Created attachment 263795
Project with Error using JDK8

I have used Java 8 Streams in code using JDK 8. The code is compilable using JAVA_HOME/bin/javac but Eclipse shows error for same class. I have attached same project with this bug.</thetext>
        <comment>
            <comment_id>2744253</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-26 12:02:04 -0400</when>
            <comment_text>Can this problem be reproduced without scala classes?

I tried to replace those two classes with this:
//---
class IndexedSeq&lt;T&gt; {
	int size() { return 0; }
}
class ActorRef {}
//---

With that replacement the program was accepted alright.

There must be something within those libs that breaks type inference.

In bug 468276 we concluded that scala generates class files that could not be legally produced from Java and hence are outside JLS. Seeing scala collection types involved in both cases this could turn out to be a duplicate of the other bug, unless ...

Tushar, can you provide versions of IndexedSeq and ActorRef that are (a) legal Java and (b) trigger the problem?</comment_text>
        </comment>
        <comment>
            <comment_id>2744399</comment_id>
            <comment_count>2</comment_count>
            <who>Tushar Phadke</who>
            <commenter_username>tushar_phadke</commenter_username>
            <when>2016-08-27 03:43:15 -0400</when>
            <comment_text>Hi Stephan,

We use following version of the library

Alka-Actor: 2.4.1 http://downloads.typesafe.com/akka/akka_2.11-2.4.1.zip?_ga=1.63906607.1480657454.1470547529 
Scala Library: 2.11.7 (Required for Akka) http://www.scala-lang.org/download/2.11.7.html

These JARs are also attached with this bug under lib folder. We have directly included downloaded jars in project as dependency.

- Tushar</comment_text>
        </comment>
        <comment>
            <comment_id>2744415</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-27 12:22:39 -0400</when>
            <comment_text>@Tushar, I've seen the jar files. I am, however, suspecting that these jars contain classes that could not be created using only Java. That's why I asked, if you can create simplified versions of the two required classes as Java source code.

Otherwise I will assume that the bug is not in the Eclipse compiler but in those jar files.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500350</id>
        <developer>Sergey Prigogin</developer>
        <developer_username>eclipse.sprigogin</developer_username>
        <dup_id/>
        <creation_time>2016-08-26 12:30:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/jre/lib/rt.jar is not on its project's build path</short_desc>
        <thetext>The following error was produced when trying to create an external annotation on a JDK class through the workspace level preferences. The error seems to be correlated with a situation when a oroject i configured with a different JDK than the workspace level default.

Java Model Exception: Java Model Status [/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/jre/lib/rt.jar is not on its project's build path]
	at org.eclipse.jdt.internal.core.JavaElement.newJavaModelException(JavaElement.java:566)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:247)
	at org.eclipse.jdt.internal.core.Openable.openAncestors(Openable.java:505)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:241)
	at org.eclipse.jdt.internal.core.Openable.openAncestors(Openable.java:505)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:241)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:316)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:302)
	at org.eclipse.jdt.internal.core.Openable.getBuffer(Openable.java:285)
	at org.eclipse.jdt.internal.core.ClassFile.getBuffer(ClassFile.java:445)
	at org.eclipse.jdt.internal.core.ClassFile.getSource(ClassFile.java:594)
	at org.eclipse.jdt.internal.ui.text.correction.ExternalNullAnnotationQuickAssistProcessor.computeQuickAssistProposals(ExternalNullAnnotationQuickAssistProcessor.java:82)
	at org.eclipse.jface.text.quickassist.QuickAssistAssistant$ContentAssistProcessor.computeCompletionProposals(QuickAssistAssistant.java:68)
	at org.eclipse.jface.text.contentassist.ContentAssistant$3.run(ContentAssistant.java:1931)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1928)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:565)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$16(CompletionProposalPopup.java:560)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:494)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:487)
	at org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1747)
	at org.eclipse.jface.text.quickassist.QuickAssistAssistant.showPossibleQuickAssists(QuickAssistAssistant.java:109)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionAssistant.showPossibleQuickAssists(JavaCorrectionAssistant.java:198)
	at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$5.doOperation(ClassFileEditor.java:952)
	at org.eclipse.jdt.internal.ui.javaeditor.AnnotateClassFileAction.run(AnnotateClassFileAction.java:40)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:565)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:397)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4248)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1501)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1524)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1509)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1313)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4072)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3698)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:687)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)</thetext>
        <comment>
            <comment_id>2744269</comment_id>
            <comment_count>1</comment_count>
            <who>Sergey Prigogin</who>
            <commenter_username>eclipse.sprigogin</commenter_username>
            <when>2016-08-26 12:51:18 -0400</when>
            <comment_text>The workspace reproducing the problem can be downloaded from https://drive.google.com/file/d/0B6aYyBnxF6UTc21DUlNKMzRDcjQ/view?usp=sharing</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500405</id>
        <developer>Mickael Istria - away until ...</developer>
        <developer_username>mistria</developer_username>
        <dup_id/>
        <creation_time>2016-08-29 05:47:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[javadoc] No Javadoc shown with code completion</short_desc>
        <thetext>In some conditions (I didn't manage to identify yet), I see some cases where I have the hover dialog on a method saying there nothing to show, but the completion for the same method at the same location is able to find the javadoc for this method's completion proposal.
I would expect the hover dialog to be able to show javadoc whenever the completion can do it (and vice-versa).</thetext>
        <comment>
            <comment_id>2745058</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-08-30 07:28:13 -0400</when>
            <comment_text>(In reply to Mickael Istria from comment #0)
&gt; In some conditions (I didn't manage to identify yet), I see some cases where
&gt; I have the hover dialog on a method saying there nothing to show, but the
&gt; completion for the same method at the same location is able to find the
&gt; javadoc for this method's completion proposal.

&gt; I would expect the hover dialog to be able to show javadoc whenever the
&gt; completion can do it (and vice-versa).

Yes, that's correct. Please provide a reproducible test case when you encounter this again.</comment_text>
        </comment>
        <comment>
            <comment_id>2745536</comment_id>
            <comment_count>2</comment_count>
            <who>Mickael Istria - away until ...</who>
            <commenter_username>mistria</commenter_username>
            <when>2016-08-31 08:32:03 -0400</when>
            <comment_text>I managed to reproduce a similar issue e) using the CompletableFuture API. Some methods (thenRun) do not show javadoc in hover nor completion, although opening the JavaDoc view and selecting them shows the JavaDoc for this method.
In another file, I get javadoc on hover for thenRun, but not on completion...
The JavaDoc view always seems to be accurate.
I am wondering whether this could be a pure UI issue, something related to the location or the size of the javadoc popup.

However, it's still different from the initial one, which was clearly stating no javadoc was found in the hover (showing it anyway).</comment_text>
        </comment>
        <comment>
            <comment_id>2745574</comment_id>
            <comment_count>3</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-08-31 09:30:59 -0400</when>
            <comment_text>I can reproduce the case where no Javadoc is shown with completion info, but we get the Javadoc on hover and in Javadoc view.

To reproduce:
- Create a Java project using 1.8 JRE (not JDK i.e. no source attached to rt.jar).
- Paste the following method in a class:

	public static void main(String[] args) {
		CompletableFuture&lt;String&gt; cc = new CompletableFuture&lt;&gt;();
		cc.thenRun(null);
		cc.completeExceptionally(null);
	}
- Press Ctrl+space within "completeExceptionally" - we get the Info Javadoc.
- Press Ctrl+space within "thenRun" - we don't get the Info Javadoc.

Both the cases call JavadocContentAccess2#getHTMLContent with IJavaElement as a BinaryMethod. But IJavaElement#getAttachedJavadoc does not return any Javadoc for "thenRun". Moving to JDT/Core for investigation.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500416</id>
        <developer>David Karnok</developer>
        <developer_username>akarnokd</developer_username>
        <dup_id/>
        <creation_time>2016-08-29 07:45:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Compiler is slow with cyclic classes</short_desc>
        <thetext>In the project https://github.com/ReactiveX/RxJava/tree/2.x there are classes, such as `Observable` that are abstract and have several hundred subclasses each. The `Observable` class itself references its own subclasses, hence the cycle.

The problem is that whenever I change the `Observable.java` or just clean the project, the compilation can take 60 seconds or more to finish on a i7 4790 CPU running Java 8u102 on Windows 7. When I build the project from the command line with gradle, javac finishes in about 10 seconds.

Eclipse version: Neon Release (4.6.0)
Build id: 20160613-1800

Here is a part of the hot methods the Flight Recorder captured: https://gist.github.com/akarnokd/c024aa0d1d6ed64e38a51f4b5a22ff2a while running a Project &gt; Clean.</thetext>
    </bug>
    <bug>
        <id>500503</id>
        <developer>Sergey Toshin</developer>
        <developer_username>stoshins</developer_username>
        <dup_id/>
        <creation_time>2016-08-30 08:36:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>ASTParser.createASTs() throws NullPointerException in ReferenceExpression.copy(ReferenceExpression.java:141) and CompilationUnitResolver.resolve(CompilationUnitResolver.java:978)</short_desc>
        <thetext>Created attachment 263844
Testing sources which create the exception, jar where the exception happens and source of the app

Hi. This issue works only when I run my app from console using command
java -jar app.jar
You should unpack the archive, cd to the directory and run
java -jar test.jar

Sources which create exception are in bug_src

I don't know why when I copied code from my app to test app which I wanted to send to you, I got another exception

Exception in thread "main" java.lang.NullPointerException
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:978)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:639)
	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:993)
	at test.Main.prepareCompilationUnitsForFiles(Main.java:51)
	at test.Main.main(Main.java:33)

But the first exception is
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:827)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1093)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4788)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4755)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:910)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:730)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:867)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1016)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:639)
	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:993)
	at ru.scanner.Main.main(Main.java:124)</thetext>
        <comment>
            <comment_id>2770183</comment_id>
            <comment_count>1</comment_count>
            <who>Matthew Wilson</who>
            <commenter_username>mj.wilson.uk</commenter_username>
            <when>2016-10-26 06:58:31 -0400</when>
            <comment_text>I can reproduce this with a minimal test in Eclispe:

public class Colon
{
   void foo()
   {
   }

   void bar()
   {
      run( this:foo );
   }
   
   void run( Runnable r ) { }
}

eclipse.buildId=4.6.1.M20160907-1200
java.version=1.8.0_60
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_GB
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data workspace</comment_text>
        </comment>
        <comment>
            <comment_id>2770450</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-26 23:51:32 -0400</when>
            <comment_text>Reproduced with the code from comment #1. 

Even though we managed to create a ReferenceExpression with the missing ':', when we try to create a copy with Parser#parseExpression(), it returns a null.</comment_text>
        </comment>
        <comment>
            <comment_id>2772518</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-03 02:06:56 -0400</when>
            <comment_text>*** Bug 466934 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
        <comment>
            <comment_id>2772520</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-03 02:15:26 -0400</when>
            <comment_text>I haven't figured yet how we manage to ignore the missing ':' and creating a ReferenceExpression. Is it handled by the recovery? Why doesn't parseExpression() work the same way? Does it makes sense to report a syntax error early enough and bail out?</comment_text>
        </comment>
        <comment>
            <comment_id>2772540</comment_id>
            <comment_count>5</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-03 04:46:13 -0400</when>
            <comment_text>(In reply to comment #4)
&gt; I haven't figured yet how we manage to ignore the missing ':' and creating a
&gt; ReferenceExpression. Is it handled by the recovery? Why doesn't
&gt; parseExpression() work the same way? Does it makes sense to report a syntax
&gt; error early enough and bail out?
Yes, recovery enables us to get past that point by materializing the missing ':' and creating the reference expression. parseExpression doesn't get into recovery, probably because recovery happens at statement level, and we need to set the relevant context to enable recovery. If we enable statement recovery in referenceExpression.copy, provide the necessary reference context (mostly the enclosing method or type), then we could navigate the resulting AST looking for the expression whose source range matches that of the reference expression we want to copy. That would ensure that we will never end up with null in these cases</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500549</id>
        <developer>Renan Pallin</developer>
        <developer_username>renanpallin</developer_username>
        <dup_id/>
        <creation_time>2016-08-30 22:16:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Sysout snippet not working on lambda function</short_desc>
        <thetext>It's a really simple bug:
The Sysout + ctrl + space snippet not working on lambda function.</thetext>
        <comment>
            <comment_id>2745481</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-31 05:37:37 -0400</when>
            <comment_text>I see one case where it doesn't work, but would like to get your use case just to be sure. For e.g. in the following code, there's one place where the completion works and another where it doesn't:

public abstract class CycleViewHandler extends CycleBaseHandler {
	@Override
	protected void addItems(Table table, WorkbenchPage page) {
		List&lt;MPart&gt; parts = null;
		
		parts.stream().sorted((firstPart, secondPart) -&gt; {
			syso| // no completion
			Long firstPartActivationTime = (Long) firstPart.getTransientData()
					.getOrDefault(PartServiceImpl.PART_ACTIVATION_TIME, Long.MIN_VALUE);
			Long secondPartActivationTime = (Long) secondPart.getTransientData()
					.getOrDefault(PartServiceImpl.PART_ACTIVATION_TIME, Long.MIN_VALUE);
			return -(firstPartActivationTime.compareTo(secondPartActivationTime));
		}).forEach(part -&gt; {
			syso| // completion works
			if (true) {
				if (true) {
					IEditorPart activeEditor = page.getActiveEditor();
					if (activeEditor == null) {
					}
				}
			}
		});
	}
}</comment_text>
        </comment>
        <comment>
            <comment_id>2745771</comment_id>
            <comment_count>2</comment_count>
            <who>Renan Pallin</who>
            <commenter_username>renanpallin</commenter_username>
            <when>2016-08-31 17:05:37 -0400</when>
            <comment_text>Shure, in my case is the following code:

carrinhos.stream().map(c -&gt; c.getValorTotal()).forEach(e -&gt; sysout); // does't work</comment_text>
        </comment>
        <comment>
            <comment_id>2745772</comment_id>
            <comment_count>3</comment_count>
            <who>Renan Pallin</who>
            <commenter_username>renanpallin</commenter_username>
            <when>2016-08-31 17:06:02 -0400</when>
            <comment_text>Shure, in my case is the following code:

carrinhos.stream().map(c -&gt; c.getValorTotal()).forEach(e -&gt; sysout); // does't work

(In reply to Jay Arthanareeswaran from comment #1)
&gt; I see one case where it doesn't work, but would like to get your use case
&gt; just to be sure. For e.g. in the following code, there's one place where the
&gt; completion works and another where it doesn't:
&gt; 
&gt; public abstract class CycleViewHandler extends CycleBaseHandler {
&gt; 	@Override
&gt; 	protected void addItems(Table table, WorkbenchPage page) {
&gt; 		List&lt;MPart&gt; parts = null;
&gt; 		
&gt; 		parts.stream().sorted((firstPart, secondPart) -&gt; {
&gt; 			syso| // no completion
&gt; 			Long firstPartActivationTime = (Long) firstPart.getTransientData()
&gt; 					.getOrDefault(PartServiceImpl.PART_ACTIVATION_TIME, Long.MIN_VALUE);
&gt; 			Long secondPartActivationTime = (Long) secondPart.getTransientData()
&gt; 					.getOrDefault(PartServiceImpl.PART_ACTIVATION_TIME, Long.MIN_VALUE);
&gt; 			return -(firstPartActivationTime.compareTo(secondPartActivationTime));
&gt; 		}).forEach(part -&gt; {
&gt; 			syso| // completion works
&gt; 			if (true) {
&gt; 				if (true) {
&gt; 					IEditorPart activeEditor = page.getActiveEditor();
&gt; 					if (activeEditor == null) {
&gt; 					}
&gt; 				}
&gt; 			}
&gt; 		});
&gt; 	}
&gt; }</comment_text>
        </comment>
        <comment>
            <comment_id>2747702</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-07 04:21:40 -0400</when>
            <comment_text>(In reply to Renan Pallin from comment #2)
&gt; Shure, in my case is the following code:
&gt; 
&gt; carrinhos.stream().map(c -&gt; c.getValorTotal()).forEach(e -&gt; sysout); //
&gt; does't work

Can you please provide the test code that compiles?</comment_text>
        </comment>
        <comment>
            <comment_id>2753110</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-20 05:37:26 -0400</when>
            <comment_text>(In reply to Renan Pallin from comment #2)
&gt; Shure, in my case is the following code:
&gt; 
&gt; carrinhos.stream().map(c -&gt; c.getValorTotal()).forEach(e -&gt; sysout); //
&gt; does't work

Renan, can you confirm if the problem is only for syso template and it works for other cases of completion? For e.g., the following works for me:

 carrinhos.stream().map((x)-&gt; (String) x).forEach( e-&gt; e.toS));</comment_text>
        </comment>
        <comment>
            <comment_id>2753154</comment_id>
            <comment_count>6</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-20 07:27:37 -0400</when>
            <comment_text>The syso template not being proposed/completed appears to be lack of correct completion context information from JDT Core. I believe the reason is the following code in CompletionEngine#buildTokenLocationContext().

f (referenceContext instanceof LambdaExpression) {
	LambdaExpression expression = (LambdaExpression)referenceContext;
	if (expression.body().sourceStart &lt;= astNode.sourceStart &amp;&amp;
		astNode.sourceEnd &lt;= expression.body().sourceEnd) {
	// completion is inside a method body
	if (astNodeParent == null &amp;&amp;
			astNode instanceof CompletionOnSingleNameReference &amp;&amp;
			!((CompletionOnSingleNameReference)astNode).isPrecededByModifiers) {
		context.setTokenLocation(CompletionContext.TL_STATEMENT_START);
	}
}

The check astNodeParent == null returns false for completions invoked inside lambda body. But I believe this is the correct behavior. In the testcase mentioned in comment #3, the only possible completions are expressions that can return a value. So, the syso doesn't make sense at all. I have also verified that if the lambda has a block i.e.. {}, and we try to invoke the completion inside the block, then everything is fine.

I am inclined to close this report unless there is any other applicable testcase. 

BTW, I went back to the codes I had posted in comment #1 and found them to be working. Not sure what was happening before.</comment_text>
        </comment>
        <comment>
            <comment_id>2758648</comment_id>
            <comment_count>7</comment_count>
            <who>Renan Pallin</who>
            <commenter_username>renanpallin</commenter_username>
            <when>2016-10-02 21:10:16 -0400</when>
            <comment_text>Hi, sorry taking so long to answer, I'm working and finishing college and my free time is really short at the moment. In my opinion - and in the way I write code -, therefore the sysout rarely stays in the final code, is really great for me to use while I'm developping, testing, finding bugs and in some logs. I think this snippet should work in this case, also he work inside {}, in my point of view shold work whitout the {} in the same way.

Maybe is too late to provide the whole code that compile, was a test for a job I make xD

Thanks for the attention, man, I'm here if you need me and in the future, I'd like to contribute to Eclipse too =)

Renan


(In reply to Jay Arthanareeswaran from comment #6)
&gt; The syso template not being proposed/completed appears to be lack of correct
&gt; completion context information from JDT Core. I believe the reason is the
&gt; following code in CompletionEngine#buildTokenLocationContext().
&gt; 
&gt; f (referenceContext instanceof LambdaExpression) {
&gt; 	LambdaExpression expression = (LambdaExpression)referenceContext;
&gt; 	if (expression.body().sourceStart &lt;= astNode.sourceStart &amp;&amp;
&gt; 		astNode.sourceEnd &lt;= expression.body().sourceEnd) {
&gt; 	// completion is inside a method body
&gt; 	if (astNodeParent == null &amp;&amp;
&gt; 			astNode instanceof CompletionOnSingleNameReference &amp;&amp;
&gt; 			!((CompletionOnSingleNameReference)astNode).isPrecededByModifiers) {
&gt; 		context.setTokenLocation(CompletionContext.TL_STATEMENT_START);
&gt; 	}
&gt; }
&gt; 
&gt; The check astNodeParent == null returns false for completions invoked inside
&gt; lambda body. But I believe this is the correct behavior. In the testcase
&gt; mentioned in comment #3, the only possible completions are expressions that
&gt; can return a value. So, the syso doesn't make sense at all. I have also
&gt; verified that if the lambda has a block i.e.. {}, and we try to invoke the
&gt; completion inside the block, then everything is fine.
&gt; 
&gt; I am inclined to close this report unless there is any other applicable
&gt; testcase. 
&gt; 
&gt; BTW, I went back to the codes I had posted in comment #1 and found them to
&gt; be working. Not sure what was happening before.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500570</id>
        <developer>Jean-Philippe Lesot</developer>
        <developer_username>jplesot</developer_username>
        <dup_id/>
        <creation_time>2016-08-31 06:17:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>javax.lang.model.util.Elements.overrides(...) is broken</short_desc>
        <thetext>Created attachment 263861
APTest.java

Take the following source code:

interface Thing {
  String mth();
}

interface Other {
  String mth();
}

@SuppressWarnings("")
abstract class Impl implements Thing, Other {
}

And an annotation processor which do (see attached source file for the complete source code):

processingEnv.getMessager().printMessage(Kind.WARNING, String.valueOf("overrides(other, thing)=" + processingEnv.getElementUtils().overrides(otherMethod, thingMethod, impl)));
processingEnv.getMessager().printMessage(Kind.WARNING, String.valueOf("overrides(thing, other)=" + processingEnv.getElementUtils().overrides(thingMethod, otherMethod, impl)));

Javac (1.8.0_45) replies:

$ javac -cp AP.jar Test.java
warning: overrides(other, thing)=false
warning: overrides(thing, other)=false

ECJ (4.7M1) replies:

$ java -jar ~/Downloads/ecj-4.7M1.jar -source 8 AP.jar ~/Test.java
2. WARNING: overrides(other, thing)=true
3. WARNING: overrides(thing, other)=true

With the following code:

interface Thing {
  String mth();
}

class Other {
  String mth() { return null; }
}

@SuppressWarnings("")
class Impl extends Other implements Thing {
}

Javac (1.8.0_45) replies:

$ javac -cp AP.jar Test2.java
warning: overrides(other, thing)=true
warning: overrides(thing, other)=false

ECJ (4.7M1) replies:

$ java -jar ~/Downloads/ecj-4.7M1.jar -source 8 AP.jar ~/Test2.java
3. WARNING: overrides(other, thing)=false
4. WARNING: overrides(thing, other)=true</thetext>
        <comment>
            <comment_id>2745498</comment_id>
            <comment_count>1</comment_count>
            <who>Jean-Philippe Lesot</who>
            <commenter_username>jplesot</commenter_username>
            <when>2016-08-31 06:18:29 -0400</when>
            <comment_text>Created attachment 263862
AP Eclipse roject</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500728</id>
        <developer>Lukas Eder</developer>
        <developer_username>lukas.eder</developer_username>
        <dup_id/>
        <creation_time>2016-09-02 06:09:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Saving can get quite slow</short_desc>
        <thetext>I've made the experience that Eclipse can get quite slow on the organise imports save action when saving some files. I've run a profiling session with JMC and this is the single hot method:

Stack Trace	Sample Count	Percentage(%)
org.eclipse.jdt.core.compiler.CharOperation.hashCode(char[])	477	35.624
   org.eclipse.jdt.internal.compiler.util.HashtableOfObject.putUnsafely(char[], Object)	477	35.624
      org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategory(char[], DiskIndex, int[], FileOutputStream)	477	35.624
         org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategories(DiskIndex, int[], FileOutputStream)	477	35.624
            org.eclipse.jdt.internal.core.index.DiskIndex.mergeWith(MemoryIndex)	477	35.624
               org.eclipse.jdt.internal.core.index.Index.save()	477	35.624
                  org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex(Index)	477	35.624
                     org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndexes()	477	35.624
                        org.eclipse.jdt.internal.core.search.indexing.IndexManager.notifyIdle(long)	477	35.624
                           org.eclipse.jdt.internal.core.search.processing.JobManager.run()	477	35.624
                              java.lang.Thread.run()	477	35.624


This is the call tree leading to the hot method, and other related methods:

Stack Trace	Sample Count	Percentage(%)
java.lang.Thread.run()	819	61.165
   org.eclipse.jdt.internal.core.search.processing.JobManager.run()	814	60.792
      org.eclipse.jdt.internal.core.search.indexing.IndexManager.notifyIdle(long)	731	54.593
         org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndexes()	731	54.593
            org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex(Index)	731	54.593
               org.eclipse.jdt.internal.core.index.Index.save()	731	54.593
                  org.eclipse.jdt.internal.core.index.DiskIndex.mergeWith(MemoryIndex)	731	54.593
                     org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategories(DiskIndex, int[], FileOutputStream)	730	54.518
                        org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategory(char[], DiskIndex, int[], FileOutputStream)	730	54.518
                           org.eclipse.jdt.internal.compiler.util.HashtableOfObject.putUnsafely(char[], Object)	593	44.287
                              org.eclipse.jdt.core.compiler.CharOperation.hashCode(char[])	477	35.624
                              org.eclipse.jdt.internal.compiler.util.HashtableOfObject.rehash()	48	3.585
                           org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(char[], boolean)	57	4.257
                           org.eclipse.jdt.internal.compiler.util.HashtableOfObject.get(char[])	53	3.958
                           org.eclipse.jdt.internal.core.index.DiskIndex$IntList.add(int)	24	1.792
                           org.eclipse.jdt.internal.core.index.DiskIndex.writeCategoryTable(char[], HashtableOfObject, FileOutputStream)	3	0.224


Most time is spent inside of DiskIndex.mergeCategory()

I'm very happy to provide additional information that might be needed to track down the problem. I didn't want to add too much information that won't help solve the issue.</thetext>
    </bug>
    <bug>
        <id>500786</id>
        <developer>Natasha DSouza</developer>
        <developer_username>dsouza.natasha303</developer_username>
        <dup_id/>
        <creation_time>2016-09-03 03:49:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Unable to find method reference having an enum parameter which is defined within a class in Mars</short_desc>
        <thetext>Pleae note that this issue happen for an enum defined within a class.

Please use the exact test case

package ind.pakistan.life.search
public class TestCompareAtrributeFilte {
	public enum CompareType {
			EQUAL,NOT}
}

Next the enum defined above is used in static method defined in another class:
package ind.pakistan.life.search;

import  ind.pakistan.life.search.TestCompareAtrributeFilte.CompareType;

public class SampleUse {
  public static void compareTest(CompareType compare,String...criteria){
     // do nothing
  }
}

the compareTest method defined above is usen in test class below

package ind.pakistan.life.search;
import ind.pakistan.life.search;.TestCompareAtrributeFilte.CompareType;
public class SampleToolTest {
public void test(){
  SampleUse.compareTest(CompareType.EQUAL, "Natasha");
  SampleUse.compareTest(CompareType.EQUAL, "Natasha","Ashiwin");
 }
}

I have implemented an tool that generates the references for methods needed  and below is the search pattern used.

IJavaSearchScope scope = createJavaSearchScope(packages.toArray(new IPackageFragment[packages.size()]));
			
MethodPattern pattern = (MethodPattern)  SearchPattern.createPattern(method, IJavaSearchConstants.METHOD,IJavaSearchConstants.REFERENCES, R_EXACT_MATCH);
pattern.varargs = true;
new SearchEngine().search(pattern, new SearchParticipant[] { getDefaultSearchParticipant() }, scope, requestor, null);

Using the above pattern and passing the method argument string as "ind.pakistan.life.search.SampleUse.compareTest(ind.pakistan.life.search.TestCompareAtrributeFilte.CompareType, java.lang.String[])" yields the below result in 

1) eclipse Kepler working fine and gives 2 matches as expected
Version: Kepler Service Release 1
Build id: 20130911-2042

2) eclipse Mars its not working fine and yields 0 matches
Version: Mars.1 Release (4.5.1)
Build id: 20150924-1200

Please can you have look into this issue?</thetext>
    </bug>
    <bug>
        <id>500809</id>
        <developer>Roel van Nuland</developer>
        <developer_username>eclipse</developer_username>
        <dup_id/>
        <creation_time>2016-09-03 17:12:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Support for NON-NLS block</short_desc>
        <thetext>When you have large blocks of Strings which you do not want to externalize, you currently have to mark each and every String separately.
Like this:
private String STRING_A = "string a"; //$NON-NLS-1$
private String STRING_B = "string b"; //$NON-NLS-1$
private String STRING_C = "string c"; //$NON-NLS-1$

Would it be possible to add support for a $NON-NLS-START$ and $NON-NLS-END$ tag (or something similar) so whole blocks can be marked, like this:
// $NON-NLS-START$
private String STRING_A = "string a";
private String STRING_B = "string b";
private String STRING_C = "string c";
// $NON-NLS-END$</thetext>
        <comment>
            <comment_id>2746729</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-04 03:17:22 -0400</when>
            <comment_text>@Vikas, are you sure support for $NON-NLS is provided by JDT/UI? I know we have code in JDT/Core that implements this :)</comment_text>
        </comment>
        <comment>
            <comment_id>2746736</comment_id>
            <comment_count>2</comment_count>
            <who>Vikas Chandra</who>
            <commenter_username>Vikas.Chandra</commenter_username>
            <when>2016-09-04 05:10:18 -0400</when>
            <comment_text>Oops, I thought I triaged this to JDT UI, then saw it back in JDT Core. I thought I had made a mistake and triaged it back to JDT UI :-)

Now moving back by JDT Core.</comment_text>
        </comment>
        <comment>
            <comment_id>2746738</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-04 05:18:00 -0400</when>
            <comment_text>(In reply to Vikas Chandra from comment #2)
&gt; Oops, I thought I triaged this to JDT UI, then saw it back in JDT Core. I
&gt; thought I had made a mistake and triaged it back to JDT UI :-)
&gt; 
&gt; Now moving back by JDT Core.

:)

You should have received a bugzilla email revealing that I did the change, didn't you? For cases of doubt, I'm sure you also know about the History link in the bugzilla header, right?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500881</id>
        <developer>Andreas  Hoehmann</developer>
        <developer_username>andreas.hoehmann</developer_username>
        <dup_id/>
        <creation_time>2016-09-05 13:45:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Senseless build cycles in big complex project after git branch switch</short_desc>
        <thetext>I know the summary is a little bit overloaded :) But I want share some experiences from our project at siemens (~45 maven modules, 500K LOC, core modules with automatic jaxb generation (maven), many spring stuff etc.).

In the last years the build time in this project was continuous increased (better m2e, better eclipse, etc.).

But ... today ... I still have unexplainable build-results if I switch between branches for our huge project. 

Feature branches are always different because we are changing the version to guarantee unique ci-results over all branches. So maybe there is no chance for eclipse to "check" what is necessary to rebuild and what not. Maybe this is a m2e problem. I don't know.</thetext>
        <comment>
            <comment_id>2747076</comment_id>
            <comment_count>1</comment_count>
            <who>Andreas  Hoehmann</who>
            <commenter_username>andreas.hoehmann</commenter_username>
            <when>2016-09-05 13:48:38 -0400</when>
            <comment_text>Ohh I forgot the results ;)

If I'm switching the branches then I see in the "m2e" workspace builds view that some of the modules are build many many times again and again.

So what I expect is:

1. user switch the branch
2. all modules are changed by git
3. eclipse / m2e calculates an execution plan 
4. and *then* it starts the build

In theory it could/should not be possible that a later module build is triggers a former one again and again.

Maybe there are some best practices for "huge" projects based on one big reactor maven project in eclipse? 

Thxs
:D</comment_text>
        </comment>
        <comment>
            <comment_id>2747078</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-05 13:54:09 -0400</when>
            <comment_text>Do you have the Maven Builder from m2e enabled for your projects?

Since JDT knows nothing about maven, the combination of JDT's builder and the Maven Builder might indeed create a situation where the result of each builder triggers the other builder.
Ideally, m2e should control / avoid this.</comment_text>
        </comment>
        <comment>
            <comment_id>2747079</comment_id>
            <comment_count>3</comment_count>
            <who>Andreas  Hoehmann</who>
            <commenter_username>andreas.hoehmann</commenter_username>
            <when>2016-09-05 13:57:18 -0400</when>
            <comment_text>Hi Stephan, you are right ... We are using the "default" m2e integration, workspace resolution enabled, automatic maven project update on, auto build on.

If this is a m2e issue we should move the bug to that project?</comment_text>
        </comment>
        <comment>
            <comment_id>2747092</comment_id>
            <comment_count>4</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-09-05 15:51:57 -0400</when>
            <comment_text>I think this happens because eclipse starts building while m2e is still updating the class paths.

As workaround, it should help to disable "Project &gt; Build automatically" before switching branch and turn it back on when m2e is finished.</comment_text>
        </comment>
        <comment>
            <comment_id>2747109</comment_id>
            <comment_count>5</comment_count>
            <who>Andreas  Hoehmann</who>
            <commenter_username>andreas.hoehmann</commenter_username>
            <when>2016-09-05 16:54:00 -0400</when>
            <comment_text>Could this be possible to do that "automatically"? I can try to provide a patch for such "feature". Which project would be the best for that?</comment_text>
        </comment>
        <comment>
            <comment_id>2747112</comment_id>
            <comment_count>6</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-05 17:02:23 -0400</when>
            <comment_text>(In reply to Andreas  Hoehmann from comment #5)
&gt; Could this be possible to do that "automatically"? I can try to provide a
&gt; patch for such "feature". Which project would be the best for that?

Well, EGit would define the trigger for disabling auto-builds.
M2e would need to signal "done" to re-enable.
And all this only if both of these plug-ins are involved.
Ergo: I don't see a good location where this could be coordinated. Anyone?

BTW: at work I typically disable/remove the Maven Builder (plus some disabling of m2e errors), so I use m2e just for maintaining the Maven Dependencies classpath container, and perhaps an occasional "Run As &gt; Maven Build" and such. The m2e guys may not like this, but for me this runs much more smoothly.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500941</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-09-06 16:46:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] reconsider PackageFragmentRoot.isModule() vis-a-vis working copies of module-info.java</short_desc>
        <thetext>Resolving a service reference (interface or implementation) from a module-info.java to a type in the same project fails, when the module-info.java only exists as a working copy.

I'm not sure if this scenario causes problems in the real world, but in tests it is not possible to perform code select or such just on a working copy of module-info.java, which OTOH is our typical style of testing code select for regular .java files.

The cause of this failure is in the implementation of PackageFragmentRoot.isModule(), which iterates over contained CUs, and in the use of this method in call paths like this:

PackageFragmentRoot.getModule() line: 868	
NameLookup.getModule(PackageFragmentRoot) line: 810	
NameLookup.seekModule(char[], boolean, IJavaElementRequestor) line: 1167	
NameLookup.seekModules(char[], JavaElementRequestor) line: 1173	
NameLookup.findModule(String) line: 931	
SearchableEnvironment.getModule(char[]) line: 761	
SearchableEnvironment(ModuleEnvironment).getVisibleModules(char[]) line: 181	
SearchableEnvironment(ModuleEnvironment).isPackage(char[][], char[], char[]) line: 113	
LookupEnvironment.isPackage(char[][], char[], char[]) line: 1740	
PackageBinding.findPackage(char[], char[]) line: 99	
PackageBinding.getTypeOrPackage(char[], char[]) line: 206	
ClassScope(Scope).getTypeOrPackage(char[], int, boolean) line: 3240	
ClassScope(Scope).getTypeOrPackage(char[][]) line: 3346	
SelectionOnQualifiedTypeReference.getTypeBinding(Scope) line: 45	

Since the current CU *is* module-info.java the environment might somehow just know that the containing package fragment root is a module.

BTW, the current approach will also look funny, when admitting multiple src folders contributing to the same module. Since only one PFR can contain module-info.java, all others will have to answer false to isModule(), which may surprise clients. IOW, even CUs that are "contained" in the module, may be contained in a PFR that answers false to isModule(). :-/
=&gt; Should isModule() be moved to IJavaProject?</thetext>
        <comment>
            <comment_id>2747603</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-06 18:17:42 -0400</when>
            <comment_text>testModuleInfo_serviceReference_OK() in https://git.eclipse.org/r/#/c/75266/4/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests9.java has a TODO referring to this issue.</comment_text>
        </comment>
        <comment>
            <comment_id>2747638</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-07 01:11:50 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #0)
&gt; BTW, the current approach will also look funny, when admitting multiple src
&gt; folders contributing to the same module. Since only one PFR can contain
&gt; module-info.java, all others will have to answer false to isModule(), which
&gt; may surprise clients. IOW, even CUs that are "contained" in the module, may
&gt; be contained in a PFR that answers false to isModule(). :-/
&gt; =&gt; Should isModule() be moved to IJavaProject?

Yep, I was one of the original supporters of the "one module per source folder" idea. But I dropped that support for reasons such as similarity with OSGI etc. But the API remained. We need to think through all the Java model APIs with a fresh mind.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501128</id>
        <developer>Simon Cheung</developer>
        <developer_username>cheung.sai.ho</developer_username>
        <dup_id/>
        <creation_time>2016-09-09 06:04:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Type inference with lambdas &amp; CompletableFuture fails with JDT but succeeds with javac</short_desc>
        <thetext>The following sample code compiles using javac 1.8.0_45 but results in "Type mismatch" in Eclipse Neon 4.6 (org.eclipse.jdt.core_3.12.0.v20160516-2131.jar).

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

public class EclipseBug
{
    public static void main(String[] args)
    {
        // Fails with "Type mismatch: cannot convert from CompletableFuture&lt;Object&gt; to CompletableFuture&lt;Map&lt;String,String&gt;&gt;"
        CompletableFuture&lt;Map&lt;String, String&gt;&gt; future =
            someMethod().thenApply(map -&gt; map.entrySet()
                                             .stream()
                                             .collect(Collectors.toMap(e -&gt; transformKey(e.getKey()),
                                                                       e -&gt; e.getValue())));
    }

    public static CompletableFuture&lt;Map&lt;Integer, String&gt;&gt; someMethod()
    {
        // Implementation not important
        return CompletableFuture.supplyAsync(HashMap::new);
    }

    public static String transformKey(Integer value)
    {
        // Implementation not important
        return value + "suffix";
    }
}</thetext>
        <comment>
            <comment_id>2748928</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-09 06:11:51 -0400</when>
            <comment_text>I see this compiles fine as of latest I build. I will dig out which bug addressed this.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501408</id>
        <developer>Rob Lucas</developer>
        <developer_username>roblucas0</developer_username>
        <dup_id/>
        <creation_time>2016-09-14 05:22:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Deprecation on annotation not showing in Problems view</short_desc>
        <thetext>I have come across a situation where a deprecated piece of code is showing with a strikethrough when viewing the code but this is not showing as a warning in the Problems view.

The example code is:

@CucumberOptions(format = {"json:target/cucumber/myfile.json"})

"format" is deprecated in the above code and shows as a strikethrough when viewing the code but does not show as a separate warning in the Problems view.

I have checked all the relevant preferences and they all look OK and I am getting both the strikethrough and the warning for other deprecated code, e.g.:

    public AggregationBuffer getNewAggregationBuffer() throws HiveException {

AggregationBuffer is deprecated and shows as strikethrough and in Problems view.

Suspect this is related to the code being an annotation and so suspect bug.</thetext>
    </bug>
    <bug>
        <id>501448</id>
        <developer>Agnieszka Pachuta</developer>
        <developer_username>pachuta.agnieszka</developer_username>
        <dup_id/>
        <creation_time>2016-09-14 14:19:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>ASTRewrite.rewriteAST(...) doesn't format enum constants</short_desc>
        <thetext>ASTRewrite.rewriteAST(...) doesn't apply formatter options given as an argument to format enum constans alignment. The options are taken into account when I use formatter explicitly. Example:

    ...
    Document javaSourceDocument = new Document(javaSource);
    Map options = DefaultCodeFormatterConstants.getEclipseDefaultSettings();
    JavaCore.setComplianceOptions(JavaCore.VERSION_1_8, options);
    options.put(
        DefaultCodeFormatterConstants.FORMATTER_ALIGNMENT_FOR_ENUM_CONSTANTS,
        DefaultCodeFormatterConstants.createAlignmentValue(
            true,
            DefaultCodeFormatterConstants.WRAP_ONE_PER_LINE,
            DefaultCodeFormatterConstants.INDENT_ON_COLUMN));

    TextEdit edits = astRewrite.rewriteAST(javaSourceDocument, options);
    edits.apply(javaSourceDocument);
    
    // Here, in javaSourceDocument.get() all enum constants are in the same line, not formatted.

    final CodeFormatter codeFormatter = ToolFactory.createCodeFormatter(options); // Use the same options.
    String source = javaSourceDocument.get();
    TextEdit edits2 =
        codeFormatter.format(
            CodeFormatter.K_COMPILATION_UNIT, 
            source, 
            0, 
            source.length(),
            0, 
            System.getProperty("line.separator")
            );
    Document document = new Document(source);
    edits2.apply(document);

    // Here, document.get() contains formatted enum constants.</thetext>
    </bug>
    <bug>
        <id>501469</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-09-15 03:49:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8] Intersection of two functional interfaces with same signature allowed</short_desc>
        <thetext>The following code is modified version of an example from:
  http://cr.openjdk.java.net/~dlsmith/jsr335-0.6.1/A.html

public class XYZ {
	public static void main(String[] args) {
		// Javac reports an error here, while ECJ doesn't
		Foo&lt;Object&gt; f = (Foo&lt;Object&gt; &amp; Bar&lt;Object&gt;) (Object i) -&gt; {};
	}
}
interface Foo&lt;T&gt; { void m(T arg); }
interface Bar&lt;T&gt; { void m(T arg); }

I don't have any spec to back this, but wanted to report the difference in behavior.</thetext>
    </bug>
    <bug>
        <id>501517</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-09-15 12:39:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] figure out glitches in spec of module-info</short_desc>
        <thetext>Rereading http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html (unspecified version, retrieved as of now) I'm puzzled what we should make of these:


(1): A compilation unit holding a module declaration may also contain import declarations. No text in the "spec" refers to those imports, so they appear to be without meaning.


(2) module-info.java is a compilation unit, which is member of an unnamed package. This fact doesn't seem to bear any semantics. See also 7.3, which applies to every module-info.java by construction:
  "A compilation unit that has no package declaration is part of an unnamed package (§7.4.2)."


(3) "A compilation unit (JLS 7.3) may contain a module declaration, in which case the filename of the compilation unit is typically module-info.java."
Note the use of *typically*!! How should module declarations be handled that appear in files having a different name? Is any name legal? How are compilers supposed to find necessary module declarations?</thetext>
        <comment>
            <comment_id>2773332</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-05 18:49:50 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #0)
&gt; (1): A compilation unit holding a module declaration may also contain import
&gt; declarations. No text in the "spec" refers to those imports, so they appear
&gt; to be without meaning.

Meanwhile I saw mentioning of using imports for annotations inside module-info.

This then inspired me to file bug 507109</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501652</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-09-18 06:26:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][impl] inconsistent call to ITypeAnnotationWalker.toSupertype(..)</short_desc>
        <thetext>BTB.cachePartsFrom(..) contains this call:
  toplevelWalker.toSupertype(i, superclassName)
which is intended to walk to a super *interface* but passes the name of the super *class*.

While most implementations ignore this argument, it is used in ExternalAnnotationProvider.DispatchingAnnotationWalker.toSupertype(..)</thetext>
    </bug>
    <bug>
        <id>501909</id>
        <developer>Brian Antao</developer>
        <developer_username>bantao</developer_username>
        <dup_id/>
        <creation_time>2016-09-21 07:43:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Renaming a Parent Project breaks the links with child projects</short_desc>
        <thetext>I have a hierarchical project structure with a parent project and child project ... If I rename the parent project the child project name references also need to be updated. This renaming operation is causing the links to the child projects to be broken ...


-- Configuration Details --
Product: Eclipse 4.6.0.20160525-2036 (org.eclipse.epp.package.jee.product)
Installed Features:
 org.eclipse.jdt 3.12.0.v20160606-1100</thetext>
        <comment>
            <comment_id>2754073</comment_id>
            <comment_count>1</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-09-22 02:21:12 -0400</when>
            <comment_text>(In reply to Brian Antao from comment #0)
&gt; I have a hierarchical project structure with a parent project and child
&gt; project ... If I rename the parent project the child project name references
&gt; also need to be updated. This renaming operation is causing the links to the
&gt; child projects to be broken ...
&gt; 

Can you please elaborate what you meant by hierarchical project structure. If you are referring to project dependency, renaming works for me. ie I have a Child project having a dependency on Parent project and the Parent project is renamed to NewParent, project dependency is automatically changed to NewParent.
If this is not the scenario at your end, please attach the sample projects as a zip attachment that reproduces the problem mentioned.</comment_text>
        </comment>
        <comment>
            <comment_id>2754123</comment_id>
            <comment_count>2</comment_count>
            <who>Brian Antao</who>
            <commenter_username>bantao</commenter_username>
            <when>2016-09-22 04:39:44 -0400</when>
            <comment_text>Created attachment 264333
Picture of Project Hierarchy in Eclipse which fails rename

This is the Structure of our Eclipse hierarchical project -- parent project with app, assembly and tomcat as child projects.
In the next attachment you will see just the app child project

Now if the parent project is renamed this breaks all the links of the individual child projects ...</comment_text>
        </comment>
        <comment>
            <comment_id>2754124</comment_id>
            <comment_count>3</comment_count>
            <who>Brian Antao</who>
            <commenter_username>bantao</commenter_username>
            <when>2016-09-22 04:40:53 -0400</when>
            <comment_text>Created attachment 264334
Picture of single child project

This is the single child project ...</comment_text>
        </comment>
    </bug>
    <bug>
        <id>502158</id>
        <developer>Evgeni Kumanov</developer>
        <developer_username>kumanov</developer_username>
        <dup_id/>
        <creation_time>2016-09-26 09:21:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][compiler][inference] Eclipse compiler can't infer type in java lambda expression</short_desc>
        <thetext>The following code compiles under Mars.2 (1.8 compliance) and with Oracle's JDK 1.8.0_45-b14 compiler:
------------
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class EclipseCompilerBug {
    private class SomeClass {

    }

    private &lt;T&gt; T convertValue(Object fromValue, Class&lt;T&gt; toValueType) {
        return null;
    }

    private List&lt;SomeClass&gt; getSome(List&lt;Map&lt;String, Object&gt;&gt; list) {
        return list.stream()
                .map(e -&gt; e.get("someKey"))
                .map(Collection.class::cast)
                .flatMap(Collection::stream)
                .map(m -&gt; convertValue(m, SomeClass.class))
                .distinct()
                .collect(Collectors.toList());
    }
}
------------

However under Neon 4.6.0 (1.8 compliance) I get following error:

Description	Resource	Path	Location	Type
Type mismatch: cannot convert from Object to List&lt;EclipseCompilerBug.SomeClass&gt;	EclipseCompilerBug.java	/eclipse-bug/src/main/java	line 16	Java Problem

It seems the inferred type from convertValue method is not preserved.</thetext>
        <comment>
            <comment_id>2755526</comment_id>
            <comment_count>1</comment_count>
            <who>Evgeni Kumanov</who>
            <commenter_username>kumanov</commenter_username>
            <when>2016-09-26 13:11:17 -0400</when>
            <comment_text>OK, just found out that the code can be fixed this way:
------------
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class EclipseCompilerBug {
    private class SomeClass {

    }

    private &lt;T&gt; T convertValue(Object fromValue, Class&lt;T&gt; toValueType) {
        return null;
    }

    private List&lt;SomeClass&gt; getSome(List&lt;Map&lt;String, Object&gt;&gt; list) {
        return list.stream()
                .map(e -&gt; e.get("someKey"))
                .&lt;Collection&lt;?&gt;&gt; map(Collection.class::cast)
                .flatMap(Collection::stream)
                .map(m -&gt; convertValue(m, SomeClass.class))
                .distinct()
                .collect(Collectors.toList());
    }
}
------------

The difference is this line:
.&lt;Collection&lt;?&gt;&gt; map(Collection.class::cast)

I need to explicitly specify to the map() method the function type as Collection. The actual bug is that an automatic type inference should have taken place instead, since I am providing a Collection.class::cast, so obviously this is a Function&lt;Object, Collection&gt;</comment_text>
        </comment>
        <comment>
            <comment_id>2755635</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-26 18:06:13 -0400</when>
            <comment_text>A quick caveat before I start investigating:

Collection is a raw type, and when unchecked conversions are used during type inference, any type arguments are discarded from the inference result (per JLS). This could imply that map(Collection.class::cast) is inferred to return Stream#RAW indeed. Not convenient, but correct?

We should also check against early access builds of javac 9.</comment_text>
        </comment>
        <comment>
            <comment_id>2755844</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-27 08:13:33 -0400</when>
            <comment_text>Likely connected to bug 473657.

In particular see bug 473657 comment 19:
 "Dan's answer confirms that javac has a bug: https://bugs.openjdk.java.net/browse/JDK-8135087"

I don't see any recent activity on Oracle's side.</comment_text>
        </comment>
        <comment>
            <comment_id>2755854</comment_id>
            <comment_count>4</comment_count>
            <who>Evgeni Kumanov</who>
            <commenter_username>kumanov</commenter_username>
            <when>2016-09-27 08:27:16 -0400</when>
            <comment_text>I am using this more readable construct now and it's working (without warnings):

.map(e -&gt; (Collection&lt;?&gt;) e)

Which is still producing a stream of raw type but seems to be working (probably because there's no inference). I am not sure why the inference producing raw types should produce errors to the stream chain though. But it's getting too academical to me at this point anyway.</comment_text>
        </comment>
        <comment>
            <comment_id>2755896</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-27 10:00:16 -0400</when>
            <comment_text>(In reply to Evgeni Kumanov from comment #4)
&gt; I am using this more readable construct now and it's working (without
&gt; warnings):
&gt; 
&gt; .map(e -&gt; (Collection&lt;?&gt;) e)

From a compiler p.o.v. the previous version with explicit type arguments is preferable, because then you still benefit from full type checking and be sure that no runtime errors occur. The explicit cast, OTOH, could still fail at runtime.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>502252</id>
        <developer>Matthias Sohn</developer>
        <developer_username>matthias.sohn</developer_username>
        <dup_id/>
        <creation_time>2016-09-27 10:04:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>StackOverflowError in JavaProject.addToResult</short_desc>
        <thetext>I hit this when starting Eclipse Neon workbench in debugger
org.eclipse.jdt version is 3.12.1.v20160907-1200

!ENTRY org.eclipse.core.jobs 4 2 2016-09-27 15:48:35.738
!MESSAGE An internal error occurred during: "Initializing Java Tooling".
!STACK 0
java.lang.StackOverflowError
	at java.util.HashMap.putVal(HashMap.java:628)
	at java.util.HashMap.put(HashMap.java:611)
	at org.eclipse.jdt.internal.core.JavaProject.addToResult(JavaProject.java:2774)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2757)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2869)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2693)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2869)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2693)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2869)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2693)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2869)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2693)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2869)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2693)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	...</thetext>
        <comment>
            <comment_id>2764594</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-09 14:56:49 -0400</when>
            <comment_text>Looks like nobody had an idea how to reproduce / address this issue?

Matthias, do you have an hints on what might trigger this?

Or even an idea what caused the infinite recursion (given you could in fact observe it in the debugger)?</comment_text>
        </comment>
        <comment>
            <comment_id>2764629</comment_id>
            <comment_count>2</comment_count>
            <who>Matthias Sohn</who>
            <commenter_username>matthias.sohn</commenter_username>
            <when>2016-10-10 03:46:15 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #1)
&gt; Looks like nobody had an idea how to reproduce / address this issue?
&gt; 
&gt; Matthias, do you have an hints on what might trigger this?
&gt; 
&gt; Or even an idea what caused the infinite recursion (given you could in fact
&gt; observe it in the debugger)?

no idea, it happens sometimes

If it happens I get this error immediately after starting the workbench in the debugger</comment_text>
        </comment>
    </bug>
    <bug>
        <id>502431</id>
        <developer>Tushar Kapila</developer>
        <developer_username>tgkprog</developer_username>
        <dup_id/>
        <creation_time>2016-09-28 10:17:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>way to link run configuration to a property file for easy reuse and version control</short_desc>
        <thetext>http://ctrlv.in/854743
the Environment tab on the run config screen, does not allow us to link the name-value pairs to a file.
Would be good if we could so can put that file in version control, export from the UI to a file, etc. So an import and export buttons to classical java.util.Properties file format (not xml)? Similar to an Ini
Or a json for the whole screen (run config) then could save that and give it to my developers for them to quickly import and run an app that needs a cople of runtime configs...</thetext>
    </bug>
    <bug>
        <id>502563</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-09-29 09:20:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>APIs to get FQNs and type signatures of method parameter types</short_desc>
        <thetext>1. API to get the FQN of the method parameter types:

Currently, IMethod.getParameterTypes() returns a String[] having the type signatures of the method parameters which are of the form {"QString;","I"}.

The new API could be added to IMethod and should return the fully qualified type names of the method parameter types, in the same form as obtained from java.lang.Class.getName().

See also: IType#resolveType.

2. API to get the type signatures from a type's FQN:

The API could be added to JavaCore and should convert the passed argument (i.e. the FQN of a type in the form which is obtained from java.lang.Class.getName()) to type signature. The returned value is intended to be passed to IType.getMethod(String name, String[] parameterTypeSignatures) to identify a particular method.

These APIs are required to support JUnit5's overloaded test methods: bug 488566.</thetext>
        <comment>
            <comment_id>2757271</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-29 10:34:56 -0400</when>
            <comment_text>Are you asking this for convenience or is there anything that cannot yet be done with the help of IMethod.getParameterTypes(), IType.resolveType() and methods in class o.e.j.c.Signature?</comment_text>
        </comment>
        <comment>
            <comment_id>2757798</comment_id>
            <comment_count>2</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-09-30 01:28:47 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #1)
&gt; Are you asking this for convenience or is there anything that cannot yet be
&gt; done with the help of IMethod.getParameterTypes(), IType.resolveType() and
&gt; methods in class o.e.j.c.Signature?

Primarily for convenience. About the other part, I am not sure since I couldn't find any easy way to get the required results in both the conversions and whatever I have tried doesn't work in all the cases.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>502844</id>
        <developer>Chandrakala MS</developer>
        <developer_username>chandra-ms</developer_username>
        <dup_id/>
        <creation_time>2016-09-30 06:40:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Project dependencies to modules that are implicitly readable is not resolved</short_desc>
        <thetext>As per Java9 module system implied readability, 
module B requires public A and module C requires B means, module C can see A without explicitly declaring dependency using requires in module C's module descriptor. 

Eclipse with Java9 support, resolves only explicit dependencies that are declared by a module using requires. Implicitly readable modules are not resolved. 
Will this be implemented?

Tested with eclipse-SDK-Y20160908-1000-win32-x86_64</thetext>
        <comment>
            <comment_id>2757995</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-30 08:19:16 -0400</when>
            <comment_text>(In reply to Chandrakala MS from comment #0)
&gt; Will this be implemented?

Of course. It is not clear why this scenario isn't working. We have a unit test for this: 

ModuleBuilderTests#test_ModuleSourcePath_implicitdeps()

which is passing. But there's something fishy. It passes only when run as part of the suite. Fails only when that particular test is run. I will take a look.</comment_text>
        </comment>
        <comment>
            <comment_id>2758684</comment_id>
            <comment_count>2</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-03 01:42:24 -0400</when>
            <comment_text>(In reply to comment #1)
&gt; (In reply to Chandrakala MS from comment #0)
&gt; &gt; Will this be implemented?
&gt; 
&gt; Of course. It is not clear why this scenario isn't working. We have a unit test
&gt; for this:
&gt; 
&gt; ModuleBuilderTests#test_ModuleSourcePath_implicitdeps()
&gt; 
&gt; which is passing. But there's something fishy. It passes only when run as part
&gt; of the suite. Fails only when that particular test is run. I will take a look.
Probably running into bug 499429 - there's a kind of chicken and egg situation where you need the package fragment roots initialized to know if a project is a module or not (the ModulePathContainer requires this information to figure out the dependencies), and you need the container to compute the package fragment roots. This leads to situations where things do not work reliably. I have a WIP patch that addresses this by making sure the module is initialized first before we try and compute the roots.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>502851</id>
        <developer>Marc R. Hoffmann</developer>
        <developer_username>hoffmann</developer_username>
        <dup_id/>
        <creation_time>2016-09-30 07:33:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Compiler: Unused Parameter Warning shown for Method References</short_desc>
        <thetext>Created attachment 264509
Unused.java

STEPS TO REPRODUCE

In Preferences under 
 
  Java --&gt; Compiler --&gt; Error/Warnings --&gt; Unnecessary Code

set "value of method parameter is not used" to "Warning" and check "Ignore in overriding and implementing methods"

Add some piece of code to a Java project which creates a SAM instance via a reference to a private method. The SAM interface requires a parameter which is not used within the method. See attached example.

ACTUAL BEHAVIOR

The compiler shows a warning "The value of the parameter x ist not used".


EXPECTED BEHAVIOR

No warning is shown, as the method is implementing the SAM interface and therefore needs to declare the parameter.</thetext>
    </bug>
    <bug>
        <id>503016</id>
        <developer>Yousha Aleayoub</developer>
        <developer_username>Yousha.A</developer_username>
        <dup_id/>
        <creation_time>2016-10-01 18:55:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Exception while saving project preferences .settings/org.eclipse.jdt.core.prefs.</short_desc>
        <thetext>What steps will reproduce the problem?
1. File -&gt; Import project -&gt; Existing project into workspace -&gt; Browse -&gt; Finish

Project's setting content in "project/.settings/org.eclipse.jdt.core" file:

eclipse.preferences.version=1
org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
org.eclipse.jdt.core.compiler.compliance=1.6
org.eclipse.jdt.core.compiler.source=1.6


-- Error Details --
Date: Sun Oct 02 02:19:25 IRST 2016
Message: Exception occurred while saving project preferences: /myProject/.settings/org.eclipse.jdt.core.prefs.
Severity: Error
Product: Eclipse 4.6.1.20160912-1200 (org.eclipse.epp.package.java.product)
Plugin: org.eclipse.core.resources
Session Data:
eclipse.buildId=4.6.1.M20160907-1200
java.version=1.8.0_102
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

Exception Stack Trace:
org.eclipse.core.internal.resources.ResourceException: A resource already exists on disk 'C:\Users\Yousha\Workspace\Java\myProject\.settings'.
	at org.eclipse.core.internal.resources.Folder.assertCreateRequirements(Folder.java:47)
	at org.eclipse.core.internal.resources.Folder.create(Folder.java:93)
	at org.eclipse.core.internal.resources.ProjectPreferences$1.run(ProjectPreferences.java:634)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.ProjectPreferences.save(ProjectPreferences.java:660)
	at org.eclipse.core.internal.preferences.EclipsePreferences.internalFlush(EclipsePreferences.java:431)
	at org.eclipse.core.internal.resources.ProjectPreferences.flush(ProjectPreferences.java:365)
	at org.eclipse.jdt.internal.core.JavaProject.setOption(JavaProject.java:2955)
	at com.android.ide.eclipse.adt.internal.project.ProjectHelper.checkAndFixCompilerCompliance(ProjectHelper.java:517)
	at com.android.ide.eclipse.adt.internal.project.ProjectHelper.fixProjectClasspathEntries(ProjectHelper.java:422)
	at com.android.ide.eclipse.adt.internal.project.ProjectHelper.fixProject(ProjectHelper.java:296)
	at com.android.ide.eclipse.adt.internal.wizards.newproject.NewProjectCreator.createEclipseProject(NewProjectCreator.java:837)
	at com.android.ide.eclipse.adt.internal.wizards.newproject.NewProjectCreator.createProjectAsync(NewProjectCreator.java:660)
	at com.android.ide.eclipse.adt.internal.wizards.newproject.NewProjectCreator.access$0(NewProjectCreator.java:590)
	at com.android.ide.eclipse.adt.internal.wizards.newproject.NewProjectCreator$3.execute(NewProjectCreator.java:400)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:107)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:128)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:119)


-- Error Details --
Date: Sun Oct 02 02:19:25 IRST 2016
Message: A resource already exists on disk 'C:\Users\Yousha\Workspace\Java\myProject\.settings'.
Severity: Error
Product: Eclipse 4.6.1.20160912-1200 (org.eclipse.epp.package.java.product)
Plugin: org.eclipse.core.resources</thetext>
    </bug>
    <bug>
        <id>503029</id>
        <developer>Zane Ralston</developer>
        <developer_username>zralston</developer_username>
        <dup_id/>
        <creation_time>2016-10-03 00:49:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>ASTRewrite#rewriteAST(...) is adding an InsertEdit with one space before what was actually added</short_desc>
        <thetext>I'm trying to update Javadoc and I'm noticing an extra InsertEdit with one space before the InsertEdit that was actually made.

Here's a method in the compilation unit:

    /**
     * Creates a {@link Integer}
     */
     public Integer create(){}

What I'm trying to do is add a period at the end of the summary (after the Integer link tag).

Simplified code example:

    ListRewrite listRewrite = astRewrite.getListRewrite(tagElement, TagElement.FRAGMENTS_PROPERTY);
    ASTNode astNode = astRewrite.createStringPlaceholder(".", ASTNode.TEXT_ELEMENT);
    listRewrite.insertLast(astNode, (TextEditGroup) null);
    return astRewrite.rewriteAST(...);

The TextEdit that's returned from ASTRewrite#rewriteAST(...) is:

    {MultiTextEdit} [949,0] [undefined]
      {InsertEdit} [949,0] &lt;&lt; 
      {InsertEdit} [949,0] &lt;&lt;.

The first InsertEdit has a space. Applying it to the compilation unit results in:

    /**
     * Creates a {@link Integer} .
     */
     public Integer create(){}

That's not what I was expecting at all. Can someone verify if this isn't working as intended? If anyone needs more information, let me know. Thanks.</thetext>
    </bug>
    <bug>
        <id>503079</id>
        <developer>Till Brychcy</developer>
        <developer_username>register.eclipse</developer_username>
        <dup_id/>
        <creation_time>2016-10-03 12:09:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][compiler] Remove InferenceContext18.SHOULD_WORKAROUND_BUG_JDK_8054721 and related code</short_desc>
        <thetext>Some code not specified by the JLS was introduced during bug 437444 guarded by InferenceContext18.SHOULD_WORKAROUND_BUG_JDK_8054721 to make some tests green.
But since the commit for bug 448794, if you set InferenceContext18.SHOULD_WORKAROUND_BUG_JDK_8054721=false, there are only a few logging differences in the tests (this is just the last commit, some tests are made green without the workaround by the changes for 448792 - I haven't looked further back)

So it looks like this code was never really needed because of JDK-8054721, but because some other JLS-specified behavior was not completely implemented at the time of bug 437444.

Or maybe there is some deeper knowledge about javac internals behind SHOULD_WORKAROUND_BUG_JDK_8054721 and we are missing some tests that show it is still necessary?</thetext>
        <comment>
            <comment_id>2758962</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-03 12:13:04 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/82381</comment_text>
        </comment>
        <comment>
            <comment_id>2759646</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-04 08:50:19 -0400</when>
            <comment_text>Seeing https://bugs.openjdk.java.net/browse/JDK-8054721 at
  Status: open
  Fix version(s): 9
let's please not remove this yet. I hope that when they close their spec-bug, we will see:
- a specification change
- examples where this change makes a difference.

At that point we'll be able to check if our "workaround" has an impact on these very examples or not. On those grounds we should be able to make an educated call.


Bug 437444 has some loose ends in this area, the section of the discussion that is closest to the issue at hand starts at bug 437444 comment 152.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>503304</id>
        <developer>Chandrakala MS</developer>
        <developer_username>chandra-ms</developer_username>
        <dup_id/>
        <creation_time>2016-10-04 03:04:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Some of the classes in exported packages in java.base module are not resolved</short_desc>
        <thetext>Some of the classes cannot be resolved though the package containing these are exported in the module descriptor of java.base

Standalone java program using the same API works fine.

Tested with IBM Java9 build with eclipse-SDK-Y20160908-1000-win32-x86_64 on Windows.</thetext>
        <comment>
            <comment_id>2759411</comment_id>
            <comment_count>1</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-04 03:34:00 -0400</when>
            <comment_text>An example would be good, or atleast the names of some of such classes, to give us a starting point</comment_text>
        </comment>
        <comment>
            <comment_id>2759873</comment_id>
            <comment_count>2</comment_count>
            <who>Chandrakala MS</who>
            <commenter_username>chandra-ms</commenter_username>
            <when>2016-10-04 12:03:43 -0400</when>
            <comment_text>If you have access to IBM Java9 beta1 build then try using com.ibm.jvm.Dump</comment_text>
        </comment>
    </bug>
    <bug>
        <id>504472</id>
        <developer>Raj Tomar</developer>
        <developer_username>rajtomar50</developer_username>
        <dup_id/>
        <creation_time>2016-10-06 00:11:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>I am trying to run maven application using tomcat:run command.</short_desc>
        <thetext>SEVERE: Compilation error
org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException
	at org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.&lt;init&gt;(ClassFileReader.java:342)
	at org.apache.jasper.compiler.JDTCompiler$1.findType(JDTCompiler.java:206)
	at org.apache.jasper.compiler.JDTCompiler$1.findType(JDTCompiler.java:163)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:96)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:49)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:97)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:167)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2187)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:974)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1164)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:366)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:623)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:392)
	at org.apache.jasper.compiler.JDTCompiler.generateClass(JDTCompiler.java:429)
	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:349)
	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:327)
	at org.apache.jasper.compiler.Compiler.compile(Compiler.java:314)
	at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:592)
	at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:317)
	at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:313)
	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:260)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:717)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:127)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:298)
	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:857)
	at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:588)
	at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:489)
	at java.lang.Thread.run(Thread.java:745)</thetext>
        <comment>
            <comment_id>2764507</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-08 19:11:40 -0400</when>
            <comment_text>I doubt that this is JDT's fault, we are just detecting that a given class file has an invalid format.

Some things to check:
- Find the affected class file and try to read it using javap.
- Check the logs if there's a nested exception</comment_text>
        </comment>
    </bug>
    <bug>
        <id>505811</id>
        <developer>Ed Willink</developer>
        <developer_username>ed</developer_username>
        <dup_id/>
        <creation_time>2016-10-12 12:17:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Support file/folder-based suppress warnings</short_desc>
        <thetext>EMF is a very powerful generator of Java code. Unfortunately its generated code has not really moved beyond Java 5, consequently when EMF contributes to a strongly checked project, there are many warnings to fix up or more likely to just permanently clutter the developer's problem view.

Suggest allowing finer-grained warning settings, perhaps per classpath source, so that the emf-gen folder can be set to have far fewer warnings.</thetext>
    </bug>
    <bug>
        <id>505828</id>
        <developer>Michael Vorburger</developer>
        <developer_username>mike</developer_username>
        <dup_id/>
        <creation_time>2016-10-12 16:47:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null] The "Inherit null annotations" feature should be stronger than @NonNullByDefault</short_desc>
        <thetext>The "Inherit null annotations" option intro. in bug 388281 IMHO doesn't inter-op "correctly" (i.e. not the way an end-user would typically expect) with @NonNullByDefault.  Example:

interface SomeInterface {

    void foo(@Nullable Object bar);
}

@NonNullByDefault
public class SomeClass implements SomeInterface {

    @Override
    public void foo(Object bar) {
    }
}

This causes a "The default '@NonNull' conflicts with the inherited '@Nullable' annotation in the overridden method from SomeInterface" error.  -- I do understand why it's saying that, and repeating foo(@Nullable Object bar) in SomeClass "fixes" the error of course  - but it's not what you would expect - after all, what's the point of having a feature to inherit null annotations if they're not... inherited, and you have to repeat them anyway, in this case? 

It would thus seem more "natural" if the inherited @Nullable annotations would automatically be "stronger" than @NonNullByDefault.

PS: I had also raised this in https://www.eclipse.org/forums/index.php/m/1741422/ 2 months ago already, but the analysis shown above is more succinct, and can hopefully contribute to a resolution of this.</thetext>
        <comment>
            <comment_id>2766034</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-13 06:11:58 -0400</when>
            <comment_text>The current design of null annotation inheritance is a compromise. The background can be studied in bug 388281.

Summary:

Coming from bug 385440 there was a common understanding that annotation inheritance would be particularly important for migration scenarii: if super class gets annotated, this shouldn't force all "legacy" subclasses to react immediately. By means of annotation inheritance those subclasses could still be legal without changes.

Discussion regarding "conflicts" between inheritance and @NNBD starts in bug 388281 comment 7, were I argued that things could get quite confusing and "I don't want you to write this kind of code".

The discussion also touches on showing effective null annotations in hovers, which at that point was not planned, but meanwhile I've implemented that feature. So regarding visualization we are in a better position by now (but others made a strong point that code needs to be understandable also without the tool).

In bug 388281 comment 10 Sebastian proposed "the strongest annotation wins", which I answered by proposing "inheritance beats default".

Till today I am not 100% convinced which of the two approaches would be more useful / match more people's intuition.

Today's solution was introduced in bug 388281 comment 12.
Since then we treat inheritance and @NNBD equally as mechanisms for "implicit" null annotations.

In bug 388281 comment 20 Markus criticized that "this 'inheritance' is not well-defined and easily understood, and it carries UX problems with it..."

Agreement was achieved in bug 388281 comment 24 f.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>505934</id>
        <developer>Simon Lieschke</developer>
        <developer_username>simon.lieschke</developer_username>
        <dup_id/>
        <creation_time>2016-10-13 20:57:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Scrapbook imports do not work</short_desc>
        <thetext>Steps to reproduce:
1. Create a scrapbook page with the following trivial code: System.out.println(new ArrayList&lt;String&gt;());
2. Add the java.util package as an import for the scrapbook page (by right clicking and selecting "Set Imports...")
3. Select the line of code in the scrapbook page and execute it

Expected results:
The scrapbook page successfully executes and "[]" is output to the console.

Actual results:
The scrapbook page fails to execute and the text "The import java.util is never used" is inserted at the top of the scrapbook page

If I use the fully qualified classname for ArrayList in the scrapbook page code and remove the java.util package import the code executes as expected.

-- Configuration Details --
Product: Eclipse 4.6.1.20161007-1200 (org.eclipse.epp.package.java.product)
Installed Features:
 org.eclipse.jdt 3.12.1.v20160907-1200</thetext>
    </bug>
    <bug>
        <id>505935</id>
        <developer>Osvaldo Pinali Doederlein</developer>
        <developer_username>opinali</developer_username>
        <dup_id/>
        <creation_time>2016-10-13 22:17:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8] Compiler error involving wildcards and raw types, works in javac</short_desc>
        <thetext>This fails in Eclipse, works in javac:

---


import java.util.List;

public class Test {
  static class F&lt;E&gt; {
    public static &lt;E&gt; F&lt;E&gt; foo(final Iterable&lt;E&gt; iter) { return null; }
  }

  static class D&lt;T, V&gt; {
    List&lt;T&gt; doo(X&lt;V&gt; x) { return null; }
  }

  static interface X&lt;T&gt; {}

  public static void main(String[] args) {
    X&lt;?&gt; x = null;
    D&lt;String, ?&gt; d = new D&lt;String, Integer&gt;();
    F.foo(d.doo((X) x));
  }
}</thetext>
        <comment>
            <comment_id>2766437</comment_id>
            <comment_count>1</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-14 02:16:00 -0400</when>
            <comment_text>Reproducible on master. Compiled fine until 4.6 M6. Trying to narrow down to the commit that caused the change in behavior</comment_text>
        </comment>
        <comment>
            <comment_id>2766806</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-14 15:38:00 -0400</when>
            <comment_text>@Osvaldo: iron laws of type inference:

(1) NEVER use raw types in conjunction with type inference.

(2) If you really must use raw types, rule (1) applies.

:)


Plus: when removing the cast, also javac will tell you that the program is not type safe:

error: incompatible types: X&lt;CAP#1&gt; cannot be converted to X&lt;CAP#2&gt;
    F.foo(d.doo(x));
                ^
  where CAP#1,CAP#2 are fresh type-variables:
    CAP#1 extends Object from capture of ?
    CAP#2 extends Object from capture of ?
Note: Some messages have been simplified; recompile with -Xdiags:verbose to get full output
1 error</comment_text>
        </comment>
        <comment>
            <comment_id>2766810</comment_id>
            <comment_count>3</comment_count>
            <who>Osvaldo Pinali Doederlein</who>
            <commenter_username>opinali</commenter_username>
            <when>2016-10-14 15:55:54 -0400</when>
            <comment_text>Hi Stephan, I know the code is awful, in my defense I'm not the author of the real-world code from which I have derived this repro snippet :)

I can force Eclipse to not break on this code by adding an extra ugly cast:

    F.foo(d.&lt;X&gt;doo((X) x));
            ^^^

The "bug" is the fact that with the original code snippet, javac only complains with lots of warnings, but jdt has a hard failure so it breaks the build. My team is IDE-neutral so people not using Eclipse frequently reintroduce this kind of breakage (from my point of view) by running automated code cleanup tools (this is at Google, where we have an obsession for lint and auto-fixing tools...).</comment_text>
        </comment>
        <comment>
            <comment_id>2766813</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-14 16:14:16 -0400</when>
            <comment_text>(In reply to Osvaldo Pinali Doederlein from comment #3)
&gt; Hi Stephan, I know the code is awful, in my defense I'm not the author of
&gt; the real-world code from which I have derived this repro snippet :)
&gt; 
&gt; I can force Eclipse to not break on this code by adding an extra ugly cast:
&gt; 
&gt;     F.foo(d.&lt;X&gt;doo((X) x));
&gt;             ^^^

That's not a cast but an explicit type argument, whereby you avoid one step of inference, because you already specify the type, which inference would have to find by itself otherwise. This is a (comparably) good fix for two reasons:
- compiler will check if your type hint makes any sense
- you don't need a cast that could throw CCE at runtime


&gt; The "bug" is the fact that with the original code snippet, javac only
&gt; complains with lots of warnings, but jdt has a hard failure so it breaks the
&gt; build. My team is IDE-neutral so people not using Eclipse frequently
&gt; reintroduce this kind of breakage (from my point of view) by running
&gt; automated code cleanup tools (this is at Google, where we have an obsession
&gt; for lint and auto-fixing tools...).

IDE-neutral is good. Vendor neutral is even better, and to figure out what is the vendor neutral solution we must find out if the given snippet is legal Java per JLS or not. javac is just one implementation, which has its own set of bugs (specifically when dealing with raw types).

Hopefully, seeing the relevant change in ecj will help us understand who is to blame.

waiting for Sasi's result.</comment_text>
        </comment>
        <comment>
            <comment_id>2766844</comment_id>
            <comment_count>5</comment_count>
            <who>Osvaldo Pinali Doederlein</who>
            <commenter_username>opinali</commenter_username>
            <when>2016-10-14 20:17:24 -0400</when>
            <comment_text>Agree 100% with vendor neutrality; the point of bugs like this is that, I suppose, the Java language spec is strict on the outcome of all type errors, it's never an option whether the compiler will emit a fatal error or not... so either javac has a bug, or ecj has a bug, or maybe even the spec has some unclear corner case that should be clarified. I'm curious to know which of these is true here. :)</comment_text>
        </comment>
        <comment>
            <comment_id>2767087</comment_id>
            <comment_count>6</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-17 02:35:33 -0400</when>
            <comment_text>(In reply to comment #4)
&gt; 
&gt; waiting for Sasi's result.
It's the commit http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=12d1c84ee9af849add945a196f8d13163f45dde7 for bug 488649 that caused the change in behavior. Specifically, the "signal to erase return type and exceptions, while keeping javac compatibility at 1.7-" causes this error to occur. Will delve into details now.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506009</id>
        <developer>Stefan Xenos</developer>
        <developer_username>sxenos</developer_username>
        <dup_id/>
        <creation_time>2016-10-14 16:13:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>UI freezes reported in PackageFragment.getElementName</short_desc>
        <thetext>We've had some UI freeze reports with stacks that look like this:

Thread 'main' tid=1 (RUNNABLE)
!STACK 0
java.lang.Exception: Stack Trace
	at org.eclipse.jdt.internal.core.util.Util.concatWith(Util.java:338)
	at org.eclipse.jdt.internal.core.PackageFragment.getElementName(PackageFragment.java:257)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.findSinglePackageChild(PackageExplorerContentProvider.java:503)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.getFolded(PackageExplorerContentProvider.java:484)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.getHierarchicalPackageChildren(PackageExplorerContentProvider.java:419)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.getPackageContent(PackageExplorerContentProvider.java:247)
	at org.eclipse.jdt.ui.StandardJavaElementContentProvider.getChildren(StandardJavaElementContentProvider.java:182)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.getChildren(PackageExplorerContentProvider.java:293)
	at org.eclipse.jdt.internal.ui.navigator.JavaNavigatorContentProvider.getChildren(JavaNavigatorContentProvider.java:180)
	at org.eclipse.ui.internal.navigator.extensions.SafeDelegateTreeContentProvider.getChildren(SafeDelegateTreeContentProvider.java:95)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceContentProvider$1.run(NavigatorContentServiceContentProvider.java:157)</thetext>
        <comment>
            <comment_id>2766814</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-14 16:14:34 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/83269</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506174</id>
        <developer>Sasikanth Bharadwaj</developer>
        <developer_username>sasikanth.bharadwaj</developer_username>
        <dup_id/>
        <creation_time>2016-10-19 02:48:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[test][compiler][eval] Investigate failures/errors in org.eclipse.jdt.core.tests.eval</short_desc>
        <thetext>Build id - I20161018-0800

http://download.eclipse.org/eclipse/downloads/drops4/I20161018-0800/testresults/html/org.eclipse.jdt.core.tests.compiler_ep47I-unit-cen64_linux.gtk.x86_64_8.0.html

Stacktrace of failures

No targetException null

junit.framework.AssertionFailedError: No targetException null
at org.eclipse.jdt.core.tests.eval.SanityTestEvaluationContext.testEvaluate(SanityTestEvaluationContext.java:82)
at org.eclipse.jdt.core.tests.junit.extension.TestCase.runTest(TestCase.java:954)
at org.eclipse.jdt.core.tests.util.CompilerTestSetup.run(CompilerTestSetup.java:56)
at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:744)
at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:351)
at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:37)
at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:33)
at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)
at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
at org.eclipse.equinox.launcher.Main.main(Main.java:1492)
at org.eclipse.core.launcher.Main.main(Main.java:34)

Stack trace of errors

N/A

java.lang.Error
at org.eclipse.jdt.core.tests.eval.SanityTestEvaluationResult.setUp(SanityTestEvaluationResult.java:46)
at org.eclipse.jdt.core.tests.util.CompilerTestSetup.run(CompilerTestSetup.java:56)
at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:744)
at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:351)
at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:37)
at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:33)
at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)
at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
at org.eclipse.equinox.launcher.Main.main(Main.java:1492)
at org.eclipse.core.launcher.Main.main(Main.java:34)</thetext>
        <comment>
            <comment_id>2768478</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-20 02:24:16 -0400</when>
            <comment_text>This is one of those cases where something is broken about getting hold of the JVM. This kind of errors have proven to be difficult to crack in the past.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506230</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-10-19 12:55:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] Message for '_' as identifier needs to be harder in 1.9</short_desc>
        <thetext>Currently the message for '_' as identifier starts with "should". This is wrong, since it is disallowed (error) in 1.9, compared to 1.8 where it was only a warning.</thetext>
    </bug>
    <bug>
        <id>506239</id>
        <developer>Gorkem Ercan</developer>
        <developer_username>gorkem.ercan</developer_username>
        <dup_id/>
        <creation_time>2016-10-19 14:59:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>New API for organize imports</short_desc>
        <thetext>JDT LS project requires an API to implement organize imports quick assist/commands. I think an API equivalent to org.eclipse.jdt.internal.corext.codemanipulation.OrganizeImportsOperation.createTextEdit(IProgressMonitor) will be sufficient.</thetext>
    </bug>
    <bug>
        <id>506254</id>
        <developer>Tobias Riemenschneider</developer>
        <developer_username>tobys</developer_username>
        <dup_id/>
        <creation_time>2016-10-20 03:24:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Add support for @jdk.Exported annotation</short_desc>
        <thetext>With Java SE 1.8 the @jdk.Exported annotation was introduced. It is used for identifying JDK specific types and packages outside of the Java SE namespaces java.* and javax.* that are part of the official interface of the JDK (see http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8001614 and related reports). For example, several types of the Java 8 Nashorn Javascript Engine are 'made public available' by using this annotation. This annotation is also supported by OpenJDK (see http://mail.openjdk.java.net/pipermail/security-dev/2013-October/009082.html).

Unfortunately the annotation is currently not supported by JDT, i.e., when using such a JDK specific type like jdk.nashorn.api.scripting.NashornException JDT reports an access restriction. As a workaround you can configure the severity of forbidden references to restricted API (which might mask other issues) or add access rules for each and every used type or package to the JRE contained in build path. In combination with build automation tools like Gradle additional configuration in the build scripts is required for preventing that these manual configurations are overwritten on each and every rebuild.

Therefore I would propose to support the @jdk.Exported annotation in JDT and prevent reporting access restrictions for exported types and packages.</thetext>
    </bug>
    <bug>
        <id>506375</id>
        <developer>Michael Vorburger</developer>
        <developer_username>mike</developer_username>
        <dup_id/>
        <creation_time>2016-10-21 23:24:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null] Allow NonNullByDefault in external library annotation (EEA)</short_desc>
        <thetext>I believe there would be value in allowing to externally annotate (EEA) a package of a library with @NonNullByDefault.

If this is already possible today and I'm not getting it, could you elaborate how one does this?  I've tried the Ctrl-1 on the package name and keyword declaration in a Some.class, as well as on the package-info.class, and neither do anything.

For example, the Google Guava authors seem to assume @NonNull for most of their code (and they do use @Nullable occasionally), so instead of annotating method after method return value with @NonNull, it would be cool if I could externally annotate their package.  (FYI The Guava packages do have a javax.annotation.ParametersAreNonnullByDefault which one could "interpret" as a secondary annotation for @NonNullByDefault, if though that's not exactly the same semantics.)</thetext>
        <comment>
            <comment_id>2769307</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-23 16:49:43 -0400</when>
            <comment_text>Not supported.

I initially assumed, that eea should spell out each annotation individually (which could still be generated by some tool, of course).

I see some room for improvement now, but I'm reluctant to increase the number of lookups needed to read one class.

So, as a compromise I could see a per-class @NNBD stored in an .eea file.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506396</id>
        <developer>Xuanchi Yu</developer>
        <developer_username>yuxuanchiadm</developer_username>
        <dup_id/>
        <creation_time>2016-10-22 21:38:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][compiler][generics] Generics bug when overriding method cause CCE</short_desc>
        <thetext>Code to reproduce bug:

public class OverrideGenericsBug {
	public interface A&lt;T&gt; {
		&lt;R extends T&gt; A&lt;R&gt; test();

		T get();
	}

	public static class B implements A&lt;CharSequence&gt; {
		@Override
		public B test() {
			return this;
		}

		@Override
		public CharSequence get() {
			return new StringBuilder();
		}
	}

	public static void main(String[] args) {
		A&lt;CharSequence&gt; obj = new B();
		A&lt;String&gt; what = obj.&lt;String&gt;test();
		String string = what.get();
		System.out.println(string);
	}
}

Eclipse compiler compiled this code without any warning. Javac compiler warning about this code.</thetext>
        <comment>
            <comment_id>2769285</comment_id>
            <comment_count>1</comment_count>
            <who>Xuanchi Yu</who>
            <commenter_username>yuxuanchiadm</commenter_username>
            <when>2016-10-22 21:59:48 -0400</when>
            <comment_text>So "A" is an interface. "A" has a type TypeVariable "&lt;T&gt;".
The method "test()" in "A" returns another "A" but we can change "&lt;T&gt;" to its subtype.

Now "B" is ParameterizedType extends "A" and "&lt;T&gt;" parameterized to "CharSequence".
The problem is we can override "test()" and returns "B" without any warning. This is looks fine but if we have a varible "A&lt;CharSequence&gt; obj" pointer to object "B". We can just call "obj.&lt;ANY_SUB_TYPE&gt;test()" to let things go wrong.

Javac doesn't reject this code but warning about. Because it described in JLS§8.4.5</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506399</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-10-24 00:51:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] AIOBE when compiling inner types from default package in a module</short_desc>
        <thetext>Steps to reproduce:

Create a module project with a simple module-info.
Create the following type in default package and try to compile:

public class TestOne {
	Connection con = null;
	public static class Inner {}
}  

The following exception is thrown:
java.lang.ArrayIndexOutOfBoundsException: 0
	at org.eclipse.jdt.internal.compiler.lookup.ModuleBinding.getDeclaredPackage(ModuleBinding.java:255)
	at org.eclipse.jdt.internal.compiler.lookup.ModuleBinding.declaresPackage(ModuleBinding.java:301)
	at org.eclipse.jdt.internal.compiler.lookup.ModuleBinding.canSee(ModuleBinding.java:363)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.canTypeBeSeen(LookupEnvironment.java:269)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.canBeSeenBy(SourceTypeBinding.java:1468)
	at org.eclipse.jdt.internal.compiler.util.Util.recordNestedType(Util.java:1125)
	at org.eclipse.jdt.internal.compiler.codegen.ConstantPool.literalIndexForType(ConstantPool.java:710)
	at org.eclipse.jdt.internal.compiler.ClassFile.initialize(ClassFile.java:5144)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:631)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:562)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:638)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:391)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:878)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:141)
	at java.lang.Thread.run(Thread.java:745)</thetext>
        <comment>
            <comment_id>2769328</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-24 00:56:00 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/83758</comment_text>
        </comment>
        <comment>
            <comment_id>2769337</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-24 02:01:28 -0400</when>
            <comment_text>Sasi, can you take a look at the patch?</comment_text>
        </comment>
        <comment>
            <comment_id>2769338</comment_id>
            <comment_count>3</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-24 02:07:18 -0400</when>
            <comment_text>(In reply to comment #2)
&gt; Sasi, can you take a look at the patch?
Exactly what is needed. May be add a null check as well, just to be absolutely certain :-)</comment_text>
        </comment>
        <comment>
            <comment_id>2769339</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-24 02:11:00 -0400</when>
            <comment_text>I have another issue related to the accessibility within default packages. Having these two types in separate CUs (both in default package) has problems:

public class X extends Y {
}

public class Y {
}

I am investigating this now.</comment_text>
        </comment>
        <comment>
            <comment_id>2769346</comment_id>
            <comment_count>5</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-24 02:51:32 -0400</when>
            <comment_text>(In reply to comment #4)
&gt; I have another issue related to the accessibility within default packages.
&gt; Having these two types in separate CUs (both in default package) has problems:
&gt; 
&gt; public class X extends Y {
&gt; }
&gt; 
&gt; public class Y {
&gt; }
&gt; 
&gt; I am investigating this now.
That's most likely because of having a different default package for each module. We should have a single default package, and in our visibility check, make sure that client and source module are the same if the type is in default package so that we do not run into this kind of issues with default packages</comment_text>
        </comment>
        <comment>
            <comment_id>2769437</comment_id>
            <comment_count>6</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-24 06:15:29 -0400</when>
            <comment_text>*** Bug 506424 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
        <comment>
            <comment_id>2769448</comment_id>
            <comment_count>7</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-24 06:49:39 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #1)
&gt; New Gerrit change created: https://git.eclipse.org/r/83758

This has been merged directly via:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=0c70c85bde6467a052c1a5c7c9b674c46d13f52e</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506478</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-10-25 01:13:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Having the same module in two source folders in a project triggers wrong error in editor</short_desc>
        <thetext>To reproduce, create a java project with two source folders, each having a module-info.java in their default package. Name both the modules same (doesn't matter what is defined inside the module). Now the editor shows the following error:

The type java.lang.Object cannot be resolved. It is indirectly referenced from required .class files

There is no error in the problems view, though.

However, if the second module has a different module name, the problems view correctly reports the following problem:

The type module-info is already defined	module-info.java	

This is the correct behavior and should be reported regardless of the second module's name.</thetext>
    </bug>
    <bug>
        <id>506481</id>
        <developer>Chandrakala MS</developer>
        <developer_username>chandra-ms</developer_username>
        <dup_id/>
        <creation_time>2016-10-25 03:14:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Compiler error - junit references are not resolved though junit.jar is present on classpath</short_desc>
        <thetext>Compilation errors - import org cannot be resolved

junit references are not resolved though junit.jar is present on classpath or project build path. Observed this when my project has dependencies on other modules or non-modular code.

However, a simple junit test both as a module or non-module compiles and runs fine.

Tested with eclipse-SDK-Y20161020-1000-win32-x86_64 on Windows 7</thetext>
        <comment>
            <comment_id>2775701</comment_id>
            <comment_count>1</comment_count>
            <who>Chandrakala MS</who>
            <commenter_username>chandra-ms</commenter_username>
            <when>2016-11-14 01:22:12 -0500</when>
            <comment_text>Any updates?</comment_text>
        </comment>
        <comment>
            <comment_id>2775702</comment_id>
            <comment_count>2</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-14 01:27:42 -0500</when>
            <comment_text>Please provide a simple project/set of projects that demonstrate this problem. Thanks</comment_text>
        </comment>
        <comment>
            <comment_id>2775723</comment_id>
            <comment_count>3</comment_count>
            <who>Chandrakala MS</who>
            <commenter_username>chandra-ms</commenter_username>
            <when>2016-11-14 04:52:39 -0500</when>
            <comment_text>Created attachment 265329
testcase to reproduce the issue</comment_text>
        </comment>
        <comment>
            <comment_id>2775729</comment_id>
            <comment_count>4</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-14 05:07:57 -0500</when>
            <comment_text>Please export the project using Export -&gt; Archive under the General category. The attached project does not contain the sources. However, looking at the build path of the project, it looks like you are trying to use jars on the classpath of a module project, which is not allowed. A named module cannot directly use jars on it's classpath. That would require automatic module support where you specify the jar as a dependency in module-info and then the compiler can treat the jar as an automatic module. We do not support automatic modules yet.</comment_text>
        </comment>
        <comment>
            <comment_id>2775990</comment_id>
            <comment_count>5</comment_count>
            <who>Chandrakala MS</who>
            <commenter_username>chandra-ms</commenter_username>
            <when>2016-11-15 01:54:42 -0500</when>
            <comment_text>Created attachment 265350
complete zip with src</comment_text>
        </comment>
        <comment>
            <comment_id>2775991</comment_id>
            <comment_count>6</comment_count>
            <who>Chandrakala MS</who>
            <commenter_username>chandra-ms</commenter_username>
            <when>2016-11-15 01:57:45 -0500</when>
            <comment_text>Re: comment 4, I have attached the zip again. When can I expect support for automatic modules?  

How can I pass JVM args to javac? I would like to use --add-reads option to read the unnamed module from my module. Thanks.</comment_text>
        </comment>
        <comment>
            <comment_id>2776006</comment_id>
            <comment_count>7</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-15 02:57:38 -0500</when>
            <comment_text>(In reply to comment #6)
&gt; Re: comment 4, I have attached the zip again. When can I expect support for
&gt; automatic modules?
&gt; 
All in good time :-). This is definitely a must have, but we are still at the very beginning. You can track the open issues here https://wiki.eclipse.org/JDT_Core/Java9/Open_items

&gt; How can I pass JVM args to javac? I would like to use --add-reads option to read
&gt; the unnamed module from my module. Thanks.
The options are detailed in JEP 261, but I believe add-reads option does not address what you want to accomplish. The only way a named module can access a jar on it's classpath is via automatic modules. I don't know if javac already supports this, but try adding a requires in your module-info to the name of the jar you want to access on the classpath and see if that works. I heard of a naming algorithm for automatic modules, which will decide what the name in the requires should be, but using the jar name would be the first step</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506587</id>
        <developer>David Christensen</developer>
        <developer_username>davidaca</developer_username>
        <dup_id/>
        <creation_time>2016-10-26 17:33:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>JVMVRFY012 stack shape inconsistent</short_desc>
        <thetext>Hi,

After generating a deploy artifact using Eclipse Batch as the compiler, attempts to execute application built result in error.

Error: A JNI error has occurred, please check your installation and try again
Exception in thread "main" java.lang.VerifyError: JVMVRFY012 stack shape inconsistent; 

Compile command used:
C:\opt\ibmjava\803.12\bin\java.exe -jar C:\opt\IBM\IMShared\plugins\org.eclipse.jdt.core_3.8.4.v20140417-1504.jar -source 1.6 -target 1.6 -classpath . jp\co\fnt\stp1\app\apptier\front\kj\eip\ctrl\KyakMainKjnSyutkCommand.java

Test case execution command:
&lt;pathToJava8&gt;/jre/bin/java -Dsun.java.launcher.diag=true -cp . jp/co/fnt/stp1/app/apptier/front/kj/eip/ctrl/KyakMainKjnSyutkCommand

It seems bytecode is not valid.
Is it possible to get a fix for this problem?

Please let me know if I can further help in something.</thetext>
        <comment>
            <comment_id>2770419</comment_id>
            <comment_count>1</comment_count>
            <who>David Christensen</who>
            <commenter_username>davidaca</commenter_username>
            <when>2016-10-26 17:34:29 -0400</when>
            <comment_text>After some investigation, it was found the VerifyError was because the local variable table for the current frame is different from what the stackmap frame.

This is the local variable table for the current frame:

    locals: { 'jp/co/fnt/stp1/app/apptier/front/kj/eip/ctrl/KyakMainKjnSyutkCommand', 'java/sql/Connection', 'java/lang/String', 'jp/co/fnt/stp1/app/apptier/front/kj/eip/model/accessor/G3Kyf0010GetKojnKyakJohoQueryAccessor', top, 'jp/co/fnt/stp1/app/apptier/front/kj/eip/model/accessor/G3Kyo0030GetKakariNameQueryAccessor', top, 'jp/co/fnt/stp1/app/apptier/front/kj/eip/model/accessor/Kyf0030TableAccessor', top, 'jp/co/fnt/stp1/app/apptier/front/kj/eip/model/accessor/G3Kyf2000GetTeikokuJohoQueryAccessor', 'jp/co/fnt/stp1/app/apptier/front/kj/eip/model/accessor/G3Kyf2000GetTeikokuJohoQueryRecord', 'jp/co/fnt/stp1/app/apptier/front/kj/eip/model/accessor/G3Kyf2000GetKjnJohoQueryAccessor', top, 'jp/co/fnt/stp1/app/apptier/front/kj/eip/model/accessor/Kyg0020TableAccessor', top, 'java/lang/String' }

This is the one for the stackmap frame:
    locals: { 'jp/co/fnt/stp1/app/apptier/front/kj/eip/ctrl/KyakMainKjnSyutkCommand', 'java/sql/Connection', 'java/lang/String', 'jp/co/fnt/stp1/app/apptier/front/kj/eip/model/accessor/G3Kyf0010GetKojnKyakJohoQueryAccessor', top, 'jp/co/fnt/stp1/app/apptier/front/kj/eip/model/accessor/G3Kyo0030GetKakariNameQueryAccessor', top, 'jp/co/fnt/stp1/app/apptier/front/kj/eip/model/accessor/Kyf0030TableAccessor', top, 'jp/co/fnt/stp1/app/apptier/front/kj/eip/model/accessor/G3Kyf2000GetTeikokuJohoQueryAccessor', 'jp/co/fnt/stp1/app/apptier/front/kj/eip/model/accessor/G3Kyf2000GetTeikokuJohoQueryRecord', 'jp/co/fnt/stp1/app/apptier/front/kj/eip/model/accessor/G3Kyf2000GetKjnJohoQueryAccessor', top, 'jp/co/fnt/stp1/app/apptier/front/kj/eip/model/accessor/Kyg0020TableAccessor', 'jp/co/fnt/stp1/app/apptier/front/kj/eip/model/accessor/Kyg0020TableRecord', 'java/lang/String' }

As you can see here, the local[14] for the current frame is "top" (roughly stands for empty), for the stack map frame, it is type Kyg0020TableRecord</comment_text>
        </comment>
        <comment>
            <comment_id>2770420</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-26 18:05:14 -0400</when>
            <comment_text>(In reply to David Christensen from comment #0)
&gt; Compile command used:
&gt; C:\opt\ibmjava\803.12\bin\java.exe -jar
&gt; C:\opt\IBM\IMShared\plugins\org.eclipse.jdt.core_3.8.4.v20140417-1504.jar
&gt; -source 1.6 -target 1.6 -classpath .
&gt; jp\co\fnt\stp1\app\apptier\front\kj\eip\ctrl\KyakMainKjnSyutkCommand.java
&gt; 

The version 3.8.4.v20140417-1504 is quite old. Could you please try a recent version? You can download the batch compiler from http://download.eclipse.org/eclipse/downloads/  - select a version and then look for "JDT Core Batch Compiler".</comment_text>
        </comment>
        <comment>
            <comment_id>2772833</comment_id>
            <comment_count>3</comment_count>
            <who>David Christensen</who>
            <commenter_username>davidaca</commenter_username>
            <when>2016-11-03 19:10:58 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #2)
&gt; (In reply to David Christensen from comment #0)
&gt; &gt; Compile command used:
&gt; &gt; C:\opt\ibmjava\803.12\bin\java.exe -jar
&gt; &gt; C:\opt\IBM\IMShared\plugins\org.eclipse.jdt.core_3.8.4.v20140417-1504.jar
&gt; &gt; -source 1.6 -target 1.6 -classpath .
&gt; &gt; jp\co\fnt\stp1\app\apptier\front\kj\eip\ctrl\KyakMainKjnSyutkCommand.java
&gt; &gt; 
&gt; 
&gt; The version 3.8.4.v20140417-1504 is quite old. Could you please try a recent
&gt; version? You can download the batch compiler from
&gt; http://download.eclipse.org/eclipse/downloads/  - select a version and then
&gt; look for "JDT Core Batch Compiler".


Hi Stephan,
Also tried with org.eclipse.jdt.core_3.10.2.v20150805-1358.jar with same result. Other factor is that this version is very tight with my environment and a new upgrade from this is complicated (but not impossible).
Thanks</comment_text>
        </comment>
        <comment>
            <comment_id>2773241</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-04 18:43:38 -0400</when>
            <comment_text>(In reply to David Christensen from comment #3)
&gt; (In reply to Stephan Herrmann from comment #2)
&gt; &gt; (In reply to David Christensen from comment #0)
&gt; &gt; &gt; Compile command used:
&gt; &gt; &gt; C:\opt\ibmjava\803.12\bin\java.exe -jar
&gt; &gt; &gt; C:\opt\IBM\IMShared\plugins\org.eclipse.jdt.core_3.8.4.v20140417-1504.jar
&gt; &gt; &gt; -source 1.6 -target 1.6 -classpath .
&gt; &gt; &gt; jp\co\fnt\stp1\app\apptier\front\kj\eip\ctrl\KyakMainKjnSyutkCommand.java
&gt; &gt; &gt; 
&gt; &gt; 
&gt; &gt; The version 3.8.4.v20140417-1504 is quite old. Could you please try a recent
&gt; &gt; version? You can download the batch compiler from
&gt; &gt; http://download.eclipse.org/eclipse/downloads/  - select a version and then
&gt; &gt; look for "JDT Core Batch Compiler".
&gt; 
&gt; 
&gt; Hi Stephan,
&gt; Also tried with org.eclipse.jdt.core_3.10.2.v20150805-1358.jar with same
&gt; result. Other factor is that this version is very tight with my environment
&gt; and a new upgrade from this is complicated (but not impossible).
&gt; Thanks

With 3.10.2.v20150805-1358 you're still missing approx. 3 bug fixes relating to stackmaps: bug 490988, bug 498362, bug 507011

What can be done from here?
- Maybe you can identify one of the bugs as matching your situation?
- Otherwise we'd need your help on reproducing the issue.</comment_text>
        </comment>
        <comment>
            <comment_id>2779994</comment_id>
            <comment_count>5</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-25 04:29:22 -0500</when>
            <comment_text>Same problem as bug 499809. I have been able to create a test that causes a verify error without involving null analysis. Fix in the works. More explanation in bug 499809 comment 2</comment_text>
        </comment>
        <comment>
            <comment_id>2782352</comment_id>
            <comment_count>6</comment_count>
            <who>Kit Lo</who>
            <commenter_username>kitlo</commenter_username>
            <when>2016-12-02 10:03:53 -0500</when>
            <comment_text>Sasi, is this a dup of bug 499809?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506608</id>
        <developer>Sergey Olefir</developer>
        <developer_username>solf.gm</developer_username>
        <dup_id/>
        <creation_time>2016-10-27 05:57:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Add a @SuppressWarnings to suppress 'Unnecessary @SuppressWarnings'</short_desc>
        <thetext>Please consider adding a @SuppressWarnings("unnecessary") (or some other token) that will suppress such warnings as 'Unnecessary @SuppressWarnings("resource")'.

I know that there's a compiler option, however that option is 'global' -- at the very least it affects the entire project.

Usecase: a mix of human- and generated- code in the same project (specifically was trying out Xtend). The generated code needs various warnings suppressed (as the generation engine isn't careful enough), the human code is best kept with warnings enabled.

@SuppressWarnings("all") would take care of the generated code but it'll also suppress some warnings that don't need to be suppressed. Suppressing individual problems (e.g. @SuppressWarnings("hiding") or smth) is fine as long as there's an actual warning in generated code but itself generates a warning if there happen to be no such problem. Hence the request.</thetext>
    </bug>
    <bug>
        <id>506640</id>
        <developer>Felipe Pontes</developer>
        <developer_username>felipepontes</developer_username>
        <dup_id/>
        <creation_time>2016-10-27 12:57:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Eclipse batch compiler returns wrong declared fields number when using Reflection API</short_desc>
        <thetext>Accordingly to Reflection API documentation (https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredFields--) method Class.getDeclaredFields() "returns an array of Field objects reflecting all the fields declared by the class or interface represented by this Class object. This includes public, protected, default (package) access, and private fields, but excludes inherited fields". Class A in the below program hasn't any declared fields. So, when compiling it using the eclipse batch compiler Class.getDeclaredFields() result should be zero declared field instead of one declared field.

Program

   public class A extends B {
	public void a() {
		switch(c) {
			case X:
			
		}
	}
   }

   public abstract class B {
	protected enum C {
		X, Y
	}
	protected C c;
   }

Current result

   private static int[] A.$SWITCH_TABLE$B$C.

Expected result

   No declared fields.

Configuration

   Software

      O.S.: Linux Ubuntu 14.04 64bits
      ECJ: org.eclipse.jdt.core-3.13.0-SNAPSHOT-batch-compiler.jar (Eclipse Neon 4.6)

   Hardware: Intel(R) Core(TM) i5-5200U CPU @ 2.20GHz</thetext>
    </bug>
    <bug>
        <id>506645</id>
        <developer>Felipe Pontes</developer>
        <developer_username>felipepontes</developer_username>
        <dup_id/>
        <creation_time>2016-10-27 13:28:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.lookup.FieldBinding.constant(FieldBinding.java:218)</short_desc>
        <thetext>NullPointerException when trying to compile the following program using the eclipse bath compiler.


Program

   public class A {
        @NotNull
        final B.C&lt;D&gt; field;
        void x(@NotNull B.C&lt;D&gt; parameter) {
		field = parameter;
        }
   }

Steps to reproduce

   Execute the following command:
java -jar org.eclipse.jdt.core-3.13.0-SNAPSHOT-batch-compiler.jar -1.8 A.java

Current result

   ERROR in A.java (at line 0)
           public class A {
           ^
   Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.lookup.FieldBinding.constant(FieldBinding.java:218)

Expected result

   No internal compiler errors.

Configuration

   Software

      O.S.: Linux Ubuntu 14.04 64bits
      ECJ: org.eclipse.jdt.core-3.13.0-SNAPSHOT-batch-compiler.jar (Eclipse Neon 4.6)

   Hardware: Intel(R) Core(TM) i5-5200U CPU @ 2.20GHz</thetext>
        <comment>
            <comment_id>2770732</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-27 17:47:49 -0400</when>
            <comment_text>Seems to be a result of unresolved B.C, in combination with the annotation (not necessarily a nonnull annotation).

The fact that also NotNull and D are unresolved is irrelevant.

Same exception is thrown from compiling

//---
   @interface Ann {}
   class D {}
   public class A {
        @Ann
        final B.C&lt;D&gt; field;
        void x(B.C&lt;D&gt; parameter) {
            field = parameter;
        }
   }
//---

Removing the B. from B.C avoids the bug, as does ensuring that B.C can be resolved. Also removing "final" from the field avoids the bug.

BTW: assigning a final field in a regular method is bogus to begin with - but then changing x() to a constructor does not avoid the NPE.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506648</id>
        <developer>Felipe Pontes</developer>
        <developer_username>felipepontes</developer_username>
        <dup_id/>
        <creation_time>2016-10-27 13:47:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Internal compiler error: java.lang.Exception: java.lang.IllegalArgumentException: Unknown location : CLASS_OUTPUT at</short_desc>
        <thetext>Created attachment 265088
Class path jars.

IllegalArgumentException when trying to compile the following program using the eclipse batch compiler.

Program

   public class A {}

Steps to reproduce

   Extract the classpath-jars.tar.gz file contents and execute the command presented in command.txt file.

Current result

   ERROR in A.java (at line 0)
   	public class A{}
	^
   Internal compiler error: java.lang.Exception: java.lang.IllegalArgumentException: Unknown location : CLASS_OUTPUT at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundDispatcher.handleProcessor(RoundDispatcher.java:169)

Expected result

   No internal compiler errors.

Configuration

   Software

      O.S.: Linux Ubuntu 14.04 64bits
      ECJ: org.eclipse.jdt.core-3.13.0-SNAPSHOT-batch-compiler.jar (Eclipse Neon 4.6)

   Hardware: Intel(R) Core(TM) i5-5200U CPU @ 2.20GHz</thetext>
        <comment>
            <comment_id>2770659</comment_id>
            <comment_count>1</comment_count>
            <who>Felipe Pontes</who>
            <commenter_username>felipepontes</commenter_username>
            <when>2016-10-27 13:48:10 -0400</when>
            <comment_text>Created attachment 265089
Command to compile the program.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506649</id>
        <developer>Felipe Pontes</developer>
        <developer_username>felipepontes</developer_username>
        <dup_id/>
        <creation_time>2016-10-27 13:55:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Internal compiler error: java.util.ServiceConfigurationError: javax.annotation.processing.Processor: Provider org.openjdk.jmh.generators.BenchmarkProcessor could not be instantiated at java.util.ServiceLoader.fail(ServiceLoader.java:232)</short_desc>
        <thetext>Created attachment 265090
Annotation processor jar.

ServiceConfigurationError when trying to compile the following program using the eclipse batch compiler.

Program

   public class A {}

Steps to reproduce

   Execute the following command (see attached file):
   java -jar org.eclipse.jdt.core-3.13.0-SNAPSHOT-batch-compiler.jar -cp jmh-generator-annprocess-1.0.1.jar -1.8 A.java

Current result

   ERROR in A.java (at line 0)
   public class A{} 
   ^
   Internal compiler error: java.util.ServiceConfigurationError: javax.annotation.processing.Processor: Provider org.openjdk.jmh.generators.BenchmarkProcessor could not be instantiated at java.util.ServiceLoader.fail(ServiceLoader.java:232)

Expected result

   No internal compiler errors.

Configuration

   Software

      O.S.: Linux Ubuntu 14.04 64bits
      ECJ: org.eclipse.jdt.core-3.13.0-SNAPSHOT-batch-compiler.jar (Eclipse Neon 4.6)

   Hardware: Intel(R) Core(TM) i5-5200U CPU @ 2.20GHz</thetext>
    </bug>
    <bug>
        <id>506653</id>
        <developer>Felipe Pontes</developer>
        <developer_username>felipepontes</developer_username>
        <dup_id/>
        <creation_time>2016-10-27 15:35:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Eclipse claims about duplicated method declaration</short_desc>
        <thetext>Eclipse batch compiler presents a compilation error but it should compile the following program:

Program

   public class A {
	public class B {
		&lt;E extends Object, F extends E&gt; E bar(F x) {
			return null;
		}
	}
	public class C extends B {
		public String bar(Object x) {
			return null;
		}
	}
   }


Current result

   ERROR in A.java (at line 8)
	public String bar(Object x) {
	              ^^^^^^^^^^^^^
   Name clash: The method bar(Object) of type A.C has the same erasure as bar(F) of type A.B but does not override it


Expected result

   No compilation errors.

Configuration

   Software

      O.S.: Linux Ubuntu 14.04 64bits
      ECJ: org.eclipse.jdt.core-3.13.0-SNAPSHOT-batch-compiler.jar (Eclipse Neon 4.6)

   Hardware: Intel(R) Core(TM) i5-5200U CPU @ 2.20GHz</thetext>
        <comment>
            <comment_id>2770739</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-27 18:08:17 -0400</when>
            <comment_text>While javac indeed accepts the program I'm not sure from the top of my head, whether this is a legal Java program.

Both methods do have the same erasure, and I doubt that C.bar overrides B.bar.

Of course the program can easily be extended to throw CCE without a single cast in the sources, e.g.,:

//---
   public class A {
    public class B {
        &lt;E extends Object, F extends E&gt; E bar(F x) {
            return null;
        }
    }
    public class C extends B {
        public String bar(Object x) {
            return "Oops";
        }
    }
    public static void main(String... args) {
        new A().test();
    }
    void test() {
        B b = new C();
        Integer i = b.bar(1);
    }
   }
//---

javac accepts, execution =&gt; CCE, not good.
ecj rejects, because C.bar is not compatible with B.bar

Feel free to prove me wrong.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506664</id>
        <developer>Felipe Pontes</developer>
        <developer_username>felipepontes</developer_username>
        <dup_id/>
        <creation_time>2016-10-27 16:13:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Eclipse can't handle method parameters declaration using generics</short_desc>
        <thetext>Eclipse batch compiler presents a compilation error but it should compile the following program:

Program

   package java.util.stream;
   import java.util.function.IntFunction;
   public class Y&lt;T&gt; {
      public Node&lt;T&gt; y(IntFunction&lt;T[]&gt; generator) {
         return null;
      }
   }

   package java.util.stream;
   import java.util.function.IntFunction;
   public class X&lt;T&gt; extends Y&lt;T&gt; {
      public void x() {
         IntFunction rawGenerator = null;
         Nodes.flatten(y(rawGenerator), rawGenerator);
      }
   }

Current result

   ERROR in X.java (at line 6)
	Nodes.flatten(y(rawGenerator), rawGenerator);
	      ^^^^^^^
   The method flatten(Node&lt;T&gt;, IntFunction&lt;T[]&gt;) in the type Nodes is not applicable for the arguments (Node, IntFunction)

Expected result

   No compilation errors.

Configuration

   Software

      O.S.: Linux Ubuntu 14.04 64bits
      ECJ: org.eclipse.jdt.core-3.13.0-SNAPSHOT-batch-compiler.jar (Eclipse Neon 4.6)

   Hardware: Intel(R) Core(TM) i5-5200U CPU @ 2.20GHz</thetext>
    </bug>
    <bug>
        <id>506741</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-10-29 16:51:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8] accept potentially compatible method in overloading</short_desc>
        <thetext>Dan claims ecj has a bug: https://bugs.openjdk.java.net/browse/JDK-8164611 (might be a future language enhancement though :) ).</thetext>
        <comment>
            <comment_id>2772095</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-02 01:46:28 -0400</when>
            <comment_text>Should we mark this as spec change or something?</comment_text>
        </comment>
        <comment>
            <comment_id>2772415</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-02 15:42:03 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #1)
&gt; Should we mark this as spec change or something?

I can't yet tell. I will mark it accordingly as soon as I find the time to analyse.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506977</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-11-03 09:37:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>The batch compiler only has warningToken which covers two settings</short_desc>
        <thetext>The batch compiler only has warningToken which covers two settings.

We need to only disable the unused @SuppressWarnings. A new token 'unusedSuppressWarnings' should be added.</thetext>
        <comment>
            <comment_id>2772678</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-03 10:21:21 -0400</when>
            <comment_text>Xref: the current situation was introduced via bug 127533.

Is this request questioning our common practice to summarize several problem IDs under one batch compiler option token? I.e., do you expect that each and every problem ID can be individually configured also via CLI?

What should the relation between 'warningToken' and 'unusedSuppressWarnings' be? Should 'warningToken' still cover the same problem ID? I assume so, because  eerything else would be a breaking API change, right? 
This will then open the door for the next request: 'unhandledWarningToken'.</comment_text>
        </comment>
        <comment>
            <comment_id>2772687</comment_id>
            <comment_count>2</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-03 10:35:07 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #1)
&gt; Is this request questioning our common practice to summarize several problem
&gt; IDs under one batch compiler option token? I.e., do you expect that each and
&gt; every problem ID can be individually configured also via CLI?

No, it's just this particular case. I want to get a warning when the token is wrong but not when the @SuppressWarning is unused. The reason behind this, is that most projects use different (mostly stricter) rules in their project settings than used in the official build. When they then suppress such a warning, they get blamed in the official build. Hence, we want to disable the warning for unused @

&gt; 
&gt; What should the relation between 'warningToken' and 'unusedSuppressWarnings'
&gt; be? Should 'warningToken' still cover the same problem ID? I assume so,
&gt; because  eerything else would be a breaking API change, right? 
&gt; This will then open the door for the next request: 'unhandledWarningToken'.</comment_text>
        </comment>
        <comment>
            <comment_id>2772690</comment_id>
            <comment_count>3</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-03 10:40:25 -0400</when>
            <comment_text>(In reply to Dani Megert from comment #2)
&gt; (In reply to Stephan Herrmann from comment #1)
&gt; &gt; Is this request questioning our common practice to summarize several problem
&gt; &gt; IDs under one batch compiler option token? I.e., do you expect that each and
&gt; &gt; every problem ID can be individually configured also via CLI?
&gt; 
&gt; No, it's just this particular case. I want to get a warning when the token
&gt; is wrong but not when the @SuppressWarning is unused. The reason behind
&gt; this, is that most projects use different (mostly stricter) rules in their
&gt; project settings than used in the official build. When they then suppress
&gt; such a warning, they get blamed in the official build. Hence, we want to
&gt; disable the warning for unused @

Sorry, somehow hit Ctrl+S.

... warning for unused @SuppressWarnings in the official build.


 
&gt; &gt; What should the relation between 'warningToken' and 'unusedSuppressWarnings'
&gt; &gt; be? Should 'warningToken' still cover the same problem ID? I assume so,

Yes, same problem ID and no change for cases where 'unusedSuppressWarnings' is not used.


&gt; &gt; This will then open the door for the next request: 'unhandledWarningToken'.

No, I would not add that.


I suggest that when 'unusedSuppressWarnings' is used, this always wins i.e. regarding "unused" we ignore what 'warningToken' says, but we use the 'warningToken' severity for the unhandled tag.</comment_text>
        </comment>
        <comment>
            <comment_id>2772712</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-03 11:24:02 -0400</when>
            <comment_text>(In reply to Dani Megert from comment #3)
&gt; I suggest that when 'unusedSuppressWarnings' is used, this always wins i.e.
&gt; regarding "unused" we ignore what 'warningToken' says, but we use the
&gt; 'warningToken' severity for the unhandled tag.

Special-case precedence sounds shaky to me.

Wouldn't it be more consistent with our existing strategy to evaluate left-to-right so that, e.g.,
  -warn:+warningToken,-unusedSuppressWarnings
would evaluate to warning only about unhandled tokens (first turn on two sub-options, then disable one of them)? 
Isn't that what this request is initially about?

Compare to, e.g.,
  -warn:+all,-unused
or
  -warn:+unused,-unusedExceptionParam
etc.</comment_text>
        </comment>
        <comment>
            <comment_id>2772915</comment_id>
            <comment_count>5</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-04 05:11:36 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #4)
&gt; (In reply to Dani Megert from comment #3)
&gt; &gt; I suggest that when 'unusedSuppressWarnings' is used, this always wins i.e.
&gt; &gt; regarding "unused" we ignore what 'warningToken' says, but we use the
&gt; &gt; 'warningToken' severity for the unhandled tag.
&gt; 
&gt; Special-case precedence sounds shaky to me.
&gt; 
&gt; Wouldn't it be more consistent with our existing strategy to evaluate
&gt; left-to-right so that, e.g.,
&gt;   -warn:+warningToken,-unusedSuppressWarnings
&gt; would evaluate to warning only about unhandled tokens (first turn on two
&gt; sub-options, then disable one of them)? 
&gt; Isn't that what this request is initially about?
&gt; 
&gt; Compare to, e.g.,
&gt;   -warn:+all,-unused
&gt; or
&gt;   -warn:+unused,-unusedExceptionParam
&gt; etc.

Yes, that sounds even better and is consistent with what we have.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507001</id>
        <developer>Daniel Friederich</developer>
        <developer_username>danielfriederich</developer_username>
        <dup_id/>
        <creation_time>2016-11-03 15:23:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Warning The method xxx from the type X is never used locally is shown for code using xxx from another class.</short_desc>
        <thetext>Technically the message is not actually wrong as it is really not used locally.
But my expectation with this message is that it is save to remove the function (which is also the quickfix for it), but in this case this breaks the code.

I saw this warning from some java library in github (https://github.com/vidstige/jadb.git).
Simplified the issue is shown for the PubDef.hello method in this code:
public class Def {
	static private class PrivDef {
		static public class PubDef {
			public void hello() {
				System.out.println("Hello");
			}
		}
		PubDef getPubDef() {
			return new PubDef();
		}
	}
	PrivDef.PubDef getPubDef() {
		return new PrivDef().getPubDef();
	}
}

However another class can call hello:

public class User {
	static public int main(char[] args) {
		Def d = new Def();
		d.getPubDef().hello();
		return 0;
	}
}

Hence it is not correct to remove it.</thetext>
        <comment>
            <comment_id>2772816</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-03 16:30:13 -0400</when>
            <comment_text>Geewiz, always another surprise with Java.

Conceptually, that's what I'd call an API leak: getPubDef() makes an inaccessible type accessible (kind-of, see below).

Interesting twist: User cannot name Def.Privdef.PubDef but it can use it. Wow!
Hint: try extracting "d.getPubDef()" to a local variable =&gt; Boom!

Put differently, java seems to allow accessing a method of an inaccessible type.

=&gt; Our assumption that membership in a private type restricts the accessibility is wrong.

OTOH, I'd definitely not accept the above as good design. So maybe the warning (and resulting error if you remove the method) is a good thing to alert folks of the bad design :p


On a related note: I just surfed JLS to figure out what should change for Jigsaw, and indeed could not find any requirement that the receiver type of a field access or method invocation must be accessible. Looks like a spec bug, if you ask me.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507008</id>
        <developer>Alex Iliev</developer>
        <developer_username>alexander.iliev</developer_username>
        <dup_id/>
        <creation_time>2016-11-03 17:22:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][compiler][inference] Cannot infer type arguments with upper bound</short_desc>
        <thetext>ecj reports the commented errors on the following code, source level 1.8. Tried with versions 4.6 and 4.7M3. Compiles fine under javac 7, 8 and 9.


public class Demo1
{
    interface MyFunction&lt;A,B&gt; {
        B apply(A a);
    }

    // Note: no problems if A doesn't have the upper bound

    private static class DelegatingFunction&lt;A extends Number, B&gt; implements MyFunction&lt;A, B&gt; {

        private final MyFunction&lt;? super A, ? extends B&gt; delegate;

        DelegatingFunction(MyFunction&lt;? super A, ? extends B&gt; delegate) {
            this.delegate = delegate;
        }

        public B apply(A t) {
            return this.delegate.apply(t);
        }
    }

    private static &lt;A extends Number, B&gt; DelegatingFunction&lt;A, B&gt;
    makeDelegatingFunction(MyFunction&lt;? super A, ? extends B&gt; delegate) {
        return new DelegatingFunction&lt;A,B&gt;(delegate);
    }


    public static &lt;A extends Number, B&gt; void constructor(MyFunction&lt;? super A, ? extends B&gt; delegate) {
        DelegatingFunction&lt;A, B&gt; f = new DelegatingFunction&lt;&gt;(delegate);
        // ERROR: Cannot infer type arguments for DelegatingFunction&lt;&gt;

        // workaround:
        f = new DelegatingFunction&lt;A,B&gt;(delegate);
    }

    public static &lt;A extends Number, B&gt; void genericMethod(MyFunction&lt;? super A, ? extends B&gt; delegate) {
        DelegatingFunction&lt;A, B&gt; f = makeDelegatingFunction(delegate);
        // ERROR: The method makeDelegatingFunction(MyFunction&lt;? super A,? extends B&gt;) in the type Demo1
        // is not applicable for the arguments (MyFunction&lt;capture#13-of ? super A,capture#14-of ? extends B&gt;)

        // workaround:
        f = Demo1.&lt;A,B&gt;makeDelegatingFunction(delegate);
    }
}</thetext>
        <comment>
            <comment_id>2772844</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-04 00:32:55 -0400</when>
            <comment_text>Reproduced on master.</comment_text>
        </comment>
        <comment>
            <comment_id>2773427</comment_id>
            <comment_count>2</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-07 01:59:37 -0500</when>
            <comment_text>The upper bound causes us to conclude that we have an inconsistent intersection during glb computation, and hence inference fails for the diamond. In ReferenceBinding.isConsistentIntersection, we have this line with the comment 

// when invoked during type inference we only want to check inconsistency among real types:
		if (current.isTypeVariable() || current.isWildcard() || !current.isProperType(true))
			continue;

In that case, we should probably apply the same rule to mostSpecific (which is taken as the first of the intersecting types, which is a CaptureBinding in this case)?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507069</id>
        <developer>Ed Willink</developer>
        <developer_username>ed</developer_username>
        <dup_id/>
        <creation_time>2016-11-04 12:28:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>No longer possible to annotate as 'designed with null type annotations in mind'</short_desc>
        <thetext>Using M3, I finally have a coherent installation to report against.

I have a List.eea:

class java/util/List
iterator
 ()Ljava/util/Iterator&lt;TE;&gt;;
 ()L1java/util/Iterator&lt;TE;&gt;;
toArray
 &lt;T:Ljava/lang/Object;&gt;([TT;)[TT;
 &lt;T:Ljava/lang/Object;&gt;([1TT;)[1TT;

with no get definition. As indicated prior to Oxygen, the absence defines that get is deliberately unannotated. But my source code reports an Info.

Unsafe interpretation of method return type as '@NonNull' based on the receiver type '@NonNull List&lt;DependencyAnalyzer.@NonNull DependencyPaths&gt;'. Type 'List&lt;E&gt;' doesn't seem to be designed with null type annotations in mind.

Only an Info, but there should be a way to suppress it. Assuming that absence is deliberate is indeed unsafe so we really need a third no-annotation annotation to enable a positive definition of e.g. List.get as intentionally unannotated.</thetext>
        <comment>
            <comment_id>2773139</comment_id>
            <comment_count>1</comment_count>
            <who>Ed Willink</who>
            <commenter_username>ed</commenter_username>
            <when>2016-11-04 12:34:45 -0400</when>
            <comment_text>Much more seriously, an @Nullable annotation on Map&lt;,@NonNull&gt;.get is ignored with the result being interpreted as @NonNull give downstream problems within the required 'redundnat' if (... != null) guard.</comment_text>
        </comment>
        <comment>
            <comment_id>2773194</comment_id>
            <comment_count>2</comment_count>
            <who>Ed Willink</who>
            <commenter_username>ed</commenter_username>
            <when>2016-11-04 14:20:33 -0400</when>
            <comment_text>These problems can be seen in

org.eclipse.qvtd.compiler.internal.qvtp2qvts.DependencyAnalyzer

The spurious warnings only show in the editor. Problems View is clean.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507130</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-11-07 04:49:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Reconcile new indexer work and JRT file system</short_desc>
        <thetext>After the most recent of merge of master into BETA_JAVA9, there is a new failure:

ParticipantBuildTests.testResolvedMethod()

These are in a way result of a merge conflict with the merge. There were conflicting changes from both branches in ClassFile.getJarBinaryTypeInfo(). I consciously chose to go with the change from master. But we need to take a close look at how we want to read contents of class files from index that are originally from JRT system.

To get an idea of the problem, one needs to compare the change in the aforementioned method in master and previous version in JAVA9 branch before this merge.</thetext>
        <comment>
            <comment_id>2774024</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-08 04:27:48 -0500</when>
            <comment_text>So far from what I have seen, this affects reconciler and Open Type dialogue.</comment_text>
        </comment>
        <comment>
            <comment_id>2774440</comment_id>
            <comment_count>2</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-11-08 17:49:58 -0500</when>
            <comment_text>Thanks for the heads-up. I'll take a look at it.</comment_text>
        </comment>
        <comment>
            <comment_id>2785305</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-12 01:09:55 -0500</when>
            <comment_text>To unblock us on several fronts, I have released a small fix to load classes from JRT:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=a049fc4eb04b836e525fb1fa8d9272f81e4c1380

The rest of the indexer work can be taken up at a suitable time.</comment_text>
        </comment>
        <comment>
            <comment_id>2785398</comment_id>
            <comment_count>4</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-12-12 06:12:20 -0500</when>
            <comment_text>(In reply to comment #3)
&gt; To unblock us on several fronts, I have released a small fix to load classes
&gt; from JRT:
&gt; 
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=a049fc4eb04b836e525fb1fa8d9272f81e4c1380
&gt; 
&gt; The rest of the indexer work can be taken up at a suitable time.
This causes failures in several dom and model tests, see https://hudson.eclipse.org/platform/job/eclipse.jdt.core-Gerrit/2053/#showFailuresLink for complete list</comment_text>
        </comment>
        <comment>
            <comment_id>2785418</comment_id>
            <comment_count>5</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-12 06:42:43 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/86939</comment_text>
        </comment>
        <comment>
            <comment_id>2785421</comment_id>
            <comment_count>6</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-12 06:44:56 -0500</when>
            <comment_text>(In reply to Sasikanth Bharadwaj from comment #4) 
&gt; &gt; The rest of the indexer work can be taken up at a suitable time.
&gt; This causes failures in several dom and model tests, see
&gt; https://hudson.eclipse.org/platform/job/eclipse.jdt.core-Gerrit/2053/
&gt; #showFailuresLink for complete list

In an enthusiasm to cut down on duplicate code, I failed to understand that the ClassFile#getJarBinaryTypeInfo() is not just for Jar package fragement roots. I have fixed it in the gerrit patch, where tests are currently being run.</comment_text>
        </comment>
        <comment>
            <comment_id>2785691</comment_id>
            <comment_count>7</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-13 00:18:53 -0500</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/86939 was merged to [BETA_JAVA9].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=1816b78b7bb37038af2f191b4e993a6ce14d8d2d</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507248</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-11-08 15:07:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Error message about cycle does not tell where the cycle is</short_desc>
        <thetext>N20161103-2000.

I got tons of errors that there's a cycle in my build path.

The error message is shown below.

Unfortunately it is useless since it does not show the cycle, but only gives a list of involved projects.



A cycle was detected in the build path of project 'org.eclipse.jdt.compiler.apt'. The cycle consists of projects {org.apache.felix.gogo.command, org.apache.felix.gogo.runtime, org.eclipse.osgi.services, CSVReader, org.eclipse.core.filebuffers, org.eclipse.core.runtime, org.eclipse.equinox.app, org.eclipse.core.resources, org.eclipse.ant.core, org.eclipse.core.variables, org.eclipse.core.expressions, DanisAddOns, org.eclipse.team.core, org.eclipse.compare.core, org.eclipse.team.cvs.core, org.eclipse.jsch.core, org.eclipse.ui, org.eclipse.ui.workbench, org.eclipse.help, org.eclipse.e4.core.services, org.eclipse.e4.ui.workbench.swt, org.eclipse.e4.ui.workbench, org.eclipse.e4.ui.model.workbench, org.eclipse.emf.ecore, org.eclipse.emf.common, org.eclipse.e4.emf.xpath, org.eclipse.e4.ui.services, org.eclipse.e4.ui.di, org.eclipse.e4.core.di.extensions, org.eclipse.e4.core.commands, org.eclipse.emf.ecore.change, org.eclipse.emf.ecore.xmi, org.eclipse.e4.ui.css.core, org.eclipse.e4.ui.css.swt, org.eclipse.e4.ui.bindings, org.eclipse.e4.ui.css.swt.theme, org.eclipse.e4.ui.workbench.addons.swt, org.eclipse.e4.ui.workbench.renderers.swt, org.eclipse.jdt.core, org.eclipse.jdt.compiler.tool, org.eclipse.jdt.compiler.apt, org.eclipse.jdt.ui, org.eclipse.search, org.eclipse.ui.ide, org.eclipse.ui.views, org.eclipse.jface.text, org.eclipse.ui.forms, org.eclipse.ui.workbench.texteditor, org.eclipse.ltk.core.refactoring, org.eclipse.ltk.ui.refactoring, org.eclipse.ui.navigator, org.eclipse.compare, org.eclipse.ui.editors, org.eclipse.team.ui, org.eclipse.debug.core, org.eclipse.debug.ui, org.eclipse.ui.console, org.eclipse.jdt.launching, org.eclipse.jdt.debug, org.eclipse.ui.navigator.resources, org.eclipse.ui.views.properties.tabbed, org.eclipse.jdt.core.manipulation, Eclipse ZRH ALL Tests, org.eclipse.core.expressions.tests, org.eclipse.core.filebuffers.tests, org.eclipse.jdt.text.tests, org.eclipse.text.tests, org.eclipse.jface.text.tests, org.eclipse.jdt.ui.tests, org.eclipse.jdt.junit, org.eclipse.jdt.debug.ui, org.eclipse.jdt.junit.core, org.eclipse.equinox.simpleconfigurator.manipulator, org.eclipse.equinox.frameworkadmin.equinox, org.eclipse.test.performance, org.eclipse.jdt.ui.tests.refactoring, org.eclipse.ltk.core.refactoring.tests, org.eclipse.ltk.ui.refactoring.tests, org.eclipse.search.tests, org.eclipse.ui.editors.tests, org.eclipse.ui.workbench.texteditor.tests, RegexTests, com.oti.zrh.eclipse.tools, org.apache.jasper.glassfish, org.eclipse.ant.launching, org.eclipse.core.externaltools, org.eclipse.ant.tests.core, org.eclipse.ant.tests.ui, org.eclipse.ui.externaltools, org.eclipse.ant.ui, org.eclipse.compare.tests, org.eclipse.core.tests.resources, org.eclipse.core.tests.harness, org.eclipse.pde.junit.runtime, org.eclipse.compare.win32, org.eclipse.core.tests.net, org.eclipse.core.tests.runtime, org.eclipse.debug.examples.core, org.eclipse.debug.examples.memory, org.eclipse.debug.examples.mixedmode, org.eclipse.debug.examples.ui, org.eclipse.debug.tests, org.eclipse.e4.core.tests, org.eclipse.e4.ui.bindings.tests, org.eclipse.e4.ui.dialogs, org.eclipse.e4.ui.tests, org.eclipse.e4.ui.tests.css.core, org.eclipse.e4.ui.tests.css.swt, org.eclipse.egit.core, org.eclipse.egit.ui, org.eclipse.equinox.console, org.eclipse.equinox.ds, org.eclipse.equinox.util, org.eclipse.equinox.event, org.eclipse.equinox.http.jetty, org.eclipse.equinox.http.servlet, org.eclipse.equinox.http.registry, org.eclipse.equinox.jsp.jasper, org.eclipse.equinox.jsp.jasper.registry, org.eclipse.equinox.p2.director.app, org.eclipse.equinox.p2.directorywatcher, org.eclipse.equinox.p2.publisher.eclipse, org.eclipse.equinox.p2.publisher, org.eclipse.equinox.p2.touchpoint.eclipse, org.eclipse.equinox.p2.garbagecollector, org.eclipse.equinox.p2.extensionlocation, org.eclipse.equinox.p2.repository.tools, org.eclipse.equinox.p2.ui, org.eclipse.equinox.security.ui, org.eclipse.equinox.p2.ui.importexport, org.eclipse.equinox.p2.updatesite, org.eclipse.help.base, org.eclipse.help.ui, org.eclipse.help.webapp, org.eclipse.jdt.apt.core, org.eclipse.jdt.apt.pluggable.core, org.eclipse.jdt.apt.ui, org.eclipse.jdt.astview, org.eclipse.jdt.compiler.apt.tests, org.eclipse.jdt.copyrightsaveaction, org.eclipse.jdt.core.tests.builder, org.eclipse.jdt.core.tests.compiler, org.eclipse.jdt.core.tests.model, org.eclipse.jdt.debug.jdi.tests, org.eclipse.jdt.debug.tests, org.eclipse.jdt.jeview, org.eclipse.jdt.ui.examples.javafamily, org.eclipse.jdt.ui.examples.projects, org.eclipse.jface.examples.databinding, org.eclipse.jface.tests.databinding, org.eclipse.jface.tests.databinding.conformance, org.eclipse.jsch.ui, org.eclipse.pde.api.tools, org.eclipse.pde.core, org.eclipse.pde.build, org.eclipse.pde.api.tools.generator, org.eclipse.pde.api.tools.tests, org.eclipse.pde.api.tools.ui, org.eclipse.pde.ui, org.eclipse.ui.intro, org.eclipse.ui.cheatsheets, org.eclipse.ui.views.log, org.eclipse.pde.launching, org.eclipse.ui.trace, org.eclipse.pde.build.tests, org.eclipse.pde.ds.annotations, org.eclipse.pde.ds.core, org.eclipse.pde.ds.tests, org.eclipse.pde.ds.ui, org.eclipse.pde.runtime, org.eclipse.pde.ua.core, org.eclipse.pde.ua.ui, org.eclipse.pde.ui.templates, org.eclipse.pde.ui.tests, org.eclipse.platform, org.eclipse.releng.tests, org.eclipse.releng.tools, org.eclipse.team.cvs.ui, org.eclipse.team.cvs.ssh2, org.eclipse.team.tests.core, org.eclipse.team.tests.cvs.core, org.eclipse.test, org.eclipse.ui.ide.application, org.eclipse.ua.tests, org.eclipse.ui.intro.universal, org.eclipse.ui.intro.quicklinks, org.eclipse.ui.browser, org.eclipse.ua.tests.doc, org.eclipse.ui.editors.bugzilla, org.eclipse.ui.examples.contributions, org.eclipse.ui.examples.fieldassist, org.eclipse.ui.examples.javaeditor, org.eclipse.ui.examples.job, org.eclipse.ui.examples.propertysheet, org.eclipse.ui.examples.rcp.texteditor, org.eclipse.ui.examples.readmetool, org.eclipse.ui.examples.recipeeditor, org.eclipse.ui.examples.views.properties.tabbed.article, org.eclipse.ui.genericeditor, org.eclipse.ui.genericeditor.tests, org.eclipse.ui.monitoring, org.eclipse.ui.net, org.eclipse.ui.tests, org.eclipse.ui.tests.harness, org.eclipse.ui.tests.navigator, org.eclipse.ui.tests.performance, org.eclipse.ui.tests.views.properties.tabbed, org.eclipse.ui.win32, org.mortbay.jetty.server}</thetext>
        <comment>
            <comment_id>2774464</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-08 23:38:20 -0500</when>
            <comment_text>AFAIK, the dependency is in an order that is listed down, at least in a simple cycle I tried out. But this case seems to be much more complicated.

The problem with the cycle is we don't know where to start and we instead list all the projects that are involved in the cycle.</comment_text>
        </comment>
        <comment>
            <comment_id>2774511</comment_id>
            <comment_count>2</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-09 03:40:10 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #1)
&gt; AFAIK, the dependency is in an order that is listed down, at least in a
&gt; simple cycle I tried out. But this case seems to be much more complicated.
&gt; 
&gt; The problem with the cycle is we don't know where to start and we instead
&gt; list all the projects that are involved in the cycle.

At some point you detect the cycle. That's where we could start to compute the cycle path.

The list is definitely not ordered because the last one 'org.mortbay.jetty.server' does not require the first one 'org.apache.felix.gogo.command'.


After looking closer, some PDE containers looked weird. I then restarted and did a clean + full build and the problem went away.


See also bug 37275.</comment_text>
        </comment>
        <comment>
            <comment_id>2786339</comment_id>
            <comment_count>3</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-12-14 12:22:33 -0500</when>
            <comment_text>Just ran into the same problem after importing the latest build.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507288</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-11-09 07:30:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Define what scope to use in presence of modules</short_desc>
        <thetext>The introduction of modules calls for new scopes in different parts of the Java tooling. At the moment, I am able to list down these:


Workspace scope:

  All known modules in the workspace, regardless of whether they are "required" by any source modules in the workspace. This should also include multiple modules with same name.

Module scope:
  Just the current module we are talking about, both in case of binary and source modules.

Extended module scope:

  Probably needs a better name. The scope includes this module and all modules that can be seen by this module (explicitly or implicitly).



These scopes will need to be applied case by case. For e.g., the following scenarios:

1. While completing packages in an export statement in module-info, the scope should be limited to "Module scope", but completions on module name in "requires" and "exports-to" should get the workspace scope. Similarly other features like search etc. should pick the right scope in presence of modules.</thetext>
    </bug>
    <bug>
        <id>507371</id>
        <developer>Chin Bim</developer>
        <developer_username>chin.bimbo</developer_username>
        <dup_id/>
        <creation_time>2016-11-10 14:15:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][inference] Cannot infer type argument(s) error</short_desc>
        <thetext>For this piece of code:

interface IB&lt;T&gt; {
}

interface IC&lt;T extends IB&lt;U&gt;, U&gt; {
    void onMessage(T obj);
}

class MyClass {
    &lt;T extends IB&lt;U&gt;, U&gt; void setValue(IC&lt;T, U&gt; event) {
    }
}

class Foo {
    public static void main(String args[]) {
        MyClass tmp = new MyClass();
        tmp.setValue((event) -&gt; {}); // error here
    }
}

I'm getting this error when using Eclipse Neon 4.6.1:

Cannot infer type argument(s) for &lt;T, U&gt; setValue(IC&lt;T,U&gt;)

but the same piece of code compiles fine using Eclipse 4.6.0 and Intellij IDEA 2016.2, or using javac.</thetext>
        <comment>
            <comment_id>2775221</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-10 15:06:57 -0500</when>
            <comment_text>Fails since 4.5M3

Accepted by javac 9 (ea), too.

Inference doesn't get any useful hints regarding T and U, so we should probably expect the following solution:
 U = Object
 T = IB&lt;Object&gt;</comment_text>
        </comment>
        <comment>
            <comment_id>2775226</comment_id>
            <comment_count>2</comment_count>
            <who>Chin Bim</who>
            <commenter_username>chin.bimbo</commenter_username>
            <when>2016-11-10 15:24:08 -0500</when>
            <comment_text>I don't know about 4.5M3 but it works on 4.6.0 (I only saw this error the first time after updated to 4.6.1).</comment_text>
        </comment>
        <comment>
            <comment_id>2775307</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-10 17:44:26 -0500</when>
            <comment_text>Right, 4.6.0 accepts this, but since the fix for bug 496574, we report an error. That doesn't, however, mean that the fix for bug 496574 is to blame. This fix only exposes an inference failure, that previously was silently swallowed for no good reason.

4.5 M3 was the point in time, when bug 437444 introduced this "swallowing". This indicates that our inference probably never succeeded for this example.

Next we need to figure out *why* inference fails.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507629</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-11-16 13:41:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Implement new definite assignment rules for lambdas</short_desc>
        <thetext>See https://bugs.openjdk.java.net/browse/JDK-8043176

Spec for definite assignment did not properly handle lambdas which has been fixed for Java 9.</thetext>
    </bug>
    <bug>
        <id>507647</id>
        <developer>Mickael Istria - away until ...</developer>
        <developer_username>mistria</developer_username>
        <dup_id/>
        <creation_time>2016-11-17 02:35:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>An INFO or WARNING for non-specialized default methods</short_desc>
        <thetext>As default methods are not meant to be actually part of the logic, but are mostly there to allow interfaces to evolve in a backward-compatible way, it would make sense to report absence of implementation for default methods as a WARNING or an INFO.
As a designer of an interface, even if a method is made "default", I expect implementations to implement it.</thetext>
        <comment>
            <comment_id>2776844</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-11-17 02:49:07 -0500</when>
            <comment_text>Moving to JDT Core for consideration.</comment_text>
        </comment>
        <comment>
            <comment_id>2777293</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-17 22:54:02 -0500</when>
            <comment_text>There are quite a few default methods added in the Java platform classes that people are not really expected to override. IMO, we want them to be reported, if we decide to do, as INFO by default.</comment_text>
        </comment>
        <comment>
            <comment_id>2777336</comment_id>
            <comment_count>3</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-18 03:41:49 -0500</when>
            <comment_text>(In reply to comment #0)
&gt; As a designer of an interface, even if a method is made "default", I expect
&gt; implementations to implement it.
I would make a method default only if I expect all clients to have the same implementation and only few to override it with reason. That said, I agree that it would be good to report this in the interest of clients that would want to override the default behavior</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507832</id>
        <developer>Ed Willink</developer>
        <developer_username>ed</developer_username>
        <dup_id/>
        <creation_time>2016-11-20 11:43:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>unjustified IndexOutOfBoundsException In Scanner</short_desc>
        <thetext>org.eclipse.jdt.internal.compiler.parser.Scanner line 1695 is

// this avoids duplicating the code in the catch(IndexOutOfBoundsException e)

The comment explains why normal scanning throws IOBE.

Given that the duplicated save is about 10 lines, this VERY bad practice seems totally unjustified.

a) it incurs a performance penalty through throwing an exception on a non-exception code path - bad Java coding practice.

b) it irritates / confuses users by infecting user debugging sessions with spurious JDT non-errors - bad Eclipse citizen.</thetext>
    </bug>
    <bug>
        <id>507872</id>
        <developer>Marvin  Fröhlich</developer>
        <developer_username>qudus</developer_username>
        <dup_id/>
        <creation_time>2016-11-21 06:39:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[Errors and Warnings] @Override in anonymous interface implementation</short_desc>
        <thetext>There should be another exception to the "Missing @Override annotation" rule for anonymous implementations like this.

##################################################
btn.addActionListener( new ActionListener()
{
    public void actionPerformed( ActionEvent e )
    {
    }
} );
##################################################

If I set this rule to 'Warning' (and also include interfaces') the code above would produce a warning. Anonymous inline implementations get pretty bloated with the @Override line(s).

I know, in the above case I could use lambda. But I can't, if there are two methods to be implemented.</thetext>
    </bug>
    <bug>
        <id>507920</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-11-21 18:38:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9][model] Java Model Exception while code completion</short_desc>
        <thetext>Created attachment 265500
Projects to reproduce the scenario

To reproduce:

- Import the projects in the attached zip
- open to module-info.java in the first project
- after provide pack11 put a . and the JME will be thrown

Java Model Exception: Java Model Status [first [in [Working copy] module-info.java [in &lt;default&gt; [in src [in first]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:591)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:317)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:303)
	at org.eclipse.jdt.internal.core.NameLookup.getModuleDescriptionInfo(NameLookup.java:824)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.getModule(SearchableEnvironment.java:779)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getModule(LookupEnvironment.java:164)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.buildType(ClassScope.java:428)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.buildTypeBindings(CompilationUnitScope.java:179)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.buildTypeBindings(LookupEnvironment.java:280)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:2120)
	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:131)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:362)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:350)
	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.internalComputeCompletionProposals(JavaCompletionProposalComputer.java:250)
	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.computeCompletionProposals(JavaCompletionProposalComputer.java:212)
	at org.eclipse.jdt.internal.ui.text.java.JavaTypeCompletionProposalComputer.computeCompletionProposals(JavaTypeCompletionProposalComputer.java:63)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:337)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:331)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:288)</thetext>
        <comment>
            <comment_id>2778486</comment_id>
            <comment_count>1</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-22 04:23:49 -0500</when>
            <comment_text>This happens because the module declaration became a working copy, recovery somehow does not yield a module declaration when there are parse errors, so in effect we end up not finding the ModuleDescriptionInfo for the SourceModule. We have to somehow use the old module descriptor till the new one can be parsed or steer recovery so that it will lead to a module declaration to avoid running into this</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508306</id>
        <developer>Jean-Marie HENAFF</developer>
        <developer_username>jmhenaff</developer_username>
        <dup_id/>
        <creation_time>2016-11-28 10:26:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Indirectly referenced class file error if generic super type in library references a type absent from classpath</short_desc>
        <thetext>Created attachment 265613
Sample eclipse project

I've attached a sample project to reproduce the issue.

Basically, Test&lt;T&gt; inherits from LibType&lt;T&gt;.
Test belongs to the source files to compile.
LibType is in a library on classpath, but references TypeMissingFromClasspath, which is not the classpath when Test is compiled.

Things that seem to trigger the bug:
- LibType has to be generic
- Test must define a constructor with a parameter

Reproduced with ecj 4.7M3.

Compiles with javac.</thetext>
        <comment>
            <comment_id>2780756</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-28 15:35:52 -0500</when>
            <comment_text>Essentially, no guarantees are made that compilation with an incomplete classpath will succeed. A typical scenario is overload resolution, where all compilers need even types that are not referenced in any way by the current source file.

I agree, however, that in this particular example it would be *nice* if ecj avoids touching TypeMissingFromClasspath.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508375</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-11-29 09:01:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>intermittent failures in CompletionTests2.testBug151500a()</short_desc>
        <thetext>Debugging CompletionTests2 I observed:

- testBug151500a() may fail when running the full test class
- it doesn't fail when run in isolation
- it doesn't fail when stepping through CompletionEngine.findMethods(..)
- when it succeeds, the currentType representation of j.l.Object is a MissingTypeBinding

Symptom of failure: unexpected methods from Object are proposed -- as sub-word proposals I assume, since none of the methods is a prefix match for the selector prefix "s":

equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), 30}\n
getClass[METHOD_REF]{getClass(), Ljava.lang.Object;, ()Ljava.lang.Class;, getClass, null, 30}\n
hashCode[METHOD_REF]{hashCode(), Ljava.lang.Object;, ()I, hashCode, null, 30}\n
toString[METHOD_REF]{toString(), Ljava.lang.Object;, ()Ljava.lang.String;, toString, null, 30}\n

Things to investigate: 
- is JCL_LIB15 resolved?
  - is this resolving affected by concurrency or other non-deterministic stuff?
- are subword proposals expected in this context?

Similar for testBug281598c() in the same class.</thetext>
        <comment>
            <comment_id>2781123</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-29 12:20:44 -0500</when>
            <comment_text>To add some weirdness: testBug151500a() uses an inconsistent combo of JCL_LIB15 and compliance of "1.4". That would perhaps explain, why j.l.Object is not found (thus letting the test pass). OTOH, testBug281598c() looks consistent with JCL_LIB and implicit "1.4".</comment_text>
        </comment>
        <comment>
            <comment_id>2781133</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-29 12:50:24 -0500</when>
            <comment_text>The test _could_ easily be fixed by putting this into some suitable location:

  javaProject.setOption(AssistOptions.OPTION_SubstringMatch, AssistOptions.DISABLED)

But I'm uncomfortable with that, given the tests actually pass in production builds plus the fact that s.o. accidentally makes "use" of a broken configuration with no JCL_LIB available on the classpath.

Are others seeing the failures as well, or is there s.o. spooky on my machine? Perhaps an IDE-only issue?</comment_text>
        </comment>
        <comment>
            <comment_id>2781706</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-01 01:24:32 -0500</when>
            <comment_text>I just tried on my machine and happens here as well.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508561</id>
        <developer>Ryan Gustafson</developer>
        <developer_username>ryan.gustafson</developer_username>
        <dup_id/>
        <creation_time>2016-12-01 15:38:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Formatter missing space between method type parameters and return type</short_desc>
        <thetext>The formatter misses a space between method type parameters and the return type, when the method type parameters provide type arguments.  For example:

interface Foo {
	&lt;T&gt; void bar(); // Ok
	&lt;T extends Enum&lt;T&gt;&gt;void baz(); // Missing space
}

This is with 4.6.1 (Neon.1a).</thetext>
        <comment>
            <comment_id>2782706</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-05 00:57:17 -0500</when>
            <comment_text>I believe this was fixed recently but can't dig out the bug number.

Mateusz, do you recall the bug report for that?

Ryan, if you can grab a recent build from 4.7 stream, you can see it working as expected.</comment_text>
        </comment>
        <comment>
            <comment_id>2785046</comment_id>
            <comment_count>2</comment_count>
            <who>Ryan Gustafson</who>
            <commenter_username>ryan.gustafson</commenter_username>
            <when>2016-12-09 14:14:43 -0500</when>
            <comment_text>I pulled down the Oxygen M3 build and the above example formats as desired.</comment_text>
        </comment>
        <comment>
            <comment_id>2785278</comment_id>
            <comment_count>3</comment_count>
            <who>Mateusz Matela</who>
            <commenter_username>mateusz.matela</commenter_username>
            <when>2016-12-11 16:40:45 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #1)
&gt; Mateusz, do you recall the bug report for that?

I don't recall fixing a bug like that.
Also, I can't reproduce it with default settings in any version of Eclipse I tried. Ryan, did the problem occur only for a specific formatter profile? Could you share it?</comment_text>
        </comment>
        <comment>
            <comment_id>2785585</comment_id>
            <comment_count>4</comment_count>
            <who>Ryan Gustafson</who>
            <commenter_username>ryan.gustafson</commenter_username>
            <when>2016-12-12 13:38:36 -0500</when>
            <comment_text>I tried using our formatter settings in stock 4.6 and 4.7 M3 installs an it's not happening.  I'll do more testing to see if I can isolate it further, we have numerous plugins installed.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508586</id>
        <developer>Sergey Toshin</developer>
        <developer_username>stoshins</developer_username>
        <dup_id/>
        <creation_time>2016-12-02 04:34:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>StringLiteral.getLiteralValue() throws IllegalArgumentException when called in multiple threads</short_desc>
        <thetext>Created attachment 265697
Line 54, "com.android.browser.BrowserActivity"

This is a really weird bug. I attached the source where it happens (on line 54, "com.android.browser.BrowserActivity"). Exception is thrown only in case when I use my code which doesn't modify ast, but just call getLiteralValue() (in wrong moment?), I wasn't able to reproduce it by making compilation unit of the file and calling getLiteralValue() for each StringLiteral (via ASTVisitor). The bug doesn't occur if I use debugger to catch the moment of "throw" to give you more details. I've observed that if I hit breakpoints for all 

throw new InvalidInputException(smth);

in class org.eclipse.jdt.internal.compiler.parser.Scanner because

	public String getLiteralValue() {
		String s = getEscapedValue();
		int len = s.length();
		if (len &lt; 2 || s.charAt(0) != '\"' || s.charAt(len-1) != '\"' ) {
			throw new IllegalArgumentException();
		}

		Scanner scanner = this.ast.scanner;
		char[] source = s.toCharArray();
		scanner.setSource(source);
		scanner.resetTo(0, source.length);
		try {
			int tokenType = scanner.getNextToken(); // exception is thrown somewhere here

exception is not thrown and code finishes fine. But if breakpoints are missing, it always throws IllegalArgumentException</thetext>
        <comment>
            <comment_id>2782235</comment_id>
            <comment_count>1</comment_count>
            <who>Sergey Toshin</who>
            <commenter_username>stoshins</commenter_username>
            <when>2016-12-02 04:45:37 -0500</when>
            <comment_text>Probably the source is looking like fine, and the details are not enough. Please tell me what else I can provide</comment_text>
        </comment>
        <comment>
            <comment_id>2782329</comment_id>
            <comment_count>2</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-02 09:33:25 -0500</when>
            <comment_text>This is typically the type of problem that cannot be solved without being able to debug the problem directly­. So unless you can provide a reproducable test case, I doubt there is much we can do to help.</comment_text>
        </comment>
        <comment>
            <comment_id>2786322</comment_id>
            <comment_count>3</comment_count>
            <who>Sergey Toshin</who>
            <commenter_username>stoshins</commenter_username>
            <when>2016-12-14 11:29:05 -0500</when>
            <comment_text>Hi. I figured out, it can be reproduced pretty easy

Just call in multiple threads 
sl.getLiteralValue(); // StringLiteral sl
for any string literal

Let me know if you were not able to reproduce this, and I will attach my sources

I receive the exception sent previously or this one:

java.lang.StringIndexOutOfBoundsException: String index out of range: -1
	at java.lang.String.&lt;init&gt;(Unknown Source)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getCurrentStringLiteral(Scanner.java:534)
	at org.eclipse.jdt.core.dom.StringLiteral.getLiteralValue(StringLiteral.java:238)</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508861</id>
        <developer>Patrick Tasse</developer>
        <developer_username>patrick.tasse</developer_username>
        <dup_id/>
        <creation_time>2016-12-07 17:11:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>ArrayIndexOutOfBoundsException in DiskIndex</short_desc>
        <thetext>Occurs regularly, latest with build I20161204-2000

Happens when typing the second character in Open Type dialog (Ctrl+Shift+T).

java.lang.ArrayIndexOutOfBoundsException: 515
	at org.eclipse.jdt.internal.core.index.DiskIndex.readStreamChars(DiskIndex.java:927)
	at org.eclipse.jdt.internal.core.index.DiskIndex.readChunk(DiskIndex.java:738)
	at org.eclipse.jdt.internal.core.index.DiskIndex.readDocumentName(DiskIndex.java:783)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResult(DiskIndex.java:153)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:222)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:140)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:310)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2333)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:280)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:104)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:65)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:262)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1816)
	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1132)
	at org.eclipse.jdt.internal.ui.dialogs.FilteredTypesSelectionDialog.fillContentProvider(FilteredTypesSelectionDialog.java:519)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog$FilterJob.filterContent(FilteredItemsSelectionDialog.java:2098)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog$FilterJob.internalRun(FilteredItemsSelectionDialog.java:2046)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog$FilterJob.doRun(FilteredItemsSelectionDialog.java:2018)
	at org.eclipse.ui.dialogs.FilteredItemsSelectionDialog$FilterJob.run(FilteredItemsSelectionDialog.java:2005)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:56)</thetext>
    </bug>
    <bug>
        <id>508865</id>
        <developer>Matthew DOnofrio</developer>
        <developer_username>artist</developer_username>
        <dup_id/>
        <creation_time>2016-12-07 21:01:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Code completion breaks following a lambda which contains a do-while loop</short_desc>
        <thetext>Attempting to perform code completion provides "No Default Proposals".

Example:

import java.util.concurrent.CompletableFuture;

public class Test {
public static void main(
   String[] args)
{
   CompletableFuture&lt;Boolean&gt; f = CompletableFuture.supplyAsync(() -&gt; {
      do {
      }
      while (false);
      
      return true;
   });
   
   f. // Cannot code complete here
}
}</thetext>
    </bug>
    <bug>
        <id>508889</id>
        <developer>Sasikanth Bharadwaj</developer>
        <developer_username>sasikanth.bharadwaj</developer_username>
        <dup_id/>
        <creation_time>2016-12-08 05:25:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Support Module attribute in Disassembler</short_desc>
        <thetext>We need to support the module attribute in Disassembler as well.
I started work on this sometime ago, mainly to add testcases for code gen, but stopped midway. It might be a good idea to wait for JVM specification before we add this support anyway</thetext>
        <comment>
            <comment_id>2784294</comment_id>
            <comment_count>1</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-12-08 08:13:44 -0500</when>
            <comment_text>(In reply to Sasikanth Bharadwaj from comment #0)
&gt; It might be a good idea to wait for JVM specification
&gt; before we add this support anyway

http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html#jigsaw-2.2 looks pretty complete to me (version from 2016/10/28). Would you need anything else from the VM spec?</comment_text>
        </comment>
        <comment>
            <comment_id>2784334</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-08 09:07:39 -0500</when>
            <comment_text>(In reply to Markus Keller from comment #1)
&gt; (In reply to Sasikanth Bharadwaj from comment #0)
&gt; &gt; It might be a good idea to wait for JVM specification
&gt; &gt; before we add this support anyway
&gt; 
&gt; http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html#jigsaw-2.2 looks
&gt; pretty complete to me (version from 2016/10/28). Would you need anything
&gt; else from the VM spec?

Nope, we do have the details we need. But considering that there have been changes in this area as recently as last month, unless someone really wants this, we will keep it in the back burner.</comment_text>
        </comment>
        <comment>
            <comment_id>2784424</comment_id>
            <comment_count>3</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-08 10:22:43 -0500</when>
            <comment_text>Jay, I can take a look at this if you want. Let me know what the ETA is.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508955</id>
        <developer>Frank Benoit</developer>
        <developer_username>frank.rene.benoit</developer_username>
        <dup_id/>
        <creation_time>2016-12-09 00:56:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Null safety warning cannot be avoided. Collectors.joining</short_desc>
        <thetext>This was first described here: https://www.eclipse.org/forums/index.php/t/1082996/

Example code:
@NonNullByDefault
public class Example {
	public String func(List&lt;String&gt; list){
		return list.stream().collect(Collectors.joining(","));
	}
}


I get these warnings:
Null type safety (type annotations): The expression of type 'Collector&lt;CharSequence,capture#of ?,String&gt;' needs unchecked conversion to conform to 'Collector&lt;? super @NonNull String,capture#of ?,@NonNull String&gt;'


I use this annotation:
class java/util/stream/Collectors
joining
 (Ljava/lang/CharSequence;)Ljava/util/stream/Collector&lt;Ljava/lang/CharSequence;*Ljava/lang/String;&gt;;
 (Ljava/lang/CharSequence;)L1java/util/stream/Collector&lt;L1java/lang/CharSequence;*1L1java/lang/String;&gt;;</thetext>
    </bug>
    <bug>
        <id>508980</id>
        <developer>Ulrich Hobelmann</developer>
        <developer_username>ulrich.hobelmann</developer_username>
        <dup_id/>
        <creation_time>2016-12-09 07:29:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Error opening zip file in JDT</short_desc>
        <thetext>Happens constantly when I hover a class or during certain code completion triggers. Extremely annoying, as the error view keeps popping up.

I tried deleting the whole versions in my maven repo, but the error still occurs. The jars also look fine, but it's also hard to say if I'm looking at the right jar. It might be some other file it's stumbling over, as it doesn't say which one it's trying to read.

What steps will reproduce the problem?
1. Hover over a class from the JIRA api. (like jira-api-7.0.5.jar)


-- Error Details --
Date: Fri Dec 09 13:24:15 CET 2016
Message: Internal Error
Severity: Error
Product: Eclipse 4.6.1.20161007-1200 (org.eclipse.epp.package.java.product)
Plugin: org.eclipse.jdt.ui
Exception Stack Trace:
Java Model Exception: java.util.zip.ZipException: error in opening zip file
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:928)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1039)
	at org.eclipse.jdt.internal.core.BinaryType.getAttachedJavadoc(BinaryType.java:997)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:538)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:717)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:635)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:627)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)
Caused by: java.util.zip.ZipException: error in opening zip file
	at java.util.zip.ZipFile.open(Native Method)
	at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:219)
	at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:149)
	at java.util.jar.JarFile.&lt;init&gt;(JarFile.java:166)
	at java.util.jar.JarFile.&lt;init&gt;(JarFile.java:103)
	at sun.net.www.protocol.jar.URLJarFile.&lt;init&gt;(URLJarFile.java:93)
	at sun.net.www.protocol.jar.URLJarFile.getJarFile(URLJarFile.java:69)
	at sun.net.www.protocol.jar.JarFileFactory.get(JarFileFactory.java:99)
	at sun.net.www.protocol.jar.JarURLConnection.connect(JarURLConnection.java:122)
	at sun.net.www.protocol.jar.JarURLConnection.getInputStream(JarURLConnection.java:150)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:862)
	... 10 more
Caused by: java.util.zip.ZipException: error in opening zip file
	at java.util.zip.ZipFile.open(Native Method)
	at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:219)
	at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:149)
	at java.util.jar.JarFile.&lt;init&gt;(JarFile.java:166)
	at java.util.jar.JarFile.&lt;init&gt;(JarFile.java:103)
	at sun.net.www.protocol.jar.URLJarFile.&lt;init&gt;(URLJarFile.java:93)
	at sun.net.www.protocol.jar.URLJarFile.getJarFile(URLJarFile.java:69)
	at sun.net.www.protocol.jar.JarFileFactory.get(JarFileFactory.java:99)
	at sun.net.www.protocol.jar.JarURLConnection.connect(JarURLConnection.java:122)
	at sun.net.www.protocol.jar.JarURLConnection.getInputStream(JarURLConnection.java:150)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:862)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1039)
	at org.eclipse.jdt.internal.core.BinaryType.getAttachedJavadoc(BinaryType.java:997)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:538)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:717)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:635)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:627)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)


-- Error Details --
Date: Fri Dec 09 13:24:15 CET 2016
Message: error in opening zip file
Severity: Error
Product: Eclipse 4.6.1.20161007-1200 (org.eclipse.epp.package.java.product)
Plugin: org.eclipse.jdt.core
Exception Stack Trace:
java.util.zip.ZipException: error in opening zip file
	at java.util.zip.ZipFile.open(Native Method)
	at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:219)
	at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:149)
	at java.util.jar.JarFile.&lt;init&gt;(JarFile.java:166)
	at java.util.jar.JarFile.&lt;init&gt;(JarFile.java:103)
	at sun.net.www.protocol.jar.URLJarFile.&lt;init&gt;(URLJarFile.java:93)
	at sun.net.www.protocol.jar.URLJarFile.getJarFile(URLJarFile.java:69)
	at sun.net.www.protocol.jar.JarFileFactory.get(JarFileFactory.java:99)
	at sun.net.www.protocol.jar.JarURLConnection.connect(JarURLConnection.java:122)
	at sun.net.www.protocol.jar.JarURLConnection.getInputStream(JarURLConnection.java:150)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:862)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1039)
	at org.eclipse.jdt.internal.core.BinaryType.getAttachedJavadoc(BinaryType.java:997)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:538)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:717)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:635)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:627)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)</thetext>
        <comment>
            <comment_id>2785133</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-10 09:47:52 -0500</when>
            <comment_text>This exception definitely lacks relevant information.

URLConnection.getInputStream() doesn't seem to provide this information when somewhere inside a ZipException is thrown.

JavaElement.getURLContents() is in a good position to fill in this information (e.g., inside an addition specific "catch (ZipException e)"), but I'm not 100% sure which is the best strategy for combining the exception + additional message parts into a JavaModelStatus or JavaModelException. Perhaps the catch block from MalformedURLException gives a good example:
   throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.CANNOT_RETRIEVE_ATTACHED_JAVADOC, this))

Maybe, this form should be preferred for several of the caught-wrapped-rethrown exceptions?

@Jay, @Manoj, what's your say?</comment_text>
        </comment>
        <comment>
            <comment_id>2785386</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-12 05:25:23 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #1)
&gt; JavaElement.getURLContents() is in a good position to fill in this
&gt; information (e.g., inside an addition specific "catch (ZipException e)"),
&gt; but I'm not 100% sure which is the best strategy for combining the exception
&gt; + additional message parts into a JavaModelStatus or JavaModelException.
&gt; Perhaps the catch block from MalformedURLException gives a good example:
&gt;    throw new JavaModelException(new
&gt; JavaModelStatus(IJavaModelStatusConstants.CANNOT_RETRIEVE_ATTACHED_JAVADOC,
&gt; this))

Not sure I understand your point. This example only captures the current element and not the URL we are trying to open.</comment_text>
        </comment>
        <comment>
            <comment_id>2785518</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-12 10:17:04 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #2)
&gt; (In reply to Stephan Herrmann from comment #1)
&gt; &gt; JavaElement.getURLContents() is in a good position to fill in this
&gt; &gt; information (e.g., inside an addition specific "catch (ZipException e)"),
&gt; &gt; but I'm not 100% sure which is the best strategy for combining the exception
&gt; &gt; + additional message parts into a JavaModelStatus or JavaModelException.
&gt; &gt; Perhaps the catch block from MalformedURLException gives a good example:
&gt; &gt;    throw new JavaModelException(new
&gt; &gt; JavaModelStatus(IJavaModelStatusConstants.CANNOT_RETRIEVE_ATTACHED_JAVADOC,
&gt; &gt; this))
&gt; 
&gt; Not sure I understand your point. This example only captures the current
&gt; element and not the URL we are trying to open.

Your're right, but that would already be way better than what we have today: no information at all :-/

OTOH, does JavaModelStatus support custom exception details?</comment_text>
        </comment>
        <comment>
            <comment_id>2785733</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-13 04:03:52 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #3)
&gt; Your're right, but that would already be way better than what we have today:
&gt; no information at all :-/
&gt; 
&gt; OTOH, does JavaModelStatus support custom exception details?

I see that creating a JMException with an exception does propagate the exception to the newly created JavaModelStatus. Clients are free to make use of it via 

org.eclipse.core.runtime.Status.getException().

That is what the currently effective catch block is doing, but clearly we are not getting the right message in the log.</comment_text>
        </comment>
        <comment>
            <comment_id>2785738</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-13 04:11:17 -0500</when>
            <comment_text>For the records, a similar issue was reported in apt (bug 474770).

If the ZipException doesn't contain the troublesome file name, perhaps we can simply log the error before creating the JME?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>509029</id>
        <developer>Gunnar Wagenknecht</developer>
        <developer_username>gunnar</developer_username>
        <dup_id/>
        <creation_time>2016-12-10 17:56:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>ConcurrentModificationException in JavaModelManager</short_desc>
        <thetext>Neon.2 RC4, happens during startup

There are quite a few plug-ins involved here but it looks like it's something in the workspace triggering this.


Java Model Exception: java.util.ConcurrentModificationException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:185)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:119)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:136)
	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:95)
	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:420)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:174)
Caused by: java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1437)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1471)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1469)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2860)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getMavenClasspath(PDEClasspathContributor.java:129)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getEntriesForDependency(PDEClasspathContributor.java:89)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addPlugin(RequiredPluginsClasspathContainer.java:278)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addHostPlugin(RequiredPluginsClasspathContainer.java:321)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.computePluginEntries(RequiredPluginsClasspathContainer.java:112)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.getClasspathEntries(RequiredPluginsClasspathContainer.java:76)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2699)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2869)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getMavenClasspath(PDEClasspathContributor.java:129)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getEntriesForDependency(PDEClasspathContributor.java:89)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addPlugin(RequiredPluginsClasspathContainer.java:278)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addDependencyViaImportPackage(RequiredPluginsClasspathContainer.java:219)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.computePluginEntries(RequiredPluginsClasspathContainer.java:147)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.getClasspathEntries(RequiredPluginsClasspathContainer.java:76)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2699)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2869)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getMavenClasspath(PDEClasspathContributor.java:129)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getEntriesForDependency(PDEClasspathContributor.java:89)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addPlugin(RequiredPluginsClasspathContainer.java:278)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addDependencyViaImportPackage(RequiredPluginsClasspathContainer.java:219)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.computePluginEntries(RequiredPluginsClasspathContainer.java:147)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.getClasspathEntries(RequiredPluginsClasspathContainer.java:76)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2699)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2869)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getMavenClasspath(PDEClasspathContributor.java:129)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getEntriesForDependency(PDEClasspathContributor.java:89)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addPlugin(RequiredPluginsClasspathContainer.java:278)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addDependencyViaImportPackage(RequiredPluginsClasspathContainer.java:219)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.computePluginEntries(RequiredPluginsClasspathContainer.java:147)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.getClasspathEntries(RequiredPluginsClasspathContainer.java:76)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2699)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2869)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getMavenClasspath(PDEClasspathContributor.java:129)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getEntriesForDependency(PDEClasspathContributor.java:89)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addPlugin(RequiredPluginsClasspathContainer.java:278)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addDependencyViaImportPackage(RequiredPluginsClasspathContainer.java:219)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addHostPlugin(RequiredPluginsClasspathContainer.java:332)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.computePluginEntries(RequiredPluginsClasspathContainer.java:112)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.getClasspathEntries(RequiredPluginsClasspathContainer.java:76)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2699)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2869)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getMavenClasspath(PDEClasspathContributor.java:129)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getEntriesForDependency(PDEClasspathContributor.java:89)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addPlugin(RequiredPluginsClasspathContainer.java:278)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addDependencyViaImportPackage(RequiredPluginsClasspathContainer.java:219)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.computePluginEntries(RequiredPluginsClasspathContainer.java:147)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.getClasspathEntries(RequiredPluginsClasspathContainer.java:76)
	at org.eclipse.jdt.internal.core.JavaModelManager.containerPutIfInitializingWithSameEntries(JavaModelManager.java:742)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:49)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1973)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2693)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.JavaProject.buildStructure(JavaProject.java:464)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:316)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:302)
	at org.eclipse.jdt.internal.core.JavaProject.getJavaProjectElementInfo(JavaProject.java:1642)
	at org.eclipse.jdt.internal.core.JavaProject.newNameLookup(JavaProject.java:2329)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.&lt;init&gt;(SearchableEnvironment.java:61)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.&lt;init&gt;(SearchableEnvironment.java:68)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.&lt;init&gt;(CancelableNameEnvironment.java:26)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:178)
	... 17 more
Caused by: java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1437)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1471)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1469)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2860)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getMavenClasspath(PDEClasspathContributor.java:129)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getEntriesForDependency(PDEClasspathContributor.java:89)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addPlugin(RequiredPluginsClasspathContainer.java:278)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addHostPlugin(RequiredPluginsClasspathContainer.java:321)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.computePluginEntries(RequiredPluginsClasspathContainer.java:112)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.getClasspathEntries(RequiredPluginsClasspathContainer.java:76)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2699)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2869)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getMavenClasspath(PDEClasspathContributor.java:129)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getEntriesForDependency(PDEClasspathContributor.java:89)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addPlugin(RequiredPluginsClasspathContainer.java:278)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addDependencyViaImportPackage(RequiredPluginsClasspathContainer.java:219)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.computePluginEntries(RequiredPluginsClasspathContainer.java:147)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.getClasspathEntries(RequiredPluginsClasspathContainer.java:76)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2699)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2869)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getMavenClasspath(PDEClasspathContributor.java:129)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getEntriesForDependency(PDEClasspathContributor.java:89)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addPlugin(RequiredPluginsClasspathContainer.java:278)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addDependencyViaImportPackage(RequiredPluginsClasspathContainer.java:219)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.computePluginEntries(RequiredPluginsClasspathContainer.java:147)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.getClasspathEntries(RequiredPluginsClasspathContainer.java:76)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2699)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2869)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getMavenClasspath(PDEClasspathContributor.java:129)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getEntriesForDependency(PDEClasspathContributor.java:89)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addPlugin(RequiredPluginsClasspathContainer.java:278)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addDependencyViaImportPackage(RequiredPluginsClasspathContainer.java:219)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.computePluginEntries(RequiredPluginsClasspathContainer.java:147)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.getClasspathEntries(RequiredPluginsClasspathContainer.java:76)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2699)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2869)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getMavenClasspath(PDEClasspathContributor.java:129)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getEntriesForDependency(PDEClasspathContributor.java:89)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addPlugin(RequiredPluginsClasspathContainer.java:278)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addDependencyViaImportPackage(RequiredPluginsClasspathContainer.java:219)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addHostPlugin(RequiredPluginsClasspathContainer.java:332)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.computePluginEntries(RequiredPluginsClasspathContainer.java:112)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.getClasspathEntries(RequiredPluginsClasspathContainer.java:76)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2699)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:47)
	at org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:110)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager$10.run(JavaModelManager.java:2869)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2885)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1965)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getMavenClasspath(PDEClasspathContributor.java:129)
	at org.sonatype.tycho.m2e.internal.PDEClasspathContributor.getEntriesForDependency(PDEClasspathContributor.java:89)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addPlugin(RequiredPluginsClasspathContainer.java:278)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.addDependencyViaImportPackage(RequiredPluginsClasspathContainer.java:219)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.computePluginEntries(RequiredPluginsClasspathContainer.java:147)
	at org.eclipse.pde.internal.core.RequiredPluginsClasspathContainer.getClasspathEntries(RequiredPluginsClasspathContainer.java:76)
	at org.eclipse.jdt.internal.core.JavaModelManager.containerPutIfInitializingWithSameEntries(JavaModelManager.java:742)
	at org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:49)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1973)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3424)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2693)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.JavaProject.buildStructure(JavaProject.java:464)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:316)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:302)
	at org.eclipse.jdt.internal.core.JavaProject.getJavaProjectElementInfo(JavaProject.java:1642)
	at org.eclipse.jdt.internal.core.JavaProject.newNameLookup(JavaProject.java:2329)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.&lt;init&gt;(SearchableEnvironment.java:61)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.&lt;init&gt;(SearchableEnvironment.java:68)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.&lt;init&gt;(CancelableNameEnvironment.java:26)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:178)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:185)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:119)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:136)
	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:95)
	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:420)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:174)</thetext>
    </bug>
    <bug>
        <id>509165</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-12-13 11:07:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>CCE in Parser.consumeMethodHeaderRightParen(..) in CompilationUnit.codeSelect(..)</short_desc>
        <thetext>(same snippet as in bug 483307)

Hover over one of the two references to Integer in the signature of the compare method:

public class LambdaAnonymousTest {
    public static void main(String[] args) {
        Executors.callable(() -&gt; {
            Collections.sort(
                    Arrays.asList(1, 2, 4, 3),
                    new Comparator&lt;Integer&gt;() {
                        @Override
                        public int compare(Integer a, Integer b) { // &lt;- Integer
                            return a - b;
                        }
                    });
        });
    }
}

eclipse.buildId=4.7.0.I20161213-0600
java.version=1.8.0_102
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -showlocation
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -consolelog -console -showlocation -data a

org.eclipse.jface.text
Error
Tue Dec 13 17:02:44 CET 2016
Unexpected runtime error while computing a text hover

java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.ast.TypeDeclaration cannot be cast to org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeMethodHeaderRightParen(Parser.java:5241)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6366)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.parseBlockStatements(AssistParser.java:1713)
	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.parseBlockStatements(AssistParser.java:1551)
	at org.eclipse.jdt.internal.codeassist.impl.Engine.parseBlockStatements(Engine.java:340)
	at org.eclipse.jdt.internal.codeassist.impl.Engine.parseBlockStatements(Engine.java:303)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1032)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:163)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:377)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:371)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:121)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:633)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:629)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)</thetext>
    </bug>
    <bug>
        <id>509169</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-12-13 11:46:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][search] Search for references returns bad element for anonymous inside lambda expression</short_desc>
        <thetext>(snippet expanded from bug 483307)

In the snippet below, search for references to the diff(..) method (or open a call hierarchy). The match in aaa() is a compare method in an anonymous type that both don't exist.

If you move all the method bodies of aaa(), bbb(), and ccc() into one method body, then all three results are IMethods that don't exist, and the parents of the other matches are the wrong types.

package xy;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.concurrent.Executors;

public class LambdaAnonymousTest2 {
    public void aaa() {
        Executors.callable(() -&gt; {
            Collections.sort(
                    getInput(),
                    new Comparator&lt;Integer&gt;() {
                        @Override
                        public int compare(Integer a, Integer b) {
                            return diff(a, b);
                        }
                    });
        });
    }

    public void bbb() {
        Executors.callable(new Runnable() {
            @Override
            public void run() {
                Collections.sort(
                        getInput(),
                        new Comparator&lt;Integer&gt;() {
                            @Override
                            public int compare(Integer a, Integer b) {
                                return diff(a, b);
                            }
                        });
            }
        });
    }

    public void ccc() {
        Collections.sort(
                getInput(),
                new Comparator&lt;Integer&gt;() {
                    @Override
                    public int compare(Integer a, Integer b) {
                        return diff(a, b);
                    }
                });
    }

    public static List&lt;Integer&gt; getInput() {
        return Arrays.asList(1, 2, 4, 3);
    }

    public static int diff(Integer a, Integer b) {
        return a - b;
    }
}</thetext>
    </bug>
    <bug>
        <id>509324</id>
        <developer>Kris De Volder</developer>
        <developer_username>kdevolder</developer_username>
        <dup_id/>
        <creation_time>2016-12-15 16:56:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>jdt generics regression in neon 2</short_desc>
        <thetext>Created attachment 265905
sample maven project

Got some code that 
 - compiles fine in neon 1
 - has a compile error in neon 2
 - compiles fine with javac / maven on commandline
 - compiles fine in oxygen (I didn't try but one of my coleagues did)

Wasn't totally sure if we should report this. Since maybe its already fixed in oxygen. 

But since neon.2 isn't even released yet and this seems to be a problem actually introduced in neon.2...

Anyhoo I'l leave it to the experts to decide if this can / should still be fixed in Neon. 

To reproduce: import attached maven project in neon.2
You will get a compile error like this:

Description	Resource	Path	Location	Type
Type mismatch: cannot convert from Object to TestGenerics.SshHost	TestGenerics.java	/neon-2-compilation-problem/src/main/java/testgenerics	line 32	Java Problem</thetext>
        <comment>
            <comment_id>2786860</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-15 17:22:06 -0500</when>
            <comment_text>(In reply to Kris De Volder from comment #0)
&gt; Created attachment 265905 [details]
&gt; sample maven project
&gt; 
&gt; Got some code that 
&gt;  - compiles fine in neon 1
&gt;  - has a compile error in neon 2

reproduced

&gt;  - compiles fine with javac / maven on commandline

reproduced with javac version 1.8 and 9 (ea)

&gt;  - compiles fine in oxygen (I didn't try but one of my coleagues did)

accepted in 4.7M1 &amp; 4.7M2, rejected since 4.7M3
 
&gt; Wasn't totally sure if we should report this. Since maybe its already fixed
&gt; in oxygen. 

unfortunately not.

&gt; But since neon.2 isn't even released yet and this seems to be a problem
&gt; actually introduced in neon.2...

neon.2 is in "quiet week". No more code changes unless to prevent severe damage.</comment_text>
        </comment>
        <comment>
            <comment_id>2786862</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-15 17:45:47 -0500</when>
            <comment_text>This is going to be difficult: the change is caused by the fix for bug 499725, which was part of a cluster including bug 501949 by the same reporter. Hi, Kris :)

Difficult also, because that cluster of fixes deliberately moves our implementation away from JLS, to leverage advice from javac developers. I.e., all this was done to make ecj more similar to javac, despite JLS saying differently. If this breaks congruence with javac in other cases we will have to request more information about how javac is implemented, not sure if this can possibly terminate ...</comment_text>
        </comment>
    </bug>
    <bug>
        <id>509331</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-12-16 00:28:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] ClassfileReader should be updated per new JLS</short_desc>
        <thetext>As per the new JLS spec, there are two new entries:

    u2 module_name_index;
    u2 module_flags;

Even though code generation seem to take care of these, ClassFileReader is not adjusted but should be.

But we can't do this yet because the JDT team is stuck with JRE b142, which still contains modules with the previous class format. Once we have access to it, we should fix this.</thetext>
        <comment>
            <comment_id>2786941</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-16 04:27:36 -0500</when>
            <comment_text>Created attachment 265909
Draft patch

This doesn't work in all conditions as of now, but once we can test it with the latest JRE, we can push this in.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>509366</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-12-16 12:53:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Unable to find correct source file for module-info from JRT</short_desc>
        <thetext>As of build 146, the source bundled with the JDK (i.e. src.zip) is modularized. In other words, there is now a new sub folder for each module, under which the corresponding sources are archived. Since this change, the source mapper is unable to locate the correct source file for module-info.class. Because there are several module-info.class present, the mapper always picks up the first one on the list.

It is working fine for other types, though, because we go through each sub folder and look for sources in them. Even here, presence of multiple files with same name will cause problem.

The fix I have in mind is to have JrtPackageFragmentRoot limit its root path explicitly to its module folder.</thetext>
        <comment>
            <comment_id>2787163</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-16 14:55:38 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/87338</comment_text>
        </comment>
    </bug>
    <bug>
        <id>485479</id>
        <developer>Tea Jani</developer>
        <developer_username>teajani666</developer_username>
        <dup_id/>
        <creation_time>2016-01-09 10:02:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>cant open any class in eclipse . it used to work great. suddently doesnt show anything</short_desc>
        <thetext/>
    </bug>
    <bug>
        <id>485484</id>
        <developer>Jean VEGA</developer>
        <developer_username>JeanLasVEGAs</developer_username>
        <dup_id/>
        <creation_time>2016-01-09 20:27:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Eclipse Crashes when Remote Debugging</short_desc>
        <thetext>Created attachment 259096
JVM Crash Dump

The setup is Eclipse:
Version: Mars.1 Release (4.5.1)
Build id: 20150924-1200

Remote debugging Tomcat + Liferay Portal on another machine. I have observed crashes since Eclipse 3.3 and every other version until Mars.

JVM crash dump attached.</thetext>
    </bug>
    <bug>
        <id>485857</id>
        <developer>Frank Gasdorf</developer>
        <developer_username>fgdrf</developer_username>
        <dup_id/>
        <creation_time>2016-01-14 10:18:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Conditional breakpoints Memory leak</short_desc>
        <thetext>Created attachment 259186
simple test class to reproduce memory leak

Having conditional breakpoint with an object reference causes Java heap exceptions. 

Exception in thread "main" java.lang.OutOfMemoryError: Java heap space

The garbage collecton doesn't release these objects.

Simple code to reproduce if Breakpoint is enabled in attached file (DebugBreaker.java).

Breakpoint conditon for Breakpoint in line 14:

   System.out.println(i.toString());
   return false;</thetext>
    </bug>
    <bug>
        <id>486419</id>
        <developer>Josh Cicchini</developer>
        <developer_username>josh.cicchini</developer_username>
        <dup_id/>
        <creation_time>2016-01-23 13:05:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>File -&gt; Print interface glitched, unnavigable</short_desc>
        <thetext>When I attempt to print code from the Eclipse environment, the File -&gt; Print dialogue box that arises is too small to contain all of its options. It allows neither resizing nor scrolling along its axes. I must print my code in landscape mode for class, and of course would prefer for it to print double-sided and in black &amp; white; none of these options are currently reachable from my version of Eclipse, and the default settings override any adjustments I attempt to make by right-clicking on my printer in the containing list.

-- Configuration Details --
Product: Eclipse 4.5.1.20150917-1200 (org.eclipse.epp.package.java.product)
Installed Features:
 org.eclipse.jdt 3.11.1.v20150904-0015</thetext>
    </bug>
    <bug>
        <id>486427</id>
        <developer>Jerry Li</developer>
        <developer_username>jerry.li2807</developer_username>
        <dup_id/>
        <creation_time>2016-01-24 03:20:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>"Terminate/Disconnect All" has strange implied behavior.</short_desc>
        <thetext>Created attachment 259353
Image illustrating problem

The "Terminate/Disconnect All" element that appears when right clicking the console of Eclipse has a behavior that implies that the current application is not terminated.

A example of this is in a attached picture, and some minimal code that is used to sample the behavior is below:

public class termtest {
    public static void main(String[] args){
        System.out.println("Did I terminate?");
    }
}

I have additionally asked about this behavior on Stack Overflow: http://stackoverflow.com/questions/34970750/eclipse-terminate-disconnect-all-behavior</thetext>
    </bug>
    <bug>
        <id>487042</id>
        <developer>Igal Sapir</developer>
        <developer_username>igal</developer_username>
        <dup_id/>
        <creation_time>2016-02-02 15:44:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Step Debugger throws Timeout Exception on Windows</short_desc>
        <thetext>Running a multi threaded application on Windows, the debugger throws Timeout Exceptions when stepping to the next frame.

The exception is shown as a modal MessageBox and I can not see a stack trace anywhere.

This has been an issue with versions from at least the past five years, and has been verified to exist in the most recent build -- Eclipse Neon 4.6 M4.

Please note:

(1) My colleague debugs this project in Eclipse Kepler on a Mac with no issue

(2) There is a daemon thread running in the application (not the thread on which I'm setting the breakpoint).  When I disable the daemon thread then there is no issue.

To reproduce:  

  (a) Download and import the three projects from github:

    "loader" and "core" projects from  https://github.com/lucee/Lucee
    "debug" project from https://github.com/lucee/debug

  (b) Debug as Java Application the class RunAsJavaApplication.java in the debug project, i.e. https://github.com/lucee/debug/blob/master/src/main/RunAsJavaApplication.java

      This would start an embedded Jetty on localhost:8080

  (c) Set a breakpoint anywhere in the core project, e.g. at https://github.com/lucee/Lucee/blob/master/core/src/main/java/lucee/runtime/functions/dateTime/Now.java#L35

  (d) Create a CFML script file in the debug projects "web" directory, e.g. "time.cfm" with a line of code that calls the breakpointed location.  If your breakpoint is on the Now() function as suggested in item (c) above then this line would suffice:

      &lt;cfoutput&gt;The time is #Now()#&lt;/cfoutput&gt;

So you will have that line in the file ${debug-project}/web/time.cfm

  (e) Launch that file with your browser by pointing it to 

      http://localhost:8080/time.cfm

  (f) Wait about a minute and then step through the frames at a reasonable pace.  On the next Step attempt (or Resume) after about a minute of the initial breakpoint hit you will see the error.</thetext>
        <comment>
            <comment_id>2667223</comment_id>
            <comment_count>1</comment_count>
            <who>Igal Sapir</who>
            <commenter_username>igal</commenter_username>
            <when>2016-02-02 15:47:10 -0500</when>
            <comment_text>Created attachment 259501
Screenshot of Error Modal MessageBox</comment_text>
        </comment>
        <comment>
            <comment_id>2667229</comment_id>
            <comment_count>2</comment_count>
            <who>Igal Sapir</who>
            <commenter_username>igal</commenter_username>
            <when>2016-02-02 15:58:01 -0500</when>
            <comment_text>Created attachment 259502
Screenshot of the full Eclipse Window with Error Modal Box</comment_text>
        </comment>
        <comment>
            <comment_id>2667231</comment_id>
            <comment_count>3</comment_count>
            <who>Igal Sapir</who>
            <commenter_username>igal</commenter_username>
            <when>2016-02-02 16:00:48 -0500</when>
            <comment_text>Created attachment 259503
Screenshot of Eclipse SDK Installation Details</comment_text>
        </comment>
        <comment>
            <comment_id>2667234</comment_id>
            <comment_count>4</comment_count>
            <who>Igal Sapir</who>
            <commenter_username>igal</commenter_username>
            <when>2016-02-02 16:04:45 -0500</when>
            <comment_text>I originally reported this in https://bugs.eclipse.org/bugs/show_bug.cgi?id=94452 -- which seems related and was closed as fixed for Eclipse 4.6 M4, but was advised to open a new ticket.

This issue was tested with Eclipse 4.6 M4 and still shows the problem.

Thank you.</comment_text>
        </comment>
        <comment>
            <comment_id>2667294</comment_id>
            <comment_count>5</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-02-02 21:33:42 -0500</when>
            <comment_text>Andrey,
Do you want to look at this ?</comment_text>
        </comment>
        <comment>
            <comment_id>2667318</comment_id>
            <comment_count>6</comment_count>
            <who>Andrey Loskutov</who>
            <commenter_username>loskutov</commenter_username>
            <when>2016-02-03 00:41:17 -0500</when>
            <comment_text>Igal, can you please clesr the error log view, restart your case and after timeout error occurs attach here all new errors from the log.</comment_text>
        </comment>
        <comment>
            <comment_id>2667630</comment_id>
            <comment_count>7</comment_count>
            <who>Igal Sapir</who>
            <commenter_username>igal</commenter_username>
            <when>2016-02-03 10:25:09 -0500</when>
            <comment_text>Created attachment 259534
Screenshot showing empty Error Log Window

The error log is empty.

Am I looking at the correct error log?  

Is there a setting I should change for more verbose logging?</comment_text>
        </comment>
        <comment>
            <comment_id>2667648</comment_id>
            <comment_count>8</comment_count>
            <who>Andrey Loskutov</who>
            <commenter_username>loskutov</commenter_username>
            <when>2016-02-03 10:44:58 -0500</when>
            <comment_text>While the error dialog is shown, can you create the JVM dump via jstack? Just curiuos about the threads running at that moment in the Eclipse.</comment_text>
        </comment>
        <comment>
            <comment_id>2667650</comment_id>
            <comment_count>9</comment_count>
            <who>Andrey Loskutov</who>
            <commenter_username>loskutov</commenter_username>
            <when>2016-02-03 10:45:55 -0500</when>
            <comment_text>P.S. I've set bug version to 4.5 but please set it to the first version you see the problem with that setup.</comment_text>
        </comment>
        <comment>
            <comment_id>2667693</comment_id>
            <comment_count>10</comment_count>
            <who>Igal Sapir</who>
            <commenter_username>igal</commenter_username>
            <when>2016-02-03 11:34:56 -0500</when>
            <comment_text>Created attachment 259542
Thread Dump while Modal Error Box is Open

I don't have older versions of Eclipse installed, but I have experienced this issue since the old days of Eclipse Juno, possibly even Eclipse Indigo (at least since 2011).

My "solution" back then was to use IntelliJ IDEA instead of Eclipse, because other committers to the project are on a Mac and do not suffer from this issue, and IntelliJ does not suffer from this problem.

See attached Thread Dump.</comment_text>
        </comment>
        <comment>
            <comment_id>2667890</comment_id>
            <comment_count>11</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-02-04 01:53:32 -0500</when>
            <comment_text>"Packet Receive Manager" #582 daemon prio=5 os_prio=0 tid=0x000000001fb73000 nid=0xb78 runnable [0x000000002afcf000]
   java.lang.Thread.State: RUNNABLE
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.io.DataInputStream.readInt(Unknown Source)
	at org.eclipse.jdi.internal.connect.SocketConnection.readPacket(SocketConnection.java:69)
	- eliminated &lt;owner is scalar replaced&gt; (a java.io.DataInputStream)	at org.eclipse.jdi.internal.connect.PacketReceiveManager.readAvailablePacket(PacketReceiveManager.java:300)
	at org.eclipse.jdi.internal.connect.PacketReceiveManager.run(PacketReceiveManager.java:87)
	at java.lang.Thread.run(Unknown Source)


Trying to get anything from remote server ?</comment_text>
        </comment>
        <comment>
            <comment_id>2667944</comment_id>
            <comment_count>12</comment_count>
            <who>Andrey Loskutov</who>
            <commenter_username>loskutov</commenter_username>
            <when>2016-02-04 04:01:27 -0500</when>
            <comment_text>(In reply to Igal Sapir from comment #0)
&gt; Please note:
&gt; 
&gt; (1) My colleague debugs this project in Eclipse Kepler on a Mac with no issue

That's interesting, I've initially missed that. Here I think immediately on different firewall rules / proxies etc in different OS you could use.

&gt; (2) There is a daemon thread running in the application (not the thread on
&gt; which I'm setting the breakpoint).  When I disable the daemon thread then
&gt; there is no issue.

Interesting is to know *what* this thread is doing while you are debugging? Can you make a dump of the application while it is waiting on the breakpoint and can you point to the code of that daemon thread? Just wondering if this thread "steals" or blocks the network resources or something similar on Windows.</comment_text>
        </comment>
        <comment>
            <comment_id>2668140</comment_id>
            <comment_count>13</comment_count>
            <who>Igal Sapir</who>
            <commenter_username>igal</commenter_username>
            <when>2016-02-04 10:08:54 -0500</when>
            <comment_text>(In reply to Sarika Sinha from comment #11)
&gt; 
&gt; Trying to get anything from remote server ?

I am not sure, but I don't see any lucee.* code in the stack trace, only Eclipse?

The application checks in the background for updates and other things, so it's possible that this is what we see here.

That, by the way, is controlled by the daemon thread (item (2) in the OP), which when disabled the timeout doesn't take place.</comment_text>
        </comment>
        <comment>
            <comment_id>2668152</comment_id>
            <comment_count>14</comment_count>
            <who>Igal Sapir</who>
            <commenter_username>igal</commenter_username>
            <when>2016-02-04 10:26:22 -0500</when>
            <comment_text>(In reply to Andrey Loskutov from comment #12)
&gt; That's interesting, I've initially missed that. Here I think immediately on
&gt; different firewall rules / proxies etc in different OS you could use.

I really doubt that.  The application runs fine when I don't set a breakpoint, or when the daemon thread mentioned below is disabled.  If there was a firewall issue then I would have problems without the breakpoint either.

I allowed Eclipse, of course, in the Windows Firewall.
 
&gt; Interesting is to know *what* this thread is doing while you are debugging?
&gt; Can you make a dump of the application while it is waiting on the breakpoint
&gt; and can you point to the code of that daemon thread? Just wondering if this
&gt; thread "steals" or blocks the network resources or something similar on
&gt; Windows.

Do I need to do a different kind of Thread Dump?  Or is it just that you're not sure which thread in the dump is the daemon thread of the application?

Please advise.  Thank you.</comment_text>
        </comment>
        <comment>
            <comment_id>2668193</comment_id>
            <comment_count>15</comment_count>
            <who>Igal Sapir</who>
            <commenter_username>igal</commenter_username>
            <when>2016-02-04 11:23:44 -0500</when>
            <comment_text>I might be missing something with the Thread Dumps.  Is there a different process that I need to do the dump on?

Most of the code in the application I'm debugging is in a package named "lucee".  How come I don't see anything with "lucee.*" in the Thread Dump?</comment_text>
        </comment>
        <comment>
            <comment_id>2668205</comment_id>
            <comment_count>16</comment_count>
            <who>Igal Sapir</who>
            <commenter_username>igal</commenter_username>
            <when>2016-02-04 11:48:00 -0500</when>
            <comment_text>After waiting a while longer, two exceptions showed up on the Error Log:


eclipse.buildId=4.6.0.I20151209-2300
java.version=1.8.0_71
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Command-line arguments:  -os win32 -ws win32 -arch x86_64

org.eclipse.jdt.debug
Error
Thu Feb 04 08:43:14 PST 2016
Internal error logged from JDI Debug: 

org.eclipse.jdi.TimeoutException: Timeout occurred while waiting for packet 17272.
	at org.eclipse.jdi.internal.connect.PacketReceiveManager.getReply(PacketReceiveManager.java:193)
	at org.eclipse.jdi.internal.connect.PacketReceiveManager.getReply(PacketReceiveManager.java:204)
	at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:192)
	at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:227)
	at org.eclipse.jdi.internal.ThreadReferenceImpl.frames(ThreadReferenceImpl.java:263)
	at org.eclipse.jdi.internal.ThreadReferenceImpl.frames(ThreadReferenceImpl.java:245)
	at org.eclipse.jdt.internal.debug.core.model.JDIThread.getUnderlyingFrames(JDIThread.java:675)
	at org.eclipse.jdt.internal.debug.core.model.JDIThread.computeStackFrames(JDIThread.java:574)
	at org.eclipse.jdt.internal.debug.core.model.JDIThread.computeStackFrames(JDIThread.java:646)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.supportsDropToFrame(JDIStackFrame.java:642)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.canDropToFrame(JDIStackFrame.java:610)
	at org.eclipse.debug.internal.core.commands.DropToFrameCommand.isSteppable(DropToFrameCommand.java:35)
	at org.eclipse.debug.internal.core.commands.StepCommand.isExecutable(StepCommand.java:46)
	at org.eclipse.debug.core.commands.AbstractDebugCommand$UpdateJob.run(AbstractDebugCommand.java:101)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)



eclipse.buildId=4.6.0.I20151209-2300
java.version=1.8.0_71
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Command-line arguments:  -os win32 -ws win32 -arch x86_64

org.eclipse.jdt.debug
Error
Thu Feb 04 08:43:08 PST 2016
Internal error logged from JDI Debug:

org.eclipse.jdi.TimeoutException: Timeout occurred while waiting for packet 17270.
    at org.eclipse.jdi.internal.connect.PacketReceiveManager.getReply(PacketReceiveManager.java:193)
    at org.eclipse.jdi.internal.connect.PacketReceiveManager.getReply(PacketReceiveManager.java:204)
    at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:192)
    at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:227)
    at org.eclipse.jdi.internal.ThreadReferenceImpl.frames(ThreadReferenceImpl.java:263)
    at org.eclipse.jdi.internal.ThreadReferenceImpl.frames(ThreadReferenceImpl.java:245)
    at org.eclipse.jdt.internal.debug.core.model.JDIThread.getUnderlyingFrames(JDIThread.java:675)
    at org.eclipse.jdt.internal.debug.core.model.JDIThread.computeStackFrames(JDIThread.java:574)
    at org.eclipse.jdt.internal.debug.core.model.JDIThread.computeStackFrames(JDIThread.java:646)
    at org.eclipse.jdt.internal.debug.core.model.JDIThread.getTopStackFrame(JDIThread.java:1329)
    at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.isTopStackFrame(JDIStackFrame.java:1033)
    at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.canStepInto(JDIStackFrame.java:224)
    at org.eclipse.debug.internal.core.commands.StepIntoCommand.isSteppable(StepIntoCommand.java:27)
    at org.eclipse.debug.internal.core.commands.StepCommand.isExecutable(StepCommand.java:46)
    at org.eclipse.debug.core.commands.AbstractDebugCommand$UpdateJob.run(AbstractDebugCommand.java:101)
    at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)



Session Data:
eclipse.buildId=4.6.0.I20151209-2300
java.version=1.8.0_71
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Command-line arguments:  -os win32 -ws win32 -arch x86_64</comment_text>
        </comment>
        <comment>
            <comment_id>2678949</comment_id>
            <comment_count>17</comment_count>
            <who>Igal Sapir</who>
            <commenter_username>igal</commenter_username>
            <when>2016-03-04 11:28:30 -0500</when>
            <comment_text>Does the stack trace I posted a month ago give you any valuable information?

Is there anything else I can help with in debugging this issue?</comment_text>
        </comment>
        <comment>
            <comment_id>2679241</comment_id>
            <comment_count>18</comment_count>
            <who>Andrey Loskutov</who>
            <commenter_username>loskutov</commenter_username>
            <when>2016-03-06 10:15:47 -0500</when>
            <comment_text>(In reply to Igal Sapir from comment #17)
&gt; Does the stack trace I posted a month ago give you any valuable information?

No.

&gt; Is there anything else I can help with in debugging this issue?

Yes. Create a jstack dump of your application you are trying to debug (not Eclipse!) while this deamon thread is running at the moment you receive timeout at Eclipse side. If the application is open source, point to the source code of that deamon thread. If not, please provide here at least an idea what this thread is doing.</comment_text>
        </comment>
        <comment>
            <comment_id>2679264</comment_id>
            <comment_count>19</comment_count>
            <who>Igal Sapir</who>
            <commenter_username>igal</commenter_username>
            <when>2016-03-06 13:41:33 -0500</when>
            <comment_text>&gt; Create a jstack dump of your application you are trying to debug (not Eclipse!) while this deamon thread is running at the moment you receive timeout at Eclipse side.

How do I do that?</comment_text>
        </comment>
        <comment>
            <comment_id>2681974</comment_id>
            <comment_count>20</comment_count>
            <who>Igal Sapir</who>
            <commenter_username>igal</commenter_username>
            <when>2016-03-14 13:31:38 -0400</when>
            <comment_text>&gt; Create a jstack dump of your application you are trying to debug (not Eclipse!)

Can anyone advise how to do this?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>487568</id>
        <developer>Sarika Sinha</developer>
        <developer_username>sarika.sinha</developer_username>
        <dup_id/>
        <creation_time>2016-02-10 05:15:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>[Tests] testHyperlinkMatchSignatureExtended failed</short_desc>
        <thetext>http://download.eclipse.org/eclipse/downloads/drops4/N20160209-2000/testresults/html/org.eclipse.jdt.debug.tests_macosx.cocoa.x86_64_8.0.html

testHyperlinkMatchSignatureExtended	Error	[]: array lengths differed, expected.length=1 actual.length=0

java.lang.AssertionError: []: array lengths differed, expected.length=1 actual.length=0
at org.eclipse.jdt.debug.tests.console.JavaStackTraceConsoleTest.testHyperlinkMatchSignatureExtended(JavaStackTraceConsoleTest.java:70)
at org.eclipse.jdt.debug.tests.AbstractDebugTest.runBare(AbstractDebugTest.java:2469)
at org.eclipse.jdt.debug.tests.DebugSuite$1.run(DebugSuite.java:57)
at java.lang.Thread.run(Thread.java:745)</thetext>
    </bug>
    <bug>
        <id>487665</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-02-11 09:06:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Variables view content assist duplicates "Java" templates</short_desc>
        <thetext>Created attachment 259709
Screenshot

I20160209-0800

See attached screenshot. In the Variables view, content assist duplicates templates from the "Java" context. The same happens for "new", "nls", and the "to..." templates.</thetext>
    </bug>
    <bug>
        <id>488108</id>
        <developer>Al Bundy</developer>
        <developer_username>TheRealHawk</developer_username>
        <dup_id/>
        <creation_time>2016-02-19 09:21:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Eclipse shows always(?) an empty(?) "[Debug Console]" when debugging an application</short_desc>
        <thetext>My console is configured to show on changes on stderr or stdout.

But every time I start to debug an application a new console titled with "[Debug Console]" is shown which is always empty.

Then I have to switch the console back to my outputs.
As soon as a breakpoint is reached the mysterious "[Debug Console]" is shown again and I have to switch back.
Then after EACH debug-step the #$%&amp;#"§% "[Debug Console]" is shown again.

Is it possible to disable this "[Debug Console]"???
And can someone describe the purpose of this console?</thetext>
        <comment>
            <comment_id>2673747</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-02-19 09:38:11 -0500</when>
            <comment_text>What Eclipse version do you use and what kind of application do you launch?</comment_text>
        </comment>
        <comment>
            <comment_id>2673757</comment_id>
            <comment_count>2</comment_count>
            <who>Al Bundy</who>
            <commenter_username>TheRealHawk</commenter_username>
            <when>2016-02-19 09:45:38 -0500</when>
            <comment_text>Eclipse for RCP and RAP Developers

Version: Mars.1 Release (4.5.1)
Build id: 20150924-1200

I start different kinds of applications: RCP-Projects, Tests, simple java-classes, ...

The console appears also when debugging a simple java class with only a main-method.</comment_text>
        </comment>
        <comment>
            <comment_id>2673963</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-19 17:34:58 -0500</when>
            <comment_text>When the [Debug Console] appears, you may want to press Shift-Alt-F1 (Plugin Spy) to figure out the implementing class.</comment_text>
        </comment>
        <comment>
            <comment_id>2677839</comment_id>
            <comment_count>4</comment_count>
            <who>Al Bundy</who>
            <commenter_username>TheRealHawk</commenter_username>
            <when>2016-03-02 06:39:20 -0500</when>
            <comment_text>Created attachment 260040
plugin spy

I've added a screenshot from plugin spy.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488918</id>
        <developer>Paranthaman Rajendran</developer>
        <developer_username>parantham</developer_username>
        <dup_id/>
        <creation_time>2016-03-03 02:34:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Eclipse getting hanged during Debugging process</short_desc>
        <thetext>Created attachment 260059
Thread Dump

Hi ,

  My Eclipse version: Indigo Service Release 2, Build :20120216-1857.

  we are facing issue with eclipse while debugging my application. it getting very slow and hanged.

  Please find the below thread dump. please help us to resolve the issue.



Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.80-b11 mixed mode):

"Attach Listener" daemon prio=10 tid=0x00007f1c40002000 nid=0x3b7c waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
	- None

"Worker-2395" prio=10 tid=0x00007f1bd44f9800 nid=0x3a4c waiting for monitor entry [0x00007f1bad999000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at org.eclipse.core.internal.jobs.JobManager.nextJob(JobManager.java:970)
	- waiting to lock &lt;0x0000000780cceac8&gt; (a java.lang.Object)
	at org.eclipse.core.internal.jobs.JobManager.startJob(JobManager.java:1478)
	at org.eclipse.core.internal.jobs.WorkerPool.startJob(WorkerPool.java:221)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:50)

   Locked ownable synchronizers:
	- None

"Worker-2394" prio=10 tid=0x00007f1bd7a95000 nid=0x3a4b waiting for monitor entry [0x00007f1bb3cfc000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at org.eclipse.core.internal.jobs.JobManager.nextJob(JobManager.java:970)
	- waiting to lock &lt;0x0000000780cceac8&gt; (a java.lang.Object)
	at org.eclipse.core.internal.jobs.JobManager.startJob(JobManager.java:1478)
	at org.eclipse.core.internal.jobs.WorkerPool.startJob(WorkerPool.java:221)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:50)

   Locked ownable synchronizers:
	- None

"Worker-2393" prio=10 tid=0x00007f1bd7c30800 nid=0x6ddc sleeping[0x00007f1b9c586000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
	at java.lang.Thread.sleep(Native Method)
	at org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:925)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget$ThreadDeathHandler.handleEvent(JDIDebugTarget.java:1959)
	at org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch(EventDispatcher.java:154)
	at org.eclipse.jdt.internal.debug.core.EventDispatcher.access$0(EventDispatcher.java:104)
	at org.eclipse.jdt.internal.debug.core.EventDispatcher$1.run(EventDispatcher.java:248)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

   Locked ownable synchronizers:
	- None

"Worker-2392" prio=10 tid=0x00007f1bd7a87800 nid=0x6ddb waiting for monitor entry [0x00007f1b98a4b000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at org.eclipse.core.internal.jobs.JobManager.nextJob(JobManager.java:970)
	- waiting to lock &lt;0x0000000780cceac8&gt; (a java.lang.Object)
	at org.eclipse.core.internal.jobs.JobManager.startJob(JobManager.java:1478)
	at org.eclipse.core.internal.jobs.WorkerPool.startJob(WorkerPool.java:221)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:50)

   Locked ownable synchronizers:
	- None

"Worker-2391" prio=10 tid=0x00007f1bd79f1000 nid=0x6dda waiting for monitor entry [0x00007f1ba5818000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at org.eclipse.core.internal.jobs.JobManager.nextJob(JobManager.java:970)
	- waiting to lock &lt;0x0000000780cceac8&gt; (a java.lang.Object)
	at org.eclipse.core.internal.jobs.JobManager.startJob(JobManager.java:1478)
	at org.eclipse.core.internal.jobs.WorkerPool.startJob(WorkerPool.java:221)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:50)

   Locked ownable synchronizers:
	- None

Regards,
Paranthaman</thetext>
        <comment>
            <comment_id>2678257</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-03-03 02:54:14 -0500</when>
            <comment_text>Please try with latest Eclipse release Mars.2
http://www.eclipse.org/downloads/</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489211</id>
        <developer>Carsten Pfeiffer</developer>
        <developer_username>carsten.pfeiffer</developer_username>
        <dup_id/>
        <creation_time>2016-03-08 08:27:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Support for editing RuntimeClasspathEntry instances</short_desc>
        <thetext>The launch configuration dialog for e.g. Java Applications has a "Classpath" tab, which allows to add/remove "User Entries" to the classpath.

When you press Advanced -&gt; Add Library, you get a wizard which first allows you to select a library (a classpath container) and then configure it in the next step (if the container is configurable).

After adding such a library, it is unfortunately impossible to edit it again, because the "Edit" button is disabled. All you can do is remove it and create a new one.

The general support for editing such entries is already there, see org.eclipse.jdt.internal.debug.ui.classpath.IClasspathEditor. Only two things would be needed to allow editing such libraries:

1) provide an implementation of IClasspathEditor that uses 			BuildPathDialogAccess.configureContainerEntry() to invoke the configuration dialog
2) let org.eclipse.jdt.internal.launching.RuntimeClasspathEntry implement IAdaptable that delegates to Platform.getAdapterManager()
3) provide an AdapterFactory for RuntimeClasspathEntry/IClasspathEditor that checks if the entry is of kind CPE_CONTAINER and then returns the IClasspathEditor of 1)

I have an implementation of this that works for me and I'd like to contribute it. I'm not sure if adding an interface to RuntimeClasspathEntry is compatibility problem though, even though it is an internal class.</thetext>
    </bug>
    <bug>
        <id>489365</id>
        <developer>Claude Quezel</developer>
        <developer_username>cquezel</developer_username>
        <dup_id/>
        <creation_time>2016-03-10 10:59:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Hyperlinks in the stack trace console should accept non ascii</short_desc>
        <thetext>If the stack trace contains a typical line like:

at com.example.Math.introduction(Math.java:101)

Eclipse underlines the "Math.java:101" and allows me to click to follow the link to the correct file and line number.

If I have a line with special characters like:

at com.example.Français.débutant(Français.java:101)

Eclipse does not detect the class reference.</thetext>
        <comment>
            <comment_id>2680986</comment_id>
            <comment_count>1</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-03-10 22:19:31 -0500</when>
            <comment_text>Moving to JDT Debug for comments</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489436</id>
        <developer>johnny boniphace</developer>
        <developer_username>johnnymapunda</developer_username>
        <dup_id/>
        <creation_time>2016-03-11 09:24:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>package project1;  public class johnny { public static void main(string args[]){  system.out.println("this is boooring");      } }</short_desc>
        <thetext/>
    </bug>
    <bug>
        <id>490411</id>
        <developer>David Williams</developer>
        <developer_username>david_williams</developer_username>
        <dup_id/>
        <creation_time>2016-03-24 20:38:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Dirty working tree: files/jars in JDT Debug</short_desc>
        <thetext>+++ This bug was initially created as a clone of Bug #419506 +++

The latest "dirt report" shows JDT Debug still produces "dirt" during a build. 

Entering 'eclipse.jdt.debug'
?? org.eclipse.jdt.debug.tests/javadebugtests.jar
?? org.eclipse.jdt.debug/jdi.jar
?? org.eclipse.jdt.debug/jdimodel.jar

If these are "intermediate" files produced during the build, would be best to create them somewhere under /target so they would not cleaned up automatically during a build or rebuild.</thetext>
        <comment>
            <comment_id>2687031</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-03-25 06:49:16 -0400</when>
            <comment_text>(In reply to David Williams from comment #0)
&gt; +++ This bug was initially created as a clone of Bug #419506 +++
&gt; 
&gt; The latest "dirt report" shows JDT Debug still produces "dirt" during a
&gt; build. 
&gt; 
&gt; Entering 'eclipse.jdt.debug'
&gt; ?? org.eclipse.jdt.debug.tests/javadebugtests.jar
&gt; ?? org.eclipse.jdt.debug/jdi.jar
&gt; ?? org.eclipse.jdt.debug/jdimodel.jar
&gt; 
&gt; If these are "intermediate" files produced during the build, would be best
&gt; to create them somewhere under /target so they would not cleaned up
&gt; automatically during a build or rebuild.

Why is this now showing up, i.e. is this something new?

Those files are part of the final bundle and no dirt. Note that this bundle is not JARed.</comment_text>
        </comment>
        <comment>
            <comment_id>2687056</comment_id>
            <comment_count>2</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-03-25 08:52:15 -0400</when>
            <comment_text>(In reply to David Williams from comment #0)
&gt; If these are "intermediate" files produced during the build, would be best
&gt; to create them somewhere under /target 

Are class files also produced outside the tree and not in the bin folder like in the workspace?</comment_text>
        </comment>
        <comment>
            <comment_id>2687072</comment_id>
            <comment_count>3</comment_count>
            <who>David Williams</who>
            <commenter_username>david_williams</commenter_username>
            <when>2016-03-25 09:33:10 -0400</when>
            <comment_text>(In reply to Dani Megert from comment #1)

&gt; Why is this now showing up, i.e. is this something new?
&gt; 
&gt; Those files are part of the final bundle and no dirt. Note that this bundle
&gt; is not JARed.

Not new. In bug 419506 you mentioned "a separate bug may have to be open for debug", but one never was. 

(In reply to Dani Megert from comment #2)

&gt; Are class files also produced outside the tree and not in the bin folder
&gt; like in the workspace?

I would guess these are produced as part of some "ant process" and (later) become part of a bundles. 

There's are ways of doing this "in the /target" directory (perhaps under "resources"? -- I forget) and then there is some pom incantation needed to convince Tycho to add them to the bundle ... something like "addAddtionalResources". I'd have to look for existing examples to get the exact name.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490866</id>
        <developer>Andreas Sewe</developer>
        <developer_username>andreas.sewe</developer_username>
        <dup_id/>
        <creation_time>2016-04-01 04:43:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Debug view: Show fully-qualified method names in tooltip of stacktrace</short_desc>
        <thetext>Currently, the Debug view offers no tooltip when hovering over a stacktrace element like "Main.main(String[]) line : 1426".

In most cases, this is not a problem, as one can always look at the source in the associated Java editor.

If, however, JDT cannot find the sources of the method in question (showing the "Source not found / Edit Source Lookup path..." editor), it's really hard to guess what JAR needs to be added, as one does not know what package one is looking for. Here, a tooltip would be really helpful.</thetext>
    </bug>
    <bug>
        <id>491143</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-04-06 06:17:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Moving an executed snippet causes an exception</short_desc>
        <thetext>1. have a simple snippet, let's say "1 &lt;&lt; 25"
2. run it
3. move it to another project

==&gt;

!ENTRY org.eclipse.jdt.debug 4 125 2016-04-06 12:08:28.344
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.core.internal.resources.ResourceException: The resource tree is locked for modifications.
	at org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:119)
	at org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:2188)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2235)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.debug.core.model.Breakpoint.setAttribute(Breakpoint.java:209)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.decrementInstallCount(JavaBreakpoint.java:870)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.deregisterRequest(JavaBreakpoint.java:279)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.removeRequests(JavaBreakpoint.java:783)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.removeFromTarget(JavaBreakpoint.java:724)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.removeFromTarget(JavaLineBreakpoint.java:191)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1650)
	at org.eclipse.jdt.internal.debug.ui.snippeteditor.JavaSnippetEditor.shutDownVM(JavaSnippetEditor.java:580)
	at org.eclipse.jdt.internal.debug.ui.snippeteditor.JavaSnippetEditor.cleanupOnRenameOrMove(JavaSnippetEditor.java:1241)
	at org.eclipse.jdt.internal.debug.ui.snippeteditor.JavaSnippetEditor.setPartName(JavaSnippetEditor.java:1231)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeTitle(AbstractTextEditor.java:4076)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4180)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:229)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1466)
	at org.eclipse.jdt.internal.debug.ui.snippeteditor.JavaSnippetEditor.doSetInput(JavaSnippetEditor.java:304)
	at org.eclipse.ui.texteditor.AbstractTextEditor.setInputWithNotify(AbstractTextEditor.java:4239)
	at org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:4259)
	at org.eclipse.ui.texteditor.AbstractTextEditor$ElementStateListener$6.run(AbstractTextEditor.java:531)
	at org.eclipse.ui.texteditor.AbstractTextEditor$ElementStateListener.execute(AbstractTextEditor.java:595)
	at org.eclipse.ui.texteditor.AbstractTextEditor$ElementStateListener.elementMoved(AbstractTextEditor.java:562)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider$FileBufferListener.underlyingFileMoved(TextFileDocumentProvider.java:332)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager$6.run(TextFileBufferManager.java:718)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.fireUnderlyingFileMoved(TextFileBufferManager.java:715)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.handleFileMoved(ResourceFileBuffer.java:429)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer$FileSynchronizer$3.execute(ResourceFileBuffer.java:161)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer$SafeFileChange.run(ResourceFileBuffer.java:84)
	at org.eclipse.ui.internal.editors.text.UISynchronizationContext.run(UISynchronizationContext.java:32)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.execute(TextFileBufferManager.java:601)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer$FileSynchronizer.resourceChanged(ResourceFileBuffer.java:182)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:289)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:152)
	at org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:374)
	at org.eclipse.core.internal.resources.Workspace.checkpoint(Workspace.java:529)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation$1.run(PerformChangeOperation.java:262)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:305)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:221)
	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper$Operation.run(RefactoringExecutionHelper.java:108)
	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5521)
	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:105)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:437)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:353)
	at org.eclipse.ui.internal.WorkbenchWindow$14.run(WorkbenchWindow.java:2184)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2180)
	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:194)
	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:153)
	at org.eclipse.jdt.internal.ui.refactoring.reorg.ReorgMoveStarter.run(ReorgMoveStarter.java:70)
	at org.eclipse.jdt.internal.ui.packageview.SelectionTransferDropAdapter.handleDropMove(SelectionTransferDropAdapter.java:264)
	at org.eclipse.jdt.internal.ui.packageview.SelectionTransferDropAdapter.performDrop(SelectionTransferDropAdapter.java:201)
	at org.eclipse.jdt.internal.ui.dnd.JdtViewerDropAdapter.drop(JdtViewerDropAdapter.java:246)
	at org.eclipse.jface.util.DelegatingDropAdapter$3.run(DelegatingDropAdapter.java:219)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:173)
	at org.eclipse.jface.util.DelegatingDropAdapter.drop(DelegatingDropAdapter.java:216)
	at org.eclipse.swt.dnd.DNDListener.handleEvent(DNDListener.java:91)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4415)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1079)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:802)
	at org.eclipse.swt.dnd.DropTarget.Drop(DropTarget.java:472)
	at org.eclipse.swt.dnd.DropTarget.Drop_64(DropTarget.java:406)
	at org.eclipse.swt.dnd.DropTarget$3.method6(DropTarget.java:270)
	at org.eclipse.swt.internal.ole.win32.COMObject.callback6(COMObject.java:119)
	at org.eclipse.swt.internal.ole.win32.COM.DoDragDrop(Native Method)
	at org.eclipse.swt.dnd.DragSource.drag(DragSource.java:378)
	at org.eclipse.swt.dnd.DragSource.access$0(DragSource.java:304)
	at org.eclipse.swt.dnd.DragSource$1.handleEvent(DragSource.java:173)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4415)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1079)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4233)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3821)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1119)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1020)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:687)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)
!SUBENTRY 1 org.eclipse.core.resources 4 380 2016-04-06 12:08:28.346
!MESSAGE The resource tree is locked for modifications.</thetext>
    </bug>
    <bug>
        <id>491288</id>
        <developer>Sarika Sinha</developer>
        <developer_username>sarika.sinha</developer_username>
        <dup_id/>
        <creation_time>2016-04-07 19:02:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Add Test Case for 5188</short_desc>
        <thetext>We can add couple of test cases for Bug 5188.</thetext>
    </bug>
    <bug>
        <id>491289</id>
        <developer>Sarika Sinha</developer>
        <developer_username>sarika.sinha</developer_username>
        <dup_id/>
        <creation_time>2016-04-07 19:06:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Breakpoints from one project is hit in another project for Scrapbook page</short_desc>
        <thetext>Taking the bug out from Comment#63 of Bug 5188

A snippet in project P2 that uses a type and a method that are also in P1, and the method in P1 contains a breakpoint. Executing that snippet hits the breakpoint.</thetext>
        <comment>
            <comment_id>2744476</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-08-29 02:18:07 -0400</when>
            <comment_text>Adding to this, 
I just faced an issue that with a simple Scrapbook page with syout statement works fine on an empty workspace. After I debug any program in this workspace with breakpoints (not with same type or method). It stops at ScrapbookMain1.eval at line Number 28.

So I tried this out and I can reproduce this in Luna, Mars, Neon as well. S nothing new .

Here I am not debugging Scrapbook but scrapbook execution is like an evaluation.</comment_text>
        </comment>
        <comment>
            <comment_id>2780414</comment_id>
            <comment_count>2</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-11-28 00:54:05 -0500</when>
            <comment_text>*** Bug 508223 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491370</id>
        <developer>ankit tyagi</developer>
        <developer_username>anki.tyagi991</developer_username>
        <dup_id/>
        <creation_time>2016-04-09 06:21:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>abx</short_desc>
        <thetext/>
    </bug>
    <bug>
        <id>491376</id>
        <developer>Jakub Knetl</developer>
        <developer_username>knetl.j</developer_username>
        <dup_id/>
        <creation_time>2016-04-09 13:19:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Cannot set detail formatter on array</short_desc>
        <thetext>When debuging if I right click any variable I can define detail formatter which works fine. But when I right click a variable which is an array, then there is no option to set the formatter.

I also tried to set detail formatter for underlying type which was in the array. The type is then displayed with formatter, but array is still displayed using toString() method of contained type.

The strange is that if I right click the array (after setting the detail formatter on underlying type) is that I can see option "Remove Detail Formatter" on the array. When I click on that then it removes the formatter from underlying type.

Is there any way how to display array using custom formatter?</thetext>
    </bug>
    <bug>
        <id>491752</id>
        <developer>chao chang</developer>
        <developer_username>chang-chao</developer_username>
        <dup_id/>
        <creation_time>2016-04-14 23:58:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>SubForestFilter should not throw NoTestsRemainException in apply method</short_desc>
        <thetext>For the details,see the following issue in the junit project.
https://github.com/junit-team/junit4/issues/1277</thetext>
        <comment>
            <comment_id>2696779</comment_id>
            <comment_count>1</comment_count>
            <who>chao chang</who>
            <commenter_username>chang-chao</commenter_username>
            <when>2016-04-20 03:36:20 -0400</when>
            <comment_text>1.Description

SubForestFilter may hide the real failure cause(exception) of a test


2.Steps To Reproduce

2.1. Write the following test code

@RunWith(PowerMockRunner.class)
@PrepareForTest(value = { ClassUnderTest.class })
public class BarTest {

    @Test
    public void test() {
        System.out.println("hello world");
    }
}
2.2.Put wrong version javassist which is needed by powermock in class path

2.3.In eclipse,select the test method,and run as junit

3.The expected result

The root cause,namely,javassist failure in stacktrace be shown.
In the case above,Exception javassist.bytecode.InterfaceMethodrefInfo cannot be cast to javassist.bytecode.MethodrefInfo should be seen.

4.the current result

BarTest.test
initializationError(org.junit.runner.manipulation.Filter)
java.lang.Exception: No tests found matching [{ExactMatcher:fDisplayName=test], {ExactMatcher:fDisplayName=test(BarTest)], {LeadingIdentifierMatcher:fClassName=BarTest,fLeadingIdentifier=test]] from org.junit.internal.requests.ClassRequest@72d1ad2e
    at org.junit.internal.requests.FilterRequest.getRunner(FilterRequest.java:40)
    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestLoader.createFilteredTest(JUnit4TestLoader.java:77)
    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestLoader.createTest(JUnit4TestLoader.java:68)
    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestLoader.loadTests(JUnit4TestLoader.java:43)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:444)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)


5. The reason 

Here is the getRunner code of the org.junit.internal.requests.FilterRequest class.

    public Runner getRunner() {
        try {
            Runner runner = request .getRunner();
            fFilter.apply( runner);
            return runner ;
        } catch (NoTestsRemainException e ) {
            return new ErrorReportingRunner(Filter.class, new Exception(String
                    . format("No tests found matching %s from %s", fFilter
                            .describe(), request.toString())));
        }
    }

In the above case,the fFilter is a SubForestFilter and the runner is already an ErrorReportingRunner ,in the apply method of the SubForestFilter NoTestsRemainException is thrown,thus the real failure reason that was wrapped in ErrorReportingRunner cannot be seen.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491981</id>
        <developer>arne anka</developer>
        <developer_username>eclipse-bugs</developer_username>
        <dup_id/>
        <creation_time>2016-04-19 06:01:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>source lookup unpredictable and cannot be influenced</short_desc>
        <thetext>i get a stacktrace which goes into a JAR not part of the project nor in its build path.
click on  the "(classname.java:line)" link tries to find the JAR elsewhere, taking whatever it finds in the workspace.
i have to close all projects possibly containing a version of the JAR in their build paths to finally get a "Source not found for ....".

it is apparently impossible to influence JDT in its arbitrary decisions and even if it fails, it does not offer a way to select the JAR on my own.

having to close other projects, which are in no way related or connected to the current project, just because JDT fails to accept that it doesn't know what it does, is inacceptable -- and that even when it finally gives up it does not offer a way for me to finally tell it how wrong it is and where to look instead, even more.</thetext>
        <comment>
            <comment_id>2696548</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-04-19 12:28:54 -0400</when>
            <comment_text>Can you please provide reproducible steps.</comment_text>
        </comment>
        <comment>
            <comment_id>2726253</comment_id>
            <comment_count>2</comment_count>
            <who>arne anka</who>
            <commenter_username>eclipse-bugs</commenter_username>
            <when>2016-07-01 05:35:34 -0400</when>
            <comment_text>- create several jars with the same class
- distribute over several open projects in workspace
- use a project that by name or creation date is in the middle of all those projects (since i don't know why eclipse choses the worng prject/jar, i cannot be more specfic)
- create stacktrace that involves the class from the jar
- click the stacktrace's "(classname.java:line)" part
- find yourself in the wrong project/jar</comment_text>
        </comment>
        <comment>
            <comment_id>2726255</comment_id>
            <comment_count>3</comment_count>
            <who>arne anka</who>
            <commenter_username>eclipse-bugs</commenter_username>
            <when>2016-07-01 05:36:13 -0400</when>
            <comment_text>*** Bug 433315 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
        <comment>
            <comment_id>2729198</comment_id>
            <comment_count>4</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-07-11 04:34:58 -0400</when>
            <comment_text>(In reply to arne anka from comment #2)
&gt; - create several jars with the same class
&gt; - distribute over several open projects in workspace
&gt; - use a project that by name or creation date is in the middle of all those
&gt; projects (since i don't know why eclipse choses the worng prject/jar, i
&gt; cannot be more specfic)
&gt; - create stacktrace that involves the class from the jar
&gt; - click the stacktrace's "(classname.java:line)" part
&gt; - find yourself in the wrong project/jar

Can you attach a sample workspace, I tried with exporting to 5 different jars.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492265</id>
        <developer>Thomas  Mäder</developer>
        <developer_username>t.s.maeder</developer_username>
        <dup_id/>
        <creation_time>2016-04-22 13:13:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Hot Code Replacement should not replace garbage Classes</short_desc>
        <thetext>While investigating https://issues.jboss.org/browse/JBIDE-21857 I found out that classes which are effectively garbage, but not collected yet in the VM are still being replaced by the JavaHotCodeReplaceManger. I have tried to come up with a patch that would allow to detect garbge classes and not do HCR with them. 
However, I have failed so far. I am filing this bug in the hope that you guys are smarter than me and come up with a way.</thetext>
        <comment>
            <comment_id>2702257</comment_id>
            <comment_count>1</comment_count>
            <who>Rob Stryker</who>
            <commenter_username>stryker</commenter_username>
            <when>2016-05-03 06:15:52 -0400</when>
            <comment_text>To be a bit more clear here, a loaded class (ex: servlet) in an application server may have several references to it.  A user may execute some action (such as a full publish of a web app) which causes the server to remove all references to the old class, and load a new version. 

If a breakpoint is set in that class before the full publish action is initiated by the user, however, the old version of the class may never reach a state of having 0 references. The breakpoint itself will force a reference to the class unless the breakpoint is first disabled before the full publish action.  

This means a garbage collection event may never clean up the old version of the class.  Subsequent small non-breaking changes to the class (such as changing a string inside a method) will create a third version. HCR will attempt to replace all versions of the class that are still active with this new third version.  Since the 2nd version of the class is actively used by the application server, it will be (successfully) replaced by the non-breaking change. 

However, the first version, which may have differed in class structure, and was never cleaned up / garbage collected because the breakpoint prevented it from being so, will also attempt to be replaced, and this will cause another HCR failure. 

So I guess the usecase can be summarized as "Do not attempt to hot-code replace a class when that class has no references to it other than a breakpoint, and a newer version of the class exists in the application."</comment_text>
        </comment>
        <comment>
            <comment_id>2702287</comment_id>
            <comment_count>2</comment_count>
            <who>Thomas  Mäder</who>
            <commenter_username>t.s.maeder</commenter_username>
            <when>2016-05-03 07:12:36 -0400</when>
            <comment_text>The debugger could not install breakpoints in classes that are not reacheable. Again, this comes down to the question what the "live" classes are.</comment_text>
        </comment>
        <comment>
            <comment_id>2702288</comment_id>
            <comment_count>3</comment_count>
            <who>Thomas  Mäder</who>
            <commenter_username>t.s.maeder</commenter_username>
            <when>2016-05-03 07:14:07 -0400</when>
            <comment_text>To clear: "the debugger could refrain from installing..."</comment_text>
        </comment>
        <comment>
            <comment_id>2702703</comment_id>
            <comment_count>4</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-05-04 02:30:44 -0400</when>
            <comment_text>(In reply to Thomas  Mäder from comment #3)
&gt; To clear: "the debugger could refrain from installing..."

You mean, debugger could refrain from installing breakpoints if it is not reachable ? 

Generally breakpoints are installed before it becomes unreachable as Rob has also mentioned.</comment_text>
        </comment>
        <comment>
            <comment_id>2702720</comment_id>
            <comment_count>5</comment_count>
            <who>Thomas  Mäder</who>
            <commenter_username>t.s.maeder</commenter_username>
            <when>2016-05-04 03:22:09 -0400</when>
            <comment_text>1) Yes that's what I mean. 
2) The debugger could remove/reinstall breakpoints on replaced classes. That's actually the workaround I have implemented.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492307</id>
        <developer>Sebastien Arod</developer>
        <developer_username>sebastien.arod</developer_username>
        <dup_id/>
        <creation_time>2016-04-23 16:32:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Inline Debugging feature similar to Intellij or Chrome Debugger</short_desc>
        <thetext>IntelliJ as a nice feature named "Inline Debugging" that allows to display at each end of lines the current values of the variables used on the lines.

Google Chrome debuggerhave a similar feature.

All the values are already available in the eclipse "Variables" view but when trying to understand code it's nice to have the relevant debug values displayed at the end of the line.</thetext>
    </bug>
    <bug>
        <id>492461</id>
        <developer>Sarika Sinha</developer>
        <developer_username>sarika.sinha</developer_username>
        <dup_id/>
        <creation_time>2016-04-26 11:19:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>[console] ConsolePatternMatcher causes large delays with some large input -further improvementss</short_desc>
        <thetext>Follow up from Bug 17588
@Matej,
If you want to take this up, it can be assigned to you!</thetext>
    </bug>
    <bug>
        <id>493419</id>
        <developer>Michael Vorburger</developer>
        <developer_username>mike</developer_username>
        <dup_id/>
        <creation_time>2016-05-11 08:09:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Edit Source Lookup Path broken: Flickers but then reverts because of some minor internal exception which should probably be ignored (caught, logged, move on..)</short_desc>
        <thetext>Created attachment 261642
brief screencast video illustrating the problem

Please see the brief screencast video I'll attach:

In debugger, "Source not found" (OK, it's right; because this happens when launching a hosted Eclipse which runs an M2E Plugin which I'd like to debug), so "Edit Source Lookup Path..." to add the required Project.  

It appears to finds it, and for a microsecond opens the correct Java (it's too quick to see if it's fully successful, but it does open something), but the the JDT "Java Model Exception" shown below occurs and the editor closes again.

Couldn't and shouldn't it, despite the "Java Model Exception" (which can still be caught, logged, move on..) keep the editor open?

Or should it give a clearer higher-level end-user understandable explanation why the source can still not be found?  Please note that the workspace where these source projects are has no red.


Java Model Exception: Java Model Status [org.opendaylight.yangide.org.opendaylight.yangide.feature does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newJavaModelException(JavaElement.java:566)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:247)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:316)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:302)
	at org.eclipse.jdt.internal.core.JavaElement.getChildren(JavaElement.java:257)
	at org.eclipse.jdt.internal.core.JavaProject.getPackageFragmentRoots(JavaProject.java:1850)
	at org.eclipse.pde.launching.PDESourcePathProvider.addBinaryPackageFragmentRoots(PDESourcePathProvider.java:125)
	at org.eclipse.pde.launching.PDESourcePathProvider.resolveClasspath(PDESourcePathProvider.java:101)
	at org.eclipse.jdt.internal.launching.RuntimeClasspathProvider.resolveClasspath(RuntimeClasspathProvider.java:65)
	at org.eclipse.jdt.launching.JavaRuntime.resolveSourceLookupPath(JavaRuntime.java:838)
	at org.eclipse.jdt.launching.sourcelookup.containers.JavaSourcePathComputer.computeSourceContainers(JavaSourcePathComputer.java:58)
	at org.eclipse.debug.internal.core.sourcelookup.SourcePathComputer.computeSourceContainers(SourcePathComputer.java:71)
	at org.eclipse.debug.core.sourcelookup.containers.DefaultSourceContainer.createSourceContainers(DefaultSourceContainer.java:117)
	at org.eclipse.debug.core.sourcelookup.containers.CompositeSourceContainer.getSourceContainers(CompositeSourceContainer.java:133)
	at org.eclipse.debug.core.sourcelookup.containers.CompositeSourceContainer.findSourceElements(CompositeSourceContainer.java:48)
	at org.eclipse.debug.core.sourcelookup.AbstractSourceLookupParticipant.findSourceElements(AbstractSourceLookupParticipant.java:70)
	at org.eclipse.debug.core.sourcelookup.AbstractSourceLookupDirector$SourceLookupQuery.run(AbstractSourceLookupDirector.java:142)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.debug.core.sourcelookup.AbstractSourceLookupDirector.doSourceLookup(AbstractSourceLookupDirector.java:505)
	at org.eclipse.debug.core.sourcelookup.AbstractSourceLookupDirector.getSourceElement(AbstractSourceLookupDirector.java:785)
	at org.eclipse.pde.internal.launching.sourcelookup.PDESourceLookupDirector.getSourceElement(PDESourceLookupDirector.java:67)
	at org.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility.lookup(SourceLookupFacility.java:344)
	at org.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility$SourceLookupJob.run(SourceLookupFacility.java:741)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)</thetext>
    </bug>
    <bug>
        <id>494481</id>
        <developer>rektide</developer>
        <developer_username>rektide</developer_username>
        <dup_id/>
        <creation_time>2016-05-24 15:53:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>[1.9]Java9 JRE reports "Target is not a JDK root. System library was not found"</short_desc>
        <thetext>Hello. I've tried using both Eclipse Neon RC2[1] and Eclipse Mars.2 + the 4.5-P update site for Java 9 support[2], and neither is willing to use either my distro's Java9 (9b116) nor the most recent available from Oracle's site (9b119). In all cases, from Preferences-&gt;Java-&gt;Installed JREs-&gt;Add, I pick the target JDK as JRE home, and get this error condition in the "JRE Definition" window:

"Target is not a JDK root. System library was not found."

I'd really like to start working with Java 9, &amp; hope this can get resolved. Thanks. I did a quick look at Eclipse running under strace last night and didn't see any obvious files it was looking for. I dno't know what the "system library" that can't be found is, but it didn't- to my novice eyes- seem to be a file inside the JDK directory.

[1] http://marketplace.eclipse.org/content/java-9-support-beta-neon
[2] https://www.eclipse.org/community/eclipse_newsletter/2015/june/article4.php</thetext>
        <comment>
            <comment_id>2711849</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-24 23:01:58 -0400</when>
            <comment_text>We are aware of this issue and it's been noted elsewhere that the JDK/JRE are still changing in ways that breaks Eclipse and other tools. 

We will look at it soon after Neon is shipped.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>494533</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-05-25 08:57:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>JDIDebugUIPlugin#showPreferencePage(String) needs to take a parent Shell</short_desc>
        <thetext>(from bug 478975's review comments on https://git.eclipse.org/r/#/c/73419/ )

JDIDebugUIPlugin#showPreferencePage(String) needs to take a parent Shell as argument. It cannot just use the active workbench window, since there are cases where this method is called from a dialog.

Visible effects in Project properties -&gt; Java build path -&gt; Libraries Tab -&gt; Add library -&gt; JRE System Library -&gt; Click on Installed JREs or Environments:

- Mac OS X 10.11 in full-screen mode: Preference dialog opens behind Add Library dialog.

- Windows 7: After closing the preference dialog, the workbench window gets activated (but doesn't accept input events, because it's blocked by the modal dialog).

All callers of JDIDebugUIPlugin#getActiveWorkbenchShell() need to be checked for similar problems. The Javadoc of that method needs to warn about this problem and advise callers to consider getting the proper shell from their context.</thetext>
    </bug>
    <bug>
        <id>494622</id>
        <developer>Mickael Istria - away until ...</developer>
        <developer_username>mistria</developer_username>
        <dup_id/>
        <creation_time>2016-05-26 06:15:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Relabel "Display" view</short_desc>
        <thetext>It seems like some users, even advanced ones, do not get that they can write/run/debug arbitrary Java code from the Display view. I believe it's mostly because the view name doesn't emphasize the features.
Eclipse IDE should consider something using something more explicit

Some proposals:
* Java Scratchpad (for Debug)
* Java Interpreter (for Debug)
* Java Shell (for Debug)</thetext>
        <comment>
            <comment_id>2721458</comment_id>
            <comment_count>1</comment_count>
            <who>Mickael Istria - away until ...</who>
            <commenter_username>mistria</commenter_username>
            <when>2016-06-17 01:48:37 -0400</when>
            <comment_text>What about just "Java Notes" ?</comment_text>
        </comment>
        <comment>
            <comment_id>2721476</comment_id>
            <comment_count>2</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-06-17 03:00:51 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/75438</comment_text>
        </comment>
        <comment>
            <comment_id>2723209</comment_id>
            <comment_count>3</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-06-23 05:45:40 -0400</when>
            <comment_text>Adding Dani for his comments.</comment_text>
        </comment>
        <comment>
            <comment_id>2737252</comment_id>
            <comment_count>4</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-08-04 11:47:09 -0400</when>
            <comment_text>We should figure out what the real difference between the Scrapbook Page and the Display view is, and whether we can merge them.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495861</id>
        <developer>Joel DRIGO</developer>
        <developer_username>joel.drigo</developer_username>
        <dup_id/>
        <creation_time>2016-06-10 06:16:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>improving debugging lambdas(or any code sequence) within streams</short_desc>
        <thetext>Hi!

Debugging Java 8 streams could be tricky and I would like to call for proposals and implementing something to help it.

My ideas are :
- could be able to add break point into the stream method parameter.
By exemple :
stream.filter(s-&gt; somePredicate(s))
      .map([put a breakpoint here]String::toUpperCase)
      .collect(/*something...*/)

- hide stream internal stacktrace code (like pipelines), or highlight my code and lambdas in debugging stacktrace</thetext>
        <comment>
            <comment_id>2719346</comment_id>
            <comment_count>1</comment_count>
            <who>Joel DRIGO</who>
            <commenter_username>joel.drigo</commenter_username>
            <when>2016-06-10 08:52:50 -0400</when>
            <comment_text>Patrik, I added you in CC</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496520</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-06-22 01:20:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>[1.9] Redesign VM to adapt JRE 1.9</short_desc>
        <thetext>As bug 489207 shows, the boot classpath is no longer available. And the system libraries are no longer a bunch of JAR files but internal to the JVM. All the StandardVM* classes should reflect this. Perhaps a new kind of VM could be an option. Another possibility is to simply let the VM exist without any libraries and let the clients handle it.

In any case, JREContainer needs to adapt and provide a better implementation of getClasspathEntries().

This will most likely require changes in JDT Core. Classpath resolution should find a way to handle the library-less JREContainer. Ideally we would come up with a new IClasspathEntry#getEntryKind(), but looks like that route is closed with the API definitions.</thetext>
    </bug>
    <bug>
        <id>496528</id>
        <developer>Luke Hutchison</developer>
        <developer_username>luke.hutch</developer_username>
        <dup_id/>
        <creation_time>2016-06-22 04:29:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Ctrl+Shift+C and Ctrl+Shift+V should do the same things as Ctrl+C and Ctrl+V to minimize confusion</short_desc>
        <thetext>In 4.6M6, Ctrl+Shift+V was bound to "Open from Clipboard". It's extremely easy to accidentally type this instead of Ctrl+V when you want to paste, if you have been copying/pasting text from/to a console window.

Ideally, Ctrl+Shift+C would just copy, and Ctrl+Shift+V would just paste, so that if you accidentally get it wrong, Eclipse will still do what you probably intended.

I believe this is important because copying and pasting are some of the most common and fundamental actions to want to use shortcut keys for, and it's so easy to accidentally trigger "Open from Clipboard" instead of pasting. (I watched another engineer trigger this multiple times today, and she had a puzzled look on her face each time it happened -- it's not just me!)</thetext>
        <comment>
            <comment_id>2724254</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-06-27 04:56:38 -0400</when>
            <comment_text>Caused by the fix in Bug 487575.
Dani, Please suggest.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497205</id>
        <developer>Gary Knutson</developer>
        <developer_username>Den.Gar.bub</developer_username>
        <dup_id/>
        <creation_time>2016-07-03 19:39:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>hello world  locked up</short_desc>
        <thetext>ran the Hello World program forget to check main method box and cannot get out of it</thetext>
        <comment>
            <comment_id>2726671</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-07-03 23:37:06 -0400</when>
            <comment_text>What do you mean by "cannot get out of it" ?

You are not able to create main method or you are not bale to get out of the dialog ?
Please describe the bug in detail.</comment_text>
        </comment>
        <comment>
            <comment_id>2726715</comment_id>
            <comment_count>2</comment_count>
            <who>Gary Knutson</who>
            <commenter_username>Den.Gar.bub</commenter_username>
            <when>2016-07-04 04:07:48 -0400</when>
            <comment_text>cannot get out of the dialog cannot change anything or run anything in this Hello World
introduction every thing is automatically generated with prompts and statements are
provided - you follow along it just so happened that I missed prompt to provide main
method which is obtained by check marking a box after check marking a box which provided the HelloWorld class - the program will not allow you to go back thru and make
changes</comment_text>
        </comment>
        <comment>
            <comment_id>2726718</comment_id>
            <comment_count>3</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-07-04 04:10:35 -0400</when>
            <comment_text>Please provide the exact steps to reproduce.</comment_text>
        </comment>
        <comment>
            <comment_id>2726809</comment_id>
            <comment_count>4</comment_count>
            <who>Gary Knutson</who>
            <commenter_username>Den.Gar.bub</commenter_username>
            <when>2016-07-04 09:14:43 -0400</when>
            <comment_text>it looks like I'm not able to save changes after inserting method and println</comment_text>
        </comment>
        <comment>
            <comment_id>2727030</comment_id>
            <comment_count>5</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-07-04 22:29:25 -0400</when>
            <comment_text>(In reply to Gary Knutson from comment #4)
&gt; it looks like I'm not able to save changes after inserting method and println

Please provide the exact steps from starting to reproduce. Which Version of Eclipse are you using? What else did you install. We can not understand the problem if you don't provide all the details.</comment_text>
        </comment>
        <comment>
            <comment_id>2727342</comment_id>
            <comment_count>6</comment_count>
            <who>Gary Knutson</who>
            <commenter_username>Den.Gar.bub</commenter_username>
            <when>2016-07-05 13:47:21 -0400</when>
            <comment_text>computer is iMac )SX 10.11.5- JDK 1.80 92 - Java Neon -Eclipse Neon 4.6.0

    In welcome menu of eclipse signed on to Hello World to create first program using
the cheat sheets feature which auto generates statement and responses create java 
project create HelloWorld class and main method(First Time around I forget to check box
for main method) Add print statement run java application which did not work because
it did not have main method - So i went thru process again hitting redo promo and i 
came up with this HelloWorld.java x
                      public class HelloWorld{
                          public static void main(String[]args){
                      System.out.println("Hellow world!");
 then I hit save and launched and message Launch error- Editor does not contain a main
type</comment_text>
        </comment>
        <comment>
            <comment_id>2729148</comment_id>
            <comment_count>7</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-07-11 02:45:02 -0400</when>
            <comment_text>I can not reproduce the problem.

At which step did you try "redo" ?
Is the name of the file same in first and redo attempt ? 
Is the build automatically on?</comment_text>
        </comment>
        <comment>
            <comment_id>2729322</comment_id>
            <comment_count>8</comment_count>
            <who>Gary Knutson</who>
            <commenter_username>Den.Gar.bub</commenter_username>
            <when>2016-07-11 10:22:42 -0400</when>
            <comment_text>I think that is the crux of the whole problem you have to make the error of not checking main method first time on the hello world cheat sheet first time thru and      
then go to hello world cheat sheet and create java protect and then hit redo prompt</comment_text>
        </comment>
        <comment>
            <comment_id>2729325</comment_id>
            <comment_count>9</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-07-11 10:27:20 -0400</when>
            <comment_text>(In reply to Gary Knutson from comment #8)
&gt; I think that is the crux of the whole problem you have to make the error of
&gt; not checking main method first time on the hello world cheat sheet first
&gt; time thru and      
&gt; then go to hello world cheat sheet and create java protect and then hit redo
&gt; prompt

Yes I did the same but my question was at what point did you apply redo ?
did you put the same file name again? is the automatic buil on?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498004</id>
        <developer>David Winter</developer>
        <developer_username>1029384756nexus</developer_username>
        <dup_id/>
        <creation_time>2016-07-16 13:31:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>only 32 bit version</short_desc>
        <thetext>There is only 32 bit version on yore site. 
the 64 bit version link download's the 32 bit version
why????</thetext>
        <comment>
            <comment_id>2731205</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-07-17 23:17:24 -0400</when>
            <comment_text>Which link are you referring to ?
Try
https://www.eclipse.org/downloads/</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498188</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-07-20 06:08:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Feature to put a breakpoint in all the search results</short_desc>
        <thetext>Need a facility where I can put a breakpoint in all the statements in the search results wherever applicable (say Javadoc results are not for eg)

An old so link also says - http://stackoverflow.com/questions/29336540/breakpoint-on-search-results-in-eclipse</thetext>
        <comment>
            <comment_id>2732402</comment_id>
            <comment_count>1</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-07-21 00:16:09 -0400</when>
            <comment_text>(In reply to Manoj Palat from comment #0)
&gt; Need a facility where I can put a breakpoint in all the statements in the
&gt; search results wherever applicable (say Javadoc results are not for eg)
&gt; 
&gt; An old so link also says -
&gt; http://stackoverflow.com/questions/29336540/breakpoint-on-search-results-in-
&gt; eclipse

An additional requirement would be to put the breakpoint in the next statement (wherever possible) as explained below:

use_case:
Consider a search for a write access of a variable/field f and assume we have the result:

 f = fill_the_value();
 use_field(f);

It would save one step if the breakpoint is enable at the use_field(f);
In cases where the statement is at the end of a block, the default could be the statement itself.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498365</id>
        <developer>Donald Dunne</developer>
        <developer_username>donald.g.dunne</developer_username>
        <dup_id/>
        <creation_time>2016-07-22 13:54:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Add collapse all to Debug View</short_desc>
        <thetext>I work on eclipse.org/osee and we develop a client server architecture.  Because of this, we run/debug a server, a client and sometimes a test suite.  When these are launched, the Debug window expands out all the threads.  This requires us to manually collapse the ones we're not interested in, so we can see the one.  Either allow launched items to be collapsed by default and only expand when breakpoint is hit, or provide collapse all so it's more easily done.</thetext>
        <comment>
            <comment_id>2733172</comment_id>
            <comment_count>1</comment_count>
            <who>Donald Dunne</who>
            <commenter_username>donald.g.dunne</commenter_username>
            <when>2016-07-22 14:32:25 -0400</when>
            <comment_text>I also use the debug toolbar and love to be able to select the running application and kill it from there.  Having to collapse each item or scroll down to the main thread takes a lot of time throughout a day of debugging.</comment_text>
        </comment>
        <comment>
            <comment_id>2733334</comment_id>
            <comment_count>2</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-07-25 01:28:27 -0400</when>
            <comment_text>That's a nice suggestion.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498428</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-07-25 08:19:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>"Run to Line" on Ctrl+Alt+Click in annotation/line number rulers</short_desc>
        <thetext>Add "Run to Line" on Ctrl+Alt+Click in annotation/line ruler.

For "Step Into", there's already a Ctrl+Alt+Click hyperlink that works in the editor's text area. A nice complement for that would be a "Run to Line" action in the annotation and line number rulers that would also work on Ctrl+Alt+Click.

To make the feature discoverable, a "Run to Line" action should be added to the context menu, with shortcut "Ctrl+Alt+Click". See the existing "Enable/Disable Breakpoint" and "Breakpoint Properties..." actions with their *+Click shortcuts.</thetext>
        <comment>
            <comment_id>2734002</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-07-26 20:31:18 -0400</when>
            <comment_text>This change request emerged based on a scientific study on how developers debug, in discussion with Daniel Megert, Markus Keller, Sarika Sinha, and Moritz Beller.
Link to the study  -
http://repository.tudelft.nl/islandora/object/uuid%3Abf3325ce-f246-4977-91bc-785f877347b8?collection=education</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498433</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-07-25 09:29:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Templates like ${enclosing_type} can't resolve context in conditional breakpoints editor</short_desc>
        <thetext>Try to insert the "systrace" template in a conditional breakpoint expression. It will just yield this, instead of properly filling in the context variables:

System.out.println("enclosing_type.enclosing_method()");

Expected for a breakpoint in p.q.MyType#foo(): 

System.out.println("MyType.foo()");

The problem is that org.eclipse.jdt.internal.corext.template.java.CompilationUnitContextType.EnclosingJavaElement#resolve(TemplateContext) is called with a JavaContext whose fCompilationUnit is null, so the context is lost.

org.eclipse.jdt.internal.debug.ui.contentassist.JavaDebugContentAssistProcessor#computeCompletionProposals(ITextViewer, int) probably needs to pass a non-null CU when calling TemplateEngine#complete(ITextViewer, int, ICompilationUnit).

The hard part is that this probably cannot be the actual ICompilationUnit, because that
- would allow template variables like the ImportsResolver to modify a CU that should not be modified, and
- would not work for breakpoints in class files with attached source

JavaDebugContentAssistProcessor#computeCompletionProposals(..) already knows the enclosing "IType type". This could be a starting point for passing on the required context, and TemplateContext#fReadOnly could help avoiding unwanted non-local edits. Another solution could be to actually create a new working copy and then disregard non-local changes.</thetext>
    </bug>
    <bug>
        <id>498928</id>
        <developer>Luke Usherwood</developer>
        <developer_username>ldubox-coding101</developer_username>
        <dup_id/>
        <creation_time>2016-07-31 07:05:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>A character in the 'Display' view can destroy the Workspace layout</short_desc>
        <thetext>== Simplified steps: ==

 1. Create some executable Java code:
 
   e.g. paste the string "return;" into the package explorer view

 2. Place a breakpoint in the code and debug it.

 3. In the 'Display' view, enter the text "(char) -1" and press Ctrl+Shift+D to evaluate and display the result of the expression

== Observed ==

 a) Errors start appearing periodically that the automatic workbench save is failing, and again on close. 

 b) The workbench file is zero-length:
 
     ...\.metadata\.plugins\org.eclipse.e4.workbench\workbench.xmi

 c) The layout is lost &amp; reverts to default

I'd like to comment that I've encountered various problems with the workspace layout being lost and corrupted over the years, so this is another chapter in the ongoing saga. I consider this a serious "loss of user data" type of bug.

== Requests ==

 A. Could you please save the workspace layout data to a temporary file &amp; rename it into place only if everything succeeds? That would then be robust against a whole class of such problems. (I'm happy for the errors to still be displayed visibly, but just not to lose my hand-crafted layouts.)

 B. Plug holes in escaping of characters which can be printed to the Display when debugging

== Diagnostics ==

The following can be found in the log:

!ENTRY org.eclipse.osgi 4 0 2016-07-31 12:40:50.540
!MESSAGE Application error
!STACK 1
java.lang.RuntimeException: An invalid XML character (Unicode: 0xffff) was found in the element content:&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;view&gt;(char) 65535&amp;#x0D;&amp;#x0A;&amp;#x09; (char) &lt;/view&gt;
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl$Escape.convert(XMLSaveImpl.java:3417)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.getDatatypeValue(XMLSaveImpl.java:3113)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveDataTypeSingle(XMLSaveImpl.java:1698)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveFeatures(XMLSaveImpl.java:1280)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveFeatures(XMLSaveImpl.java:1224)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveElementID(XMLSaveImpl.java:2716)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveElement(XMLSaveImpl.java:1181)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveElement(XMLSaveImpl.java:1042)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveContainedMany(XMLSaveImpl.java:2417)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveFeatures(XMLSaveImpl.java:1553)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveFeatures(XMLSaveImpl.java:1224)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveElementID(XMLSaveImpl.java:2716)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveElement(XMLSaveImpl.java:1181)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveElement(XMLSaveImpl.java:1042)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveContainedMany(XMLSaveImpl.java:2417)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveFeatures(XMLSaveImpl.java:1553)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveFeatures(XMLSaveImpl.java:1224)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveElementID(XMLSaveImpl.java:2716)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveElement(XMLSaveImpl.java:1181)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveElement(XMLSaveImpl.java:1042)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveContainedMany(XMLSaveImpl.java:2417)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveFeatures(XMLSaveImpl.java:1553)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveFeatures(XMLSaveImpl.java:1224)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.saveElementID(XMLSaveImpl.java:2716)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.writeTopObject(XMLSaveImpl.java:683)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.traverse(XMLSaveImpl.java:591)
	at org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl.save(XMLSaveImpl.java:251)
	at org.eclipse.emf.ecore.xmi.impl.XMLResourceImpl.doSave(XMLResourceImpl.java:389)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.save(ResourceImpl.java:1430)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.save(ResourceImpl.java:999)
	at org.eclipse.e4.ui.internal.workbench.ResourceHandler.save(ResourceHandler.java:218)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application.saveModel(E4Application.java:187)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
!SESSION 2016-07-31 12:47:12.298 -----------------------------------------------
eclipse.buildId=4.6.0.I20160606-1100
java.version=1.8.0_92
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_NZ
Command-line arguments:  -os win32 -ws win32 -arch x86_64</thetext>
        <comment>
            <comment_id>2735848</comment_id>
            <comment_count>1</comment_count>
            <who>Luke Usherwood</who>
            <commenter_username>ldubox-coding101</commenter_username>
            <when>2016-07-31 07:17:08 -0400</when>
            <comment_text>On re-read I sound very negative there, sorry! Just trying to be brief but accurate. On the whole I'm very happy with all the effort that's gone into e4 &amp; the improvements its brought. :-)</comment_text>
        </comment>
        <comment>
            <comment_id>2746335</comment_id>
            <comment_count>2</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-09-02 03:41:55 -0400</when>
            <comment_text>Sounds like something JDT should catch. Moving to them for investigation.</comment_text>
        </comment>
        <comment>
            <comment_id>2746400</comment_id>
            <comment_count>3</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-09-02 06:13:23 -0400</when>
            <comment_text>I could not reproduce it.
Lars, you were able to reproduce it ?

Luke, Are you able to reproduce it on a new Workspace with Eclipse SDK ?</comment_text>
        </comment>
        <comment>
            <comment_id>2746426</comment_id>
            <comment_count>4</comment_count>
            <who>Luke Usherwood</who>
            <commenter_username>ldubox-coding101</commenter_username>
            <when>2016-09-02 07:57:40 -0400</when>
            <comment_text>Yes I reproduced it in a clean workspace, getting an error message when shutting down.

I'm using "Eclipse SDK" Neon as my base, with various other plugins.

Is text encoding relevant? Being on Windows, I see these preferences...

 [General &gt; Workspace] Text file encoding: Default, Cp1251

 [XML &gt; XML Files] Encoding: UTF-8</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498988</id>
        <developer>Andrey Loskutov</developer>
        <developer_username>loskutov</developer_username>
        <dup_id/>
        <creation_time>2016-08-01 09:10:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>[releng] Dirty git status after build in eclipse.jdt.debug</short_desc>
        <thetext>I'm trying to build JDT as part of the SDK build and I see that after the (failed) build "git status" reports:

cd eclipse.jdt.debug
git status
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

        org.eclipse.jdt.debug/jdi.jar
        org.eclipse.jdt.debug/jdimodel.jar

Ideally this should not happen, build should not create "untracked" files - they either should be deleted if they are temporary artifacts, or ignored. 
I will post a patch with modified .gitignore file in a moment.</thetext>
        <comment>
            <comment_id>2736155</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-08-01 09:11:50 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/78259</comment_text>
        </comment>
        <comment>
            <comment_id>2736216</comment_id>
            <comment_count>2</comment_count>
            <who>Alexander Kurtakov</who>
            <commenter_username>akurtakov</commenter_username>
            <when>2016-08-01 12:15:53 -0400</when>
            <comment_text>I really believe these files should be produced in target/ instead of gitignoring them.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499352</id>
        <developer>Rainer Klute</developer>
        <developer_username>rainer.klute</developer_username>
        <dup_id/>
        <creation_time>2016-08-08 05:34:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>List of installed JREs is empty</short_desc>
        <thetext>Under certain (and unclear) circumstances JDT does not find even a single JRE, i.e. the list of installed JREs is empty (Window → Preferences → Java → Installed JREs).

However, since Eclipse has been started successfully, at least one JRE is necessarily installed somewhere and should be included in the list.</thetext>
        <comment>
            <comment_id>2738085</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-08 05:55:08 -0400</when>
            <comment_text>Anything in the error log that would give us some hint?</comment_text>
        </comment>
        <comment>
            <comment_id>2738093</comment_id>
            <comment_count>2</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-08-08 06:23:43 -0400</when>
            <comment_text>Can you reproduce it with a new workspace?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500137</id>
        <developer>Elias Anderman</developer>
        <developer_username>kosmosprime</developer_username>
        <dup_id/>
        <creation_time>2016-08-23 10:50:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Breakpoints don't get highlighted if the debug view wasn't active before</short_desc>
        <thetext>If eclipse is set to not switch to the debug perspective and not open the debug view, when a breakpoint is hit but the debug view has not been open before, the breakpoint does work but eclipse does not highlight the line or allow you to inspect the values of variables by hovering the mouse cursor over them.
Switching to the debug perspective (which contains the debug view) or adding it fixes this, even if you switch back to the java view or close the debug view before starting the program. Restarting eclipse causes the bug to appear again.

Steps to reproduce:
1) In the preferences, under "Run/Debug", untick "Activate the debug view when a breakpoint is hit".
2) In the preferences, under "Run/Debug" -&gt; "Launching", set "Launch in debug mode when workspace contains breakpoints" to "Never".
3) In the preferences, under "Run/Debug" -&gt; "Perspectives", set "Open the associated perspective when launching" and "Open the associated perspective when an application suspends" to "Never".
4) Restart Eclipse.
5) Place a breakpoint in a location which gets executed (the program does not matter).
6) Launch the associated program.

This bug is by no means important as, when it occurs, simply switching to the debug view solves it. The error log view does not display any errors associated with the problem, so it likely has something to do with certain components not being initialized ahead of time.</thetext>
    </bug>
    <bug>
        <id>500648</id>
        <developer>Andreas Sewe</developer>
        <developer_username>andreas.sewe</developer_username>
        <dup_id/>
        <creation_time>2016-09-01 05:31:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Primitive Display Options description wrong (supports Unicode, not just ASCII)</short_desc>
        <thetext>Created attachment 263886
Variables view showing Unicode value for int &gt; 127

On the Java &gt; Debug &gt; Primitive Display Options preference page, there's an option called

  Display ASCII character values (byte, short, int, long)

AFAICT, this works for numbers &gt; 127 (the ASCII range) as well (see screenshot). I assume the option works for the entire Unicode range (unless it uses some kind of local encoding). If so, the preference page should say so.</thetext>
    </bug>
    <bug>
        <id>501059</id>
        <developer>David Georg Reichelt</developer>
        <developer_username>davidgeorg_reichelt</developer_username>
        <dup_id/>
        <creation_time>2016-09-08 06:06:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Buttons are not disabled after program end / debugging end and displayed in wrong place</short_desc>
        <thetext>Created attachment 264026
Bug in Debugmode

Both when debugging an application and when just starting it and displaying its output in the console, the buttons do not look disabled after program end.

Furthermore, in the console view, they are displayed twice.

This behaviour seems to occur on eclipse neon and ubuntu 16.04 not only for me: http://askubuntu.com/questions/822104/eclipse-neon-icons-are-not-disabled .

I attach a picture of the bug in the console view.</thetext>
    </bug>
    <bug>
        <id>501168</id>
        <developer>Carsten Reckord</developer>
        <developer_username>reckord</developer_username>
        <dup_id/>
        <creation_time>2016-09-09 14:24:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Unable to override contributed logical structure definitions</short_desc>
        <thetext>It is no longer possible to override contributed logical structure definitions with custom ones.

I used to have custom logical structure definitions, e.g. for java.util.Map with separate child variables for keySet(), entrySet() and values(). This is no longer possible. The logical structure definition for java.util.Map contributed by jdt.debug can neither be edited nor removed. A new definition for the same type is disregarded in favor of the contributed definition.

I'm not sure in which JDT version this broke. I had to redo my workspace setup a while ago and never got around to configuring my custom definitions. Now I took the opportunity after updating to Neon, and realized that this was broken.</thetext>
    </bug>
    <bug>
        <id>501620</id>
        <developer>Key Lawson</developer>
        <developer_username>key.lawson</developer_username>
        <dup_id/>
        <creation_time>2016-09-16 18:11:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Local variable Debug expressions don't work</short_desc>
        <thetext>After entering a simple debug expression, like variable name: c2

I get in red '&lt;error(s)_during_the_evaluation', and --

Puzzle19 [in K [in [Working copy] K$Puzzle19.java [in &lt;default&gt; [in src [in K$Puzzle19]]]]] does not exist	

---

The problem seems to be my using a '$' in the project and class names. 
I created project and class 'KPuzzle19', copied and renamed my source file, 
and the same debug expressions worked properly.</thetext>
    </bug>
    <bug>
        <id>502132</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-09-26 04:42:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>show monitors do not work</short_desc>
        <thetext>Created attachment 264404
Code to be used for debugging to reproduce the error

the monitors of deadlocked thread are not shown if "show monitors" option is put on.

Steps to reproduce:

Use the attached code.
put a breakpoint at syso ("hello world");
debug
in debug view -&gt; drop down -&gt; Java -&gt; show monitors.

Expected output is similar to what is shown at http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Ftips%2Fjdt_tips.html&amp;cp=1_5_6&amp;anchor=debugging_section, sub-section on "Threads and Monitors".</thetext>
    </bug>
    <bug>
        <id>505327</id>
        <developer>Marc Schlegel</developer>
        <developer_username>marc.schlegel</developer_username>
        <dup_id/>
        <creation_time>2016-10-07 03:13:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Debug expressions broken when source is located in OSGI-OPT/src of JAR</short_desc>
        <thetext>Created attachment 264683
Screenshot showing expression failure in Watch/Display view

Eclipse provides a feature where sources for a artefact (osgi-bundle) can be placed inside the artefact under OSGI-OPT/src. The debugger is able to pick the sources without having to handle source-attachments in the BuildPath.

This feature is heavily used by the BndTools/OSGi community.

Currently when setting a breakpoint within a module which has its source included under OSGI-OPT/src, the debugger stops at the correct location and displays all variables.
Now it is not possible to evaluate any expression! Adding a watch-expression based on a current variable fails as does any expression in the Display-view.

Furthermore there is no content-assist for anything beyond the currently available variable.

Please see attached screenshot. The example was done with the latest MyFaces-Impl from Maven (debug information is available) which was enhanced with sources.

BndTools does nothing special about the debugger. They completely rely on the feature provided by Eclipse (see discussion here: https://groups.google.com/forum/#!topic/bndtools-users/zn6x8lOjCms)</thetext>
    </bug>
    <bug>
        <id>505558</id>
        <developer>Lon Milner</developer>
        <developer_username>antiquesters</developer_username>
        <dup_id/>
        <creation_time>2016-10-07 13:33:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Debug JavaFX MPEG-4 audio Invalid Play sound and Hangs Debugger</short_desc>
        <thetext>Created attachment 264728
Sample MPEG-4 audio file to demonstrate Eclipse debugger issue

Using Eclipse Neon to play audio files with JavaFX 8 MPEG-4 audio formatted files seems to produce extra sound (possibly related) and hangs up the debugger from doing task suspend or any other Eclipse control. Application can continue following Eclipse termination with Windows forced close. 
The same application works fine for this audio format when using Eclipse Run application and when using both NetBeans IDE and IntelliJ IDEA debuggers. It also worked on Windows 7 and Eclipse versions prior to Luna. The problem can be demonstrated using the EmbeddedMediaPlayer application available from Oracle at: "https://docs.oracle.com/javase/8/javafx/sample-apps/EmbeddedMediaPlayer.zip"
Included is a sample MPEG-4 audio test file that can be used to demonstrate the Eclipse debugger issue described above.</thetext>
    </bug>
    <bug>
        <id>506353</id>
        <developer>David E. Veliev</developer>
        <developer_username>gotoindvdum</developer_username>
        <dup_id/>
        <creation_time>2016-10-21 11:06:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Display view throw an exception on trying to display string with non-latin characters</short_desc>
        <thetext>Created attachment 264996
Screenshot

For example, trying to evaluate string 

&gt; "testД".toString()

leads to an exception

&gt;	Evaluation failed. Reason(s):
&gt;		String index out of range: 18.

Eclipse version information:

&gt; Eclipse Java EE IDE for Web Developers.

&gt; Version: Neon.1a Release (4.6.1)
&gt; Build id: 20161007-1200</thetext>
    </bug>
    <bug>
        <id>506611</id>
        <developer>Ed Willink</developer>
        <developer_username>ed</developer_username>
        <dup_id/>
        <creation_time>2016-10-27 06:52:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>StackOverflow cannot be debugged</short_desc>
        <thetext>When a StackOverflow occurs, the debugger sometimes goes incredibly slow as it endeavours to proceed without any memory. It is generally impractical to actually use the debugger.

Suggest: run the debugger with a 75% limit on the stack usage, so that the remaining 25% can be released to assist in debugging the overflow.</thetext>
    </bug>
    <bug>
        <id>507133</id>
        <developer>pasam soujanya</developer>
        <developer_username>psoujany</developer_username>
        <dup_id/>
        <creation_time>2016-11-07 05:00:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>org.eclipse.jdt.debug.tests.core.LineTrackerTests.testStackTraces failing with AIOBE</short_desc>
        <thetext>org.eclipse.jdt.debug.tests.core.LineTrackerTests.testStackTraces failing with AIOBE while reading last element in the array of JavaExceptionHyperLink instance should be followed by JavaStackTraceHyperlink which is not happening with IBM SDK.

Test worked as expected with Oracle JDK.

Error Trace:
----------------------
&lt;error message="Array index out of range: 201" type="java.lang.ArrayIndexOutOfBoundsException"&gt;java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 201
    at org.eclipse.jdt.debug.tests.core.LineTrackerTests.testStackTraces(LineTrackerTests.java:244)
    at org.eclipse.jdt.debug.tests.AbstractDebugTest.runBare(AbstractDebugTest.java:2466)
    at org.eclipse.jdt.debug.tests.DebugSuite$1.run(DebugSuite.java:57)
    at java.lang.Thread.run(Thread.java:785)
&lt;/error&gt;</thetext>
    </bug>
    <bug>
        <id>507385</id>
        <developer>Lars Vogel</developer>
        <developer_username>Lars.Vogel</developer_username>
        <dup_id/>
        <creation_time>2016-11-10 18:28:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Keybindings not visible for debug keys</short_desc>
        <thetext>If I hover over one of the debug keys (Resume for example), its keybinding is not displayed in the toolbar.

This works for over toolbar entries, like "Toogle Selection Block".</thetext>
    </bug>
    <bug>
        <id>507420</id>
        <developer>Stefan Xenos</developer>
        <developer_username>sxenos</developer_username>
        <dup_id/>
        <creation_time>2016-11-11 18:32:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Copying-and-pasting from the Debug view is broken</short_desc>
        <thetext>To reproduce:

Launch the debugger on an inner workspace. Pause the debugger. Right-click on a thread in the Debug view.

Select "Copy Stack". Open a text editor. Paste.

Observed:
- You'll paste whatever happenend to be on the clipboard before copying from Eclipse.

Expected:
- Results in pasting the stack trace from the Eclipse debugger.</thetext>
        <comment>
            <comment_id>2775589</comment_id>
            <comment_count>1</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-11-12 03:03:34 -0500</when>
            <comment_text>sounds like bug 495461, but this is already fixed for some time. what version do you use?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507829</id>
        <developer>Ed Willink</developer>
        <developer_username>ed</developer_username>
        <dup_id/>
        <creation_time>2016-11-20 11:11:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Goto Breakpoint fails</short_desc>
        <thetext>M3: In Breakpoint Page, selecting a (possibly stale) breakpoint set on org.eclipse.emf.ecore.util.EcoreUtil gives about four copies of the error below. Goto file in the menu is greyed out. com.ecme.myprofile does not exist also shows in the corresponding breakpoint properties title.

com.ecme.myprofile is a closed project, upon which EMF does not depend.

org.eclipse.emf.ecore is a closed project but an installed plugin. It has been opened and closed many times. EClipse has been restarted since closing to workaround the presumably well known problem that JDT/PDE incremental build is crippled by a project close =&gt; installed plugin migration.

The repro alluded to above may be complex, but the prolific error log entries must be bad.

Java Model Exception: Java Model Status [com.ecme.myprofile does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newJavaModelException(JavaElement.java:566)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:247)
	at org.eclipse.jdt.internal.core.Openable.openAncestors(Openable.java:505)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:241)
	at org.eclipse.jdt.internal.core.Openable.openAncestors(Openable.java:505)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:241)
	at org.eclipse.jdt.internal.core.Openable.openAncestors(Openable.java:505)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:241)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:316)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:302)
	at org.eclipse.jdt.internal.core.Openable.getBuffer(Openable.java:285)
	at org.eclipse.jdt.internal.core.ClassFile.getBuffer(ClassFile.java:463)
	at org.eclipse.jdt.internal.core.ClassFile.getSource(ClassFile.java:618)
	at org.eclipse.jdt.debug.ui.breakpoints.JavaBreakpointConditionEditor.setBreakpoint(JavaBreakpointConditionEditor.java:275)
	at org.eclipse.jdt.debug.ui.breakpoints.JavaBreakpointConditionEditor.setInput(JavaBreakpointConditionEditor.java:215)
	at org.eclipse.jdt.internal.debug.ui.breakpoints.CompositeBreakpointEditor.setInput(CompositeBreakpointEditor.java:137)
	at org.eclipse.xtext.xbase.ui.debug.XbaseBreakpointDetailPaneFactory$1.display(XbaseBreakpointDetailPaneFactory.java:83)
	at org.eclipse.debug.internal.ui.views.variables.details.DetailPaneProxy.display(DetailPaneProxy.java:117)
	at org.eclipse.debug.internal.ui.views.variables.VariablesView.refreshDetailPaneContents(VariablesView.java:1201)
	at org.eclipse.debug.internal.ui.views.variables.VariablesView$8.selectionChanged(VariablesView.java:1140)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:872)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:173)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:869)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1238)
	at org.eclipse.jface.viewers.StructuredViewer$5.widgetSelected(StructuredViewer.java:1264)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:261)
	at org.eclipse.jface.util.OpenStrategy.access$5(OpenStrategy.java:256)
	at org.eclipse.jface.util.OpenStrategy$1.lambda$1(OpenStrategy.java:426)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:37)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4216)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3823)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1133)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:153)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:698)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)</thetext>
    </bug>
    <bug>
        <id>508524</id>
        <developer>Andrey Loskutov</developer>
        <developer_username>loskutov</developer_username>
        <dup_id/>
        <creation_time>2016-12-01 07:27:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>[hcr] Changing code in unrelated project triggers "Hot Code Replace Failed" dialog</short_desc>
        <thetext>Reproducible from 3.8.2 to 4.7 head.

AS IS: 
1 Create project A with the class 
public class A {
	public static void main(String[] args) {
		return; // &lt;-- breakpoint here
	}
}

2 Copy/paste the project and rename it to A2 (but don't rename the "A" class).
3 Create breakpoint in A/A::main.
4 Right click on A/A class and say Debug As -&gt; Java Application.
5 When the debugger stops at the breakpoint in A/A::main, delete main method from A2/A class and save the editor.
6 At this point "Hot Code Replace Failed" dialog will be shown.

Obviously, the original A class isn't changed at all (the changed resource is from unrelated project), so no dialogs should be shown.

The fix would be similar to the fix for bug 5188, and I think we can reuse some code there. In a long-term I plan to provide a patch.</thetext>
    </bug>
    <bug>
        <id>508707</id>
        <developer>Eric Wells</developer>
        <developer_username>epiqu1n</developer_username>
        <dup_id/>
        <creation_time>2016-12-05 19:11:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Eclipse/Java does not shut down looping JTests</short_desc>
        <thetext>When running JTests, if there is a loop present in the code being tested and no Timeout has been defined, the code will run indefinitely.  Upon trying to stop the tests, the UI will display "Stopping..." but never actually stop the test, causing each instance of this to continue running and use an entire CPU core (and a lot of energy) until either Eclipse is exited or the Java processes are stopped through Activity Monitor.

-- Configuration Details --
Product: Eclipse 4.6.0.20160613-1800 (org.eclipse.epp.package.java.product)
Installed Features:
 org.eclipse.jdt 3.12.0.v20160606-1100</thetext>
        <comment>
            <comment_id>2783092</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-05 23:32:45 -0500</when>
            <comment_text>I am not sure what might be happening. Copying Sarika for response.</comment_text>
        </comment>
        <comment>
            <comment_id>2783103</comment_id>
            <comment_count>2</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-12-06 00:22:49 -0500</when>
            <comment_text>@Eric,
Can you provide any log, call stack or memory dump to confirm that Eclipse is Contributing to this and not JTest ?</comment_text>
        </comment>
        <comment>
            <comment_id>2783447</comment_id>
            <comment_count>3</comment_count>
            <who>Eric Wells</who>
            <commenter_username>epiqu1n</commenter_username>
            <when>2016-12-06 12:04:45 -0500</when>
            <comment_text>Where would I find one of those?</comment_text>
        </comment>
        <comment>
            <comment_id>2783634</comment_id>
            <comment_count>4</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-12-06 23:16:16 -0500</when>
            <comment_text>(In reply to Eric Wells from comment #3)
&gt; Where would I find one of those?

You can find the last stacktrace in Error Logs View.

For getting dump, you can refer to
https://wiki.eclipse.org/How_to_report_a_deadlock</comment_text>
        </comment>
        <comment>
            <comment_id>2784500</comment_id>
            <comment_count>5</comment_count>
            <who>Eric Wells</who>
            <commenter_username>epiqu1n</commenter_username>
            <when>2016-12-08 11:46:15 -0500</when>
            <comment_text>There are no errors in the error log when this happens.  I just noticed that if I click the stop button in the JUnit window, it will go gray and display "Stopping..." (as in the image I linked to originally), but will not actually stop it.  However, if I click the stop button that is in the console view, it does actually terminate the program.</comment_text>
        </comment>
        <comment>
            <comment_id>2784529</comment_id>
            <comment_count>6</comment_count>
            <who>Eric Wells</who>
            <commenter_username>epiqu1n</commenter_username>
            <when>2016-12-08 12:41:30 -0500</when>
            <comment_text>Created attachment 265781
Heap dump</comment_text>
        </comment>
        <comment>
            <comment_id>2784864</comment_id>
            <comment_count>7</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-12-09 08:28:45 -0500</when>
            <comment_text>(In reply to Eric Wells from comment #6)
&gt; Created attachment 265781 [details]
&gt; Heap dump

Can't get any help from this as it does not tell the threads which were active at that time.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508722</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-12-06 04:35:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Breakpoint Groups are always sorted by name</short_desc>
        <thetext>Eclipse SDK
Version: Oxygen (4.7)
Build id: I20161205-2000
OS: Windows 7, v.6.1, x86_64 / win32

- Create two files A.java and B.java in a package 'p'.
- Add class load breakpoint to A.java first and then add it to B.java.
- Breakpoints view &gt; Sort By &gt; Creation Time. It lists p.B first and then p.A, which is expected.
- Now, create two breakpoint working sets one by one: "A" containing the breakpoint from A.java. Then, "B" containing the breakpoint from B.java.
- Breakpoints view &gt; Group By &gt; Breakpoint Working Sets. It shows A first with p.A and then B with p.B, which changes the previous breakpoints sort order.

The Groups are always sorted by name so the breakpoints will be sorted by creation time within each group only.

Just wanted to bring this up. OK to close this bug if no action is required.</thetext>
        <comment>
            <comment_id>2783177</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-12-06 04:40:18 -0500</when>
            <comment_text>This was made deliberate.
Unless people want this, I will leave it as it is.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508850</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-12-07 12:11:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Conditional breakpoints show error if condition ends with //line comment</short_desc>
        <thetext>Conditional breakpoints show an error if the condition ends with a
//line comment.

- Have code:

package p;
public class C {
	public static void main(String[] args) {
		int something = 42;
		System.out.println(something); // BP
	}
}

- Set BP with condition:

false
//&amp; something else

=&gt; When the condition is saved, any empty lines at the end get removed. That's OK, but when the breakpoint is hit, a wrong compilation error (Syntax error, insert ";" to complete BlockStatements) is shown.

I guess the code that puts braces around the condition needs to put a line break as well.</thetext>
    </bug>
    <bug>
        <id>508917</id>
        <developer>Andreas Sewe</developer>
        <developer_username>andreas.sewe</developer_username>
        <dup_id/>
        <creation_time>2016-12-08 10:15:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Export &gt; Mac OS X application bundle: "Using" a launch configuration has no effect</short_desc>
        <thetext>Just testing the Neon.2 RC4 Java EPP Package:

When using the File &gt; Export &gt; Mac OS X application bundle export wizard, it asks me to "Use this launch configuration". But selecting a launch configuration does not seem to have any effect on fields like "Main class" or "Arguments", which I assume should be filled in from the launch configuration.

Also, the "JVM version" could probably be populated from the launch configuration's "Runtime JRE".</thetext>
    </bug>
    <bug>
        <id>508918</id>
        <developer>Andreas Sewe</developer>
        <developer_username>andreas.sewe</developer_username>
        <dup_id/>
        <creation_time>2016-12-08 10:19:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Export &gt; Mac OS X application bundle: Meaning of star (*) in JVM version unclear</short_desc>
        <thetext>Just testing the Neon.2 RC4 Java EPP Package:

The File &gt; Export &gt; Mac OS X application bundle export wizard has a "JVM version" field with possible values like "1.4+", "1.4*", and "1.4.2".

I assume "1.4+" means "1.4 or later", but what the star in "1.4*" means (in particular as "1.4.2" doesn't have one) is unclear. Does it mean "exactly 1.4"

IMHO, this could be made clearer by labels like

- 1.4.x
- 1.4.0 or later</thetext>
    </bug>
    <bug>
        <id>491132</id>
        <developer>Thirukka Karnan</developer>
        <developer_username>thirukkakarnan</developer_username>
        <dup_id/>
        <creation_time>2016-04-06 03:36:00 -0400</creation_time>
        <product>JDT</product>
        <component>Doc</component>
        <short_desc>org.eclipse.jdt.ui.swtBuilderCompletionProposalComputer fromorg.eclipse.jdt.ui plug-in did not complete normally. unable to instantialte the extension</short_desc>
        <thetext>Created attachment 260737
Screenshot of the error

Content assist doesn't work after updating Eclipse Neon in Mac.
Before the update, everything worked fine.</thetext>
        <comment>
            <comment_id>2690931</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-04-06 04:23:43 -0400</when>
            <comment_text>Please provide the error log.

Maybe you used Mylyn and now it's no longer installed?</comment_text>
        </comment>
        <comment>
            <comment_id>2690964</comment_id>
            <comment_count>2</comment_count>
            <who>Thirukka Karnan</who>
            <commenter_username>thirukkakarnan</commenter_username>
            <when>2016-04-06 04:55:22 -0400</when>
            <comment_text>I haven't done anything other than accepting the auto update. So if it worked earlier, it should work now too.


Have filed a incident in AERI as well - 5704befde4b0207b1a33b8d1
Complete stack in https://dev.eclipse.org/recommenders/community/confess/#/incidents/lbYJhTEOfF0KORPzZlUJ36Hx4a3G0Q4Oh4pq2Tkocz4auzCDGSt9rL3Vw4RArtYZ if you could access it. Pasting the entire 
stacktrace present there

Plugin: org.eclipse.jdt.ui 3.12.0.v20160316-1411
Message: The 'org.eclipse.jdt.ui.swtBuilderCompletionProposalComputer' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. Unable to instantiate the extension.
Exception:
org.eclipse.core.runtime.CoreException: Plug-in "org.eclipse.jdt.ui" was unable to instantiate class "org.eclipse.jdt.internal.ui.text.java.SWTTemplateCompletionProposalComputer".
at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:194)
at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:186)
at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:905)
at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:55)
at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.createComputer(CompletionProposalComputerDescriptor.java:308)
at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.getComputer(CompletionProposalComputerDescriptor.java:275)
at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.sessionStarted(CompletionProposalComputerDescriptor.java:418)
at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.sessionStarted(CompletionProposalCategory.java:384)
at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor$CompletionListener.assistSessionStarted(ContentAssistProcessor.java:119)
at org.eclipse.jface.text.contentassist.ContentAssistant.fireSessionBeginEvent(ContentAssistant.java:2373)
at org.eclipse.jface.text.contentassist.ContentAssistant.prepareToShowCompletions(ContentAssistant.java:1775)
at org.eclipse.jface.text.contentassist.ContentAssistant.access$6(ContentAssistant.java:1766)
at org.eclipse.jface.text.contentassist.ContentAssistant$AutoAssistListener$1.run(ContentAssistant.java:369)
at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4021)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3697)
at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1118)
at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1019)
at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:157)
at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:691)
at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-2)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:497)
at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:670)
at org.eclipse.equinox.launcher.Main.basicRun(Main.java:609)
at org.eclipse.equinox.launcher.Main.run(Main.java:1516)
Caused by:
java.lang.NullPointerException:
at org.eclipse.jdt.internal.ui.JavaPlugin.getTemplateContextRegistry(JavaPlugin.java:860)
at org.eclipse.jdt.internal.ui.text.java.SWTTemplateCompletionProposalComputer.&lt;init&gt;(SWTTemplateCompletionProposalComputer.java:135)
at sun.reflect.NativeConstructorAccessorImpl.newInstance0(NativeConstructorAccessorImpl.java:-2)
at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
at java.lang.reflect.Constructor.newInstance(Constructor.java:422)
at java.lang.Class.newInstance(Class.java:442)
at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:184)
at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:905)
at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:55)
at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.createComputer(CompletionProposalComputerDescriptor.java:308)
at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.getComputer(CompletionProposalComputerDescriptor.java:275)
at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.sessionStarted(CompletionProposalComputerDescriptor.java:418)
at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.sessionStarted(CompletionProposalCategory.java:384)
at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor$CompletionListener.assistSessionStarted(ContentAssistProcessor.java:119)
at org.eclipse.jface.text.contentassist.ContentAssistant.fireSessionBeginEvent(ContentAssistant.java:2373)
at org.eclipse.jface.text.contentassist.ContentAssistant.prepareToShowCompletions(ContentAssistant.java:1775)
at org.eclipse.jface.text.contentassist.ContentAssistant.access$6(ContentAssistant.java:1766)
at org.eclipse.jface.text.contentassist.ContentAssistant$AutoAssistListener$1.run(ContentAssistant.java:369)
at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4021)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3697)
at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1118)
at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1019)
at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:157)
at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:691)
at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-2)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:497)
at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:670)
at org.eclipse.equinox.launcher.Main.basicRun(Main.java:609)
at org.eclipse.equinox.launcher.Main.run(Main.java:1516)

Plugin: org.eclipse.equinox.registry 3.6.100.v20151218-1401
Message: Plug-in "org.eclipse.jdt.ui" was unable to instantiate class "org.eclipse.jdt.internal.ui.text.java.SWTTemplateCompletionProposalComputer". [detached from CoreException of Status 'The 'org.eclipse.jdt.ui.swtBuilderCompletionProposalComputer' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. Unable to instantiate the extension.' by Error Reporting]
Exception:
java.lang.NullPointerException:
at org.eclipse.jdt.internal.ui.JavaPlugin.getTemplateContextRegistry(JavaPlugin.java:860)
at org.eclipse.jdt.internal.ui.text.java.SWTTemplateCompletionProposalComputer.&lt;init&gt;(SWTTemplateCompletionProposalComputer.java:135)
at sun.reflect.NativeConstructorAccessorImpl.newInstance0(NativeConstructorAccessorImpl.java:-2)
at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
at java.lang.reflect.Constructor.newInstance(Constructor.java:422)
at java.lang.Class.newInstance(Class.java:442)
at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:184)
at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:905)
at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:55)
at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.createComputer(CompletionProposalComputerDescriptor.java:308)
at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.getComputer(CompletionProposalComputerDescriptor.java:275)
at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.sessionStarted(CompletionProposalComputerDescriptor.java:418)
at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.sessionStarted(CompletionProposalCategory.java:384)
at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor$CompletionListener.assistSessionStarted(ContentAssistProcessor.java:119)
at org.eclipse.jface.text.contentassist.ContentAssistant.fireSessionBeginEvent(ContentAssistant.java:2373)
at org.eclipse.jface.text.contentassist.ContentAssistant.prepareToShowCompletions(ContentAssistant.java:1775)
at org.eclipse.jface.text.contentassist.ContentAssistant.access$6(ContentAssistant.java:1766)
at org.eclipse.jface.text.contentassist.ContentAssistant$AutoAssistListener$1.run(ContentAssistant.java:369)
at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4021)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3697)
at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1118)
at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1019)
at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:157)
at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:691)
at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-2)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:497)
at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:670)
at org.eclipse.equinox.launcher.Main.basicRun(Main.java:609)
at org.eclipse.equinox.launcher.Main.run(Main.java:1516)</comment_text>
        </comment>
        <comment>
            <comment_id>2690970</comment_id>
            <comment_count>3</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-04-06 05:00:26 -0400</when>
            <comment_text>Did you install the PHP plug-in?</comment_text>
        </comment>
        <comment>
            <comment_id>2690985</comment_id>
            <comment_count>4</comment_count>
            <who>Thirukka Karnan</who>
            <commenter_username>thirukkakarnan</commenter_username>
            <when>2016-04-06 05:11:20 -0400</when>
            <comment_text>No. I haven't installed PHP plugin but other's such as Java Decompiler, etc.</comment_text>
        </comment>
        <comment>
            <comment_id>2690993</comment_id>
            <comment_count>5</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-04-06 05:19:59 -0400</when>
            <comment_text>It looks like the registered JDT template contexts cannot be found. The only reason I can see this happening is:
- corrupt install
- malicious plug-in that deleted them from the registry (see bug 244770 for the PHPeclipse plug-in case)

There's nothing we can do on our side. The easiest is to start with a new install from here:
https://www.eclipse.org/downloads/</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495297</id>
        <developer>Andreas Sewe</developer>
        <developer_username>andreas.sewe</developer_username>
        <dup_id/>
        <creation_time>2016-06-02 09:51:00 -0400</creation_time>
        <product>JDT</product>
        <component>Doc</component>
        <short_desc>Context help description of "Organize import" is 'sticky'</short_desc>
        <thetext>This is an odd bug. Here are steps to reproduce (using the Neon RC3 Eclipse IDE for Java Developers):

- Open the preferences.
- Go to a page that doesn't have context help configured (e.g., "XML").
- Click the "?" button in the lower left corner to open the help pane.
- Note that this shows "About XML: This dialog allows you to set your workbench preferences", which is the default in case not context help was configured.
- Go to the Java &gt; Code Style &gt; Organize Import preference page (with the help pane still open).
- Note that this shows "About Organize Imports: On this page you can define the sort order of import statements".
- Go the earlier page again.
- This shows now "About XML: On this page you can define the sort order of import statements".

For some reason, the context help description of "Organize Imports" is sticky. Other JDT preference page seem not to be affected. Going to "Java &gt; Code Style" and then to "XML" again still has it showing "About XML: On this page you can define the sort order of import statements".</thetext>
    </bug>
    <bug>
        <id>486348</id>
        <developer>Lukas Eder</developer>
        <developer_username>lukas.eder</developer_username>
        <dup_id/>
        <creation_time>2016-01-22 07:44:00 -0500</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>Slow editing of large classes due to inefficient ArrayList access in hot loop reconciling</short_desc>
        <thetext>I've profiled an editing session, where I manipulate large-ish Java files (around 20k lines, lots of overloads, Javadoc, etc.). For the record, these are some examples of such files:

- https://github.com/jOOQ/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/impl/DSL.java
- https://github.com/jOOQ/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/DSLContext.java

The profiler session showed that there seems to be a hot loop that calls:

org.eclipse.jdt.internal.ui.javaeditor.SemanticHighlightingReconciler.PositionCollector.addPosition(int offset, int length, Highlighting highlighting)

In this method, we loop over an ArrayList and access elements via List.get(i):


---------------------------------------------------------------
Stack Trace	Sample Count	Percentage(%)
java.util.ArrayList.elementData(int)	545	10.807
   java.util.ArrayList.get(int)	545	10.807
      org.eclipse.jdt.internal.ui.javaeditor.SemanticHighlightingReconciler$PositionCollector.addPosition(int, int, SemanticHighlightingManager$Highlighting)	544	10.787
         org.eclipse.jdt.internal.ui.javaeditor.SemanticHighlightingReconciler$PositionCollector.visit(SimpleName)	544	10.787
            org.eclipse.jdt.core.dom.SimpleName.accept0(ASTVisitor)	544	10.787
               org.eclipse.jdt.core.dom.ASTNode.accept(ASTVisitor)	544	10.787
                  org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTVisitor, ASTNode$NodeList)	276	5.473
                     org.eclipse.jdt.core.dom.ArrayInitializer.accept0(ASTVisitor)	198	3.926
                     org.eclipse.jdt.core.dom.MethodInvocation.accept0(ASTVisitor)	50	0.991
                     org.eclipse.jdt.core.dom.ClassInstanceCreation.accept0(ASTVisitor)	28	0.555
                  org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTVisitor, ASTNode)	268	5.314
                     org.eclipse.jdt.core.dom.SingleVariableDeclaration.accept0(ASTVisitor)	128	2.538
                     org.eclipse.jdt.core.dom.MethodInvocation.accept0(ASTVisitor)	74	1.467
                     org.eclipse.jdt.core.dom.SingleMemberAnnotation.accept0(ASTVisitor)	27	0.535
                     org.eclipse.jdt.core.dom.MarkerAnnotation.accept0(ASTVisitor)	16	0.317
                     org.eclipse.jdt.core.dom.CastExpression.accept0(ASTVisitor)	8	0.159
                     org.eclipse.jdt.core.dom.QualifiedName.accept0(ASTVisitor)	6	0.119
                     org.eclipse.jdt.core.dom.InfixExpression.accept0(ASTVisitor)	3	0.059
                     org.eclipse.jdt.core.dom.ArrayAccess.accept0(ASTVisitor)	2	0.04
                     org.eclipse.jdt.core.dom.VariableDeclarationFragment.accept0(ASTVisitor)	2	0.04
                     org.eclipse.jdt.core.dom.ReturnStatement.accept0(ASTVisitor)	1	0.02
                     org.eclipse.jdt.core.dom.InstanceofExpression.accept0(ASTVisitor)	1	0.02
---------------------------------------------------------------


If the fRemovedPositions list could be replaced by an array, this loop would perform a lot faster. An alternative might be to loop over the List with a ListIterator.

Of course, these are only suggestions regarding the improvement of the hot loop itself. Perhaps, there is a better algorithm that would avoid this loop from being so hot.

Let me know if you need any additional profiling information, and I will happily provide it.

Also, it appears that this might be the same issue as: https://bugs.eclipse.org/bugs/show_bug.cgi?id=19133</thetext>
        <comment>
            <comment_id>2663411</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-01-22 08:10:20 -0500</when>
            <comment_text>(In reply to Lukas Eder from comment #0)
&gt; I've profiled an editing session, where I manipulate large-ish Java files
&gt; (around 20k lines, lots of overloads, Javadoc, etc.). For the record, these
&gt; are some examples of such files:
&gt; 
&gt; -
&gt; https://github.com/jOOQ/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/impl/DSL.java
&gt; 
&gt; -
&gt; https://github.com/jOOQ/jOOQ/blob/master/jOOQ/src/main/java/org/jooq/DSLContext.java

Can you attach a self-contained test project?</comment_text>
        </comment>
        <comment>
            <comment_id>2663489</comment_id>
            <comment_count>2</comment_count>
            <who>Lukas Eder</who>
            <commenter_username>lukas.eder</commenter_username>
            <when>2016-01-22 09:58:21 -0500</when>
            <comment_text>It's hard to track it down to a single class or item. I can reproduce this issue when checking out the whole project afresh from GitHub, and then importing it as a new project into Eclipse:

https://github.com/jOOQ/jOOQ/tree/master/jOOQ

From then on, when I open the org.jooq.impl.DSL class, modify it (e.g. by adding whitespace, copy pasting things around, etc.), and saving it, I can see various hot items in a profiler session, among which the call to PositionCollector.addPosition().</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488754</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-03-01 06:13:00 -0500</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[1.9] Syntax coloring of "restricted keywords" like "module" in module-info.java</short_desc>
        <thetext>module src {
	exports module;
	exports test.module;
	exports p1;
	provides java.lang.module.ModuleDescriptor with p1.A1;
	uses java.lang.module.Configuration;
}

In the above example, "module" should be colored as a keyword only at the module declaration and not at other locations.</thetext>
        <comment>
            <comment_id>2709537</comment_id>
            <comment_count>1</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-05-19 14:30:52 -0400</when>
            <comment_text>The problem is that the module-info.java language is a context-sensitive language and the "restricted keywords" are not keywords in the JLS8 sense of the word.

Since a character sequence cannot be categorized as a keyword or identifier without access to the context, a simple RuleBasedScanner with some word rules will not be enough to implement syntax highlighting for module files.

I think the best way to solve this is to use separate document partitions for the "restricted keywords" and for the "Java-like constructs" (braces, identifiers, dots, semicolons, keyword "public").

http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html is not a complete spec, but I guess the idea is that module-info.java files can contain the same kinds of comments as regular CUs. This should be checked first with the preview builds and/or clarified on the jigsaw mailing list if it has not been discussed before.

I first thought we could simply add this as a new mode in FastJavaPartitionScanner. But the problem is that we can't simply detect the start of the JAVA of MODULE state by scanning for the next character(s). We really need to parse the qualified names to know when we've reached the last segment of a name. And scanning qualified names is not trivial because in the general case, you can have whitespace and comments inside a qualified name.</comment_text>
        </comment>
        <comment>
            <comment_id>2720485</comment_id>
            <comment_count>2</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-06-14 12:25:19 -0400</when>
            <comment_text>Bug 488541 discusses problems with trying to tokenize "restricted keywords" depending on the context.

If we don't find a solution for syntax coloring, then we could also consider "restricted keywords" as identifiers and only colorize them using a semantic coloring. But that would mean we need an AST for the ModuleDeclaration (bug 496123).</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495532</id>
        <developer>I Am Legenda</developer>
        <developer_username>iamlegenda25</developer_username>
        <dup_id/>
        <creation_time>2016-06-06 07:49:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>Code completion removing right brackets</short_desc>
        <thetext>This bug happens only when I follow these exact steps:

- Type an opening left parenthesis - "(" - Eclipse will now automatically add the closing right parenthesis.
- Write anything that can be autocompleted and either press ctrl+space or wait for the autocompletion dialogue to come up.
- Without pressing Enter, type the closing right parenthesis ")" - this simply brings the cursor to the right of the previously automatically added right parenthesis.
- Type the semicolon.

This will, instead of putting the semicolon after the right parenthesis, replace the right parenthesis with the semicolon.</thetext>
    </bug>
    <bug>
        <id>495734</id>
        <developer>Erick Robertson</developer>
        <developer_username>vir4030</developer_username>
        <dup_id/>
        <creation_time>2016-06-08 14:13:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>Typing out a synchronized block deletes the closed parentheses</short_desc>
        <thetext>when I type out the following code:

  synchronized (this.orders) {

When I press the open parenthesis, it adds the closed parenthesis.  When I type the period after this, it brings up a context menu containing the local property "orders".  It's on the top so it's highlighted by default.  When I type out "orders", it types it in between the parentheses as I would expect.  But when I press the closed parenthesis, it does not close the suggestion box that has popped up beneath it.  When I then press the spacebar after the closed parenthesis, it deletes the closed parenthesis as it hides the suggestion box.

It shouldn't be deleting that closed parenthesis.</thetext>
    </bug>
    <bug>
        <id>496436</id>
        <developer>Luigi D\'Ostuni</developer>
        <developer_username>alessandro_juve_1998</developer_username>
        <dup_id/>
        <creation_time>2016-06-20 16:19:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>Language Pack Eclipse Mars2.</short_desc>
        <thetext>I download the german language pack and now I can't open the Programm Eclipse Mars2.</thetext>
        <comment>
            <comment_id>2722316</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-06-21 04:55:51 -0400</when>
            <comment_text>What's the error? Did you download the language pack that's made for your Eclipse version?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497488</id>
        <developer>Andreas Sewe</developer>
        <developer_username>andreas.sewe</developer_username>
        <dup_id/>
        <creation_time>2016-07-07 09:21:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>UI freeze due to DefaultPhoneticHashProvider processing a very long comment.</short_desc>
        <thetext>Using Eclipse IDE for Java EE Developers (Neon), I got a minute-long UI freeze when deleting a huge (10.000 characters) comment.

Here's a stack trace taken with jstack:

"main" #1 prio=6 os_prio=31 tid=0x000000010106f000 nid=0x130f runnable [0x00007fff5fbfd000]
   java.lang.Thread.State: RUNNABLE
	at org.eclipse.jdt.internal.ui.text.spelling.engine.DefaultPhoneticHashProvider.getHash(DefaultPhoneticHashProvider.java:225)
	at org.eclipse.jdt.internal.ui.text.spelling.engine.AbstractSpellDictionary.getProposals(AbstractSpellDictionary.java:406)
	at org.eclipse.jdt.internal.ui.text.spelling.engine.DefaultSpellChecker.getProposals(DefaultSpellChecker.java:299)
	at org.eclipse.jdt.internal.ui.text.spelling.WordQuickFixProcessor.getCorrections(WordQuickFixProcessor.java:96)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:384)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:344)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:339)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:474)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:102)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:76)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:287)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:187)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1194)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1163)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:894)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:244)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:234)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
	- locked &lt;0x00000007852afc60&gt; (a org.eclipse.swt.widgets.RunnableLock)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4024)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3700)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:687)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

A second sample taken a bit later ends like this:

	at org.eclipse.jdt.internal.ui.text.spelling.engine.DefaultPhoneticDistanceAlgorithm.getDistance(DefaultPhoneticDistanceAlgorithm.java:51)
	at org.eclipse.jdt.internal.ui.text.spelling.engine.AbstractSpellDictionary.getCandidates(AbstractSpellDictionary.java:232)
	at org.eclipse.jdt.internal.ui.text.spelling.engine.AbstractSpellDictionary.getProposals(AbstractSpellDictionary.java:453)
	at org.eclipse.jdt.internal.ui.text.spelling.engine.DefaultSpellChecker.getProposals(DefaultSpellChecker.java:299)
	at org.eclipse.jdt.internal.ui.text.spelling.WordQuickFixProcessor.getCorrections(WordQuickFixProcessor.java:96)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:384)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:344)


The source file in question looked like this:

/**** 10.000 chars *****/

class Example {
    public static void main(String[] args) {
    }
}

I am not 100% sure where exactly the cursor was, but I *think* I had the whole comment line selected and was then using Backspace to delete.</thetext>
    </bug>
    <bug>
        <id>497939</id>
        <developer>Dan S.</developer>
        <developer_username>salmon</developer_username>
        <dup_id/>
        <creation_time>2016-07-14 17:44:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[typing] Creating ArrayList moves cursor</short_desc>
        <thetext>When developing in Eclipse 4.6, I came across the following issue: When typing out a line with an ArrayList of Strings, code assist moves the cursor incorrectly.

It happens when I type a line like the following:
List &lt;String&gt; listOfStrings = new ArrayList&lt;String&gt;();

Everything is fine until I get to the second "String" word. Here's what happens:
1. Type "ing" just fine
2. Type the "&gt;" just fine
3. As soon as I type the "(", my cursor moves to the left one column and ends up in front of the "(". 

So trying to type "&lt;String&gt;();" quickly results in "&lt;String&gt;);("</thetext>
        <comment>
            <comment_id>2730693</comment_id>
            <comment_count>1</comment_count>
            <who>Dan S.</who>
            <commenter_username>salmon</commenter_username>
            <when>2016-07-14 17:45:30 -0400</when>
            <comment_text>If I've somehow incorrectly filed this bug, I apologize. This is my first time using Bugzilla.</comment_text>
        </comment>
        <comment>
            <comment_id>2730862</comment_id>
            <comment_count>2</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-07-15 09:21:04 -0400</when>
            <comment_text>I could not reproduce this issue based on the steps in comment #0. 

You mentioned that "code assist moves the cursor incorrectly". Where is the code assist (Ctrl+Space) active?

In Preferences &gt; Java &gt; Editor &gt; Typing, do you have "Automatically close" &gt; "(Parentheses), [square]..." checked? In that case the closing brackets are added automatically.

Please provide more details to reproduce the issue.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499536</id>
        <developer>Bill Chen</developer>
        <developer_username>billc.cn</developer_username>
        <dup_id/>
        <creation_time>2016-08-11 05:11:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>Cannot inline parameter annotation constants</short_desc>
        <thetext>To Reproduce:

1. Have a method like

void a(@SomeAnnotation(STATIC_VAR) int a) ...

2. Select "STATIC_VAR" and do Refactor -&gt; Inline...

Expected:

Constant gets inlined

Actually:

Gets an error dialogue saying: Cannot inline method parameters.


-- Configuration Details --
Product: Eclipse 4.6.0.20160613-1800 (org.eclipse.epp.package.jee.product)
Installed Features:
 org.eclipse.jdt 3.12.0.v20160606-1100</thetext>
    </bug>
    <bug>
        <id>500838</id>
        <developer>martin shultz</developer>
        <developer_username>khjgfty4regrdhg</developer_username>
        <dup_id/>
        <creation_time>2016-09-05 05:04:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>It does not work "comment"</short_desc>
        <thetext>I am using a translator, if something is not clear, ask.

It does not work "comment" in the Eclipse Java SE, which I'm trying to bind a hotkey. Opt Options-General-keys-comment. Next, try the above shortcut key and nothing happens. Thus, for example, uncomment the command works fine.

This command is very important to me, but it's not even on the menu! A Toogle comment often does not do what I need.</thetext>
        <comment>
            <comment_id>2749065</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-09-09 09:34:49 -0400</when>
            <comment_text>Sorry, no clue what your problem is. Please provide more detailed steps.</comment_text>
        </comment>
        <comment>
            <comment_id>2749305</comment_id>
            <comment_count>2</comment_count>
            <who>martin shultz</who>
            <commenter_username>khjgfty4regrdhg</commenter_username>
            <when>2016-09-10 10:52:10 -0400</when>
            <comment_text>Created attachment 264085
isolated fragment

I do not like work "Toogle comment" command. More wrote about it here: https://bugs.eclipse.org/bugs/show_bug.cgi?id=500839

Instead, the team "Toogle comment" try to use commands "comment" and "uncomment". These commands are not present in the menu or in the context menu or in the toolbar. They are binding only as to the keys.

So, suppose I need to comment out some code snippet.
In the screenshot "isolated fragment" seen the selection that you want to comment out. All further tests are carried out on it.</comment_text>
        </comment>
        <comment>
            <comment_id>2749307</comment_id>
            <comment_count>3</comment_count>
            <who>martin shultz</who>
            <commenter_username>khjgfty4regrdhg</commenter_username>
            <when>2016-09-10 10:53:45 -0400</when>
            <comment_text>Created attachment 264086
sets the keys to comment

Next, I want to make the fragment is commented out when you press Ctrl + A.
How I do it is shown in the screen shot "sets the keys to comment".

But nothing happens when you click a combination of these, everything remains as in the screenshot "isolated fragment."</comment_text>
        </comment>
        <comment>
            <comment_id>2749308</comment_id>
            <comment_count>4</comment_count>
            <who>martin shultz</who>
            <commenter_username>khjgfty4regrdhg</commenter_username>
            <when>2016-09-10 10:57:47 -0400</when>
            <comment_text>Created attachment 264087
Sets the keys to uncomment the

In the screenshot "Sets the keys to uncomment the" show how I try to install the keys Ctrl + Z for "uncomment the" command response.</comment_text>
        </comment>
        <comment>
            <comment_id>2749309</comment_id>
            <comment_count>5</comment_count>
            <who>martin shultz</who>
            <commenter_username>khjgfty4regrdhg</commenter_username>
            <when>2016-09-10 10:59:35 -0400</when>
            <comment_text>Created attachment 264088
uncommented fragment

Pressing Ctrl + Z occurs decomment as shown in the screenshot "uncommented fragment".

It seems to do everything right, but the command "comment" does not work.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500839</id>
        <developer>martin shultz</developer>
        <developer_username>khjgfty4regrdhg</developer_username>
        <dup_id/>
        <creation_time>2016-09-05 05:08:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>Improvement "Toogle comment"</short_desc>
        <thetext>I am using a translator, if something is not clear, ask.

I beg little to alter the function of "Toogle comment" in the Eclipse Java SE. Now if I click "Toogle comment" when selected multiple lines, it is almost always for each of these lines will be added to the "//". Even if the selected lines of 100 lines already commented out and will fall only one uncommented line!!! Only if all are commented out before a single line, the characters comments will be removed.

I propose to enhance this mechanism - make that if several rows, the first and the last of which has already been commented out, then pressing "Toogle comment" happened decomment all selected rows. And if the first or last or both of the selected lines are not commented out, then comment out all selected rows. Or at least add the inclusion of this possibility in the flag setting.

I think it would have been easier and more logical!</thetext>
        <comment>
            <comment_id>2746875</comment_id>
            <comment_count>1</comment_count>
            <who>martin shultz</who>
            <commenter_username>khjgfty4regrdhg</commenter_username>
            <when>2016-09-05 05:31:34 -0400</when>
            <comment_text>*** Bug 500840 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500986</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-09-07 08:59:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[linked mode] difficulties in shortening a proposed name</short_desc>
        <thetext>Assume you have s.t. like:

   void test(FooBar foobar) {
      |foobar;
   }

* At the caret invoke "Assign statement to new local variable".
* For the variable name you get two proposals "fooBar2" and "bar".
* Edit the initial "fooBar2" to become "foo"
* Hit enter to proceed.
=&gt; "fooBar2" will again be inserted.

After having been surprised by this hundrets of times, meanwhile I know I can use Tab or Ctrl+Enter, both will leave the "foo" as I typed it, but something feels backward to me here. Why should deleting "Bar2" tell the tool that I want that text back on enter? Is it only me or do others see room for improvement, too?

Idea: when ...
- editing in linked mode
- initially buffer content and first proposal are the same
- subsequently the user edits the current linked position
then could this deselect the proposal, so that explicit down-arrow would be needed to insert any of the proposals? I assume that with no proposal selected, enter would behave the way I'd intuitively expect.

Might be a general jface.text issue?</thetext>
    </bug>
    <bug>
        <id>501488</id>
        <developer>martin shultz</developer>
        <developer_username>khjgfty4regrdhg</developer_username>
        <dup_id/>
        <creation_time>2016-09-15 07:18:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>It does not work one of the key code folding</short_desc>
        <thetext>Created attachment 264168
Code

I am using a translator, if something is not clear, ask.

One of code folding buttons are displayed icon "+". Pressing its folding and unfolding occurs code but no icon changes from "-" to "+". I take a screenshot.

In addition, I have sometimes happened that this button does not work! The code has been minimized, and it happened when you press the deployment code for a moment (as flicker), then the code again instantly folded. In order to somehow expand the code had to press Folding-&gt; ExpandAll, then the code unfolds. This happened only a few times, and then it started, I could not understand.

Clearly written I can not :(</thetext>
        <comment>
            <comment_id>2752244</comment_id>
            <comment_count>1</comment_count>
            <who>martin shultz</who>
            <commenter_username>khjgfty4regrdhg</commenter_username>
            <when>2016-09-17 13:58:34 -0400</when>
            <comment_text>Created attachment 264237
It shows the problem

Even I forgot to write that the problem does not always appear, sometimes working as it should.
I have inserted a screenshot of the problem.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501498</id>
        <developer>Lars Vogel</developer>
        <developer_username>Lars.Vogel</developer_username>
        <dup_id/>
        <creation_time>2016-09-15 09:54:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>Use different icon if several markers are present</short_desc>
        <thetext>Created attachment 264171
Screenshot

If I have a warning in the ruler and also a breakpoint, the breakpoint marker is not visible.

See screenshot.

Code snippet to test
--------------------
String s = "Test";
// System.out.println(s);
--------------------

Maybe you should use a special icon in case there are several markers?</thetext>
        <comment>
            <comment_id>2751262</comment_id>
            <comment_count>1</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-09-15 10:29:49 -0400</when>
            <comment_text>&gt; Maybe you should use a special icon in case there are several markers?

I think that would be an easy fix and improve usability. At least I would have a visual indicator for this situation. Adjusted the bug summary accordingly.</comment_text>
        </comment>
        <comment>
            <comment_id>2751263</comment_id>
            <comment_count>2</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-09-15 10:31:59 -0400</when>
            <comment_text>See also the discussion in Bug 80089 but I dislike the line of though in this bug, sounds way to complex for this problem. "Configuring the layers" sounds like overdesign for me.</comment_text>
        </comment>
        <comment>
            <comment_id>2751329</comment_id>
            <comment_count>3</comment_count>
            <who>Doug Schaefer</who>
            <commenter_username>dschaefer</commenter_username>
            <when>2016-09-15 12:01:20 -0400</when>
            <comment_text>Markers have a PRIORITY, no? Shouldn't the breakpoint marker be a higher priority than the warning marker, but less than the error marker? Would that make this particular situation better?

I just worry that using a different visual indicator will still leave people looking for their breakpoints.</comment_text>
        </comment>
        <comment>
            <comment_id>2751336</comment_id>
            <comment_count>4</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-09-15 12:24:02 -0400</when>
            <comment_text>(In reply to Doug Schaefer from comment #3)
&gt; Markers have a PRIORITY, no? Shouldn't the breakpoint marker be a higher
&gt; priority than the warning marker, but less than the error marker? Would that
&gt; make this particular situation better?

I think this comment should go into Bug 80089.

&gt; I just worry that using a different visual indicator will still leave people
&gt; looking for their breakpoints.

IMMO a new icon would be better than the current status.</comment_text>
        </comment>
        <comment>
            <comment_id>2751371</comment_id>
            <comment_count>5</comment_count>
            <who>Doug Schaefer</who>
            <commenter_username>dschaefer</commenter_username>
            <when>2016-09-15 14:21:45 -0400</when>
            <comment_text>(In reply to Lars Vogel from comment #4)
&gt; (In reply to Doug Schaefer from comment #3)
&gt; &gt; Markers have a PRIORITY, no? Shouldn't the breakpoint marker be a higher
&gt; &gt; priority than the warning marker, but less than the error marker? Would that
&gt; &gt; make this particular situation better?
&gt; 
&gt; I think this comment should go into Bug 80089.

I found that bug to be too general. After talking to a few of my colleagues this specific issue about breakpoints and warnings is bugging lots of people. I don't think the general issue of multiple markers on a line is as important. Of course, neither was important enough to motivate us to fix it, so that should be taken into account as well.

&gt; 
&gt; &gt; I just worry that using a different visual indicator will still leave people
&gt; &gt; looking for their breakpoints.
&gt; 
&gt; IMMO a new icon would be better than the current status.

That's fair. It would be great if we could get more input and see where the trend is with the community, if there is one.</comment_text>
        </comment>
        <comment>
            <comment_id>2751413</comment_id>
            <comment_count>6</comment_count>
            <who>Tony McCrary</who>
            <commenter_username>tmccrary</commenter_username>
            <when>2016-09-15 16:46:56 -0400</when>
            <comment_text>Created attachment 264184
breakpoint icon concepts

Here are some concepts for a combined type of UI element. It uses color so you know there's something different about the line/breakpoint but also has some structural differences for people with color blindness. The far right is actual size.</comment_text>
        </comment>
        <comment>
            <comment_id>2753176</comment_id>
            <comment_count>7</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-20 08:10:10 -0400</when>
            <comment_text>Breakpoint + Problem may be a typical case, but wouldn't a consistent solution then require to have combined icons for *every* possible combination of markers. Think of TODO markers, bookmarks to begin with. Aren't explicit combination icons a dead end?

I'd vote for a generic icon symbolizing just "multiple markers", without even attempting to convey what markers are involved.

Or perhaps, just show the marker with highest priority with a *decoration* for "there are more".</comment_text>
        </comment>
        <comment>
            <comment_id>2753181</comment_id>
            <comment_count>8</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-09-20 08:18:40 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #7)
&gt; I'd vote for a generic icon symbolizing just "multiple markers", without
&gt; even attempting to convey what markers are involved.

+1, we should target a simple solution</comment_text>
        </comment>
        <comment>
            <comment_id>2753336</comment_id>
            <comment_count>9</comment_count>
            <who>Tony McCrary</who>
            <commenter_username>tmccrary</commenter_username>
            <when>2016-09-20 11:11:14 -0400</when>
            <comment_text>Created attachment 264290
breakpoint multi concept

This icon has an outer ring with various colors to differentiate it from the normal breakpoint icon.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507922</id>
        <developer>Klaus Christiansen</developer>
        <developer_username>klaus.edwin.christiansen</developer_username>
        <dup_id/>
        <creation_time>2016-11-22 01:50:00 -0500</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>Code cleanup deletes comments</short_desc>
        <thetext>Created attachment 265503
The code cleanup settings I used.

Java Code cleanup sometimes removes comments.
It seams that comments on the same line as an IF (maybe other block statements to?) is removed during code cleanup.
Other times the result is just poorly formatted.

Before:
@Override
public String getTypeName() {
    if (type == null) // No type means that we are the type.
        return NameUtils.upperCaseFirstChar(NameUtils.setVariableCase(getName()));
    return type.getTypeName();
}

After:
@Override
public String getTypeName() {
    if (type == null) {
        return NameUtils.upperCaseFirstChar(NameUtils.setVariableCase(getName()));
    }
    return type.getTypeName();
}



This is an example of poorly formatted code cleanup.
Before:
public void addImport(String imp) {
    if (imp.contains("FormGroup2"))
        System.err.println("addToImport ");
    String imppac = imp.substring(0, imp.lastIndexOf("."));
    if (imppac.equals(getPackageName()))
        return; // No need to add classes in same package
    if (getImports().get(imppac + ".*") != null)
        return; // Whole package already imported

    imports.put(imp, imp);
}

After:
public void addImport(String imp) {
    if (imp.contains("FormGroup2")) {
        System.err.println("addToImport ");
    }
    String imppac = imp.substring(0, imp.lastIndexOf("."));
    if (imppac.equals(getPackageName()))
     {
        return; // No need to add classes in same package
    }
    if (getImports().get(imppac + ".*") != null)
     {
        return; // Whole package already imported
    }
   
    imports.put(imp, imp);
}

Another example of poorly formatted code cleanup.

before:
protected void define(FunctionSymbol sym, boolean doSetScope) {
    if (doSetScope)
        sym.scope = this; // track the scope in each symbol
...
}

After:
protected void define(FunctionSymbol sym, boolean doSetScope) {
    if (doSetScope)
     {
        sym.scope = this; // track the scope in each symbol
    }
...
}</thetext>
    </bug>
    <bug>
        <id>508789</id>
        <developer>Mickael Istria - away until ...</developer>
        <developer_username>mistria</developer_username>
        <dup_id/>
        <creation_time>2016-12-06 14:35:00 -0500</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[content assist][preferences] Completion trigger characters widget should be a combo and propose all chars</short_desc>
        <thetext>Many people are interested in having JDT's completion showing up on every keystroke (additionally to the usual characters). This is documented on the wiki and suggested on various user media to add `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ(` to the default `.`.

In order to make this user story a bit less annoying, JDT preference page could use a combo with this value pre-set as a suggestion, so enabling content-assist on every keystroke becomes a simpler choice.</thetext>
        <comment>
            <comment_id>2783571</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-06 16:04:54 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/86539</comment_text>
        </comment>
        <comment>
            <comment_id>2784014</comment_id>
            <comment_count>2</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-12-07 11:53:35 -0500</when>
            <comment_text>Adding a combo for that corner case is not OK. We can discuss a new preference though.</comment_text>
        </comment>
        <comment>
            <comment_id>2784019</comment_id>
            <comment_count>3</comment_count>
            <who>Mickael Istria - away until ...</who>
            <commenter_username>mistria</commenter_username>
            <when>2016-12-07 12:01:23 -0500</when>
            <comment_text>(In reply to Dani Megert from comment #2)
&gt; Adding a combo for that corner case is not OK. We can discuss a new
&gt; preference though.

The benefit of a combo is that it can be used to propose multiple values, whereas a preference would be only a checkbox, right?
If we're sure that there is only one value (abcd...XYZ.(") we'll ever want to propose to users, then a checkbox is indeed fine. However, if we think there are alternatives strategies that are worth proposing to user (such as just `.` or only `.(` or only characters+'.`....) then I believe the combo is the only viable choice.</comment_text>
        </comment>
        <comment>
            <comment_id>2784031</comment_id>
            <comment_count>4</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-12-07 12:26:56 -0500</when>
            <comment_text>(In reply to Mickael Istria from comment #3)
&gt; The benefit of a combo is that it can be used to propose multiple values,
&gt; whereas a preference would be only a checkbox, right?
&gt; If we're sure that there is only one value (abcd...XYZ.(") we'll ever want
&gt; to propose to users, then a checkbox is indeed fine. However, if we think
&gt; there are alternatives strategies that are worth proposing to user (such as
&gt; just `.` or only `.(` or only characters+'.`....) then I believe the combo
&gt; is the only viable choice.

No it is not. At this point it is a new preference. That does not mean we can switch to a combo in the future.</comment_text>
        </comment>
        <comment>
            <comment_id>2784053</comment_id>
            <comment_count>5</comment_count>
            <who>Mickael Istria - away until ...</who>
            <commenter_username>mistria</commenter_username>
            <when>2016-12-07 13:21:54 -0500</when>
            <comment_text>(In reply to Dani Megert from comment #4)
&gt; No it is not. At this point it is a new preference. That does not mean we
&gt; can switch to a combo in the future.

You mean a new preference as a replacement or as an addition? Which classes would be responsible for consuming that preference?</comment_text>
        </comment>
        <comment>
            <comment_id>2786248</comment_id>
            <comment_count>6</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-12-14 09:23:27 -0500</when>
            <comment_text>(In reply to Mickael Istria from comment #5)
&gt; (In reply to Dani Megert from comment #4)
&gt; &gt; No it is not. At this point it is a new preference. That does not mean we
&gt; &gt; can switch to a combo in the future.
&gt; 
&gt; You mean a new preference as a replacement or as an addition? 

Probably an additional one that disables the current one if checked. 


&gt; Which classes
&gt; would be responsible for consuming that preference?

Look at the code.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508901</id>
        <developer>Lars Vogel</developer>
        <developer_username>Lars.Vogel</developer_username>
        <dup_id/>
        <creation_time>2016-12-08 08:19:00 -0500</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>Javadoc popup is light in the dark theme</short_desc>
        <thetext>+++ This bug was initially created as a clone of Bug #501742 +++

https://www.eclipse.org/eclipse/news/4.7/M4/ shows the Javadoc popup in the dark theme. This is not how it looks like for me (using Ubuntu 16.04).</thetext>
        <comment>
            <comment_id>2784303</comment_id>
            <comment_count>1</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-12-08 08:22:05 -0500</when>
            <comment_text>Created attachment 265768
Screenshot</comment_text>
        </comment>
        <comment>
            <comment_id>2784451</comment_id>
            <comment_count>2</comment_count>
            <who>Leo Ufimtsev</who>
            <commenter_username>lufimtse</commenter_username>
            <when>2016-12-08 11:06:12 -0500</when>
            <comment_text>What is your eclipse build?

Do you have eclipse colors set to default (information/javadoc) or to some other color?</comment_text>
        </comment>
        <comment>
            <comment_id>2784478</comment_id>
            <comment_count>3</comment_count>
            <who>Leo Ufimtsev</who>
            <commenter_username>lufimtse</commenter_username>
            <when>2016-12-08 11:18:24 -0500</when>
            <comment_text>Which version of ubuntu are you on btw?</comment_text>
        </comment>
        <comment>
            <comment_id>2784482</comment_id>
            <comment_count>4</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-12-08 11:22:51 -0500</when>
            <comment_text>(In reply to Leo Ufimtsev from comment #3)
&gt; Which version of ubuntu are you on btw?

16.04 as stated in my initial comment. ;-)</comment_text>
        </comment>
        <comment>
            <comment_id>2784485</comment_id>
            <comment_count>5</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-12-08 11:25:06 -0500</when>
            <comment_text>(In reply to Leo Ufimtsev from comment #2)
&gt; What is your eclipse build?

Eclipse SDK
Version: Oxygen (4.7)
Build id: I20161205-2000
OS: Linux, v.4.4.0-47-generic, x86_64 / gtk 3.18.9, WebKit 2.4.11

&gt; Do you have eclipse colors set to default (information/javadoc) or to some
&gt; other color?

Not that I'm aware of. I now resetted "Colors and Fonts" to default but still the Javadoc popup is light.</comment_text>
        </comment>
        <comment>
            <comment_id>2784515</comment_id>
            <comment_count>6</comment_count>
            <who>Leo Ufimtsev</who>
            <commenter_username>lufimtse</commenter_username>
            <when>2016-12-08 12:02:52 -0500</when>
            <comment_text>(In reply to Lars Vogel from comment #4)
&gt; (In reply to Leo Ufimtsev from comment #3)
&gt; &gt; Which version of ubuntu are you on btw?
&gt; 
&gt; 16.04 as stated in my initial comment. ;-)

I asked that clearly before I had my coffee :-P.</comment_text>
        </comment>
        <comment>
            <comment_id>2784521</comment_id>
            <comment_count>7</comment_count>
            <who>Leo Ufimtsev</who>
            <commenter_username>lufimtse</commenter_username>
            <when>2016-12-08 12:22:08 -0500</when>
            <comment_text>(In reply to Lars Vogel from comment #5)
&gt; (In reply to Leo Ufimtsev from comment #2)
&gt; &gt; What is your eclipse build?
&gt; 
&gt; Eclipse SDK
&gt; Version: Oxygen (4.7)
&gt; Build id: I20161205-2000
&gt; OS: Linux, v.4.4.0-47-generic, x86_64 / gtk 3.18.9, WebKit 2.4.11
&gt; 
&gt; &gt; Do you have eclipse colors set to default (information/javadoc) or to some
&gt; &gt; other color?
&gt; 
&gt; Not that I'm aware of. I now resetted "Colors and Fonts" to default but
&gt; still the Javadoc popup is light.

Hmm, I can't reproduce with I20161205 build, not with Gtk3.18 either.
(See attached).

I suppose you have default Ubuntu out of the box (or some custom spin?). No custom themes or anything like that?
If so, then I might have to setup ubuntu to research this further.</comment_text>
        </comment>
        <comment>
            <comment_id>2784522</comment_id>
            <comment_count>8</comment_count>
            <who>Leo Ufimtsev</who>
            <commenter_username>lufimtse</commenter_username>
            <when>2016-12-08 12:22:45 -0500</when>
            <comment_text>Created attachment 265780
Fedora 25. Gtk3.22. Javadoc on darktheme ok.</comment_text>
        </comment>
        <comment>
            <comment_id>2784523</comment_id>
            <comment_count>9</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-12-08 12:31:11 -0500</when>
            <comment_text>(In reply to Leo Ufimtsev from comment #7)
&gt; I suppose you have default Ubuntu out of the box (or some custom spin?). No
&gt; custom themes or anything like that?
&gt; If so, then I might have to setup ubuntu to research this further.

Correct. I use Ubuntu out-of-the-box. No customization.</comment_text>
        </comment>
        <comment>
            <comment_id>2784566</comment_id>
            <comment_count>10</comment_count>
            <who>Leo Ufimtsev</who>
            <commenter_username>lufimtse</commenter_username>
            <when>2016-12-08 14:10:33 -0500</when>
            <comment_text>Just to clarify:

1) Is this a regression, i.e has it had nice colors before, but now it doesn't have nice colors?

2) Or has it never had the desired colors, the news advertises that it has nice colors but in fact on ubuntu it still has the old colors?</comment_text>
        </comment>
        <comment>
            <comment_id>2784579</comment_id>
            <comment_count>11</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-12-08 14:35:09 -0500</when>
            <comment_text>The popup used to be always dark on Linux, so it was fitting to the dark theme. This way you may say it is a regression.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>486175</id>
        <developer>Anna Eilertsen</developer>
        <developer_username>anna.eilertsen</developer_username>
        <dup_id/>
        <creation_time>2016-01-20 09:30:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Refactoring: Move method between packages misses some imports</short_desc>
        <thetext>Created attachment 259274
code from description example

Given two classes, A and B, in separate packages, and two methods in A, where one is an instance method and one is static, if the instance method invokes the static one without the A. qualifier, moving the instance method to B will result in missing imports. 

Example code:

package a;
import b.B;
class A{
    public B b = new B();
    static void staticMethod(){}
    void moveMe(){b.m(); staticMethod();}
}

package b;
class B{
    void m(){}
}

Move method on moveMe yields 

package a;
import b.B;
class A{
    public B b = new B();
    static void staticMethod(){}
}

package b;
class B{
    void m(){}
    void moveMe(){m(); A.staticMethod();}
}

My impression from debugging is that the imports are added in checkFinalConditions(IProgressMonitor m) in ProcessorBasedRefactoring (extended by MoveRefactoring), while the qualifier A. is added at the time the refactoring actually is executed, so there were no explicit references to A in B at the time checkFinalConditions were called.</thetext>
    </bug>
    <bug>
        <id>486176</id>
        <developer>Anna Eilertsen</developer>
        <developer_username>anna.eilertsen</developer_username>
        <dup_id/>
        <creation_time>2016-01-20 09:37:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Refactoring: Move method missing "this"-qualifier on shadowed fields</short_desc>
        <thetext>Executing the move-refactoring such that the resulting method has a local variable shadowing a field in target class leads to missing this-qualifier on the field access. 

Example: 

class A {
    B b;
    void foo(){String s = b.s;}
}

class B{
    String s;
}

Moving foo to B gives us: 

class A {
    B b;
}

class B{
    String s;
    void foo(){String s = s;}
}</thetext>
        <comment>
            <comment_id>2662431</comment_id>
            <comment_count>1</comment_count>
            <who>Andrey Loskutov</who>
            <commenter_username>loskutov</commenter_username>
            <when>2016-01-20 09:42:53 -0500</when>
            <comment_text>Please report Java related refactoring issues to the JDT product.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>486344</id>
        <developer>Felix Otto</developer>
        <developer_username>felix.otto</developer_username>
        <dup_id/>
        <creation_time>2016-01-22 07:21:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Overlay icons on editor tab disappear in split mode</short_desc>
        <thetext>Created attachment 259331
Overlay/error icon missing on editor tab

The overlay icon which indicates an error in a certain Java class disappears from the editor tab, when the split mode is activated for the editor (see attached screenshots).

Is there a chance to keep it?

Regards, Felix</thetext>
    </bug>
    <bug>
        <id>486692</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-01-27 20:37:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[add parameter] A behavior preserving transformation (Add Parameter Refactoring) is rejected</short_desc>
        <thetext>Steps to Reproduce:
1. Create the following program

package Package_1;
public class ClassId_2 {
  protected long methodid_0(){
    return 0;
  }
}
package Package_1;
public class ClassId_0 extends ClassId_2 {
}
package Package_0;
import Package_1.*;
public class ClassId_1 extends ClassId_0 {
  protected long methodid_0(){
    return 1;
  }
  public long m_0(){
    return new ClassId_1().methodid_0();
  }
}



2. Apply the add parameter refactoring to add a parameter of type int in the method Package_0.ClassId_1.methodid_0.

3. The tool does not apply the transformation and warns the following message:
The selected method overrides method in declared type

4. Another refactoring tool applies the same transformation and the resulting program (the program below) preserves behavior.

package Package_0;
import Package_1.*;
public class ClassId_1 extends ClassId_0 {
  protected long methodid_0(int i){
    return 1;
  }
  public long m_0(){
    return new ClassId_1().methodid_0(0);
  }
}

package Package_1;
public class ClassId_0 extends ClassId_2 {
}

package Package_1;
public class ClassId_2 {
  protected long methodid_0(int i){
    return 0;
  }
}</thetext>
    </bug>
    <bug>
        <id>486693</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-01-27 20:46:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[encapsulate field] A behavior preserving transformation (Encapsulate Fiekd Refactoring) is rejected</short_desc>
        <thetext>Steps to Reproduce:
1. Create the following program

package Package_1;
public class ClassId_1 {
  long getfieldid_0(){
    return 0;
  }
  public long caller_0(){
    return getfieldid_0();
  }
  public long methodid_0(){
    return caller_0();
  }
}
package Package_0;
import Package_1.*;
public class ClassId_0 extends ClassId_1 {
  public long fieldid_0=10;
}


2. Apply the encapsulate refactoring in the field ClassId_0.fieldid_0.

3. The tool does not apply the transformation and warns the following message:


4. Another refactoring tool applies the same transformation and the resulting program (the program below) preserves the behavior.

package Package_1;
public class ClassId_1 {
  long getfieldid_0(){
    return 0;
  }
  public long caller_0(){
    return getfieldid_0();
  }
  public long methodid_0(){
    return caller_0();
  }
}

package Package_0;
import Package_1.*;
public class ClassId_0 extends ClassId_1 {
  private long fieldid_0=10;

public long getfieldid_0() {
    return fieldid_0;
}

public void setfieldid_0(long fieldid_0) {
    this.fieldid_0 = fieldid_0;
}
}</thetext>
    </bug>
    <bug>
        <id>486694</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-01-27 20:52:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[move method] A behavior preserving transformation (Move Method Refactoring) is rejected</short_desc>
        <thetext>Steps to Reproduce:
1. Create the following program


package Package_1;
public class ClassId_1 {
  protected long m_0(  int a){
    return 1;
  }
}

package Package_0;
import Package_1.*;
public class A_0 extends ClassId_1 {
  public ClassId_0 fieldid_0= new ClassId_0();
  protected long m_0(  int a){
    return 0;
  }
}

package Package_0;
public class ClassId_0 extends A_0 {
  public long methodid_0(){
    return this.m_0(2);
  }
}

2. Apply the move method refactoring to move method m_0(int) from class A_0 to class ClassId_0.

3. The tool does not apply the transformation and warn the following message:
The method invocations to m_0 cannot be updated since the original method is used  Polymorphically.

4. Another refactoring tool applies the same transformation and the resulting program (the program below) preserves the program behavior.

package Package_1;
public class ClassId_1 {
  protected long m_0(  int a){
    return 1;
  }
}
package Package_0;
import Package_1.*;
public class A_0 extends ClassId_1 {
  public ClassId_0 fieldid_0=new ClassId_0();
  protected long m_0(  int a){
    return fieldid_0.m_0(a);
}
}

package Package_0;
public class ClassId_0 extends A_0 {
  public long methodid_0(){
    return this.m_0(2);
  }

protected long m_0(  int a){
    return 0;
  }
}</thetext>
    </bug>
    <bug>
        <id>487016</id>
        <developer>Peter Rader</developer>
        <developer_username>p.rader</developer_username>
        <dup_id/>
        <creation_time>2016-02-02 09:46:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Wrong convert anonymous class to nested</short_desc>
        <thetext>Having this code:

public class Test {
	public abstract class Foo { }
	public static void main(String[] args) {
		final Test t = new Test();
		t.new Foo() {};
	}
}

In the outline-view rmb-click on the node "new Foo(){...}" let you refactor the anonymous-class to nested-class by specify a classname (Bar in example):

public class Test {
	public static final class Bar extends Foo {}
	public abstract class Foo {}
	public static void main(String[] args) {
		final Test t = new Test();
		new Bar();
	}
}

This can not compile because Bar is static. I expected to become this instead:

public class Test {
	public final class Bar extends Foo {}
	public abstract class Foo {}
	public static void main(String[] args) {
		final Test t = new Test();
		t.new Bar();
	}
}</thetext>
    </bug>
    <bug>
        <id>488174</id>
        <developer>David De</developer>
        <developer_username>daviddecoding</developer_username>
        <dup_id/>
        <creation_time>2016-02-21 12:32:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Class Resolver Map&lt;SocketChannel, List&gt; can't resolve any class correctly</short_desc>
        <thetext>Cannot resolve Map or generic classes.</thetext>
        <comment>
            <comment_id>2674149</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-21 15:29:06 -0500</when>
            <comment_text>Sorry, but you need to be much more specific if you want anybody to understand the problem.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488811</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-03-01 18:46:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[move method] A behavior preserving transformation (Move Method Refactoring) is rejected using the API of Eclipse</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the classes

package p1;
import p2.B;
public class A {
  public static int m(B b){
    return 0;
  }
}

package p2;
public class B {}

2. Apply the move method refactoring to move method m from class A to class B.

3. Using the API of Eclipse, it does not apply the transformation and warns the following message: This refactoring cannot be used to move static methods.


4. Using the Graphical User Interface, we can apply it:

package p1;
public class A {}

package p2;
public class B {
  public static int m(){
    return 0;
  }
}</thetext>
    </bug>
    <bug>
        <id>488812</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-03-01 18:50:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[move method] A behavior preserving transformation (Move Method Refactoring) is rejected because the method to be moved is synchronized</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following classes

package p1;
import p2.B;
public class A {
  public synchronized int m(B b){
    return 0;
  }
}

package p2;
public class B {}



2. Apply the move method refactoring to move method m() from class A to class B.

3. The tool does not apply the transformation and warn the following message:
This refactoring cannot be used to move synchronized methods.

4. Another refactoring tool applies the same transformation and the resulting program (the program below) preserves the program behavior.

package p1;
public class A {}

package p2;
public class B {
  public synchronized int m(){
    return 0;
  }
}</thetext>
    </bug>
    <bug>
        <id>488813</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-03-01 18:51:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[move method] A behavior preserving transformation (Move Method Refactoring) is rejected because the method to be moved has references to enclosing instances</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following classes

package p1;
import p2.B;
public class A {
  public class Inner {
    public void m( B b){
      System.out.println(A.this);
    }
  }
}

package p2;
public class B {}


2. Apply the move method refactoring to move method m(int) from class B to class C.

3. The tool does not apply the transformation and warn the following message:
The method cannot be moved, since it has references to enclosing instances.

4. Another refactoring tool applies the same transformation and the resulting program (the program below) preserves the program behavior.

package p1;
public class A {
  public class Inner {}
}

package p2;
import p1.A;
import p1.A.Inner;
public class B {
  public void m(Inner inner){
    System.out.println(inner);
  }
}</thetext>
    </bug>
    <bug>
        <id>489107</id>
        <developer>EPP Error Reports</developer>
        <developer_username>error-reports-inbox</developer_username>
        <dup_id/>
        <creation_time>2016-03-07 00:00:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>StringIndexOutOfBoundsException below LazyGenericTypeProposal.shouldAppendArguments</short_desc>
        <thetext>The following incident was reported via the automated error reporting:


    code:                   0
    plugin:                 org.eclipse.ui_3.107.0.v20150507-1945
    message:                Unhandled event loop exception
    fingerprint:            52699c27
    exception class:        java.lang.StringIndexOutOfBoundsException
    exception message:      String index out of range: 35
    number of children:     0
    
    java.lang.StringIndexOutOfBoundsException: String index out of range: 35
    at java.lang.String.charAt(null:-1)[REQUIRED, TOPMOST]
    at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.shouldAppendArguments(LazyGenericTypeProposal.java:670)[REQUIRED]
    at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:219)
    at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:326)
    at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:341)
    at org.eclipse.jdt.internal.ui.text.java.JavaMethodCompletionProposal.apply(JavaMethodCompletionProposal.java:58)
    at org.eclipse.recommenders.completion.rcp.processable.ProcessableParameterGuessingProposal.apply(ProcessableParameterGuessingProposal.java:172)[REQUIRED]
    at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:504)
    at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:489)
    at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:963)
    at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:914)
    at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1358)
    at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:814)
    at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:493)
    at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:66)
    at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
    at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4362)
    at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1113)
    at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1137)
    at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1122)
    at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:788)
    at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:5990)
    at org.eclipse.swt.custom.StyledText$7.handleEvent(StyledText.java:5682)
    at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
    at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4362)
    at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1113)
    at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1137)
    at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1122)
    at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1164)
    at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1160)
    at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1581)
    at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4781)
    at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:343)
    at org.eclipse.swt.widgets.Control.windowProc(Control.java:4662)
    at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339)
    at org.eclipse.swt.widgets.Display.windowProc(Display.java:5050)
    at org.eclipse.swt.internal.win32.OS.DispatchMessageW(OS.java:-2)
    at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)
    at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3767)
    at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127)
    at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
    at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018)
    at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)
    at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:654)
    at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
    at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598)
    at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
    at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139)
    at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
    at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
    at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
    at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
    at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(null:-2)
    at sun.reflect.NativeMethodAccessorImpl.invoke(null:-1)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(null:-1)
    at java.lang.reflect.Method.invoke(null:-1)
    at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)
    at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)
    at org.eclipse.equinox.launcher.Main.run(Main.java:1515)
   
  

General Information:

    reported-by:      
    anonymous-id:     25f19b00-0fdc-401b-8051-4765c9c1240b
    eclipse-build-id: 4.5.0.I20150603-2000
    eclipse-product:  org.eclipse.epp.package.java.product
    operating system: Windows8 6.2.0 (x86_64) - win32
    jre-version:      1.8.0_51-b16

The following plug-ins were present on the execution stack (*):
    1. org.eclipse.core.databinding.observable_1.5.0.v20150422-0725
    2. org.eclipse.core.databinding_1.5.0.v20150422-0725
    3. org.eclipse.core.runtime_3.11.0.v20150405-1723
    4. org.eclipse.e4.ui.workbench_1.3.0.v20150531-1948
    5. org.eclipse.e4.ui.workbench.swt_0.13.0.v20150504-0621
    6. org.eclipse.equinox.app_1.3.300.v20150423-1356
    7. org.eclipse.equinox.launcher_1.3.100.v20150511-1540
    8. org.eclipse.jdt.ui_3.11.0.v20150527-0925
    9. org.eclipse.jdt_3.11.0.v20150603-2000
    10. org.eclipse.jface.text_3.10.0.v20150603-1752
    11. org.eclipse.jface_3.11.0.v20150602-1400
    12. org.eclipse.recommenders.completion.rcp_2.2.0.v20150609-1848
    13. org.eclipse.swt_3.104.0.v20150528-0211
    14. org.eclipse.ui_3.107.0.v20150507-1945
    15. org.eclipse.ui.ide.application_1.1.0.v20150422-0725
    16. org.eclipse.ui.ide_3.11.0.v20150510-1749

Please note that:
* Messages, stacktraces, and nested status objects may be shortened.
* Bug fields like status, resolution, and whiteboard are sent
  back to reporters.
* The list of present bundles and their respective versions was
  calculated by package naming heuristics. This may or may not reflect reality.

Other Resources:
* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/55c7261ee4b09560a8aa3727  
* Manual: https://dev.eclipse.org/recommenders/community/confess/#/guide


Thank you for your assistance.
Your friendly error-reports-inbox.</thetext>
        <comment>
            <comment_id>2679321</comment_id>
            <comment_count>1</comment_count>
            <who>Andreas Sewe</who>
            <commenter_username>andreas.sewe</commenter_username>
            <when>2016-03-07 03:15:14 -0500</when>
            <comment_text>This is very likely a bug in JDT, as the only Code Recommenders frame on the stack trace...

(In reply to EPP Error Reports from comment #0)
&gt;     at
&gt; org.eclipse.recommenders.completion.rcp.processable.
&gt; ProcessableParameterGuessingProposal.
&gt; apply(ProcessableParameterGuessingProposal.java:172)[REQUIRED]

...starts the apply method with a super-call in line 172. In other words, the stacktrace contains effectively just JDT code. (FWIW, as of Code Recommenders 2.2.2, we don't copy apply at all: Bug 472474).

That being said, looking at code of LazyGenericTypeProposal.shouldAppendArguments, maybe it's worth catching a StringIndexOutOfBoundsException and rethrowing it with a better error message that includes the "line" String. Having just the index seems not enough to diagnose the issue. :-(</comment_text>
        </comment>
        <comment>
            <comment_id>2679628</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-07 19:52:24 -0500</when>
            <comment_text>Trying to understand the logic in the block in question:

Looking at this line in shouldAppendArguments():

	int index= offset - region.getOffset();

if at this point 'index &lt;= line.length()' then 'index' cannot get out of bounds without first triggering 'index == line.lenght()' at what point we would return true and all is fine.

Hence, I assume, that 'offset - region.getOffset()' already computes a point beyond the current 'line'. Which is odd, given that 'region' was computed as to contain 'offset', and 'line' represents the text corresponding to 'region'.

That would seem to indicate that these two lines:

	IRegion region= document.getLineInformationOfOffset(offset);
	String line= document.get(region.getOffset(), region.getLength());

- either produce a 'region' that is strictly to the left of 'offset',
- or produce a 'line' that's too short to contain the char at 'offset'

Both would IMHO indicate a bug in the underlying IDocument implementation, *or* a *concurrency* issue with the document being modified between these two lines??

What are the odds that 11 users independently encountered a concurrency problem hitting at such a short window?</comment_text>
        </comment>
        <comment>
            <comment_id>2679704</comment_id>
            <comment_count>3</comment_count>
            <who>Andreas Sewe</who>
            <commenter_username>andreas.sewe</commenter_username>
            <when>2016-03-08 03:52:06 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #2)
&gt; Trying to understand the logic in the block in question:
&gt; 
&gt; Looking at this line in shouldAppendArguments():
&gt; 
&gt; 	int index= offset - region.getOffset();
&gt; 
&gt; if at this point 'index &lt;= line.length()' then 'index' cannot get out of
&gt; bounds without first triggering 'index == line.lenght()' at what point we
&gt; would return true and all is fine.

Agreed. In order to throw at

  char ch= line.charAt(index);

'index &gt;= line.length' has to hold before the while loop. The alternative explanation, 'index &lt; 0', cannot be true, as that would have thrown a StringIndexOutOfBoundsException in the condition of the while loop already:

  Character.isUnicodeIdentifierPart(line.charAt(index))

&gt; Hence, I assume, that 'offset - region.getOffset()' already computes a point
&gt; beyond the current 'line'. Which is odd, given that 'region' was computed as
&gt; to contain 'offset', and 'line' represents the text corresponding to
&gt; 'region'.
&gt; 
&gt; That would seem to indicate that these two lines:
&gt; 
&gt; 	IRegion region= document.getLineInformationOfOffset(offset);
&gt; 	String line= document.get(region.getOffset(), region.getLength());
&gt; 
&gt; - either produce a 'region' that is strictly to the left of 'offset',
&gt; - or produce a 'line' that's too short to contain the char at 'offset'

What do you mean by "too short"? 'line.length() == 0'? AFAICT, that would return true rather than throwing.

&gt; Both would IMHO indicate a bug in the underlying IDocument implementation,
&gt; *or* a *concurrency* issue with the document being modified between these
&gt; two lines??
&gt; 
&gt; What are the odds that 11 users independently encountered a concurrency
&gt; problem hitting at such a short window?

Well, it's 11 users in 8 months [1] and content assist is triggered quite frequently, so I wouldn't rule that out completely, although it sounds unlikely.

[1] &lt;https://dev.eclipse.org/recommenders/committers/confess/#/problems/55c7261ee4b09560a8aa3727/similar?page=0&amp;size=20&amp;sort=timestamp,desc&gt;</comment_text>
        </comment>
        <comment>
            <comment_id>2679815</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-08 08:10:47 -0500</when>
            <comment_text>(In reply to Andreas Sewe from comment #3)
&gt; &gt; - or produce a 'line' that's too short to contain the char at 'offset'
&gt; 
&gt; What do you mean by "too short"? 'line.length() == 0'? AFAICT, that would
&gt; return true rather than throwing.

Illustration of what I meant:
offset = 110
region.getOffset() = 100 (line starts at offset 100)
index = 10 (from (110 - 100))
line.length() = 5 (line doesn't include the char at 110)

&gt; &gt; What are the odds that 11 users independently encountered a concurrency
&gt; &gt; problem hitting at such a short window?
&gt; 
&gt; Well, it's 11 users in 8 months [1] and content assist is triggered quite
&gt; frequently, so I wouldn't rule that out completely, although it sounds
&gt; unlikely.

so currently it's an "unlikely" explanation vs. no explanation :-/

To further elaborate the theory: if region was computed correctly, (with length &gt; 10 in the above example) then a too short line sounds like a result of a shorter buffer, that has EOF before position 110, otherwise regardless of any shift of positions the returned line should have a length &gt; 10. But wouldn't a region that extends beyond the current document throw IAE or similar in document.get()? Difficult to tell without knowing the exact type of document.</comment_text>
        </comment>
        <comment>
            <comment_id>2680152</comment_id>
            <comment_count>5</comment_count>
            <who>Andreas Sewe</who>
            <commenter_username>andreas.sewe</commenter_username>
            <when>2016-03-09 03:34:14 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #4)
&gt; (In reply to Andreas Sewe from comment #3)
&gt; &gt; &gt; - or produce a 'line' that's too short to contain the char at 'offset'
&gt; &gt; 
&gt; &gt; What do you mean by "too short"? 'line.length() == 0'? AFAICT, that would
&gt; &gt; return true rather than throwing.
&gt; 
&gt; Illustration of what I meant:
&gt; offset = 110
&gt; region.getOffset() = 100 (line starts at offset 100)
&gt; index = 10 (from (110 - 100))
&gt; line.length() = 5 (line doesn't include the char at 110)

FWIW, in the reported incidents 'line.length()' ranges from 5 to 44 (== to the 'index' at which StringIndexOutOfBoundsException is thrown), which seems pretty "normal" for a IDocument containing Java code.

&gt; To further elaborate the theory: if region was computed correctly, (with
&gt; length &gt; 10 in the above example) then a too short line sounds like a result
&gt; of a shorter buffer, that has EOF before position 110, otherwise regardless
&gt; of any shift of positions the returned line should have a length &gt; 10. But
&gt; wouldn't a region that extends beyond the current document throw IAE or
&gt; similar in document.get()?

At least AbstractDocument.get would throw BadLocationException (which LazyGenericTypeProposal.shouldAppendArguments handles, BTW).

&gt; Difficult to tell without knowing the exact type of document.

Agreed. Or even more specifically, the ILineTracker and ITextStore used under the hood by the IDocument in question.

I've added a "neeedinfo" request. Maybe some use provides the necessary information through the automated error reporting.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489704</id>
        <developer>Alex Blewitt</developer>
        <developer_username>alex.blewitt</developer_username>
        <dup_id/>
        <creation_time>2016-03-15 19:36:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Replace calls from new Integer to Integer.valueOf</short_desc>
        <thetext>Creating wrappers around Integers, especially for small numbers, results in a wasteful object creation on the heap. Using Integer.valueOf() allows the internal flyweight cache to be used instead; similarly for other primitive wrapper types. Some optimisations can be replaced; for example, new Integer().intValue() can be replaced with Integer.parseInt().</thetext>
        <comment>
            <comment_id>2682774</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-03-15 20:04:01 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/68508</comment_text>
        </comment>
        <comment>
            <comment_id>2692538</comment_id>
            <comment_count>2</comment_count>
            <who>Alex Blewitt</who>
            <commenter_username>alex.blewitt</commenter_username>
            <when>2016-04-09 16:24:11 -0400</when>
            <comment_text>There doesn't appear to have been any progress on reviewing the patch provided. Should we just close this as WONTFIX and abandon the Gerrit review?</comment_text>
        </comment>
        <comment>
            <comment_id>2692859</comment_id>
            <comment_count>3</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-04-11 08:14:29 -0400</when>
            <comment_text>(In reply to Alex Blewitt from comment #2)
&gt; There doesn't appear to have been any progress on reviewing the patch
&gt; provided. Should we just close this as WONTFIX and abandon the Gerrit review?

Sorry. We're just too busy with more important stuff at the moment.</comment_text>
        </comment>
        <comment>
            <comment_id>2692867</comment_id>
            <comment_count>4</comment_count>
            <who>Alex Blewitt</who>
            <commenter_username>alex.blewitt</commenter_username>
            <when>2016-04-11 08:27:44 -0400</when>
            <comment_text>(In reply to Dani Megert from comment #3)
&gt; (In reply to Alex Blewitt from comment #2)
&gt; &gt; There doesn't appear to have been any progress on reviewing the patch
&gt; &gt; provided. Should we just close this as WONTFIX and abandon the Gerrit review?
&gt; 
&gt; Sorry. We're just too busy with more important stuff at the moment. 

Understood. Have abandoned the Gerrit review.</comment_text>
        </comment>
        <comment>
            <comment_id>2692884</comment_id>
            <comment_count>5</comment_count>
            <who>Gautier de SAINT MARTIN LACAZE</who>
            <commenter_username>gautier.desaintmartinlacaze</commenter_username>
            <when>2016-04-11 08:45:37 -0400</when>
            <comment_text>Really ? I begin a review yesterday (this night in fact). Ok, I'm not a commit but I think your work is useful.</comment_text>
        </comment>
        <comment>
            <comment_id>2692923</comment_id>
            <comment_count>6</comment_count>
            <who>Alex Blewitt</who>
            <commenter_username>alex.blewitt</commenter_username>
            <when>2016-04-11 09:39:55 -0400</when>
            <comment_text>(In reply to Gautier de SAINT MARTIN LACAZE from comment #5)
&gt; Really ? I begin a review yesterday (this night in fact). Ok, I'm not a
&gt; commit but I think your work is useful.

A Gerrit review can be un-abandoned at any time and will still show the diffs from the link: it just means that it is parked. I appreciate with the upcoming release and Java 9 compatibility changes that the JDT team have more important things to do, but there's little point in keeping a review open if it's not going to get looked at until after Neon is released. I'd have volunteered to make it easier to review by breaking it down into smaller changes or other approaches, but even if I did Dani has indicated that they are focused on more important changes which wouldn't solve that problem.</comment_text>
        </comment>
        <comment>
            <comment_id>2693214</comment_id>
            <comment_count>7</comment_count>
            <who>Gautier de SAINT MARTIN LACAZE</who>
            <commenter_username>gautier.desaintmartinlacaze</commenter_username>
            <when>2016-04-11 17:05:39 -0400</when>
            <comment_text>Thanks for your explanation Alex.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490746</id>
        <developer>Thomas Ehrnhoefer</developer>
        <developer_username>thomas.ehrnhoefer</developer_username>
        <dup_id/>
        <creation_time>2016-03-31 01:56:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Copy / Paste stops working, only OS restart helps</short_desc>
        <thetext>I have been seeing a weird behaviour for a while now:

At some point, copy and paste stops working within Eclipse (that is, both the keyboard short cuts as well as the commands invoke via context menu). Not even a restart of Eclipse fixes this, I have to restart the OS.
However, it works fine in other applications (e.g. Chrome, Sublime).

This sounds very similar to https://bugs.eclipse.org/bugs/show_bug.cgi?id=483692, but on a Mac.

And I tend to disagree that it's NOT_ECLIPSE, since it's rather ONLY_ECLIPSE :)

Since the error log doesn't show anything about it, I have no more information really.</thetext>
        <comment>
            <comment_id>2690633</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-04-05 10:35:55 -0400</when>
            <comment_text>Do you use Sandbox of Comodo Internet Security?

Is it only in textual editors or also in fields inside dialogs, e.g. Search (Ctrl+H)?</comment_text>
        </comment>
        <comment>
            <comment_id>2690641</comment_id>
            <comment_count>2</comment_count>
            <who>Thomas Ehrnhoefer</who>
            <commenter_username>thomas.ehrnhoefer</commenter_username>
            <when>2016-04-05 10:44:16 -0400</when>
            <comment_text>No internet security software running (and I am on Mac, so no Windows software ;) ).

I haven't tried text boxes in dialogs, but it also didn't work for fields in the Mylyn task editor.

If it happens again (hasn't for 2 days, but I haven't used Eclipse heavily) I will play around a bit more to see if there are any editable fields that pasting does in deed work.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491071</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-04-05 07:17:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[pull up method] A behavior preserving transformation (Pull Up Method Refactoring) is rejected. [Field is referenced in one of the moved elements is not accessible from type ]</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following classes

public class A {
  int x;
}

public class B {
  int x;
  void m() {
    x++:
  }
}




2. Apply the pull up method refactoring to move method m() from class B to class A.

3. The tool does not apply the transformation and warn the following message:
Field 'B.x' referenced in one of the moved elements is not accessible from type 'A'.

4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong. 

public class A {
  int x;
  void m() {
    x++:
  }
}

public class B {
  int x;
}</thetext>
    </bug>
    <bug>
        <id>491073</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-04-05 07:37:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[move method] A behavior preserving transformation (Move Method Refactoring) is rejected. [This refactoring cannot be  used to move  potentially recursive methods]</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following classes

package p1;
import p2.B;
public class A {
  public int m(  B b){
    return m(b);
  }
}

package p2;
public class B {}




2. Apply the move method refactoring to move method m() from class A to class B.

3. The tool does not apply the transformation and warn the following message:
This refactoring cannot be used to move potentially recursive methods.

4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong. 

package p1;
import p2.B;
public class A  {}

package p2;
public class B  {
  public int m(p1.A a) {
    B b = this;
    return b.m(a);
  }
}</thetext>
    </bug>
    <bug>
        <id>491075</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-04-05 07:39:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[move method] A behavior preserving transformation (Move Method Refactoring) is rejected. [This refactoring cannot be used to move native methods.]</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following classes

package p;
public class A {
  public static native void m(){}
}

package p;
class B {}



2. Apply the move method refactoring to move method m() from class A to class X.

3. The tool does not apply the transformation and warn the following messages:
This refactoring cannot be used to move static methods.
This refactoring cannot be used to move native methods.

4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong. 

package p;
public class A  {}

package p;
class X  {
  public static native void m() {}
}</thetext>
    </bug>
    <bug>
        <id>491076</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-04-05 07:43:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[pull up method] A behavior preserving transformation (Pull Up Method Refactoring) is rejected. [Method declared in type has visibility lower than]</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following classes

package p;
class A {}

class B extends A {
  public void m(){
  }
}
class B1 extends A {
  private void m(){
  }
}


2. Apply the pull up method refactoring to move method m() from class B to class A.

3. The tool does not apply the transformation and warn the following message:
Method 'p.B1.m()' declared in type ‘p.B1' has visibility lower than ‘package', which will result in compile errors if you proceed.

4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong. 

package p;
class A  {
  void m() {
  }
}

class B extends A  {
}

class B1 extends A  {
  void m() {
  }
}</thetext>
    </bug>
    <bug>
        <id>491087</id>
        <developer>Christoph Schneegans</developer>
        <developer_username>christoph</developer_username>
        <dup_id/>
        <creation_time>2016-04-05 09:48:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Save action does not add 'this' qualifier to fields in inner classes of interfaces</short_desc>
        <thetext>It seems that the save action "Use 'this' qualifier for field accesses" ignores inner classes in interfaces, while it works properly with inner classes of classes.

Enable the save action "Use 'this' qualifier for field accesses" and set its value to "Always". Then save the following code snippet:

interface A
{
    class B
    {
        String field;

        B() { field = "foo"; }
    }
}

class C
{
    class D
    {
        String field;

        D() { field = "bar"; }
    }
}

The first assignment statement (in class B) will remain unchanged, while the second assignment statement (in class D) will be changed as expected:

  this.field = "bar";

Note that when the compiler warning "Unqualified access to instance field" is set e.g. to "Warning", both instances in the original code above show with warning markers in the editor. Thus, the save action should fix both instances, too.

-- Configuration Details --
Product: Eclipse 4.5.2.20160218-0600 (org.eclipse.epp.package.jee.product)
Installed Features:
 org.eclipse.jdt 3.11.2.v20160212-1500</thetext>
        <comment>
            <comment_id>2690901</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-06 03:20:19 -0400</when>
            <comment_text>Reproducible in master. Moving to UI.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491448</id>
        <developer>Mickael Istria - away until ...</developer>
        <developer_username>mistria</developer_username>
        <dup_id/>
        <creation_time>2016-04-11 11:58:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>An "Override as visible" quickfix for "method not visible"</short_desc>
        <thetext/>
        <comment>
            <comment_id>2693043</comment_id>
            <comment_count>1</comment_count>
            <who>Mickael Istria - away until ...</who>
            <commenter_username>mistria</commenter_username>
            <when>2016-04-11 12:01:05 -0400</when>
            <comment_text>If a method is not visible, there is no quickfix available.
An interesting one would be an "Override and delegate as visible" that would create the overriden version of the method, with visibility set to something convenient, and with default implementation being super.method(...).</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491541</id>
        <developer>Jongwook Kim</developer>
        <developer_username>jongwook.kim</developer_username>
        <dup_id/>
        <creation_time>2016-04-12 15:23:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[pull up] cannot pull up a field when subclasses have fields with different type</short_desc>
        <thetext>Given:

class A {}

class B extends A {
  int f;
}

class C extends A {
  String f
}

It's not allowed to pull up field B.f to class A. 

The Eclipse error message is: 

"Field C.f declared in type C has a different type than its moved counterpart"

, which is not a problem.</thetext>
    </bug>
    <bug>
        <id>492776</id>
        <developer>Rüdiger Herrmann</developer>
        <developer_username>ruediger.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-05-01 07:13:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[rename] Renaming a method should adjust parameter indentation</short_desc>
        <thetext>After renaming a method like 
  void veryLongMethodName( Object arg0,
                           Object arg1 );
to a shorter name, the indentation of argument lists that span multiple lines are not adjusted. The outcome looks like this:
  void shortName( Object arg0,
                           Object arg1 );

The rename method refactoring should adjust the indentation of the line-wrapped arguments list so that the second and following lines align with the first line again. This approach should only be applied if the code formatter is configured to indent on columns.

Expected result:
  void shortName( Object arg0,
                  Object arg1 );</thetext>
    </bug>
    <bug>
        <id>492951</id>
        <developer>Andrey Loskutov</developer>
        <developer_username>loskutov</developer_username>
        <dup_id/>
        <creation_time>2016-05-04 03:36:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[build path] "Add to Build Path" should not allow to add *anything*</short_desc>
        <thetext>AS IS:
Go to *any* file in a Java project (let say pom.xml), right click on it and say "Build Path -&gt; Add to Build Path". 

1) The pom.xml appears int the "Referenced Libraries" node, 
2) a build path error is created: "Description	Resource	Path	Location	Type
Archive for required library: 'pom.xml' in project 'org.eclipse.ui' cannot be read or is not a valid ZIP file	org.eclipse.ui		Build path	Build Path Problem"
3) An error is logged: "org.eclipse.jdt.core Error Invalid ZIP archive: pom.xml [in org.eclipse.ui]"

TO BE:
There must be some restrictions added to the action (e.g. show the menu only on *.jar, *.war, *.ear, *.zip files) OR at least some trivial validation checks should be done in AddSelectedLibraryToBuildpathAction (e.g. check if the file can be opened by a zip stream or something like that).

This is of course stupid to do such things from the user side (but it happened in real life :-) ), but if one accidentally selects more or different files as planned, this will break the project compilation state and this is not nice.

Reproducible in Eclipse 3.8.2 / 4.6 M6</thetext>
    </bug>
    <bug>
        <id>493131</id>
        <developer>Lukas Eder</developer>
        <developer_username>lukas.eder</developer_username>
        <dup_id/>
        <creation_time>2016-05-06 07:06:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[refactoring] Support refactoring to generate generic utility methods</short_desc>
        <thetext>I run into this issue quite frequently, and then I have to resort to a lot of manual work, which I imagine might be possible for Eclipse to refactor automatically. For instance, I have the following method, which doesn't compile:

------------------------------------------
    public static void swap(List&lt;?&gt; list) {
        list.set(0, list.set(1, list.get(0)));
        System.out.println(list);
    }
------------------------------------------

It doesn't compile because of the JLS's wildcard capturing specification (which is a bit unfortunate). The "?" type returned from "list.get(0)" is the same "?" as the one from the "list" parameter, but it is a different "?" from the "?" that "list.set(1, ?)" takes as an argument, even if we're always operating on the same parameter "list".

Now, it would be great if I could select some code and refactor the code into a method that introduces a type variable just for that. The result would look like this:

------------------------------------------
    public static void swap(List&lt;?&gt; list) {
        refactored(list);
        System.out.println(list);
    }

    private static &lt;T&gt; void refactored(List&lt;T&gt; list) {
        list.set(0, list.set(1, list.get(0)));
    }
------------------------------------------

Of course, I could manually introduce this type variable, but let's assume that "swap" is some public API that I don't want to modify. In particular, I don't want the type variable to leak into the public API.</thetext>
        <comment>
            <comment_id>2703746</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-06 08:04:05 -0400</when>
            <comment_text>I don't know how complicated this is going to be, but moving to UI for consideration.</comment_text>
        </comment>
        <comment>
            <comment_id>2703748</comment_id>
            <comment_count>2</comment_count>
            <who>Lukas Eder</who>
            <commenter_username>lukas.eder</commenter_username>
            <when>2016-05-06 08:08:20 -0400</when>
            <comment_text>Thanks for moving. Indeed, it might get a bit complicated. The simplest feature description that I can imagine is, though:

1. When refactoring/extracting a method...
2. ... check if the selection captures any wildcards
3. ... check if those wildcards are really the "same thing", from an "intuitive perspective", i.e. if they can bind to a single type variable.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>493212</id>
        <developer>Lukas Eder</developer>
        <developer_username>lukas.eder</developer_username>
        <dup_id/>
        <creation_time>2016-05-09 04:46:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[refactor] Move type to new file doesn't correctly alter static imported references</short_desc>
        <thetext>I have the following annotation:


---------------------------------------------
package test;

import static test.Annotation.E.X;

public @interface Annotation {

    E e() default X;

    enum E {
        X, Y, Z;
    }
}

---------------------------------------------

I now choose to refactor -&gt; move type to new file on the enum E. This produces the following invalid code, as the static import is left untouched:

---------------------------------------------
package test;

import static test.Annotation.E.X;

public @interface Annotation {

    E e() default X;
}
---------------------------------------------
package test;

public enum E {
    X, Y, Z;
}
---------------------------------------------

The expected output is:

---------------------------------------------
package test;

import static test.E.X; // Fix here

public @interface Annotation {

    E e() default X;
}
---------------------------------------------
package test;

public enum E {
    X, Y, Z;
}
---------------------------------------------</thetext>
        <comment>
            <comment_id>2705394</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-11 06:49:21 -0400</when>
            <comment_text>This most likely belongs in the UI. Please move back if this is a problem in rewrite.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>493214</id>
        <developer>Lukas Eder</developer>
        <developer_username>lukas.eder</developer_username>
        <dup_id/>
        <creation_time>2016-05-09 04:52:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[quick fix] Add option to static import enum literal where this is "obvious"</short_desc>
        <thetext>I have the following code:

------------------------------------------------
package test;

public @interface Test {

    E e() default X;

    enum E {
        X, Y, Z
    }
}
------------------------------------------------

In the above context, "default X" can mean only one thing: "default E.X". Unfortunately, quick fix only offers two options "create field X" and "create constant X", both of which don't even produce compilable code. Instead, the following two options would be very useful:

1. Static import E.X
2. Qualify X to be E.X

The respective output of the two refactorings would be:


1. Static import E.X
------------------------------------------------
package test;

import static test.Test.E.X;

public @interface Test {

    E e() default X;

    enum E {
        X, Y, Z
    }
}
------------------------------------------------

2. Qualify X to be E.X
------------------------------------------------
package test;

public @interface Test {

    E e() default E.X;

    enum E {
        X, Y, Z
    }
}
------------------------------------------------</thetext>
    </bug>
    <bug>
        <id>495125</id>
        <developer>Roland Illig</developer>
        <developer_username>rillig</developer_username>
        <dup_id/>
        <creation_time>2016-06-01 05:32:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Generate Constructor: Allow Insertion point after last field</short_desc>
        <thetext>Currently, when generating a constructor, it is inserted after the last member. In the common case where a class already has methods, this will be after the last method.

It should be possible to insert the constructor between the fields and the method, where it belongs, according to the Java Coding Conventions.

References:
http://www.oracle.com/technetwork/java/codeconventions-150003.pdf, section 3.1.1, p1.</thetext>
        <comment>
            <comment_id>2715926</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-01 18:21:04 -0400</when>
            <comment_text>Are you referring to 
  - Source &gt; Generate Constructor using Fields...
  - Source &gt; Generate Constructors from Superclass...
?

Both these commands are completely agnostic to ordering, they just insert their stuff at the current cursor location (and thus don't stop you from having it at your desired location).

Do you observe s.t. different?</comment_text>
        </comment>
        <comment>
            <comment_id>2715971</comment_id>
            <comment_count>2</comment_count>
            <who>Roland Illig</who>
            <commenter_username>rillig</commenter_username>
            <when>2016-06-02 02:48:49 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #1)
&gt; Are you referring to 
&gt;   - Source &gt; Generate Constructor using Fields...
&gt;   - Source &gt; Generate Constructors from Superclass...
&gt; ?

Yes, exactly.

When I click on “Source &gt; Generate Constructor using Fields...”, a large dialog opens. Below the checkbox-list of fields, there is a combobox where I can select the “Insertion point”. I was referring to that.</comment_text>
        </comment>
        <comment>
            <comment_id>2716133</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-02 07:22:54 -0400</when>
            <comment_text>(In reply to Roland Illig from comment #2)
&gt; (In reply to Stephan Herrmann from comment #1)
&gt; &gt; Are you referring to 
&gt; &gt;   - Source &gt; Generate Constructor using Fields...
&gt; &gt;   - Source &gt; Generate Constructors from Superclass...
&gt; &gt; ?
&gt; 
&gt; Yes, exactly.
&gt; 
&gt; When I click on “Source &gt; Generate Constructor using Fields...”, a large
&gt; dialog opens. Below the checkbox-list of fields, there is a combobox where I
&gt; can select the “Insertion point”. I was referring to that.

Thanks. So this combo is initialized with s.t. like "after foo()" describing the current cursor position, which makes this the default behavior. The combo also offers "first member" and "last member", the latter selecting the behavior you describe.

=&gt; You seem to be requesting another fixed option here. Which one would it be?
- "After last field"
- "First method"
?

I.e., what happens if fields and methods are happily mixed in a file? Other question: should this option distinguish constructors from regular methods? Should the option, e.g., read: "Last constructor"?</comment_text>
        </comment>
        <comment>
            <comment_id>2716629</comment_id>
            <comment_count>4</comment_count>
            <who>Roland Illig</who>
            <commenter_username>rillig</commenter_username>
            <when>2016-06-03 04:25:03 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #3)
&gt; =&gt; You seem to be requesting another fixed option here. Which one would it
&gt; be?
&gt; - "After last field"
&gt; - "First method"
&gt; ?
&gt; 
&gt; I.e., what happens if fields and methods are happily mixed in a file?

I prefer the choice “After last field”.

&gt; should this option distinguish constructors from regular methods?

When there are constructors, the new constructor should be inserted below the existing ones.

&gt; Should the option, e.g., read: "Last constructor"?

When I generate a constructor, it is mostly because no other constructor exists. Therefore this wording could be confusing. Same for “Before first method” when the methods don’t exist yet.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495342</id>
        <developer>Raffi Khatchadourian</developer>
        <developer_username>raffi.khatchadourian</developer_username>
        <dup_id/>
        <creation_time>2016-06-02 15:46:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.checkAccesses(IProgressMonitor) doesn't check constructors for accessibility</short_desc>
        <thetext>org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.checkAccesses(IProgressMonitor) checks accessed methods of the pulled up members but this method actually ignores constructors. Particularly, org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.checkAccessedMethods(IProgressMonitor, ITypeHierarchy) uses org.eclipse.jdt.internal.corext.refactoring.structure.ReferenceFinderUtil.getMethodsReferencedIn(IJavaElement[], WorkingCopyOwner, IProgressMonitor) to find methods accessed by the pulled up members. That method doesn't return referenced constructors.


-- Configuration Details --
Product: Eclipse 4.5.2.20160218-0600 (org.eclipse.epp.package.committers.product)
Installed Features:
 org.eclipse.jdt 3.11.2.v20160212-1500</thetext>
        <comment>
            <comment_id>2716877</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-03 11:05:15 -0400</when>
            <comment_text>Moving to UI</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495348</id>
        <developer>Gabor</developer>
        <developer_username>marotig</developer_username>
        <dup_id/>
        <creation_time>2016-06-02 18:18:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[quick assist] rename breaks the Java code</short_desc>
        <thetext>Quick-assist-rename fails in the following case.

Full working example:
   class Foo {           // (1)
       private int _bar; // (2) &lt;-- this variable is to be renamed
       Foo( int bar ) {  // (3)
          _bar = bar;    // (4) &lt;-- problem should appear here
       }                 // (5)
   }                     // (6)

Action:
  - Use quick-assist-rename (Ctrl+2 R) on "_bar" in line (2), change it to
    "bar".

Expected outcome:
  - Complaint that the assignment in line (4) will cause problems.

Actual outcome:
  - In line (4), the assignment "_bar = bar" is turned to "bar = bar".
  - The left-hand side of the assignment changes its meaning: suddenly, it
    starts referring to the local variable that is declared in line (3).

Described behaviour found in:
  - Eclipse-4.5.2 on Fedora Linux
  - Eclipse-4.4 on Windows 7

Remarks
  - Workspace-wide rename (Alt+Shift+R) works perfectly, it does give a warning.
  - Several easy tricks would prevent the problem, e.g., the use of the "this"
    qualifier in line (4).  Still, renaming shouldn't punish the untidy hacker
    in such a harsh way.</thetext>
        <comment>
            <comment_id>2717013</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-03 18:32:28 -0400</when>
            <comment_text>Moving to JDT/UI, though I think this may be a WONTFIX, because:


(1) This operation is not a full refactoring, it comes with no guarantee of creating correct code.
Here's another simple way of creating garbage using Rename in file:
//---
class Foo {
   int zork;
   int bar;
}
//---
Select "bar" and rename it to "zork". Boom.


(2) There *is* a warning
The case in comment 0 is flagged by a the following warning after rename:

          bar = bar;    // (4) &lt;-- problem should appear here
          ^^^^^^^^^
The assignment to variable bar has no effect


Ergo: to get some guarantees about semantically valid changes, always use the true refactoring. That's what it is for.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495359</id>
        <developer>Roland Illig</developer>
        <developer_username>rillig</developer_username>
        <dup_id/>
        <creation_time>2016-06-03 04:38:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Generate Constructor: generate useful constructor instead of default constructor</short_desc>
        <thetext>Given the following code:

public class KeyValue {

  private final String key;
  private final String value;
  
  ${cursor}
  
}

I have just defined a class having two fields, and now I need to add all the boilerplate code that Java requires:

* the constructor(s); only one in this case
* the getters
* the setters

When I press Ctrl+Space now, Eclipse offers me to insert a default constructor for the class, which is completely off-topic, since all fields are final. What I want Eclipse to insert is:

* a constructor for all final fields
* the getters for these fields, followed by its setters (unless the field is final)

This is such a common task that it should be simple to achieve. Pressing Ctrl+Space is ideal in this situation because this shortcut is used heavily in this situation. It’s just that the offered options are not appropriate to the current context.

Other example:

public class ModifiableKeyValue {

  private String key; 
  private String value; 

  ${cursor}

}

Pressing Ctrl+Space should offer to generate in one go:

* the default constructor
* the constructor initializing all fields
* for each field the getter and the setter

public class KeyModifiableValue {

  private final String key; 
  private String value; 

  ${cursor}

}

Pressing Ctrl+Space should offer to generate in one go:

* the constructor initializing all final fields
* the constructor initializing all fields
* for each field the getter and the setter</thetext>
        <comment>
            <comment_id>2717016</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-03 18:46:01 -0400</when>
            <comment_text>Are you aware of the following commands?

  Source &gt; Generate Getters and Setters

  Source &gt; Generate Constructor using Fields

They seem to do exactly what you request. Just these commands are not suitable for Ctrl+Space because user input is required for selecting various options.


Off-topic:

(In reply to Roland Illig from comment #0)
&gt; [...] and now I need to add all the boilerplate code that Java requires:
&gt; [..]
&gt; * the getters
&gt; * the setters

Java doesn't require getters and setters, it's so-called "best practice", nothing more. The following classes are fully equivalent:

final class Foo1 {
   private String val;
   public void setVal(String val) {
      this.val = val;
   }
   public String getVal() {
      return this.val;
   }
}

final class Foo2 {
   public String val;
}

The choice is your's :)</comment_text>
        </comment>
        <comment>
            <comment_id>2717419</comment_id>
            <comment_count>2</comment_count>
            <who>Roland Illig</who>
            <commenter_username>rillig</commenter_username>
            <when>2016-06-06 05:14:41 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #1)
&gt; Are you aware of the following commands?
&gt; 
&gt;   Source &gt; Generate Getters and Setters
&gt; 
&gt;   Source &gt; Generate Constructor using Fields
&gt; 
&gt; They seem to do exactly what you request. Just these commands are not
&gt; suitable for Ctrl+Space because user input is required for selecting various
&gt; options.

I am aware of these commands, but they feed too far away from the code I’m currently editing. I’m focused on typing on the keyboard, and these commands currently require me to nagivate through the menus, open some large dialogs and require me to do several choices.

I think most of these choices are normally not necessary. That’s why I would like the Ctrl+Space menu to be extended with generating a _suitable_ constructor instead of the default one. And while here, I thought it would be nice if Eclipse generated the getters and setters along the way.

&gt; Off-topic:
&gt; 
&gt; (In reply to Roland Illig from comment #0)
&gt; &gt; [...] and now I need to add all the boilerplate code that Java requires:
&gt; &gt; [..]
&gt; &gt; * the getters
&gt; &gt; * the setters
&gt; 
&gt; Java doesn't require getters and setters, it's so-called "best practice",
&gt; nothing more.

Shouldn’t Eclipse make it easy for Java developers to follow so-called “best practice”? ;) And, by the way, Java is not the programming language alone, it is also the frameworks and common sense around that language. At _that_ requires me to write getters and setters.

&gt; The following classes are fully equivalent:
&gt; final class Foo1 {
&gt;    private String val;
&gt;    public void setVal(String val) { this.val = val; }
&gt;    public String getVal() { return this.val; }
&gt; }
&gt; 
&gt; final class Foo2 {
&gt;    public String val;
&gt; }

If they were fully equivalent, Java would be a great language. But they are not. I cannot use the second class in JSPs and several other technologies.

&gt; The choice is your's :)

No, it isn’t. I’m bound to the frameworks that my projects have chosen several years ago. Therefore I am required to have all this boilerplate in my code. It would be nice of Eclipse to support me doing this boring coding.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495393</id>
        <developer>Nikolay Metchev</developer>
        <developer_username>nikolaymetchev</developer_username>
        <dup_id/>
        <creation_time>2016-06-03 08:44:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Extract Local Variable erroneously dissallowed</short_desc>
        <thetext>In the code below if you try and extract local variable the method call getX() you get a pop up saying:
"Code from explicit constructor calls cannot be extracted to a variable".
While the code is ultimately in an explicit super constructor call it can still be extracted into its own variable because it actually lives in an anonymous inner class.

------------------------------------
class Sup {
  public Sup(Runnable run) {};
}
public class Main  extends Sup{
  public Main() {
    super(new Runnable() {
      @Override
      public void run() {
        getX(); //extract local variable here
      }

      public String getX() { return "X"; }
    });
  }
}

-----------Expected result-------------
class Sup {
  public Sup(Runnable run) {};
}
public class Main  extends Sup{
  public Main() {
    super(new Runnable() {
      @Override
      public void run() {
        String x = getX(); //extract local variable here
      }

      public String getX() { return "X"; }
    });
  }
}</thetext>
    </bug>
    <bug>
        <id>495528</id>
        <developer>Tim De Backer</developer>
        <developer_username>tim.debacker.dev</developer_username>
        <dup_id/>
        <creation_time>2016-06-06 06:53:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Change default catch block template to throw RuntimeException instead of swallowing</short_desc>
        <thetext/>
        <comment>
            <comment_id>2717448</comment_id>
            <comment_count>1</comment_count>
            <who>Tim De Backer</who>
            <commenter_username>tim.debacker.dev</commenter_username>
            <when>2016-06-06 06:57:45 -0400</when>
            <comment_text>I don't want to start a debate about the usefulness on checked exceptions.

There are some very good arguments in this post (which I'm linking, as I'm quoting from it):
http://stackoverflow.com/a/614494/2095738 (pro)
http://stackoverflow.com/a/614330/2095738 (contra)

What both sides agree on and what every Java developer has learned from experience is that swallowing checked exceptions is about the worst solution. And yet this is exactly what the Eclipse IDE does.


    [Get] in the habit of whenever you have to handle a checked exception and you're feeling lazy (or you think the API programmer was overzealous in using the checked exception in the first place), don't just swallow the exception, wrap it and rethrow it.

    try {
        overzealousAPI(thisArgumentWontWork);
    } catch (OverzealousCheckedException e) {
        throw new RuntimeException(e);  
    }

    Put this in one of your IDE's little code templates and use it when you're feeling lazy. This way if you really need to handle the checked exception you'll be forced to come back and deal with it after seeing the problem at runtime. Because, believe me (and Anders Hejlsberg) you're never going to come back to that TODO in your

    catch (Exception e) { /* TODO deal with this at some point (yeah right) */}</comment_text>
        </comment>
        <comment>
            <comment_id>2717449</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-06 07:01:33 -0400</when>
            <comment_text>I am sorry, is there a bug report or enhancement request here? If so, can you clearly state what you would like Eclipse to do here?</comment_text>
        </comment>
        <comment>
            <comment_id>2717473</comment_id>
            <comment_count>3</comment_count>
            <who>Tim De Backer</who>
            <commenter_username>tim.debacker.dev</commenter_username>
            <when>2016-06-06 08:00:07 -0400</when>
            <comment_text>This is an enhancement request. Sorry if this is not the appropriate place to report these.

Swallowing checked exceptions is not considered 'good practice' in Java. 

For that reason, Eclipse - being a Java IDE - should change its default template for a catch block from "swallow and print something" to "rethrow unchecked".</comment_text>
        </comment>
        <comment>
            <comment_id>2717762</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-07 00:48:46 -0400</when>
            <comment_text>(In reply to Tim De Backer from comment #3)
&gt; This is an enhancement request. Sorry if this is not the appropriate place
&gt; to report these.

It is. Sorry, I didn't pay close attention to the bug summary. Moving to UI where the templates belong.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495571</id>
        <developer>ugur ata</developer>
        <developer_username>ataugur</developer_username>
        <dup_id/>
        <creation_time>2016-06-07 02:13:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Java 8 Lambda toMap does not auto complete correctly</short_desc>
        <thetext>I am trying to map an entity list using an attribute as the key but auto complete considers entity as Object type and only shows Object methods. When I type the method name no errors shown though.


void method(List&lt;CustomTable&gt; tables) {
     private Map&lt;String, CustomTable&gt; tablesMap;

     tablesMap = tables.stream().collect(Collectors.toMap(t -&gt; t.getName(), t -&gt; t));
}

This code works but auto complete does not show options for CustomTable entity but only from Object type.</thetext>
        <comment>
            <comment_id>2717774</comment_id>
            <comment_count>1</comment_count>
            <who>ugur ata</who>
            <commenter_username>ataugur</commenter_username>
            <when>2016-06-07 02:14:21 -0400</when>
            <comment_text>I am using 4.6 RC3 of Java EE Edition</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495857</id>
        <developer>Andreas Sewe</developer>
        <developer_username>andreas.sewe</developer_username>
        <dup_id/>
        <creation_time>2016-06-10 04:58:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[type wizards] New Annotation dialog should allow generating @Inherited</short_desc>
        <thetext>Bug 339292 is a really nice enhancement of the "New Annotation" dialog (looking forward to it in Neon :-), but it doesn't offer adding java.lang.annotation.Inherited [1]. I think it should.

Also, if no @Target is selected which is inheritable as per [1], a warning should be displayed.

[1] &lt;http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html&gt;</thetext>
        <comment>
            <comment_id>2726502</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-07-01 20:04:11 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/76461</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495874</id>
        <developer>Raffi Khatchadourian</developer>
        <developer_username>raffi.khatchadourian</developer_username>
        <dup_id/>
        <creation_time>2016-06-10 08:50:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>PullUp pulls up a method referencing a type variable that is not present in the super class</short_desc>
        <thetext>PullUp pulls up a method referencing a type variable that is not present in the super class. This results in a compile-time error after the refactoring. There is no warning issued. 

Before:

package p;

class I {
}

abstract class A&lt;E&gt; extends I {
	public void m() {
		E e = null;
	}
}

After:

package p;

class I {

	public void m() {
		E e = null;
	}
}

abstract class A&lt;E&gt; extends I {
}

E is not bound to any existing type variable.
-- Configuration Details --
Product: Eclipse 4.5.2.20160218-0600 (org.eclipse.epp.package.committers.product)
Installed Features:
 org.eclipse.jdt 3.11.2.v20160212-1500</thetext>
    </bug>
    <bug>
        <id>495877</id>
        <developer>Raffi Khatchadourian</developer>
        <developer_username>raffi.khatchadourian</developer_username>
        <dup_id/>
        <creation_time>2016-06-10 09:12:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Pull Up ignores type parameter bounds</short_desc>
        <thetext>Before:

package p;

class I&lt;E&gt; {
}

abstract class A&lt;E extends java.util.AbstractList&lt;String&gt;&gt; extends I&lt;E&gt; {
	public void m() {
		E e = null;
		e.add("test");
	}
}

After:

package p;

class I&lt;E&gt; {

	public void m() {
		E e = null;
		e.add("test");
	}
}

abstract class A&lt;E extends java.util.AbstractList&lt;String&gt;&gt; extends I&lt;E&gt; {
}

This results in a compile-time error. No warnings are issued prior to the refactoring taking place.

-- Configuration Details --
Product: Eclipse 4.5.2.20160218-0600 (org.eclipse.epp.package.committers.product)
Installed Features:
 org.eclipse.jdt 3.11.2.v20160212-1500</thetext>
    </bug>
    <bug>
        <id>495899</id>
        <developer>Jongwook Kim</developer>
        <developer_username>jongwook.kim</developer_username>
        <dup_id/>
        <creation_time>2016-06-10 13:36:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[move method] an extra parameter of the original class type should be introduced</short_desc>
        <thetext>When method A.m is moved to class B without leaving behind a delegate, class creation new A() is not evaluated after the move. That is because JDT does not introduce an extra parameter of type A when method m has no references to the members of A. It changes program behavior when the prefix expression of m invocation causes side effects. 

BEFORE
-----------------------------------
class A {
	void m(B b) {}

	void n() {
		new A().m(new B());
	}
}


AFTER
-----------------------------------
class A {
	void n() {
		new B().m();  // BUG: new A() is removed
	}
}

class B {
	void m() {}
}</thetext>
        <comment>
            <comment_id>2719505</comment_id>
            <comment_count>1</comment_count>
            <who>Jongwook Kim</who>
            <commenter_username>jongwook.kim</commenter_username>
            <when>2016-06-10 13:40:14 -0400</when>
            <comment_text>The extra parameter (of original class type A) is unnecessary only when the prefixes of all method invocations are simple variables, which are free from
side-effects.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495901</id>
        <developer>Jongwook Kim</developer>
        <developer_username>jongwook.kim</developer_username>
        <dup_id/>
        <creation_time>2016-06-10 13:48:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[move method] move method changes the order of evaluating prefix/argument expressions</short_desc>
        <thetext>When A.m is moved to class C using the second parameter, the order of evaluating argument expressions is changed after the move. The m invocation in method n below is evaluated before the move:

new A(), new B(), new C(), new D() in order

After the move, the evaluation order becomes:

new C(), new B(), new A(), new D() 

So the program behavior may change when the argument expressions have side effects.


BEFORE
----------------------------------------------------
class A {
	int i = 0;

	void m(B b, C c, D d) {
		i = 0;
	}

	void n() {
		new A().m(new B(), new C(), new D());
	}
}

class C {
}


AFTER
----------------------------------------------------
class A {
	int i = 0;

	void n() {
		new C().m(new B(), new A(), new D());  // reordering
	}
}

class C {
	void m(B b, A a, D d) {
		a.i = 0;
	}
}</thetext>
    </bug>
    <bug>
        <id>495902</id>
        <developer>Jongwook Kim</developer>
        <developer_username>jongwook.kim</developer_username>
        <dup_id/>
        <creation_time>2016-06-10 14:00:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[change method signature] removing parameter(s) gets rid of argument expressions</short_desc>
        <thetext>When the parameter (of type B) of method m is removed, m invocation does not evaluate the corresponding argument expression new B() after the refactoring. When the argument expression has side effects, the change-method-signature may change program behavior.

BEFORE
-----------------------------------
class A {
	void m(B b) {}

	void n() {
		new A().m(new B());
	}
}


AFTER
-----------------------------------
class A {
	void m() {}

	void n() {
		new A().m();
	}
}</thetext>
    </bug>
    <bug>
        <id>495903</id>
        <developer>Jongwook Kim</developer>
        <developer_username>jongwook.kim</developer_username>
        <dup_id/>
        <creation_time>2016-06-10 14:06:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[change method signature] adding a new parameter may have a default value with side effects</short_desc>
        <thetext>When method m introduces a new parameter (of type B) whose default value is new B(), m invocation will evaluate its argument expression new B() after the refactoring. When the argument expression has side effects, the change-method-signature may change program behavior.

BEFORE
-----------------------------------
class A {
	void m() {}

	void n() {
		new A().m();
	}
}

AFTER
-----------------------------------
class A {
	void m(B b) {}

	void n() {
		new A().m(new B());  // new B() may have side effects
	}
}</thetext>
    </bug>
    <bug>
        <id>495905</id>
        <developer>Jongwook Kim</developer>
        <developer_username>jongwook.kim</developer_username>
        <dup_id/>
        <creation_time>2016-06-10 14:13:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[change method signature] reordering parameters changes the order of evaluating argument expressions</short_desc>
        <thetext>When the parameters of method m is reordered from B, C, D to C, D, B, the corresponding argument expressions in m invocation change their evaluation order from new B(), new C(), new D() to new C(), new D(), new B(). When the argument expressions have side effects, the program behavior may change.


BEFORE
----------------------------------------------------
class A {
	void m(B b, C c, D d) {
	}

	void n() {
		new A().m(new B(), new C(), new D());
	}
}


AFTER
----------------------------------------------------
class A {
	void m(C c, D d, B b) {}	

	void n() {
		new A().m(new C(), new D(), new B());  // reordering
	}
}</thetext>
    </bug>
    <bug>
        <id>495907</id>
        <developer>Jongwook Kim</developer>
        <developer_username>jongwook.kim</developer_username>
        <dup_id/>
        <creation_time>2016-06-10 14:20:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[move method] move method can reference null-valued prefix (causing null pointer exception)</short_desc>
        <thetext>When method m is moved to class B, m invocation will use its null-valued argument as the prefix after the move. 

BEFORE
------------------------------
class A {
	void m(B b) {
	}

	void n() {
		B b = null;
		m(b);
	}
}

class B {
}


AFTER
------------------------------
class A {
	void n() {
		B b = null;
		b.m();  // null-valued prefix
	}
}

class B {
	void m() {
	}
}</thetext>
    </bug>
    <bug>
        <id>496003</id>
        <developer>Eric Rizzo</developer>
        <developer_username>eclipse-bugs</developer_username>
        <dup_id/>
        <creation_time>2016-06-13 10:07:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[JUnit] Provide audio feedback when test runs finish</short_desc>
        <thetext>Idea taken from http://stackoverflow.com/questions/10600317/eclipse-notification-when-all-junit-tests-run

When a test run finishes, some form of audio notification should be available.
A different sound should play for success versus failure/error.
There should be a preference for enabling and disabling the sounds.</thetext>
        <comment>
            <comment_id>2719920</comment_id>
            <comment_count>1</comment_count>
            <who>Eric Rizzo</who>
            <commenter_username>eclipse-bugs</commenter_username>
            <when>2016-06-13 10:09:28 -0400</when>
            <comment_text>I have prepared an implementation of this, complete with updates to the JUnit preferences page, a toggle button on the JUnit view toolbar, and some choices for failure/error and success sounds. I'll be preparing a pull request soon, as well as post some questions on the JDT-dev mailing list.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496103</id>
        <developer>Nikolay Metchev</developer>
        <developer_username>nikolaymetchev</developer_username>
        <dup_id/>
        <creation_time>2016-06-14 09:32:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>"Create Parameter" Quickfix not shown on inaccessible identifier</short_desc>
        <thetext>In the code below there is a compiler error. It would be nice if Create Parameter quickfix shows up for it. However only "Change param1 to static" shows up. If the compiler error identifier was renamed to param2 then the quickfix for Create Parameter does show up:


---------------------Code that demonstrates problem----------------------
class Sup {
  protected final String param1;
  public Sup(String param1) {
    this.param1 = param1;
  }
}
public class Main extends Sup{
  public Main() {
    super(param1); // Quickfix doesn't suggest create parameter here
  }
}


---------------------Code that doesn't have problem----------------------
class Sup {
  protected final String param1;
  public Sup(String param1) {
    this.param1 = param1;
  }
}
public class Main extends Sup{
  public Main() {
    super(param2); // Quickfix DOES suggest create parameter here
  }
}</thetext>
    </bug>
    <bug>
        <id>496354</id>
        <developer>Lars Vogel</developer>
        <developer_username>Lars.Vogel</developer_username>
        <dup_id/>
        <creation_time>2016-06-19 12:32:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Code completion for annotation parameters should insert also the "="</short_desc>
        <thetext>If I do code completion in IntelliJ for a annotation parameter I get the parameter followed by "=".

In Eclipse I "only" get the parameter name. The IntelliJ variant is much nicer, as the "=" is anyway required.

To verify:

 @Test (exp-&gt;Ctrl+Space
    public void addition_isCorrect() throws Exception {
       //
    }

Result in Eclipse

@Test (expected)
public void addition_isCorrect() throws Exception {
       //
}

Result in IntelliJ

@Test (expected =)
public void addition_isCorrect() throws Exception {
        //
}</thetext>
    </bug>
    <bug>
        <id>496961</id>
        <developer>Aritz Bastida</developer>
        <developer_username>aritzbastida</developer_username>
        <dup_id/>
        <creation_time>2016-06-28 19:06:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Javadoc extracted from 1.7-style generated html is not rendered correctly (for some javadocs)</short_desc>
        <thetext>Created attachment 262768
Eclipse Javadoc rendering problems

I'm generating Javadoc artifacts along with my JAR libraries. This is done automatically by Maven. I'm using Java 8 (jdk1.8.0_66, 64 bit) and Maven 3.3.9. The Javadoc Maven plugin configuration is the default one:

&lt;plugin&gt;
   &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
   &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;
   &lt;version&gt;2.10.4&lt;/version&gt;
   &lt;executions&gt;
      &lt;execution&gt;
         &lt;id&gt;attach-javadocs&lt;/id&gt;
         &lt;goals&gt;
            &lt;goal&gt;jar&lt;/goal&gt;
         &lt;/goals&gt;
     &lt;/execution&gt;
   &lt;/executions&gt;
&lt;/plugin&gt;

Apparently, the generated Javadoc site is identical to that one in Java 8 API site (https://docs.oracle.com/javase/8/docs/api/). However, Eclipse does not render it correctly (when I hover the mouse over a constructor, method, or in the Javadoc view). 

For example, given the following Javadoc comment:
    /**
     * This is a Javadoc comment to show formatting problems in Eclipse.
     * 
     * &lt;p&gt;NOTE: This is a new paragraph with &lt;b&gt;bold&lt;/b&gt; and &lt;i&gt;italic&lt;/i&gt;
     * &lt;ul&gt;
     *   &lt;li&gt;First option&lt;/li&gt;
     *   &lt;li&gt;Second option&lt;/li&gt;
     * &lt;/ul&gt;
     * @param param1  Parameter 1
     * @param param2  Parameter 2
     * @return
     * @deprecated This method is deprecated
     */
    public static Integer foo(String param1, Boolean param2) {
        return null;
    }

...it will be formatted as shown in the attached screenshot. Note that the paragraphs are merged altogether; even the section for @deprecated, which should be normally shown with its own formatting (text "deprecated" in bold, the text in italics).

Note also that the method name is repeated three times. Normally, just the first line is included, with the method signature in bold. The second and third lines seem to be included by mistake. In the HTML, these correspond to the headers in the Method Detail section. Only the inner text should be rendered...</thetext>
        <comment>
            <comment_id>2725209</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-06-29 03:12:02 -0400</when>
            <comment_text>I do not see this issue with the given Javadoc in a plain Java project with jdk1.8.0_66 in Eclipse 4.5.2 or 4.6 downloaded from: 
http://download.eclipse.org/eclipse/downloads/index.html

Please try with the above build (without Maven plug-ins) and provide sample and steps to reproduce it.</comment_text>
        </comment>
        <comment>
            <comment_id>2725293</comment_id>
            <comment_count>2</comment_count>
            <who>Aritz Bastida</who>
            <commenter_username>aritzbastida</commenter_username>
            <when>2016-06-29 06:06:26 -0400</when>
            <comment_text>Ok, I'll test with a vanilla Eclipse 4.5.2 right away, but... how should I generated the Javadoc if not with Maven? 

I mean, this problem just happens when the Javadoc is a external JAR or URL. The same Javadoc comments, if resolved internally in the Eclipse workspace, are rendered correctly.

I attach a test project called "javadoctest". Just install it in the local repository and reference it from another Java project (disable Workspace Resolution in m2e in case javadoctest is also open in the Eclipse workspace)

Then, just reference to this method and you should see the formatting errors from the screenshot:

        JavadocFooClass.foo(param1, param2);</comment_text>
        </comment>
        <comment>
            <comment_id>2725294</comment_id>
            <comment_count>3</comment_count>
            <who>Aritz Bastida</who>
            <commenter_username>aritzbastida</commenter_username>
            <when>2016-06-29 06:07:42 -0400</when>
            <comment_text>Created attachment 262772
javadoctest project</comment_text>
        </comment>
        <comment>
            <comment_id>2725335</comment_id>
            <comment_count>4</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-06-29 07:49:31 -0400</when>
            <comment_text>(In reply to Aritz Bastida from comment #2)
&gt; Ok, I'll test with a vanilla Eclipse 4.5.2 right away, but... how should I
&gt; generated the Javadoc if not with Maven? 

Project menu &gt; Generate Javadoc...

&gt; I mean, this problem just happens when the Javadoc is a external JAR or URL.
&gt; The same Javadoc comments, if resolved internally in the Eclipse workspace,
&gt; are rendered correctly.

OK, on using the generated Javadoc with the external JAR, I can reproduce this in Eclipse 4.6.

org.eclipse.jdt.core.IJavaElement.getAttachedJavadoc(IProgressMonitor monitor) returns the Javadoc in this format. Moving to JDT Core.</comment_text>
        </comment>
        <comment>
            <comment_id>2725377</comment_id>
            <comment_count>5</comment_count>
            <who>Aritz Bastida</who>
            <commenter_username>aritzbastida</commenter_username>
            <when>2016-06-29 09:11:56 -0400</when>
            <comment_text>Thanks, Noopur! Just for your reference, I compared the generated Javadoc with that from the official Java 8 API (https://docs.oracle.com/javase/8/docs/api/), and it seemed identical (same HTML elements, with the same structure). But obviously there must be some subtle difference Eclipse doesn't like... :/

BTW, how can I keep posted about the progress of this issue in JDT Core? What is the ticket number?

Thank you very much again!
Aritz</comment_text>
        </comment>
        <comment>
            <comment_id>2725501</comment_id>
            <comment_count>6</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-06-29 13:40:23 -0400</when>
            <comment_text>(In reply to Aritz Bastida from comment #5)
&gt; Thanks, Noopur! Just for your reference, I compared the generated Javadoc
&gt; with that from the official Java 8 API
&gt; (https://docs.oracle.com/javase/8/docs/api/), and it seemed identical (same
&gt; HTML elements, with the same structure). But obviously there must be some
&gt; subtle difference Eclipse doesn't like... :/

Thanks for checking this.

It shows that IJavaElement#getAttachedJavadoc returns the same Javadoc format as generated by the Javadoc tool. So the issue is while rendering it.

Other than the two additional headers, rest of the Javadoc is rendered correctly while using the Javadoc generation tool from JDK6.

The other issues are present while using JDK7 and JDK8 (see also bug 409765 and bug 410077).

&gt; BTW, how can I keep posted about the progress of this issue 

You will get the updates via this bug itself which will be moved to the appropriate component.</comment_text>
        </comment>
        <comment>
            <comment_id>2726037</comment_id>
            <comment_count>7</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-06-30 12:52:38 -0400</when>
            <comment_text>To render generated Javadoc, we need to use more parts of Javadoc's generated stylesheet.css. We can't use the full stylesheet, since that also contains font properties and some conflicting CSS classes like "header".

When rendering Javadoc from a Javadoc attachment, we may have to skip some entries of Javadoc*StyleSheet.css that cause problems with generated docs. Esp. the "0px" in margin-top/margin-bottom for things like "li p" look problematic, since a method Javadoc is now enclosed in &lt;li class="blockList"&gt;...&lt;/li&gt;.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497175</id>
        <developer>Michael Stiefler</developer>
        <developer_username>mstiefler</developer_username>
        <dup_id/>
        <creation_time>2016-07-02 03:08:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Java Editor reacts very slow / laggy on large source files in Eclipse Neon</short_desc>
        <thetext>Created attachment 262872
Slow Java Editor in Neon Stack Trace 2016-07-02

When working on large (&gt;10000 lines) Java source files, the reaction of the Editor in Eclipse Neon becomes extremely slow whenever you change something.
It doesn't depend on the type of change.
Typing a character takes a second to show it.
Marking some block of text takes a second to show up.
Adding / removing comment blocks takes a second to show up.

"A second" depends on the machine Eclipse is running on.
For instance on an i5-2500K machine this was about a second usually, on an i7-920 it could as well take 5 seconds each.

Stack trace is attached.

PC Config:
i5-2500K, Win7, 8GB RAM, 256GB SSD, 2TB HDD.
6GB free, no swapping.

Eclipse config:
-Xms512m
-Xmx1024m
-server
-XX:+UseParallelGC
-Xverify:none
-Dcom.sun.management.jmxremote

Java Version: Oracle JDK 1.8.0-92

Steps to reproduce:
Open a large (&gt;10000 lines) Java source file and have fun...

Best regards - Mike</thetext>
        <comment>
            <comment_id>2726535</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-02 07:51:33 -0400</when>
            <comment_text>Pasting below what looks like the only relevant activity. I would be good to confirm this with a few more samples to see how much of this stack is unchanged over time (perhaps activity in AnnotationRulerColumn is) vs. incidental just in this snapshot (e.g.,: is BiDi processing relevant?).

Did you have lots of annotations/markers in that file? Errors/warnings/info? TODOS? etc... ("Information" markers in Java files are new in Neon). Here "annotation" refers to how markers are rendered in the UI, not to confuse with Java annotations.

To investigate the impact of annotations: please deselect relevant annotations in Preferences &gt; General &gt; Editors &gt; Text Editors &gt; Annotations, and see if that significantly improves performances. All three check boxes below "Show in" might be relevant.

As you mention that this is a regression in Neon: the only JDT class on this stack, JavaSourceViewer, hasn't seen any relevant code changes in Neon... so if it's not the number of annotations, maybe s.t. in SWT or JFace has changed?



"main" #1 prio=6 os_prio=0 tid=0x0000000002bee800 nid=0xdcc runnable [0x000000000012d000]
   java.lang.Thread.State: RUNNABLE
	at com.ibm.icu.text.Bidi.setPara(Bidi.java:4042)
	at com.ibm.icu.text.Bidi.&lt;init&gt;(Bidi.java:5373)
	at com.ibm.icu.text.Bidi.&lt;init&gt;(Bidi.java:5260)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.getBidiLineSegments(JavaSourceViewer.java:580)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer$1.lineGetSegments(JavaSourceViewer.java:480)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:43)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4410)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1079)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:802)
	at org.eclipse.swt.custom.StyledText.sendLineEvent(StyledText.java:8254)
	at org.eclipse.swt.custom.StyledText.getBidiSegments(StyledText.java:4850)
	at org.eclipse.swt.custom.StyledTextRenderer.getTextLayout(StyledTextRenderer.java:784)
	at org.eclipse.swt.custom.StyledTextRenderer.getTextLayout(StyledTextRenderer.java:714)
	at org.eclipse.swt.custom.StyledTextRenderer.calculate(StyledTextRenderer.java:211)
	at org.eclipse.swt.custom.StyledTextRenderer.getLineHeight(StyledTextRenderer.java:563)
	at org.eclipse.swt.custom.StyledText.getLinePixel(StyledText.java:4265)
	at org.eclipse.jface.text.JFaceTextUtil.getLinePixel(JFaceTextUtil.java:285)
	at org.eclipse.jface.text.JFaceTextUtil.computeLineHeight(JFaceTextUtil.java:79)
	at org.eclipse.jface.text.source.AnnotationRulerColumn.doPaint1(AnnotationRulerColumn.java:814)
	at org.eclipse.jface.text.source.AnnotationRulerColumn.doubleBufferPaint(AnnotationRulerColumn.java:555)
	at org.eclipse.jface.text.source.AnnotationRulerColumn.redraw(AnnotationRulerColumn.java:857)
	at org.eclipse.jface.text.source.AnnotationRulerColumn$8.run(AnnotationRulerColumn.java:842)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
	- locked &lt;0x00000000fcc369f0&gt; (a org.eclipse.swt.widgets.RunnableLock)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4203)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3819)</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497199</id>
        <developer>Lars Sadau</developer>
        <developer_username>lars</developer_username>
        <dup_id/>
        <creation_time>2016-07-03 13:29:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Sonar Blocker Issue "Impossible downcast of toArray() result"</short_desc>
        <thetext>The eclipse sonar analysis[1] revealed a blocking issue in "org.eclipse.jdt.internal.corext.refactoring.typeconstraints.FullConstraintCreator". 


[1] https://dev.eclipse.org/sonar/drilldown/issues/33296?&amp;rule=findbugs%3ABC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY&amp;rule_sev=BLOCKER&amp;severity=BLOCKER</thetext>
    </bug>
    <bug>
        <id>497312</id>
        <developer>Santiago Ferreira</developer>
        <developer_username>sferreira94</developer_username>
        <dup_id/>
        <creation_time>2016-07-05 09:40:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Refactor of fields</short_desc>
        <thetext>When rename a field of a class with refactor option, the name of a variable in set method doesn't change.


-- Configuration Details --
Product: Eclipse 4.6.0.20160613-1800 (org.eclipse.epp.package.java.product)
Installed Features:
 org.eclipse.jdt 3.12.0.v20160606-1100</thetext>
        <comment>
            <comment_id>2727364</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-07-05 15:11:32 -0400</when>
            <comment_text>Do you mean, you already ticked

[ ] Rename getter: ...
[x] Rename setter: ...

but in addition to renaming the setter itself, you want the setter *argument* to be renamed, too? Is that it?</comment_text>
        </comment>
        <comment>
            <comment_id>2727378</comment_id>
            <comment_count>2</comment_count>
            <who>Santiago Ferreira</who>
            <commenter_username>sferreira94</commenter_username>
            <when>2016-07-05 16:28:06 -0400</when>
            <comment_text>Yes</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497377</id>
        <developer>Carsten Reckord</developer>
        <developer_username>reckord</developer_username>
        <dup_id/>
        <creation_time>2016-07-06 06:36:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Create field hotfix does not determine correct field type</short_desc>
        <thetext>Take this class:

import java.util.ArrayList;
import java.util.List;

public class Test {
   public List&lt;Test&gt; getOthers() {
      if (others == null) {
         others = new ArrayList&lt;&gt;();
      }
      return others;
   }
}

It will have compile errors due to the missing "others" field. Go to the if(...) line and apply the "Create field" hotfix. It will create this field:

   private ArrayList&lt;Object&gt; others;

Clearly, &lt;Object&gt; is the wrong type parameter for "others". It should have figured this out from other usages of the field. The return statement together with the method signature clearly indicates that the correct type parameter to use would have been &lt;Test&gt;.

What's more, the created field has addressable spans for the type and the name that I can tab into, which is nice to correct any issues quickly (e.g. the obligatory ArrayList-&gt;List change). But the type span covers the whole type expression including generics. It would be a lot nicer if I could tab into the type parameter(s) separately.</thetext>
        <comment>
            <comment_id>2727586</comment_id>
            <comment_count>1</comment_count>
            <who>Carsten Reckord</who>
            <commenter_username>reckord</commenter_username>
            <when>2016-07-06 06:39:41 -0400</when>
            <comment_text>Oops, I made an error in the description, and it's even worse: The aforementioned wrong generics happen if you apply the hotfix on the "new ArrayList" line. If you do it on the if(...) line, the generated field is of type Object, which is even less helpful...

Updated the summary accordingly.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498143</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-07-19 10:04:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[1.9] Handling modules in Java Build Path settings dialog</short_desc>
        <thetext>Adding initial thoughts for further discussion. Please add your inputs.

We can have a new "Modules" tab on the Java Build Path settings dialog.

- module-info.java file: 
The file can be created by default when a Java 9 project is created. We can have a text field in "Modules" tab for module declaration name. The default value can be the Java project's name. The user can change the default module declaration name while creating the project or later. If the user deletes it and leaves the field empty, we can skip the creation of (or, delete?) the module-info.java file.

For this, we need to store and retrieve the module declaration name in the Java model. 

- Required modules:
A required module can be a project, JAR, class folder, a module from the JRE (etc.?). 

We already have a way to add these to the project build path via "Projects" and "Libraries" tabs on the Java Build Path dialog. To add specific JRE modules that are required, we need a way in the UI.

Input from Jay: User can choose to use these added dependencies as modules or not. So we need a way for the user to be able to specify this.

We can just list these dependencies from "Projects" and "Libraries" tabs on the "Modules" tab with checkboxes, which if un-checked can represent that the dependency will not act as a module.

We will also need to store and retrieve these required modules in the Java model.</thetext>
        <comment>
            <comment_id>2731821</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-07-19 10:07:57 -0400</when>
            <comment_text>Sasi is also working on a modules container which can be used for bug 495292 and on the Java Build Path dialog (if suitable).</comment_text>
        </comment>
        <comment>
            <comment_id>2733718</comment_id>
            <comment_count>2</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-07-26 05:55:32 -0400</when>
            <comment_text>As discussed in the jdt.ui call, we may not need UI actions for adding module dependencies. The dependencies can be added via module-info.java file which will have the content assist support.

For only module declaration name, the new "Modules" tab may not be required.

Not working on this currently until further input is provided.</comment_text>
        </comment>
        <comment>
            <comment_id>2772796</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-03 15:05:47 -0400</when>
            <comment_text>(In reply to Noopur Gupta from comment #0)
&gt; - module-info.java file: 
&gt; The file can be created by default when a Java 9 project is created.

This doesn't yet happen, right?

Will it be handled via this ticket (speaking of "Java Build Path settings dialog") or is there a separate bug for the new project wizard?</comment_text>
        </comment>
        <comment>
            <comment_id>2772841</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-03 23:32:04 -0400</when>
            <comment_text>Also relevant is the bug 506878. This could cover the UI part to support automatic modules.</comment_text>
        </comment>
        <comment>
            <comment_id>2772852</comment_id>
            <comment_count>5</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-11-04 01:35:54 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #3)
&gt; (In reply to Noopur Gupta from comment #0)
&gt; &gt; - module-info.java file: 
&gt; &gt; The file can be created by default when a Java 9 project is created.
&gt; 
&gt; This doesn't yet happen, right?
&gt; 
&gt; Will it be handled via this ticket (speaking of "Java Build Path settings
&gt; dialog") or is there a separate bug for the new project wizard?

The initial thought was to have a text field for the module declaration name in a new "Modules" tab on the second page of New Java Project wizard (which is the Java Build Path settings page) and create the module-info.java file based on that.

Since the "Modules" tab is no more into consideration, we can always create an empty module-info.java file with the module declaration name as the project's name when a Java 9 project is created. If this sounds good, I will create a separate bug for this and work on the implementation.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498983</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-08-01 07:48:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[9] Package feature for modular JAR files</short_desc>
        <thetext>JEP 261 talks about packaging modules in the form of JAR files. It mentions about certain additional attributes that should be encoded in the module-info.class file. At the moment, it is not clear how this can be propogated to the code generator. But I guess we will need a JDT Core sub feature to support this.</thetext>
    </bug>
    <bug>
        <id>499260</id>
        <developer>Jörg Hohwiller</developer>
        <developer_username>joerg.hohwiller</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 07:17:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>change code template defaults (non-Javadoc)</short_desc>
        <thetext>For some very strange reason Eclipse is shipped with a default setting for "Overriding methods" in Code Templates that looks like this:
/* (non-Javadoc)
 * ${see_to_overridden}
 */

IMHO this never made any sense and is not any kind of Java standard.
Before Java 1.5/1.6 it would have made sense to have it like this:
/**
 * {@inheritDoc}
 */

However, as of today the only reasonable default is to leave this empty.

If you search for "(non-javadoc)" in Google or in code search engines, you will see how much harm this has done to the world. Many users just do not even know where to change this setting as it seems.

Please dare to change this default. Thank you so much.</thetext>
    </bug>
    <bug>
        <id>499304</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 13:27:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Pulling up a method introduces compilation errors</short_desc>
        <thetext>Reproducing the bug:

Consider the following program:

package p;
class A&lt;T&gt; {
  void a(  T t){
  }
}
class B extends A&lt;String&gt; {
  public void m(){
    super.a(null);
    super.a(new String());
  }
}

Now, let's pull up method m from class B to class A.

Resulting program:

package p;
class A&lt;T&gt; {
  void a(  T t){
  }

public void m() {
    this.a(null);
    this.a(new String());
  }
}
class B extends A&lt;String&gt; {
}

After the refactoring, the resulting program does not compile.</thetext>
    </bug>
    <bug>
        <id>499305</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 13:36:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Pulling up a method introduces compilation errors due to visibility changes</short_desc>
        <thetext>Reproducing the bug:

Consider the following program:
package p;

class A {
    void m() {
        //implementation
    }
}

class C extends A {
}

class B extends C {
	void m() {
		super.m();
		//further implementation
	}
}

Now, let's pull up method m from class B to class C.

Resulting program:

package p;

class A {
    protected void m() {
        //implementation
    }
}

class C extends A {

	void m() {
		super.m();
		//further implementation
	}
}

class B extends C {
}

After the refactoring, the resulting program does not compile.</thetext>
    </bug>
    <bug>
        <id>499306</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 13:42:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Pulling up a method introduces compilation errors due to visibility changes</short_desc>
        <thetext>Reproducing the bug:

Consider the following program:
package pkg1;
import java.util.List;
public class A implements B.Foo {
  public void b(){
    List&lt;Object&gt; l=null;
  }
}

package pkg1;
import java.util.List;
public class B {
interface Foo {
  }
static class Bar implements Foo {
    /** 
 * baz it! 
 */
    void baz(    final String s){
    }
  }
}


Now, let's pull up method b from class A to interface B.Foo.

Resulting program:

package pkg1;
import java.util.List;
public class A implements B.Foo {
  public void b(){
    List&lt;Object&gt; l=null;
  }
}

package pkg1;
import java.util.List;
public class B {
interface Foo {

	void b();
  }
static class Bar implements Foo {
    /** 
 * baz it! 
 */
    void baz(    final String s){
    }

	void b() {
	}
  }
}


After the refactoring, the resulting program does not compile.</thetext>
    </bug>
    <bug>
        <id>499307</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 14:11:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Renaming field introduces compilation error</short_desc>
        <thetext>Reproducing the bug:

Consider the following program:

package p;
public class A {
	static int f= 0;
	void m(){
		p.A.f= 0; /**/
	}
}

Now, let's rename field f to g by not updating references

Resulting program:

package p;
public class A {
	static int g= 0;
	void m(){
		p.A.f= 0; /**/
	}
}

After the refactoring, the resulting program does not compile.
I understand that the resulting program does not compile because I did not activate the "update reference" parameter to apply this transformation.
However, a correct refactoring transformation cannot introduces compilation erros. Therefore, Eclipse should reject this kind of transformation regardless the configuration settings, or at least, warn a message to the user to report this problem before applying the transformation.</thetext>
    </bug>
    <bug>
        <id>499308</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 14:22:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Moving a method changes the program behavior</short_desc>
        <thetext>Reproducing the bug:

Consider the following program:
package test1;
public class Test1 {
  public void methodToMove(){}
  private TestTarget target;
  public TestTarget getTestTarget(){
    return target;
  }
}

package test1;
public class TestTarget {
}

package test2;
import test1.Test1;
public class Test2 {
  public Test2(){
    new Test1().methodToMove();
  }
}

Now, let's move method Test1.methodToMove to TestTarget

Resulting program:

package test1;
public class Test1 {
  public TestTarget target;
  public TestTarget getTestTarget(){
    return target;
  }
}

package test1;
public class TestTarget {
 public void methodToMove(){}
}

package test2;
import test1.Test1;
public class Test2 {
  public Test2(){
    new Test1().target.methodToMove();
  }
}

This transformations changes the program behavior. Notice that, only in the resulting program, the Test2 constructor throws a Null Pointer.</thetext>
    </bug>
    <bug>
        <id>499311</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 18:56:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[pull up field] A behavior preserving transformation (Pull Up Field Refactoring) is rejected. [Field 'x' already exists in type 'p.A', which will result in compile errors if you proceed]</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following program

package p;
class A {
  int x;
}

class B extends A {
  int x;
}




2. Apply the pull up field refactoring to move method x from class B to class A.

3. The tool does not apply the transformation and warn the following message:
Field 'x' already exists in type 'p.A', which will result in compile errors if you proceed.

4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong. 

package p;
class A {
  int x;
}

class B extends A {
}</thetext>
    </bug>
    <bug>
        <id>499312</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 19:02:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[rename field] A behavior preserving transformation (Rename Field Refactoring) is rejected. [After renaming, the field named 'g' declared in type 'p.B' will be hidden in the scope of the field 'g'.]</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following program
package p;
class B {
  int g;
class A {
    private int f;
  }
}





2. Rename field A.f to g

3. The tool does not apply the transformation and warn the following message:
After renaming, the field named 'g' declared in type 'p.B' will be hidden in the scope of the field 'g'.

4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong. 

package p;
class B {
  int g;
class A {
    private int g;
  }
}</thetext>
    </bug>
    <bug>
        <id>499313</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 19:04:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[rename field] A behavior preserving transformation (Rename Field Refactoring) is rejected. [After renaming, the field 'f'  will be hidden in the scope  of the field 'g' declared  in type 'p.A.B']</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following program
package p;
class B {
  private int g;
class A {
    private int f;
  }
}






2. Rename field A.f to g

3. The tool does not apply the transformation and warn the following message:
After renaming, the field 'f'  will be hidden in the scope  of the field 'g' declared  in type 'p.A.B'.

4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong. 

package p;
class B {
  private int g;
class A {
    private int g;
  }
}</thetext>
    </bug>
    <bug>
        <id>499314</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 19:06:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[rename method] A behavior preserving transformation (Rename Method Refactoring) is rejected. ['p.A' or a type in its hierarchy defines  a method 'k' with the same number  of parameters and the same  parameter type names.]</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following program
package p;
class A {
  void m(){
  }
}
class B extends A {
  void k(){
  }
}


2. Rename method A.m to k

3. The tool does not apply the transformation and warn the following message:
'p.A' or a type in its hierarchy defines  a method 'k' with the same number  of parameters and the same  parameter type names.

4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong. 

package p;
class A {
  void k(){
  }
}
class B extends A {
  void k(){
  }
}</thetext>
    </bug>
    <bug>
        <id>499315</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 19:09:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[rename method] A behavior preserving transformation (Rename Method Refactoring) is rejected. [Renaming native methods will  cause an unsatisfied link error on runtime.  Related method  (declared in )  is native. Renaming will cause</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following program
package p;
class A {
  native void m();
}


2. Rename method A.m to k

3. The tool does not apply the transformation and warn the following message:
Renaming native methods will  cause an unsatisfied link error on runtime.  Related method  (declared in )  is native. Renaming will cause an UnsatisfiedLinkError on runtime.

4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong. 

package p;
class A {
  native void k();
}</thetext>
    </bug>
    <bug>
        <id>499316</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 19:11:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[rename method] A behavior preserving transformation (Rename Method Refactoring) is rejected. [or a type in its hierarchy  defines a method with the  same number of parameters,  but different parameter type names.]</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following program
package p;
public class A {
  void m(String m){
    System.out.println("A");
  }
}
class B extends A {
  void k( Object m){
    System.out.println("B");
  }
}


2. Rename method A.m to k

3. The tool does not apply the transformation and warn the following message:
or a type in its hierarchy  defines a method with the  same number of parameters,  but different parameter type names.

4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong. 

package p;
public class A {
  void k(String m){
    System.out.println("A");
  }
}
class B extends A {
  void k( Object m){
    System.out.println("B");
  }
}</thetext>
    </bug>
    <bug>
        <id>499317</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 19:13:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[add parameter] A behavior preserving transformation (Add Parameter Refactoring) is rejected. [The type 'of parameter  contains the type variable ,  which may not be available in  related methods.]</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following program
package p;
class A&lt;E&gt; {
  void m(E e){
  }
}
class Sub&lt;E&gt; extends A&lt;E&gt; {
  void m(E e){
  }
}



2. Add parameter E e2 in A.m

3. The tool does not apply the transformation and warn the following message:
The type 'of parameter  contains the type variable ,  which may not be available in  related methods.

4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong. 

package p;
class A&lt;E&gt; {
  void m(E e, E e2){
  }
}
class Sub&lt;E&gt; extends A&lt;E&gt; {
  void m(E e, E e2){
  }
}</thetext>
    </bug>
    <bug>
        <id>499318</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 19:20:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[move method] A behavior preserving transformation (Move Method Refactoring) is rejected. [The method cannot be moved,  since it has references to  enclosing instances.]</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following classes

package p1;
import p2.B;
public class A {
public class Inner {
    public A m( B b){
      return A.this;
    }
  }
}

package p2;
public class B {}



2. Apply the move method refactoring to move method m() from class A to class B.

3. The tool does not apply the transformation and warn the following messages:
The method cannot be moved,  since it has references to  enclosing instances.

4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong. 

package p1;
import p2.B;
public class A {
public class Inner {}
}

package p2;
public class B  {
  public p1.A m(p1.A a) {
    return a;
  }
}</thetext>
    </bug>
    <bug>
        <id>499319</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 19:23:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[push down method] A behavior preserving transformation (Push Down Method Refactoring) is rejected. [Method (with the same signature)  already exists in type , which  will result in compile errors  if you proceed]</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following classes

package p;
class A {
  public void f(){
  }
}
class B extends A {
  public void f(){
  }
}


2. Apply the push down method refactoring to move method f() from class A to class B.

3. The tool does not apply the transformation and warn the following messages:
Method 'f' (with the same signature) already exists in type 'p.B', which  will result in compile errors  if you proceed


4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong. 

package p;
class A {
  }
}
class B extends A {
  public void f(){
  }
}</thetext>
    </bug>
    <bug>
        <id>499320</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-08-06 19:26:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[rename method] A behavior preserving transformation (Rename Method Refactoring) is rejected. [Another name will shadow  access to the renamed element]</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following classes

package p;
class X {
  void k(){
  }
}
class A {
  private void m(){
    System.out.println("a");
  }
class B extends X {
    void f(){
      m();
    }
    public void foo(){
    }
  }
}



2. Rename method A.m to k

3. The tool does not apply the transformation and warn the following messages:
Problem in 'A.java'. Another name will shadow  access to the renamed element

4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong.

package p;
class X {
  void k(){
  }
}
class A {
  private void k(){
    System.out.println("a");
  }
class B extends X {
    void f(){
      A.this.k();
    }
    public void foo(){
    }
  }
}</thetext>
    </bug>
    <bug>
        <id>499336</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-08-07 23:15:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[1.9] Switch ASTs to JLS9</short_desc>
        <thetext>Created attachment 263499
jdt.ui patch to start with - used for testing jdt.core

Try Statement now supports variable references (effectively final vars) in addition to LocalVariableDeclaration - see bug 497719 for details

Attached is the jdt.ui patch used for testing jdt.core (if it helps)</thetext>
        <comment>
            <comment_id>2739521</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-08-12 02:16:53 -0400</when>
            <comment_text>Manoj, please provide more details on what jdt.ui support is expected here to support final / effectively final variables in try-with-resources.</comment_text>
        </comment>
        <comment>
            <comment_id>2740349</comment_id>
            <comment_count>2</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-08-16 04:22:49 -0400</when>
            <comment_text>(In reply to Noopur Gupta from comment #1)
&gt; Manoj, please provide more details on what jdt.ui support is expected here
&gt; to support final / effectively final variables in try-with-resources.

Please see the attachment for the change - the level change is required (this is a generic change when you move to 9 - not specific to twr).</comment_text>
        </comment>
        <comment>
            <comment_id>2740364</comment_id>
            <comment_count>3</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-08-16 04:55:50 -0400</when>
            <comment_text>(In reply to Manoj Palat from comment #2)
&gt; (In reply to Noopur Gupta from comment #1)
&gt; &gt; Manoj, please provide more details on what jdt.ui support is expected here
&gt; &gt; to support final / effectively final variables in try-with-resources.
&gt; 
&gt; Please see the attachment for the change - the level change is required
&gt; (this is a generic change when you move to 9 - not specific to twr).

The attachment updates the following:
- ASTProvider#SHARED_AST_LEVEL to AST.JLS9
- ASTView#JLS_LATEST to AST.JLS9

We will move to AST.JLS9 after adapting the jdt.ui code to relevant changes in the new AST level.

This should not block support for final / effectively final variables in try-with-resources. 

Updating the bug summary to reflect the same.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499430</id>
        <developer>Sasikanth Bharadwaj</developer>
        <developer_username>sasikanth.bharadwaj</developer_username>
        <dup_id/>
        <creation_time>2016-08-09 06:56:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[1.9] Need to update the NewJavaProjectCreationWizard to add the new ModulePathContainer to a new java project</short_desc>
        <thetext>Commit http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=9b4c6fe06310162fcf691a59705683aa5c5ce814 added a new ModulePathContainer to handle dependencies between module projects.
With this change, implicit dependencies between modules via the 'requires public' statement are automatically added to the build path as exported class path entries.

This container needs to be added to all new java projects (Probably only if project is a java9 project?)</thetext>
        <comment>
            <comment_id>2738518</comment_id>
            <comment_count>1</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-08-09 06:59:10 -0400</when>
            <comment_text>Created attachment 263526
Patch showing what is required from the NewJavaProjectCreationWizard

Patch showing what is required from the NewJavaProjectCreationWizard</comment_text>
        </comment>
        <comment>
            <comment_id>2755162</comment_id>
            <comment_count>2</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-09-26 02:12:32 -0400</when>
            <comment_text>It would be good to have something in this area that changes later rather than having to edit the .classpath of every new project</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499483</id>
        <developer>Shinji Kashihara</developer>
        <developer_username>kashihara</developer_username>
        <dup_id/>
        <creation_time>2016-08-10 02:38:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Properties File Editor wrong highlighting with a preceding backslash character</short_desc>
        <thetext># Correct highlighting (Unicode escape)
foo\u0020bar=barefoot

- foo\u0020bar =&gt; black
- barefoot =&gt; blue

# Incorrect highlighting (Preceding backslash)
foo\ bar=barefoot

- foo =&gt; black
- bar=barefoot =&gt; blue


Java Properties Specification
https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html

The key contains all of the characters in the line starting with the first non-white space character and up to, but not including, the first unescaped '=', ':', or white space character other than a line terminator. All of these key termination characters may be included in the key by escaping them with a preceding backslash character; for example,

\:\=</thetext>
    </bug>
    <bug>
        <id>499863</id>
        <developer>Viliam Anirud</developer>
        <developer_username>viliam</developer_username>
        <dup_id/>
        <creation_time>2016-08-17 16:51:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[1.8][quick assist] Conversion between lambda expression and method reference not semantically equal on instance method</short_desc>
        <thetext>When converting lambda expression to method reference or vice versa and when the method is an instance method, the instance scope is not taken into account.

   myInstance::myMethod

is converted to

   () -&gt; myInstance.myMethod()

However, in the former case, myInstance is evaluated at the lambda creation time while in the later case it is evaluated when the lambda is executed. These two are not semantically equivalent. The above conversion is only safe, if myInstance is final. The lambda expression should be:

   MyInstanceClass myInstanceCopy = myInstance;
   () -&gt; myInstanceCopy.myMethod()

Here is a more complete example:


  import java.util.function.Supplier;
  
  public class Test {
  
    static class Clazz {
      private final String value;
      
      public Clazz(String value) {
        this.value = value;
      }
      
      public String getValue() {
        return value;
      }
    }
    
    static Clazz myInstance;
    
    public static void main(String[] args) {
      myInstance = new Clazz("a");
      
      Supplier&lt;String&gt; supplierMethodRef = myInstance::getValue;
      // The following lambda expression is the result of conversion
      // of the method reference on the previous line to lambda
      Supplier&lt;String&gt; supplierLambda = () -&gt; myInstance.getValue();
  
      System.out.println(supplierLambda.get());
      System.out.println(supplierMethodRef.get());
      
      // after changing the value of "x", the result is different in each case
      myInstance = new Clazz("b");
      System.out.println(supplierLambda.get());
      System.out.println(supplierMethodRef.get());
    }
  }



As far as I know, there is not a way to express a lambda as a method reference in equivalent way, if the instance is not final. The current implementation is confusing, as people believe that refactored code is equivalent.</thetext>
        <comment>
            <comment_id>2741152</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-17 17:03:48 -0400</when>
            <comment_text>When the receiver is a local variable, the language rules already enforce that it be effectively final. Such a rule does not exist for fields, so, yes, in this case the point in time when the receiver value is captured is relevant, and the refactoring invisibly changes this.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500022</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-08-20 07:21:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[1.8][generate delegate] option to deselect inherited methods</short_desc>
        <thetext>The dialog for configuring the "Generate Delegate Methods ..." action has two buttons "Select All" &amp; "Deselect All". Here I suggest to add a button "Deselect Inherited" so a user can avoid generating methods for which an implementation is already available via inheritance.

This would be particularly useful for the scenario of implementing an interface by delegating to a particular implementation: here the interface may provide default methods that provide convenience methods implemented in terms of other methods. These default implementations would be useful still in the delegating scenario, not generating delegate methods for those would simplify the current class.

There is already bug 476016 in this context, but that one only speaks about avoiding illegal code, whereas this request is about improving convenience.</thetext>
    </bug>
    <bug>
        <id>500209</id>
        <developer>Clovis Seragiotto</developer>
        <developer_username>clovis.seragiotto</developer_username>
        <dup_id/>
        <creation_time>2016-08-24 09:57:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[null] Refactoring ignores @NonNullByDefault</short_desc>
        <thetext>By refactoring the class Bar below (using "Refactor/Move Type to New File"), the class Bar in the new file created does not get any @NonNull or @NonNullByDefault, resulting in a warning at the site where "foo" is called ("The expression of type 'Object' needs unchecked conversion to conform to '@NonNull Object'")

@NonNullByDefault({ PARAMETER, RETURN_TYPE, FIELD, TYPE_PARAMETER, TYPE_BOUND, TYPE_ARGUMENT, ARRAY_CONTENTS })
class Foo {
    static void foo(Object a) {
        System.out.println(a);
    }
    
    static class Bar {
        static void bar(Object b) {
            foo(b);
        }
    }
}

--- AFTER ---</thetext>
    </bug>
    <bug>
        <id>500330</id>
        <developer>Fernando Boaglio</developer>
        <developer_username>fernando</developer_username>
        <dup_id/>
        <creation_time>2016-08-26 08:48:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>equals generation with additional option</short_desc>
        <thetext/>
        <comment>
            <comment_id>2744111</comment_id>
            <comment_count>1</comment_count>
            <who>Fernando Boaglio</who>
            <commenter_username>fernando</commenter_username>
            <when>2016-08-26 08:56:26 -0400</when>
            <comment_text>I would like to have an option in equals generation to consider empty Lists or Hashs the same thing as null lists/hashs. 

Equals example (for a "tags" List) today:

if (tags == null) {
 if (other.tags != null) { return false; }
} else if (!tags.equals(other.tags)) { return false; }

Equals example (for a "tags" List) with consider [empty list] == [null list] option enabled:

if ( (other.tags == null || other.tags.size() == 0) &amp;&amp; (tags == null || tags.size() == 0)) {
return true;
} else if (tags == null || tags.size() == 0) {
if (other.tags != null || other.tags.size() &gt; 0) { return false; }
} else if (!tags.equals(other.tags)) { return false; }


Thank you.</comment_text>
        </comment>
        <comment>
            <comment_id>2744235</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-26 11:39:03 -0400</when>
            <comment_text>I personally am not sure, that's a coding style that JDT wants to actively support. Wouldn't consistently using empty lists instead of null make for much simpler and safer code?</comment_text>
        </comment>
        <comment>
            <comment_id>2744331</comment_id>
            <comment_count>3</comment_count>
            <who>Fernando Boaglio</who>
            <commenter_username>fernando</commenter_username>
            <when>2016-08-26 15:37:47 -0400</when>
            <comment_text>You are right, but these objects come from ReST services and sometimes they are null or empty.
From the business point of view, it is the same thing; that´s why I ask for this feature.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500553</id>
        <developer>Andreas Sewe</developer>
        <developer_username>andreas.sewe</developer_username>
        <dup_id/>
        <creation_time>2016-08-31 03:38:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Timeout during content assist due to "Cannot Perform Operation" dialog</short_desc>
        <thetext>While fixing Code Recommenders Bug 500054, I can across a bug in JDT's Content Assist UI.

Steps to reproduce:

- Create a new (non-Java) Project.
- Create a file called Test.java
- Trigger content assist therein.
  - This opens a "Cannot Perform Operation" dialog
- Wait for about 10 seconds before dismissing the dialog with "OK"

This opens the "Problems during Content Assist" dialog complaining that the JavaAllCompletionProposalComputer took to long.</thetext>
        <comment>
            <comment_id>2745439</comment_id>
            <comment_count>1</comment_count>
            <who>Andreas Sewe</who>
            <commenter_username>andreas.sewe</commenter_username>
            <when>2016-08-31 03:44:20 -0400</when>
            <comment_text>(In reply to Andreas Sewe from comment #0)
&gt; This opens the "Problems during Content Assist" dialog complaining that the
&gt; JavaAllCompletionProposalComputer took to long.

FYI, in Code Recommnders' recreation of the dialog, I tried to wrap the MessageDialog#openInformation in an Display#asyncExec. Unfortunately, that also doesn't result in a good user experience as this causes the proposal popup to be shown before the dialog only to vanish immediately.

Without the asyncExec, the user the proposal popup is shown after the dialog is dismissed (if dismissed quickly), so that shed can continue working with the proposals the other computers produced. This is certainly the better user experience, so asyncExec doesn't seem to be the solution here. :-(</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500841</id>
        <developer>martin shultz</developer>
        <developer_username>khjgfty4regrdhg</developer_username>
        <dup_id/>
        <creation_time>2016-09-05 05:33:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Improvement Problems window</short_desc>
        <thetext>I am using a translator, if something is not clear, ask.

Please improve the Problems view in the Eclipse Java SE. I would like to Errors, Warnings, Others will be displayed at once at the time of their occurrence, and not after compilation attempts. That is, as they are displayed in the window sideband. Or at least add the inclusion of this possibility in the flag setting.

I think it would have been more convenient!</thetext>
    </bug>
    <bug>
        <id>501298</id>
        <developer>Sunny Narula</developer>
        <developer_username>mr.sunny.narula</developer_username>
        <dup_id/>
        <creation_time>2016-09-12 22:39:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>UI not showing all errors in relation to refactoring ltk</short_desc>
        <thetext>I wrote a move refactoring processor using the ltk as a part of support for a new language. In the checkInitialConditions my code returns a bunch of problems in the user selection for the refactoring but the ensuing UI which is handled by the LTK ui components show a popup with just one error. This happens if the user selected input has a problem to begin with. If the problem happens after this check is complete the display is quite adequate in the wizard error page. 

Perhaps a minor redesign is required to show the wizard error page in the LTK ui instead of a simple popup in case there are more than one errors to show.

Please let me know if any more details are required.

Reason why doing this properly is important:
Right now the UI will show one error at a time and if ther are a number of problems with his input he will have to keep going back and forth between invoking the refactoring and making appropriate corrections required by the refactoring process. This is an irritating thing to do to the user especially if they are learning to use the ide tools.</thetext>
        <comment>
            <comment_id>2749932</comment_id>
            <comment_count>1</comment_count>
            <who>Sunny Narula</who>
            <commenter_username>mr.sunny.narula</commenter_username>
            <when>2016-09-12 23:57:30 -0400</when>
            <comment_text>After a bit of analysis I have found the offending code:
Library: eclipse/plugins/org.eclipse.ltk.ui.refactoring_3.8.0.v20160518-1817.jar

Class: org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation

Method: public int run(final Shell parent, final String dialogTitle, final IRunnableContext context) throws InterruptedException

Relevant Source Code(See line 173 and 174):

172: if (fInitialConditions.hasFatalError()) {
173: 	String message= fInitialConditions.getMessageMatchingSeverity(RefactoringStatus.FATAL);
174: 	MessageDialog.openError(parent, dialogTitle, message);
175: 	result[0]= INITIAL_CONDITION_CHECKING_FAILED;
176: } else {
177: 	fWizard.setInitialConditionCheckingStatus(fInitialConditions);
178: 	Dialog dialog= RefactoringUI.createRefactoringWizardDialog(fWizard, parent);
179: 	dialog.create();
180: 	IWizardContainer wizardContainer= (IWizardContainer) dialog;
181: 	if (wizardContainer.getCurrentPage() == null)
182: 		/*
183: 		 * Don't show the dialog at all if there are no user
184: 		 * input pages and change creation was cancelled.
185: 		 */
186: 		result[0]= Window.CANCEL;
187: 	else
188: 		result[0]= dialog.open();
189: }</comment_text>
        </comment>
        <comment>
            <comment_id>2751014</comment_id>
            <comment_count>2</comment_count>
            <who>Patrik Suzzi</who>
            <commenter_username>psuzzi</commenter_username>
            <when>2016-09-14 19:43:59 -0400</when>
            <comment_text>This seems an issue for JDT.

Could you please provide the steps to reproduce the issue, and what you consider correct?

Perhaps it would be helpful having a small project with related code. 

Thanks for reporting!</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501507</id>
        <developer>Wayne Beaton</developer>
        <developer_username>wayne</developer_username>
        <dup_id/>
        <creation_time>2016-09-15 10:50:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[1.9] Consider displaying the module-info.java file in the source folder root</short_desc>
        <thetext>Created attachment 264174
module-info.java in the default package

It seems odd to find the module-info.java file in the "default package". I'm not sure that changing the name of the folder to "unnamed" as suggested in Bug 497866 makes it any better.

Can this file just be displayed directly in the root of the source folder?</thetext>
        <comment>
            <comment_id>2751347</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-15 12:47:36 -0400</when>
            <comment_text>Yes, this also matches what I remember from discussions with the team in Bangalore.

Emphasis being on "this file", no other compilation units should be affected by this. Technically, this will put module-info.java (or whatever name it has, see bug 501517 item (3)) into the same bucket as non-java resources.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501581</id>
        <developer>Clovis Seragiotto</developer>
        <developer_username>clovis.seragiotto</developer_username>
        <dup_id/>
        <creation_time>2016-09-16 06:14:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Null annotations not shown for varargs</short_desc>
        <thetext>- For a method like 
      void main(String @NonNull [] args)

if you place the mouse pointer on the invocation of this method, you see in the documentation shown:  

      void Foo.main(String @NonNull[] args) // OK

which is expected. But for a method like 

      void main(String @NonNull ... args)

if you place the mouse pointer on the invocation, you don't see the NonNull annotation, only:  
      void Foo.main(String... args)</thetext>
        <comment>
            <comment_id>2751615</comment_id>
            <comment_count>1</comment_count>
            <who>Clovis Seragiotto</who>
            <commenter_username>clovis.seragiotto</commenter_username>
            <when>2016-09-16 06:18:01 -0400</when>
            <comment_text>*** Bug 501582 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501601</id>
        <developer>Clovis Seragiotto</developer>
        <developer_username>clovis.seragiotto</developer_username>
        <dup_id/>
        <creation_time>2016-09-16 08:46:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Null annotation not show for external annotations</short_desc>
        <thetext>If you place the mouse pointer on the invocation of a method with external annotations, you don't always see all the annotations:

import java.util.Set;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.NonNullByDefault;

import com.google.common.collect.Sets;

@NonNullByDefault({})
public class Foo {
    static &lt;E&gt; @NonNull Set&lt;E&gt; union(
            final @NonNull Set&lt;? extends E&gt; set1, final @NonNull Set&lt;? extends E&gt; set2) {
        throw new Error();
    }
    
    void test(@NonNull Set&lt;Integer&gt; a, @NonNull Set&lt;Integer&gt; b) {
        union(a, b); // (1)
        Sets.union(a, b); // (2)
    }
}

By hovering over the method invocation (1), the result is:

@NonNull Set&lt;Integer&gt; Foo.union(@NonNull Set&lt;? extends Integer&gt; set1, @NonNull Set&lt;? extends Integer&gt; set2)

By hovering over the method invocation (2), however, which has the @NonNull annotations for the return value and for both parameters, the result is:

@NonNull SetView&lt;Integer&gt; com.google.common.collect.Sets.union(@NonNull Set&lt;? extends Integer&gt; set1, Set&lt;? extends Integer&gt; set2)

That is, for (2), @NonNull is missing for the second parameter.</thetext>
        <comment>
            <comment_id>2751832</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-16 12:07:36 -0400</when>
            <comment_text>Just so that I understand: the bug title speaks of external annotations, but comment 0 only shows regular (source) annotations. With generics in the picture, your annotations should propagate into individual method signatures. Is that what you are expecting, or do you additionally have external annotations that should be taken into account? If the latter, could you include the .eea file?</comment_text>
        </comment>
        <comment>
            <comment_id>2752340</comment_id>
            <comment_count>2</comment_count>
            <who>Clovis Seragiotto</who>
            <commenter_username>clovis.seragiotto</commenter_username>
            <when>2016-09-19 01:26:32 -0400</when>
            <comment_text>class com/google/common/collect/Sets
union
 &lt;E:Ljava/lang/Object;&gt;(Ljava/util/Set&lt;+TE;&gt;;Ljava/util/Set&lt;+TE;&gt;;)Lcom/google/common/collect/Sets$SetView&lt;TE;&gt;;
 &lt;E:Ljava/lang/Object;&gt;(L1java/util/Set&lt;+TE;&gt;;L1java/util/Set&lt;+TE;&gt;;)L1com/google/common/collect/Sets$SetView&lt;TE;&gt;;</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501720</id>
        <developer>Brian de Alwis</developer>
        <developer_username>bsd</developer_username>
        <dup_id/>
        <creation_time>2016-09-19 09:01:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>OverrideMethodDialog should have a search filter field</short_desc>
        <thetext>I find myself wanting to override a method, like dispose(), but then have to search down the class hierarchy to find it.  As the developer, I rarely care where the method was originally defined.

OverrideMethodDialog should have a search field.</thetext>
        <comment>
            <comment_id>2760739</comment_id>
            <comment_count>1</comment_count>
            <who>Robert Roth</who>
            <commenter_username>robert.roth.off</commenter_username>
            <when>2016-10-05 05:35:56 -0400</when>
            <comment_text>As a temporary workaround, you can use the toggle button on the right to "Group methods by types", after that you don't have to know where the method was originally defined, just look for it in the alphabetically ordered list. A search field however would indeed help here.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501800</id>
        <developer>Lars Vogel</developer>
        <developer_username>Lars.Vogel</developer_username>
        <dup_id/>
        <creation_time>2016-09-20 04:32:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[CSS] [dark theme] Cleanup wizard looks bad in the dark theme</short_desc>
        <thetext>See screenshot.</thetext>
        <comment>
            <comment_id>2753060</comment_id>
            <comment_count>1</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-09-20 04:32:46 -0400</when>
            <comment_text>Created attachment 264274
Screenshot</comment_text>
        </comment>
    </bug>
    <bug>
        <id>502254</id>
        <developer>Gunnar Wagenknecht</developer>
        <developer_username>gunnar</developer_username>
        <dup_id/>
        <creation_time>2016-09-27 10:20:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Extract to method refactoring creates method with redundant nullness annotation warning</short_desc>
        <thetext>- package with DefaultNonNull annotation
- select expression and invoke "Extract to method"
- new method is generated as:

private static @NonNull ... ...() {...}

The generated code shows a warning "The nullness annotation is redundant with a default that applies to this location". A quickfix is available to remove the warning.

I think Eclipse should not generate this annotation if it's clear that it would be redundant.</thetext>
    </bug>
    <bug>
        <id>502813</id>
        <developer>Robert Roth</developer>
        <developer_username>robert.roth.off</developer_username>
        <dup_id/>
        <creation_time>2016-09-29 23:25:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Keyboard-only getter/setter generation</short_desc>
        <thetext>This might not be JDT-specific, but rather SWT+GTK3, but as I have not found another similar dialog, I will report it here:

Steps to reproduce (Ecipse Neon.1/4.6.1/ Build id 20160913-0900 with GTK3.20.9 on Fedora 24 ):
1. Create a Java class
2. Create a new private field
3. Right-click it and click "Source &gt; Generate getters and setters"
4. Use spacebar to select the checkbox to generate both getter and setter for the new field
5. Press enter to confirm the dialog and generate the getter and setter

Expected to happen:
  getter and setter are generated

What happens instead:
  space selects the checkbox, pressing Enter deselects the checkbox right before dismissing the dialog, so nothing is generated.</thetext>
    </bug>
    <bug>
        <id>506137</id>
        <developer>Andreas Sewe</developer>
        <developer_username>andreas.sewe</developer_username>
        <dup_id/>
        <creation_time>2016-10-18 07:08:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[rename] Rename Method refactoring should supporting adding @Deprecated annotation</short_desc>
        <thetext>At the moment, the Rename Method dialog's "Mark as deprecated" checkbox only applies the @deprecated *Javadoc tag* to the original method.

If the source level is 1.5 or higher, it should also add the @Deprecated *annotation*.

Not sure whether this is worth a second checkbox or whether the existing "Mark as deprecated" checkbox should control both the Javadoc tag and the Java annotation.</thetext>
    </bug>
    <bug>
        <id>506229</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-10-19 12:46:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[extract method] Refactor &gt; Extract Method... should fill in the method name "extracted"</short_desc>
        <thetext>Never worked.

Refactor &gt; Extract Method... should fill in the method name "extracted". It already displays that name at the bottom (signature preview).

Also, using the Extract Method Quick Assist, it uses that name by default.</thetext>
    </bug>
    <bug>
        <id>506377</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-10-22 03:52:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[1.9][quick fix] Offer quick fix to add module for unresolved import and type</short_desc>
        <thetext>Offer quick fix to add module for unresolved import and type, similar to what we have for bundles.</thetext>
    </bug>
    <bug>
        <id>506490</id>
        <developer>Andreas Sewe</developer>
        <developer_username>andreas.sewe</developer_username>
        <dup_id/>
        <creation_time>2016-10-25 05:15:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Need clear indication (in Error Log and Package Explorer) when dependency JAR corrupt</short_desc>
        <thetext>Created attachment 265036
Corrupt mockito-core 2.2.8 JAR

Hi,

I just had an unpleasant experience with JDT from Neon.1a:

I've created a new Maven project with a dependency on org.mockito:mockito-core:2.2.8 (attached).

- Using a quick fix on Mockito (to add an import) yielded nothing (except for "Create constant Mockito" and friends).

- Using Content Assist I could complete "org.mockito", but not "org.mockito.Mockito"

All the while, the Error Log was empty (except for the "The import org.mockito.Mockito" cannot be resolved).

I only figured out what the problem was when opening the org/mockito/Mockito.class file in the Package Explorer: The opened editor stated "invalid LOC header (bad signature)".

Apparently, the JAR file was corrupted somewhere along the way. But JDT complained about it not once: Not in the Error Log, not through an overlay in the Package Explorer, nowhere. :-(</thetext>
    </bug>
    <bug>
        <id>506550</id>
        <developer>Konrad Windszus</developer>
        <developer_username>konrad_w</developer_username>
        <dup_id/>
        <creation_time>2016-10-26 07:02:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Propagate variables like ${project_loc} from JUnit View</short_desc>
        <thetext>Currently if a JUnit test is triggered from the JUnit view through the context menu with a launcher leveraging variable substitution, variables like e.g. ${project_loc} are not correctly replaced.
I think in the JUnit view one JUnit test clearly belongs to one project/workspace, therefore it should be possible to propagate the variables even from this view.</thetext>
    </bug>
    <bug>
        <id>506573</id>
        <developer>Rüdiger Herrmann</developer>
        <developer_username>ruediger.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-10-26 11:25:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Abbreviate Package Name preference section has usability issues</short_desc>
        <thetext>The "Abbreviate Package Names" preference section gives the impression of a "least effort solution to configure how package names are abbreviated".

Which is fine for a start and I understand that there may not be the resources available to change that, however, I still would like to share my thoughts on this UI here:

* I find the explanation above the text entry field hard to read: three lines of dense text with many punctuation marks.

* the Tab key does enter an unintended tab character in the text instead of traversing to the next field.

* the text entry field shows (disabled) scroll-bars even though the text does not exceed the control's bounds.

Maybe an editable table with two columns would be better suited for entering package name abbreviations? Each column could clearly state what to enter, e.g. "Package Name" and "Abbreviation".</thetext>
        <comment>
            <comment_id>2770345</comment_id>
            <comment_count>1</comment_count>
            <who>Rüdiger Herrmann</who>
            <commenter_username>ruediger.herrmann</commenter_username>
            <when>2016-10-26 12:12:47 -0400</when>
            <comment_text>Created attachment 265070
Screenshot of abbreviate package names preference section</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506729</id>
        <developer>Michael Schierl</developer>
        <developer_username>schierlm</developer_username>
        <dup_id/>
        <creation_time>2016-10-28 16:02:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Content assist eats closing parentheses when not choosing field and typing semicolon</short_desc>
        <thetext>To reproduce

1. create this class and place the cursor at the marked position:

public class X {
	static int y;
	void z(X x) {}
	void test() {
		// type in the empty line below
		
	}
}



2. While ignoring any content assist windows, type the following:

z(X.y);

3. Observe that after typing y, the content assist is open suggesting X.y and the closing parenthesis has already been inserted. When you now over-type the closing parenthesis, the parenthesis get skipped as expected, but the content assist is still open suggesting X.y.

4. As soon as you now type the semicolon, the suggestion gets selected and the closing parenthesis disappears, resulting in a syntax error:

z(X.y;


Expected behaviour: As soon as the parenthesis is closed, content assist should close and therefore the semicolon should not eat the parenthesis.</thetext>
        <comment>
            <comment_id>2771124</comment_id>
            <comment_count>1</comment_count>
            <who>Michael Schierl</who>
            <commenter_username>schierlm</commenter_username>
            <when>2016-10-28 16:09:51 -0400</when>
            <comment_text>See also: http://stackoverflow.com/a/40312522/90203</comment_text>
        </comment>
        <comment>
            <comment_id>2774835</comment_id>
            <comment_count>2</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-11-10 02:11:00 -0500</when>
            <comment_text>*** Bug 507306 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506826</id>
        <developer>jules</developer>
        <developer_username>jules</developer_username>
        <dup_id/>
        <creation_time>2016-11-01 08:10:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[organize imports] specify wildcard policy for particular packages</short_desc>
        <thetext>It would be useful if, when using organize imports on files that use static imports from specific packages that are known to be relatively stable or to have naming policies that are unlikely to cause an issue when they change, we could add an exception that allows the use of wildcard imports even when the number is less than the threshold.  Perhaps the most common use case would be to provide exceptions for common unit testing library packages (e.g. org.junit.Assert, org.hamcrest.Matchers, and so on) where static imports are heavily used and where once you have used one in a file you are likely to use others, but I'm sure that once you have an ability to add a package to a list that will be treated this way people will find other ways to use it to.

To be clear, what I'm suggesting is a UI in the organize imports preferences dialog that looks something like this:

   Number of imports needed for .*        [      99]

   Number of static imports needed for .* [      99]

   [X] Allow exceptions for individual packages or classes
   +-------------------+---------+---------+  +----------+
   |Package/class      | imports | statics |  | Add...   |
   +-------------------+---------+---------+  +----------+
   |org.junit.Assert   |       - |       1 | 
   |                   |         |         |  +----------+
   |                   |         |         |  |Edit...   |
   |                   |         |         |  +----------+
   |                   |         |         |
   |                   |         |         |  +----------+
   |                   |         |         |  |Remove    |
   +-------------------+---------+---------+  +----------+</thetext>
        <comment>
            <comment_id>2772122</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-02 04:43:38 -0400</when>
            <comment_text>Manoj, I am assuming this doesn't require any work on the core part and moving to UI for consideration.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506984</id>
        <developer>EPP Error Reports</developer>
        <developer_username>error-reports-inbox</developer_username>
        <dup_id/>
        <creation_time>2016-11-03 11:01:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>PartInitException below EditorUtility.openInEditor (thrown in WorkbenchPage.busyOpenEditor)</short_desc>
        <thetext>The following problem was reported via the automated error reporting:

Message: Internal Error
org.eclipse.ui.PartInitException: System editor can only open file base resources.
    at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:3187)
    at org.eclipse.ui.internal.WorkbenchPage.access$25(WorkbenchPage.java:3176)
    at org.eclipse.ui.internal.WorkbenchPage$10.run(WorkbenchPage.java:3158)
    at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
    at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3153)
    at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3117)
    at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3107)
    at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:373)
    at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:179)
    at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:149)
    at org.eclipse.jdt.internal.ui.javaeditor.JavaEditorBreadcrumb.openInNewEditor(JavaEditorBreadcrumb.java:926)
    at org.eclipse.jdt.internal.ui.javaeditor.JavaEditorBreadcrumb.open(JavaEditorBreadcrumb.java:879)
    at org.eclipse.jdt.internal.ui.javaeditor.breadcrumb.EditorBreadcrumb.doOpen(EditorBreadcrumb.java:361)
    at org.eclipse.jdt.internal.ui.javaeditor.breadcrumb.EditorBreadcrumb.doRevealOrOpen(EditorBreadcrumb.java:346)
    at org.eclipse.jdt.internal.ui.javaeditor.breadcrumb.EditorBreadcrumb.access$8(EditorBreadcrumb.java:343)
    at org.eclipse.jdt.internal.ui.javaeditor.breadcrumb.EditorBreadcrumb$3.open(EditorBreadcrumb.java:262)
    at org.eclipse.jface.viewers.StructuredViewer$2.run(StructuredViewer.java:851)
    at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
    at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
    at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:173)
    at org.eclipse.jface.viewers.StructuredViewer.fireOpen(StructuredViewer.java:848)
    at org.eclipse.jdt.internal.ui.javaeditor.breadcrumb.BreadcrumbViewer.fireMenuSelection(BreadcrumbViewer.java:549)
    at org.eclipse.jdt.internal.ui.javaeditor.breadcrumb.BreadcrumbItemDropDown.openElement(BreadcrumbItemDropDown.java:531)
    at org.eclipse.jdt.internal.ui.javaeditor.breadcrumb.BreadcrumbItemDropDown.access$5(BreadcrumbItemDropDown.java:526)
    at org.eclipse.jdt.internal.ui.javaeditor.breadcrumb.BreadcrumbItemDropDown$5.mouseUp(BreadcrumbItemDropDown.java:380)
    at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:221)
    at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:86)



Bundles:
| org.eclipse.core.runtime | 3.12.0.v20160919-2241 | 3.12.0.v20160919-2241 |
| org.eclipse.jdt.ui | 3.13.0.v20161018-1320 | 3.13.0.v20161018-1320 |
| org.eclipse.jface | 3.13.0.v20161022-1508 | 3.13.0.v20161022-1508 |
| org.eclipse.swt | 3.106.0.v20161027-0130 | 3.106.0.v20161027-0130 |
| org.eclipse.ui | 3.109.0.v20161017-1617 | 3.109.0.v20161017-1617 |

Operating Systems:
| MacOSX | 10.10.5 | 10.10.5 |


The above information is a snapshot of the collected data. Visit https://dev.eclipse.org/recommenders/committers/aeri/v2/#!/problems/581b4f59e4b0e07e5bc2ca10 for the latest data.

Thank you for your assistance.
 Your friendly error-reports-inbox.</thetext>
        <comment>
            <comment_id>2772699</comment_id>
            <comment_count>1</comment_count>
            <who>Andreas Sewe</who>
            <commenter_username>andreas.sewe</commenter_username>
            <when>2016-11-03 11:03:42 -0400</when>
            <comment_text>IMHO, "Open in System Editor" should only be offered for base file resources; at least, the error message suggests that this is always the case, so it doesn't make sense to offer an option to the use where failure is guaranteed.</comment_text>
        </comment>
        <comment>
            <comment_id>2772919</comment_id>
            <comment_count>2</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-04 05:13:46 -0400</when>
            <comment_text>What are the steps to reproduce this?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507408</id>
        <developer>eyebrows grey</developer>
        <developer_username>myjunk777</developer_username>
        <dup_id/>
        <creation_time>2016-11-11 10:47:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Project Explorer - bug</short_desc>
        <thetext>Project Explorer - bug.

The items in my list go: gray, black, white, omit items then some reandomly appear and disappear.

If I Alt-click, the item cycle through the above in random ways...  

Oh, as long as I'm here, the "Outline" panel keeps re-appearing even though I eliminated it from my custom perspective.



-- Configuration Details --
Product: Eclipse 4.6.1.20161007-1200 (org.eclipse.epp.package.java.product)
Installed Features:
 org.eclipse.jdt 3.12.1.v20160907-1200</thetext>
        <comment>
            <comment_id>2775501</comment_id>
            <comment_count>1</comment_count>
            <who>eyebrows grey</who>
            <commenter_username>myjunk777</commenter_username>
            <when>2016-11-11 10:49:43 -0500</when>
            <comment_text>Created attachment 265320
Project Explorer

The items in my list go: gray, black, white, omit items then some reandomly appear and disappear.

If I Alt-click, the item cycle through the above in random ways...</comment_text>
        </comment>
        <comment>
            <comment_id>2779330</comment_id>
            <comment_count>2</comment_count>
            <who>eyebrows grey</who>
            <commenter_username>myjunk777</commenter_username>
            <when>2016-11-23 15:55:30 -0500</when>
            <comment_text>Created attachment 265550
Additional Screenshot</comment_text>
        </comment>
        <comment>
            <comment_id>2779333</comment_id>
            <comment_count>3</comment_count>
            <who>eyebrows grey</who>
            <commenter_username>myjunk777</commenter_username>
            <when>2016-11-23 15:57:46 -0500</when>
            <comment_text>Comment on attachment 265550
Additional Screenshot

Becoming too difficult to use Eclipse when I can see the dark text and fluctuating randomness of it. Clicking item and/or the menu icon cycles randomly...</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507614</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-11-16 09:36:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[encapsulate field] A behavior preserving transformation (Encapsulate Field Refactoring) is rejected. [Cannot convert postfix expression.  It is used inside another expression.]</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following program
public class TestPostfixExpression {
	int field;
	
	public void foo() {
		int i;
		i= field++;
	}
}



2. Encapsulate Field field

3. The tool does not apply the transformation and warn the following message:
Cannot convert postfix expression. It is used inside another expression.

4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong. 

public class TestPostfixExpression {
	int field;
	
	public void foo() {
		int i;
		i= field++;
	}
	
	public int getField() {
		return field;
	}
	public void setField(int field) {
		this.field = field;
	}
}</thetext>
    </bug>
    <bug>
        <id>507615</id>
        <developer>Melina Mongiovi</developer>
        <developer_username>melmongiovi</developer_username>
        <dup_id/>
        <creation_time>2016-11-16 09:39:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[Pull Up field] A behavior preserving transformation (Pull Up Field Refactoring) is rejected. [Field 'p.C.x' declared in type 'p.C' has a different type than its moved counterpart]</short_desc>
        <thetext>Behavior Preserving Transformation is rejected.

Reproducible: Always

Steps to Reproduce:
1. Create the following program
package p;
class A {
}
class B extends A {
  int x;
}
class C extends A {
  boolean x;
}



2. Pull Up Field B.x

3. The tool does not apply the transformation and warn the following message:
Field 'p.C.x' declared in type 'p.C' has a different type than its moved counterpart.

4. However, the following possible resulting program compiles and the transformation preserves the program behavior, which indicates that some refactoring conditions may be overly strong. 

package p;
class A {
  int x;
}
class B extends A {

}
class C extends A {

}</thetext>
    </bug>
    <bug>
        <id>507646</id>
        <developer>Mickael Istria - away until ...</developer>
        <developer_username>mistria</developer_username>
        <dup_id/>
        <creation_time>2016-11-17 02:32:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Implementing interface with default should generate skeletons for default methods</short_desc>
        <thetext>Currently, it seems like implementing an interface with "default" methods doesn't write skeletons for those methods. However, the purpose of default is mostly to enable some backward-compatibility for evolving interfaces, it's oot meant to make the method "optional". So IMO, it would better user guidance to create the skeletons for the default methods as well, to encourage developers to implement them properly.</thetext>
    </bug>
    <bug>
        <id>507663</id>
        <developer>Andreas Sewe</developer>
        <developer_username>andreas.sewe</developer_username>
        <dup_id/>
        <creation_time>2016-11-17 05:07:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[javadoc location] Validate button for Javadoc location path should be disabled if path is empty</short_desc>
        <thetext>Testing the Neon.2 RC1 Java EPP package I encountered the following less-than-optimal user experience:

- Create a Java project
- Open its "Properties"
- Go to "Javadoc Location"
- Without entering a "Javadoc location path" click "Validate"

This shows you a "Location might be invalid" dialog with an explanation that has nothing to do with the problem at hand:=, namely that the "Javadoc location path" has not been filled in yet.

IMHO, it would be best to disable the "Validate" button iff "Javadoc location path" is empty (or contains whitespace only).</thetext>
        <comment>
            <comment_id>2776919</comment_id>
            <comment_count>1</comment_count>
            <who>Andreas Sewe</who>
            <commenter_username>andreas.sewe</commenter_username>
            <when>2016-11-17 05:18:58 -0500</when>
            <comment_text>Created attachment 265405
Validating Javadoc Location dialog with less than helpful message</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507666</id>
        <developer>Ed Willink</developer>
        <developer_username>ed</developer_username>
        <dup_id/>
        <creation_time>2016-11-17 05:41:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Major UI hang saving file with API tooling issue changes</short_desc>
        <thetext>(On M3) When saving a file that has evolved as a result of EMF model chnages:

e.g. GIT\org.eclipse.ocl\plugins\org.eclipse.ocl.pivot\emf-gen\org\eclipse\ocl\pivot\PivotPackage.java

there may easily be 100 API tooling issues. Fixing some and saving leads to a major hang; typically 40 seconds. The error log stack trace shows for instance:

	at org.eclipse.jface.text.AbstractDocument.getChar(AbstractDocument.java:777)
	at org.eclipse.jdt.internal.ui.text.JavaHeuristicScanner.scanBackward(JavaHeuristicScanner.java:798)
	at org.eclipse.jdt.internal.ui.text.JavaHeuristicScanner.previousToken(JavaHeuristicScanner.java:391)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.nextToken(JavaIndenter.java:1991)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.nextToken(JavaIndenter.java:1980)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.skipScope(JavaIndenter.java:2162)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.looksLikeArrayInitializerIntro(JavaIndenter.java:1766)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.skipToStatementStart(JavaIndenter.java:1357)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.findReferencePosition(JavaIndenter.java:1026)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.findReferencePosition(JavaIndenter.java:827)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.getReferenceIndentation(JavaIndenter.java:453)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.computeIndentation(JavaIndenter.java:486)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.computeIndentation(JavaIndenter.java:472)
	at org.eclipse.jdt.internal.ui.actions.IndentAction.computeReplaceData(IndentAction.java:350)
	at org.eclipse.jdt.internal.ui.actions.IndentAction.indent(IndentAction.java:268)
	at org.eclipse.jdt.internal.corext.fix.CodeFormatFix.createCleanUp(CodeFormatFix.java:143)
	at org.eclipse.jdt.internal.ui.fix.CodeFormatCleanUp.createFix(CodeFormatCleanUp.java:61)
	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.calculateChange(CleanUpRefactoring.java:789)
	at org.eclipse.jdt.internal.corext.fix.CleanUpPostSaveListener.saved(CleanUpPostSaveListener.java:387)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$5.run(CompilationUnitDocumentProvider.java:1636)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.notifyPostSaveListeners(CompilationUnitDocumentProvider.java:1630)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy(CompilationUnitDocumentProvider.java:1410)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$4.execute(CompilationUnitDocumentProvider.java:1488)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run(TextFileDocumentProvider.java:130)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:67)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:107)
	at org.eclipse.ui.actions.WorkspaceModifyOperation$$Lambda$213/1403767628.run(Unknown Source)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:128)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:73)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:63)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:458)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:761)
	at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:5025)

and

	at org.eclipse.jface.text.AbstractDocument.getLength(AbstractDocument.java:808)
	at org.eclipse.jface.text.AbstractDocument.getChar(AbstractDocument.java:777)
	at org.eclipse.jdt.internal.ui.text.JavaHeuristicScanner.scanBackward(JavaHeuristicScanner.java:798)
	at org.eclipse.jdt.internal.ui.text.JavaHeuristicScanner.previousToken(JavaHeuristicScanner.java:434)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.nextToken(JavaIndenter.java:1991)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.nextToken(JavaIndenter.java:1980)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.skipScope(JavaIndenter.java:2162)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.looksLikeArrayInitializerIntro(JavaIndenter.java:1766)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.handleScopeIntroduction(JavaIndenter.java:1696)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.findReferencePosition(JavaIndenter.java:1053)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.findReferencePosition(JavaIndenter.java:827)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.getReferenceIndentation(JavaIndenter.java:453)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.computeIndentation(JavaIndenter.java:486)
	at org.eclipse.jdt.internal.ui.text.JavaIndenter.computeIndentation(JavaIndenter.java:472)
	at org.eclipse.jdt.internal.ui.actions.IndentAction.computeReplaceData(IndentAction.java:350)
	at org.eclipse.jdt.internal.ui.actions.IndentAction.indent(IndentAction.java:268)
	at org.eclipse.jdt.internal.corext.fix.CodeFormatFix.createCleanUp(CodeFormatFix.java:143)
	at org.eclipse.jdt.internal.ui.fix.CodeFormatCleanUp.createFix(CodeFormatCleanUp.java:61)
	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.calculateChange(CleanUpRefactoring.java:789)
	at org.eclipse.jdt.internal.corext.fix.CleanUpPostSaveListener.saved(CleanUpPostSaveListener.java:387)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$5.run(CompilationUnitDocumentProvider.java:1636)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.notifyPostSaveListeners(CompilationUnitDocumentProvider.java:1630)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy(CompilationUnitDocumentProvider.java:1410)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$4.execute(CompilationUnitDocumentProvider.java:1488)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run(TextFileDocumentProvider.java:130)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:67)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:107)
	at org.eclipse.ui.actions.WorkspaceModifyOperation$$Lambda$213/1403767628.run(Unknown Source)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:128)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:73)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:63)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:458)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:761)
	at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:5025)</thetext>
    </bug>
    <bug>
        <id>507865</id>
        <developer>Marvin  Fröhlich</developer>
        <developer_username>qudus</developer_username>
        <dup_id/>
        <creation_time>2016-11-21 05:55:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[Refactoring] Extract interface ignores deprecations</short_desc>
        <thetext>When I extract an interface from a class, that has deprecated methods, the @Deprecated annotation is not carried over to the interface.

I don't know, if there are cases, where this might be useful. But it should not be default behavior.

If Java 8 is used, the refactoring could even (optionally) put the deprecated method into the interface as 'default' implementation and totally remove from the original class.</thetext>
        <comment>
            <comment_id>2778480</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-22 03:43:25 -0500</when>
            <comment_text>Moving to UI for consideration.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507866</id>
        <developer>Marvin  Fröhlich</developer>
        <developer_username>qudus</developer_username>
        <dup_id/>
        <creation_time>2016-11-21 05:58:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[Refactoring] Extract interface, move javadoc</short_desc>
        <thetext>When extracting an interface from an existing class by option the javadoc from all extracted methods should be moved to the interface and in the original class be replaced be either nothing or {@inhericDoc} (another option).

Currently there is an option to put something like "no javaDoc" into the original class, which is a bit useless.</thetext>
        <comment>
            <comment_id>2778126</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-21 08:33:56 -0500</when>
            <comment_text>Moving to UI for consideration</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507921</id>
        <developer>Robert Roth</developer>
        <developer_username>robert.roth.off</developer_username>
        <dup_id/>
        <creation_time>2016-11-21 21:00:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[favorites] New Type Favorite dialog possibly unnecessary intermediary step</short_desc>
        <thetext>Steps to reproduce:
1. Open Eclipse Preferences
2. type Favorites in the search field
3. select Java/Editor/Content Assist/Favorites
4. Click New Type button

Expected:
the dialog appearing should suggest entries based on what you have typed -&gt; just like the second dialog does after clicking Browse on the first one

What happens instead:
you have to either copy-paste the fully qualified class name in the text field on the dialog, or click browse and search for the class you need

Note:
If instead of the first dialog you would get directly to the "Browse" dialog, you could still both search or paste a fully qualified name and press Enter/click OK, but with one step (or three clicks) less (in case you don't have the classname on clipboard) than what we have right now.</thetext>
    </bug>
    <bug>
        <id>508104</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-11-24 06:02:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>AssertionError in CallHierarchyContentProviderTest</short_desc>
        <thetext>The following test failed on Mac for M20161123-0800:

Wrong number of calls expected:&lt;2&gt; but was:&lt;1&gt; 

java.lang.AssertionError: Wrong number of calls expected:&lt;2&gt; but was:&lt;1&gt;
at org.eclipse.jdt.ui.tests.callhierarchy.CallHierarchyTestHelper.assertCalls(CallHierarchyTestHelper.java:272)
at org.eclipse.jdt.ui.tests.callhierarchy.CallHierarchyTestHelper.assertCalls(CallHierarchyTestHelper.java:287)
at org.eclipse.jdt.ui.tests.callhierarchy.CallHierarchyContentProviderTest.testGetChildrenOfCallerMaxDepth(CallHierarchyContentProviderTest.java:149)
at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23)
at junit.extensions.TestSetup$1.protect(TestSetup.java:23)
at junit.extensions.TestSetup.run(TestSetup.java:27)
at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:743)
at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:351)
at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197)
at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4032)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3708)
at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140)
at org.eclipse.test.UITestApplication.run(UITestApplication.java:62)
at org.eclipse.test.UITestApplication.start(UITestApplication.java:212)
at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
at org.eclipse.equinox.launcher.Main.main(Main.java:1492)
at org.eclipse.core.launcher.Main.main(Main.java:34)</thetext>
    </bug>
    <bug>
        <id>508287</id>
        <developer>Lars Vogel</developer>
        <developer_username>Lars.Vogel</developer_username>
        <dup_id/>
        <creation_time>2016-11-28 07:25:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>UI Freeze if using Open Type hierarchy for an object with lots of children</short_desc>
        <thetext>If I run "Open Type Hierarchy" on an object with lots of children the UIfreezes for a long time after the progress reporting reached 100%.

Easiest way to test this, is to run this operation for "Object" in a workspace with some classes, e.g., the eclipse.platform.text repo.</thetext>
    </bug>
    <bug>
        <id>508376</id>
        <developer>Lars Vogel</developer>
        <developer_username>Lars.Vogel</developer_username>
        <dup_id/>
        <creation_time>2016-11-29 09:06:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Outline wrong if I use forward navigation for an inner interface and move to outer class</short_desc>
        <thetext>If I use Ctrl+Mouseclick to navigate to an inner interface, an editor is opened for the inner interface. If I move in this editor to the outer class, this leads to incorrect display of the outline view, as it still shows the outline of the inner interface.

Example: 

Write the following code line:
System.out.printlin("UIEvents.UILifeCycle.APP_STARTUP_COMPLETE");

Ctrl+Mouseclick on UILifeCycle -&gt; Editor opens for the inner interface (and Outline is bound to this).

Expectation is that Eclipse opens editor for UIEvents and positions the cursor on UILifeCycle.</thetext>
    </bug>
    <bug>
        <id>508401</id>
        <developer>Michael Mast</developer>
        <developer_username>mbmast</developer_username>
        <dup_id/>
        <creation_time>2016-11-29 11:55:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Navigate menu has no "Go to bookmark..." option.</short_desc>
        <thetext>After creating bookmarks in source code, go to Navigate menu.  There is no "Go to bookmark..." choice and there should be (in my opinion).


-- Configuration Details --
Product: Eclipse 4.5.2.20160218-0600 (org.eclipse.epp.package.jee.product)
Installed Features:
 org.eclipse.jdt 3.11.2.v20160212-1500</thetext>
    </bug>
    <bug>
        <id>508596</id>
        <developer>Andreas Sewe</developer>
        <developer_username>andreas.sewe</developer_username>
        <dup_id/>
        <creation_time>2016-12-02 05:50:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Improve "Open Attached Javadoc" failure dialog (add missing '.'; link to "Properties" page)</short_desc>
        <thetext>Created attachment 265699
"Open Attached Java" failure dialog

There are two improvements that could IMHO be made to the dialog shown on a failed "Open Attached Javadoc" (see attached screenshot).

1. The second sentence should be terminated by a '.'

2. A link to the "Properties" page of the appropriate project would be much more helpful than describing the "click path".</thetext>
    </bug>
    <bug>
        <id>508660</id>
        <developer>Beat Schwarzentrub</developer>
        <developer_username>bsh</developer_username>
        <dup_id/>
        <creation_time>2016-12-05 05:22:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[organize imports] "Organize Imports" (and "Quick Fix") ignore inner classes of interfaces</short_desc>
        <thetext>Inner classes of an interface are "public static" by definition. However, "Organize Imports" and "Quick Fix" seem to ignore them.

Demonstration:

--- [ ISomeInterface.java ] -----------------------------------------------

package myproject.one;

public interface ISomeInterface {

	class FirstInnerClass {
	}

	public class SecondInnerClass {
	}
}

--- [ SomeClass.class ] ---------------------------------------------------

package myproject.one;

public class SomeClass {

	public static class ThirdInnerClass {
	}
}

--- [ Test.class ] --------------------------------------------------------

package myproject.two;

public class Test {

	private FirstInnerClass first;
	private SecondInnerClass second;
	private ThirdInnerClass third;
}

---------------------------------------------------------------------------

==&gt; If Ctrl-Shift-O (Organize Imports) is pressed in the third file, only two of the three required imports are generated:

import myproject.one.ISomeInterface.SecondInnerClass;
import myproject.one.SomeClass.ThirdInnerClass;

The import for "FirstInnerClass" is missing (and is also not proposed by Ctrl-1, Quick Fix), although it implicitly has the same visibility as "SecondInnerClass". It works if the interface and the test class are in the same package, but not in different packages. If the missing import is added manually, the compiler is happy again.

A temporary solution would be to add the keyword "public" manually to the inner class (as in the "SecondInnerClass" example), but this is not always possible (e.g. in libraries). Additionally, there are code style tools that warn about "redundant modifiers".</thetext>
    </bug>
    <bug>
        <id>508708</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-12-05 23:28:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[1.9] Provision to promote libraries to automatic modules</short_desc>
        <thetext>Bug 506878 in core allows a classpath entry to be promoted to an automatic module with the new classpath attribute "module". This should be supported by the UI as well. In my opinion, we might want something like what we have for exporting libraries in the buildpath page. I.e. provide a tab with all the libraries in a module project's build path listed with check boxes that would mean those selected entries are to promoted to automatic modules.

This is just my thought, of course, there could be better ways of doing this.</thetext>
        <comment>
            <comment_id>2783097</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-05 23:57:42 -0500</when>
            <comment_text>I believe we should also watch out for these entries when the launcher is invoked.

Copying Sarika.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508793</id>
        <developer>Leo Ufimtsev</developer>
        <developer_username>lufimtse</developer_username>
        <dup_id/>
        <creation_time>2016-12-06 16:43:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Debug value hover black/white color issue</short_desc>
        <thetext>- Start java debug session
- Hover over some variable
- Hover has black background and white text</thetext>
        <comment>
            <comment_id>2784907</comment_id>
            <comment_count>1</comment_count>
            <who>Alexander Kurtakov</who>
            <commenter_username>akurtakov</commenter_username>
            <when>2016-12-09 09:18:03 -0500</when>
            <comment_text>Leo, I'm pretty sure this is yet another COLOR_INFO usage in another project not in SWT.</comment_text>
        </comment>
        <comment>
            <comment_id>2784933</comment_id>
            <comment_count>2</comment_count>
            <who>Leo Ufimtsev</who>
            <commenter_username>lufimtse</commenter_username>
            <when>2016-12-09 10:03:53 -0500</when>
            <comment_text>(In reply to Alexander Kurtakov from comment #1)
&gt; Leo, I'm pretty sure this is yet another COLOR_INFO usage in another project
&gt; not in SWT.

Yes that is correct. I mistakenly selected SWT (my default..) and forgot to change it to relevant component. Thank you for pointing this out.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508953</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-12-08 23:50:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>RenamePackageTests failures in build</short_desc>
        <thetext>Several tests failed from RenamePackageTests in I20161208-0830 on win32.x86:

testHierarchical01
junit.framework.ComparisonFailure: invalid update in file MyA.java
...

testHierarchical03
Java Model Exception: Java Model Status [&lt;project root&gt; [in TestProject1481227313022] is not on its project's build path]
...

testHierarchicalToSubpackage
java.lang.NullPointerException
at org.eclipse.jdt.ui.tests.refactoring.RenamePackageTests$PackageRename.createAndPerform(RenamePackageTests.java:341)
...

testHierarchicalDisabledImport
Java Model Exception: Java Model Status [&lt;project root&gt; [in TestProject1481227313022] is not on its project's build path]
...

test1
junit.framework.ComparisonFailure: invalid update in file A.java
...

test2
junit.framework.ComparisonFailure: invalid update in file A.java
...

test6
Java Model Exception: Java Model Status [&lt;project root&gt; [in TestProject1481227313022] is not on its project's build path]
...

test8
Java Model Exception: Java Model Status [&lt;project root&gt; [in TestProject1481227313022] is not on its project's build path]
...</thetext>
    </bug>
    <bug>
        <id>508954</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-12-09 00:01:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>AssistQuickFixTest18 test failure in build</short_desc>
        <thetext>AssistQuickFixTest18.testConvertMethodReferenceToLambda3() failed in I20161208-0830 build on ep47I-unit-cen64 linux.gtk.x86_64:

org.junit.ComparisonFailure: Content not as expected
...
at org.eclipse.jdt.testplugin.StringAsserts.assertExpectedExistInProposals(StringAsserts.java:189)
at org.eclipse.jdt.ui.tests.quickfix.QuickFixTest.assertExpectedExistInProposals(QuickFixTest.java:167)
at org.eclipse.jdt.ui.tests.quickfix.AssistQuickFixTest18.testConvertMethodReferenceToLambda3(AssistQuickFixTest18.java:2671)</thetext>
    </bug>
    <bug>
        <id>509171</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-12-13 12:01:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[call hierarchy] doesn't properly expand caller in lambda in "Expand with constructors"</short_desc>
        <thetext>I20161213-0600

(snippet from bug 509169, but I think the bad search results there are orthogonal to this problem)

Open a Call Hierarchy for callers of method getInput().

The calls in ccc() and in bbb() look good. The last item expands with the constructor "new Runnable() {...}", and the bbb() is found to contain a reference to that constructor.

The call in aaa() should be traceable to aaa() somehow. Currently, that match's element is the "run" method in an type that stands for the lambda expression. That structure is OK, but then the "[constructor]" node should have aaa() as a child. Currently, it has no children.

I think this is a special case that JDT UI should handle specially in the Call Hierarchy.

package xy;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.concurrent.Executors;

public class LambdaAnonymousTest2 {
    public void aaa() {
        Executors.callable(() -&gt; {
            Collections.sort(
                    getInput(),
                    new Comparator&lt;Integer&gt;() {
                        @Override
                        public int compare(Integer a, Integer b) {
                            return diff(a, b);
                        }
                    });
        });
    }

    public void bbb() {
        Executors.callable(new Runnable() {
            @Override
            public void run() {
                Collections.sort(
                        getInput(),
                        new Comparator&lt;Integer&gt;() {
                            @Override
                            public int compare(Integer a, Integer b) {
                                return diff(a, b);
                            }
                        });
            }
        });
    }

    public void ccc() {
        Collections.sort(
                getInput(),
                new Comparator&lt;Integer&gt;() {
                    @Override
                    public int compare(Integer a, Integer b) {
                        return diff(a, b);
                    }
                });
    }

    public static List&lt;Integer&gt; getInput() {
        return Arrays.asList(1, 2, 4, 3);
    }

    public static int diff(Integer a, Integer b) {
        return a - b;
    }
}</thetext>
    </bug>
    <bug>
        <id>509238</id>
        <developer>Marcel Mann</developer>
        <developer_username>marcel.mann</developer_username>
        <dup_id/>
        <creation_time>2016-12-14 12:21:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Run Unit-Tests automatically when changing and saving code in the editor</short_desc>
        <thetext>Created attachment 265884
Launching configuration

It would be very nice if Eclipse can (re-)run all relevant Unit-Tests after changing and saving code in the editor.

I know this is possible with the Infinitest plugin, but the plugin sometimes is very buggy and it would be great, if Eclipse could provide this feature out-of-the-box.

The new IntelliJ IDEA 2016.3 version has this feature: https://twitter.com/intellijidea/status/807239309992591361

Currently I'm using this workaround:
1. Creating a launch-configuration with all the test for my project
2. Running this launch-configuration
3. Configuring Eclipse to always run the latest application (see attachment)
4. Running latest application with cmd+shift+f11 (on mac)</thetext>
    </bug>
    <bug>
        <id>509241</id>
        <developer>Jonah Graham</developer>
        <developer_username>jonah</developer_username>
        <dup_id/>
        <creation_time>2016-12-14 12:48:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>F2 for focus of popup when "Expand vertical ruler icons upon hovering" is on does not work as expected</short_desc>
        <thetext>+++ This bug was initially created as a clone of Bug #509240 +++

To reproduce:
- Turn "Expand vertical ruler icons upon hovering" on (in Preferences Editor -&gt; Hovers) 
- repoen an editor with a warning or error.
- hover on the vertical ruler and bring up error/warning message
- press F2 to set focus to popup

Then note:
1) New pop-up is created. Sometimes the text is in it, sometimes it is not - can't identify pattern. But click in the popup and it disappears.
2) The original popup hover is still present and now does not disappear automatically unless you either retrigger the hover or close the editor.</thetext>
    </bug>
    <bug>
        <id>509354</id>
        <developer>eugene rabii</developer>
        <developer_username>eugen.rabii</developer_username>
        <dup_id/>
        <creation_time>2016-12-16 09:13:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Java 9 Oxygen Plugin Fails</short_desc>
        <thetext>Created attachment 265914
Failure that I get

Java 9 Oxygen plugin seems to be broken.

1) Vanilla install of Eclipse Oxygen M3. 
2) --add-modules=java.se.ee set in eclipse.ini
3) Eclipse -&gt; Preferences -&gt; Java -&gt; Compiler -&gt; 9 (BETA); this means the plugin is installed.
4) Eclipse -&gt; Preferences -&gt; Java -&gt; Installed JRE's shows Java 9 seems ok so far.
5) Change Project settings compiler to be 1.9 - Error thrown. See screenshot. Installed JRE location.</thetext>
        <comment>
            <comment_id>2787036</comment_id>
            <comment_count>1</comment_count>
            <who>eugene rabii</who>
            <commenter_username>eugen.rabii</commenter_username>
            <when>2016-12-16 09:14:46 -0500</when>
            <comment_text>Created attachment 265915
Java 9 seems to be visible at first</comment_text>
        </comment>
        <comment>
            <comment_id>2787037</comment_id>
            <comment_count>2</comment_count>
            <who>eugene rabii</who>
            <commenter_username>eugen.rabii</commenter_username>
            <when>2016-12-16 09:15:36 -0500</when>
            <comment_text>Created attachment 265916
Another weird display</comment_text>
        </comment>
        <comment>
            <comment_id>2787051</comment_id>
            <comment_count>3</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-12-16 09:51:04 -0500</when>
            <comment_text>I currently can't verify that it works indeed, but two things to keep in mind:

1. As indicated on https://marketplace.eclipse.org/content/java-9-support-beta-oxygen you have to use the latest integration build since the code in the beta branch / marketplace moves along together.

2. Changes are still made to the Java 9 JRE/SDK and how things are organized in there. If your installed Java 9 JRE is an old one then that might be the reason it gets removed.

Can you try with all the latest?</comment_text>
        </comment>
        <comment>
            <comment_id>2787165</comment_id>
            <comment_count>4</comment_count>
            <who>eugene rabii</who>
            <commenter_username>eugen.rabii</commenter_username>
            <when>2016-12-16 15:28:05 -0500</when>
            <comment_text>Hey,

Yes.  Here is the EXACT set-up.

1) Eclipse version :  Oxygen Release Milestone 4 (4.7.0 M4)
2) Latest Java 9 Plugin (I assume) from the marketplace.
3) Latest jdk-9, that's build 149.

Same thing is re-produced.

Thank you,
Eugene.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508776</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-12-06 11:38:00 -0500</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>Javadoc hover shows mix of Info and Javadoc colors</short_desc>
        <thetext>I20161205-2000

The Javadoc hover now shows a mix of Info and Javadoc colors.
The "Press 'F2' for focus" at the bottom should use Javadoc colors as well.</thetext>
        <comment>
            <comment_id>2783544</comment_id>
            <comment_count>1</comment_count>
            <who>Leo Ufimtsev</who>
            <commenter_username>lufimtse</commenter_username>
            <when>2016-12-06 15:04:29 -0500</when>
            <comment_text>(In reply to Markus Keller from comment #0)
&gt; I20161205-2000
&gt; 
&gt; The Javadoc hover now shows a mix of Info and Javadoc colors.
&gt; The "Press 'F2' for focus" at the bottom should use Javadoc colors as well.

Works for me. Let's dissambiguiate:
1) Can you upload a screenshot please (application 'shutter' can do timed screenshots btw).
2) Does the issue still occur if you restart the Eclipse IDE after setting color?</comment_text>
        </comment>
        <comment>
            <comment_id>2783545</comment_id>
            <comment_count>2</comment_count>
            <who>Leo Ufimtsev</who>
            <commenter_username>lufimtse</commenter_username>
            <when>2016-12-06 15:06:59 -0500</when>
            <comment_text>(In reply to Markus Keller from comment #0)
&gt; I20161205-2000
&gt; 
&gt; The Javadoc hover now shows a mix of Info and Javadoc colors.
&gt; The "Press 'F2' for focus" at the bottom should use Javadoc colors as well.

Oh, is this Windows 7 specific btw?</comment_text>
        </comment>
        <comment>
            <comment_id>2783856</comment_id>
            <comment_count>3</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-12-07 09:02:47 -0500</when>
            <comment_text>(In reply to Leo Ufimtsev from comment #1)
&gt; 2) Does the issue still occur if you restart the Eclipse IDE after setting
&gt; color?

Did you try that? Why do I have to waste time to debug your bugs? Depending on your exact steps, even closing/reopening an editor should be enough to reproduce.

I now even found bug 508494, where you already identified the problem (partially).

The info colors preferences have more problems, see bug 508819. Let's not destabilize M4. Better do all the cleanup in M5.</comment_text>
        </comment>
        <comment>
            <comment_id>2783967</comment_id>
            <comment_count>4</comment_count>
            <who>Leo Ufimtsev</who>
            <commenter_username>lufimtse</commenter_username>
            <when>2016-12-07 10:47:33 -0500</when>
            <comment_text>(In reply to Markus Keller from comment #3)
&gt; (In reply to Leo Ufimtsev from comment #1)
&gt; &gt; 2) Does the issue still occur if you restart the Eclipse IDE after setting
&gt; &gt; color?
&gt; 
&gt; Did you try that? Why do I have to waste time to debug your bugs? Depending
&gt; on your exact steps, even closing/reopening an editor should be enough to
&gt; reproduce.
&gt; 
&gt; The info colors preferences have more problems, see bug 508819. Let's not
&gt; destabilize M4. Better do all the cleanup in M5.

I'm new to platform.ui development, so I apologise for inconvenience caused by lack of knowledge on my part.

The reason I asked if issue is still present after restart was not to suggest it as a solution (sorry if this looked like the case), but to is to see if you bumped into issue:
Bug 508494 – Implement property change listener in AbstractInformationControl for Javadoc 
https://bugs.eclipse.org/bugs/show_bug.cgi?id=508494
Sorry if I didn't clarify the intend. 

With that said, on the new builds, I don't get the 'mix' of colors as you mentioned in the initial outline. For me it's a solid color. At least after restarting IDE.
So I would like to clarify, does the issue persist after a restart? If not, then this bug is a duplicate of 508494).
If the issue does persist still after a restart, then can you please attach a screenshot because it does not occur on my setup. (My setup being Linux)

&gt; I now even found bug 508494, where you already identified the problem
&gt; (partially).

Can you clarify what you mean by 'partially'? Is there something I didn't describe in the bug that I should have?

Thank you for your time and reporting these issues.</comment_text>
        </comment>
        <comment>
            <comment_id>2784073</comment_id>
            <comment_count>5</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-12-07 14:22:20 -0500</when>
            <comment_text>Created attachment 265756
Screenshot

The bar at the bottom should use Javadoc colors as well (blueish in this setup).

(In reply to Leo Ufimtsev from comment #4)
&gt; The reason I asked if issue is still present after restart was
[..]
&gt; Bug 508494 – Implement property change listener in
&gt; AbstractInformationControl for Javadoc 

If you already have a guess, then please post the bug number. And I don't think it should be my job as a bug reporter to track down the problem until the solution is trivial.</comment_text>
        </comment>
        <comment>
            <comment_id>2784116</comment_id>
            <comment_count>6</comment_count>
            <who>Leo Ufimtsev</who>
            <commenter_username>lufimtse</commenter_username>
            <when>2016-12-07 16:35:14 -0500</when>
            <comment_text>(In reply to Markus Keller from comment #5)
&gt; Created attachment 265756 [details]
&gt; Screenshot

Thank you for attaching the screenshot, it is very helpful.

&gt; If you already have a guess, then please post the bug number. And I don't
&gt; think it should be my job as a bug reporter to track down the problem until
&gt; the solution is trivial.

Yes, you are correct. I should have linked to the bug. My apologies.

&gt; The bar at the bottom should use Javadoc colors as well (blueish in this setup).

Well... Let's think about it.

The strip at the bottom is not part of JavaDoc documentation per-se. It provides information on how to use the IDE, it is not Java specific. It is part of the 'Hoverbox' mechanism, it is defined in AbstractInformationControl(*1) and is used in various places; for example in CDT's C Macro expansion hover (which is not JDT).
Making AbstractInformationControl use JDT's Javadoc color is technically not correct.

For example if you press F2, then next screen has buttons like &lt;forward&gt;|&lt;Backward&gt;|...|&lt;open in browser&gt; (see next attachment. That strip at the bottom doesn't have Javadoc colors either.

With that said, currently as pe`r Bug 507062, it is using the information color, which may not necessarily be correct either. 

There are two potential solutions here:

1) I could submit a patch so that it uses regular widget colors (COLOR_WIDGET_(FOREGROUND|BACKGROUND)), that way it would be consistent with the followup 'focused' hoverbox. (See attached screenshot #Solution 1).

2) I could modify AbstractInformationControl.java such that the constructor accepts fg/bg colors as parameters, and in JavaDocHover.java(418) I could instruct it to use the background/foreground of the Javadoc. In such case the dialogue would be fully in the javadoc color.

Thoughts?

[1] https://git.eclipse.org/r/#/c/85960/3/org.eclipse.jface.text/src/org/eclipse/jface/text/AbstractInformationControl.java</comment_text>
        </comment>
        <comment>
            <comment_id>2784118</comment_id>
            <comment_count>7</comment_count>
            <who>Leo Ufimtsev</who>
            <commenter_username>lufimtse</commenter_username>
            <when>2016-12-07 16:35:44 -0500</when>
            <comment_text>Created attachment 265759
Solution 1, use widget colors.</comment_text>
        </comment>
        <comment>
            <comment_id>2784124</comment_id>
            <comment_count>8</comment_count>
            <who>Leo Ufimtsev</who>
            <commenter_username>lufimtse</commenter_username>
            <when>2016-12-07 17:05:45 -0500</when>
            <comment_text>
&gt; 2) I could modify AbstractInformationControl.java such that the constructor
&gt; accepts fg/bg colors as parameters, and in JavaDocHover.java(418) I could
&gt; instruct it to use the background/foreground of the Javadoc. In such case
&gt; the dialogue would be fully in the javadoc color.

Actually, I have a patch in progress to implement solution 2), except that it would use AbstractInformationControl.setBackground() and AbstractInformationControl.setForeground() instead of introducing a constructor. (But need to fix a bug in AbstractInformationControl first).

I'll submit tomorrow. Please wait.</comment_text>
        </comment>
        <comment>
            <comment_id>2784587</comment_id>
            <comment_count>9</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-08 14:54:15 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/86771</comment_text>
        </comment>
        <comment>
            <comment_id>2784589</comment_id>
            <comment_count>10</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-08 15:04:05 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/86773</comment_text>
        </comment>
        <comment>
            <comment_id>2784591</comment_id>
            <comment_count>11</comment_count>
            <who>Leo Ufimtsev</who>
            <commenter_username>lufimtse</commenter_username>
            <when>2016-12-08 15:11:10 -0500</when>
            <comment_text>Hello Markus, 

I submitted the following patches:

1/2: AbstractInformationControl.java
https://git.eclipse.org/r/#/c/86771/
This fixes status control not getting background colors.

2/2: JavadocHover.java
https://git.eclipse.org/r/#/c/86773/1
This makes JavaDocHover tell AbstractInformationControl to use the same JavaDoc color for the status strip at the bottom.


The 3rd patch is somewhat unrelated to this, but also touchesAbstractInformationControl: 
https://git.eclipse.org/r/#/c/86768/
Here instead of using INFO/HOVER, it resorts to using the info color that will be defined in jFace. (Essentially INFO_ on windows, LIST_ on Linux). But patch 2/2 will override colors specifically for JavadocHover. So won't affect JavaDocHover.

Is this what you had in mind?

NOTE: I haven't done extensive testing/investigation for Patch 1/2 yet. I have not yet investigated how this could potentially impact other controls yet.
However, before I spent hours investigating/testing, I would like to hear your opinion on the patches above. If you like the general approach, then I will do more detailed testing of patch 1/2.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>487780</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-02-13 02:58:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] [DOM] AST changes for java 9</short_desc>
        <thetext>Need to decide on what changes for Java 9 in DOM AST - Umbrella Bug</thetext>
        <comment>
            <comment_id>2742473</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-08-22 14:12:48 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/79451</comment_text>
        </comment>
        <comment>
            <comment_id>2742703</comment_id>
            <comment_count>2</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-08-23 07:14:04 -0400</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/79451 was merged to [BETA_JAVA9].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=5c83e7a4a08150ff31eef9f7d80db9ef25943b59</comment_text>
        </comment>
        <comment>
            <comment_id>2748792</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-09 03:10:44 -0400</when>
            <comment_text>The warnings due to the deprecation of JLS8 have been fixed via this commit:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=392774ce958ca42825bfc9dcbd30f9655a11e87e</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489833</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-03-17 07:00:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[content assist] Incorrect value from CompletionProposal.getReplaceStart() causes SIOOBE</short_desc>
        <thetext>package p1;
/**
 * Bla {@link #method(Object[]...)}.
 *
 * Auto-complete here #
 */
public class Test {

	public void method(Object[]... args) {}
	public void method2(int arg) {}
}

- In the above example, press Ctrl+space after # at the specified location.
- CompletionProposal.getReplaceStart() for the received proposals returns the offset before the first #. 

As a result, we get wrong pattern in AbstractJavaCompletionProposal.getPatternMatchRule(String pattern, String string). Here,

string is:
{@link #method(Object[]...)} - Test

and, pattern is:
#method(Object[]...)}.
 *
 * Auto-complete here #

This results in SIOOBE.

- In 4.6 M3 build, before AbstractJavaCompletionProposal#getPatternMatchRule was introduced, we used to get incorrect result and the text from the first # onwards was eaten up by applying the proposal.</thetext>
        <comment>
            <comment_id>2702730</comment_id>
            <comment_count>1</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-05-04 03:46:17 -0400</when>
            <comment_text>Initial Analysis: Though the symptoms are similar to the bug 488363, the root cause is different. Here instead of CompletionOnJavadocFieldReference a CompletionOnJavadocMessageSend node is created with reference to "@link #method(Object[]...)}" in 
Eclipse.4.6M7PLUS [Eclipse Application]	
	org.eclipse.equinox.launcher.Main at localhost:59224	
		Thread [main] (Suspended (breakpoint at line 20 in CompletionOnJavadocMessageSend))	
			CompletionOnJavadocMessageSend.&lt;init&gt;(JavadocMessageSend, int) line: 20	
			CompletionJavadocParser.syntaxRecoverArgumentType(Object, List, Object) line: 860	
			CompletionJavadocParser.parseArguments(Object) line: 453	
			CompletionJavadocParser(AbstractCommentParser).parseMember(Object) line: 763	
			CompletionJavadocParser(AbstractCommentParser).parseReference() line: 1204	
			CompletionJavadocParser.parseReference() line: 543	
			CompletionJavadocParser(JavadocParser).parseTag(int) line: 593	
			CompletionJavadocParser.parseTag(int) line: 556	
			CompletionJavadocParser(AbstractCommentParser).commentParse() line: 242	
			CompletionJavadocParser.commentParse() line: 99	
			
moving to 4.7</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492518</id>
        <developer>Sasikanth Bharadwaj</developer>
        <developer_username>sasikanth.bharadwaj</developer_username>
        <dup_id/>
        <creation_time>2016-04-27 04:17:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[search] Search for implementors does not report lambda expressions as matches when intersection type is involved</short_desc>
        <thetext>In the code below, select I, then select Seach -&gt; Implementors -&gt; Project. Search reports 0 implementors. If X implements I, then 2 matches are reported

interface I {}
interface J {
	int foo(int a, int b);
}
public class X  {

	public J bar() {
		return (I &amp; J) (i1, i2) -&gt; {return 0;};
	}
}

Type hierachy of J doesn't show the lambda expression in either case when the intersection cast is present.</thetext>
    </bug>
    <bug>
        <id>493262</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-05-09 13:38:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Remove INameEnvExtension</short_desc>
        <thetext>INEE was introduced in bug 493222 as an interim fix - With jdt.core moving to 1.8, this needs to be replaced by a default method in INE</thetext>
    </bug>
    <bug>
        <id>495475</id>
        <developer>Kris De Volder</developer>
        <developer_username>kdevolder</developer_username>
        <dup_id/>
        <creation_time>2016-06-04 22:11:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[quick fix] Create local variable quickfix fails with an NPE</short_desc>
        <thetext>I'm sorry... I do not have the energy to try and reduce this to a 'minimal' example. But I thought I would at least report the bug now that I have a chance to 'snapshot' my project at a point where it occurs. 

What's the issue: Sometimes 'create local variable' simply doesn't work, it ostensibly does nothing while silently logging an exception in the error log (see end of this report for the full stacktrace).

To reproduce try applying the quickfix by pressing CTRL-1 at this line of code:
https://github.com/kdvolder/two-three-tree/blob/ede2174f2dc0631dc3ceea85b60c9c39580a1fae/src/test/java/com/github/kdvolder/tttree/test/TTTSetTest.java#L15

If copy pasting some snippets of code isn't enough, you can simply clone the repo and checkout the commit with hash:  ede2174f2dc0631dc3ceea85b60c9c39580a1fae then import the project into eclipse to get exactly the same context I had when encountering the bug.

---- stacktrace ----
java.lang.NullPointerException
	at org.eclipse.jdt.internal.ui.viewsupport.BindingLabelProvider.getTypeLabel(BindingLabelProvider.java:351)
	at org.eclipse.jdt.internal.ui.viewsupport.BindingLabelProvider.getTypeLabel(BindingLabelProvider.java:352)
	at org.eclipse.jdt.internal.ui.viewsupport.BindingLabelProvider.getTypeArgumentsLabel(BindingLabelProvider.java:430)
	at org.eclipse.jdt.internal.ui.viewsupport.BindingLabelProvider.getTypeLabel(BindingLabelProvider.java:398)
	at org.eclipse.jdt.internal.ui.viewsupport.BindingLabelProvider.getBindingLabel(BindingLabelProvider.java:459)
	at org.eclipse.jdt.internal.corext.fix.LinkedProposalPositionGroup$JavaLinkedModeProposal.&lt;init&gt;(LinkedProposalPositionGroup.java:206)
	at org.eclipse.jdt.internal.corext.fix.LinkedProposalPositionGroup.addProposal(LinkedProposalPositionGroup.java:261)
	at org.eclipse.jdt.internal.ui.text.correction.proposals.LinkedCorrectionProposal.addLinkedPositionProposal(LinkedCorrectionProposal.java:142)
	at org.eclipse.jdt.internal.ui.text.correction.proposals.NewVariableCorrectionProposal.evaluateVariableType(NewVariableCorrectionProposal.java:502)
	at org.eclipse.jdt.internal.ui.text.correction.proposals.NewVariableCorrectionProposal.doAddLocal(NewVariableCorrectionProposal.java:248)
	at org.eclipse.jdt.internal.ui.text.correction.proposals.NewVariableCorrectionProposal.getRewrite(NewVariableCorrectionProposal.java:115)
	at org.eclipse.jdt.ui.text.java.correction.ASTRewriteCorrectionProposal.addEdits(ASTRewriteCorrectionProposal.java:110)
	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createTextChange(CUCorrectionProposal.java:231)
	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createChange(CUCorrectionProposal.java:238)
	at org.eclipse.jdt.ui.text.java.correction.ChangeCorrectionProposal.getChange(ChangeCorrectionProposal.java:366)
	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.getTextChange(CUCorrectionProposal.java:248)
	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.getAdditionalProposalInfo(CUCorrectionProposal.java:141)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$Timer$2$1.run(AdditionalInfoController.java:113)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)</thetext>
        <comment>
            <comment_id>2717347</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-06-06 02:57:49 -0400</when>
            <comment_text>*** Bug 475323 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
        <comment>
            <comment_id>2717353</comment_id>
            <comment_count>2</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-06-06 03:12:22 -0400</when>
            <comment_text>I can reproduce it with Neon RC4 build (I20160603-1000).

Example to reproduce the bug:

package p;

import java.util.List;

public class Test {

	protected &lt;E extends Comparable&lt;E&gt;&gt; List&lt;E&gt; createEmptySet() {
		return null;
	}

	public void emptySet() {
		s = createEmptySet();
	}

}

Apply quick fix "Create local variable 's'".

This worked in 4.4 but not in 4.5.</comment_text>
        </comment>
        <comment>
            <comment_id>2717378</comment_id>
            <comment_count>3</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-06-06 04:22:52 -0400</when>
            <comment_text>ITypeBinding.getWildcard() now returns null at BindingLabelProvider.java:352, resulting in NPE. 

Moving to JDT/Core.</comment_text>
        </comment>
        <comment>
            <comment_id>2717772</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-07 02:01:27 -0400</when>
            <comment_text>(In reply to Noopur Gupta from comment #3)
&gt; ITypeBinding.getWildcard() now returns null at
&gt; BindingLabelProvider.java:352, resulting in NPE. 
&gt; 
&gt; Moving to JDT/Core.

There's no wildcard in the capture: &lt;Z#0-E#0 extends Comparable&lt;Z#0-E#0&gt;&gt;

I am copying Stephan for expert opinion.</comment_text>
        </comment>
        <comment>
            <comment_id>2717880</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-07 08:45:18 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #4)
&gt; (In reply to Noopur Gupta from comment #3)
&gt; &gt; ITypeBinding.getWildcard() now returns null at
&gt; &gt; BindingLabelProvider.java:352, resulting in NPE. 
&gt; &gt; 
&gt; &gt; Moving to JDT/Core.
&gt; 
&gt; There's no wildcard in the capture: &lt;Z#0-E#0 extends Comparable&lt;Z#0-E#0&gt;&gt;

This is how we render CaptureBinding18.
Those indeed do not have a wildcard.

The underlying difficulty is that CaptureBinding18 is a type that does not fit into any of the classifications we have in JDT.

From a compiler p.o.v., greatest similarity exists with CaptureBinding. That's why I made CaptureBinding18 a subclass of CaptureBinding.

Looking at the javadoc of ITypeBinding.isCapture() a CaptureBinding18 should actually answer false here.

This only leaves us with the problem that this kind of type would then answer false to all isX() queries, leaving all clients clueless.

Actually, for labels in the UI CaptureBinding18 does not have *any* nice representation.



See also bug 470794 comment 15 and bug 470794 comment 19 (speaking of "typesIntroducedBy18_5_bullet6")

Also related: bug 429264</comment_text>
        </comment>
        <comment>
            <comment_id>2718704</comment_id>
            <comment_count>6</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-08 22:53:56 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #5)
&gt; Looking at the javadoc of ITypeBinding.isCapture() a CaptureBinding18 should
&gt; actually answer false here.

Overriding isCapture in CaptureBinding18 sounds straight forward.

&gt; This only leaves us with the problem that this kind of type would then
&gt; answer false to all isX() queries, leaving all clients clueless.
&gt; 
&gt; Actually, for labels in the UI CaptureBinding18 does not have *any* nice
&gt; representation.

Are you suggesting we provide specific implementation for labels in the UI than fixing isCapture?</comment_text>
        </comment>
        <comment>
            <comment_id>2719632</comment_id>
            <comment_count>7</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-11 09:04:20 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #6)
&gt; (In reply to Stephan Herrmann from comment #5)
&gt; &gt; Looking at the javadoc of ITypeBinding.isCapture() a CaptureBinding18 should
&gt; &gt; actually answer false here.
&gt; 
&gt; Overriding isCapture in CaptureBinding18 sounds straight forward.

To be clear: we shouldn't change this in the compiler, only dom bindings should add the extra logic so that an ITypeBinding based on a CaptureBinding18 answers: "not a capture".

 
&gt; &gt; This only leaves us with the problem that this kind of type would then
&gt; &gt; answer false to all isX() queries, leaving all clients clueless.
&gt; &gt; 
&gt; &gt; Actually, for labels in the UI CaptureBinding18 does not have *any* nice
&gt; &gt; representation.
&gt; 
&gt; Are you suggesting we provide specific implementation for labels in the UI
&gt; than fixing isCapture?

Maybe worth a try to see what labels we will get with the above change in isCapture(). If that looks awful, then, yes, I'd propose a specific implementation. But since isCapture() currently violates it's javadoc that change should be made in any case.</comment_text>
        </comment>
        <comment>
            <comment_id>2729990</comment_id>
            <comment_count>8</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-07-13 01:28:30 -0400</when>
            <comment_text>Assigning to Manoj.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498942</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-08-01 01:53:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Update ECJ Man page with new Java 9 compiler options</short_desc>
        <thetext>Bug 487421 introduces new command line option for the Eclipse compiler which the man page should reflect. Once that bug is complete, we should update the man page accordingly.</thetext>
    </bug>
    <bug>
        <id>501161</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-09-09 12:47:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9][search] Refactor code for BinaryContainer</short_desc>
        <thetext>With the fix of bug 500622 common code can be pulled up for multiple binary containers</thetext>
    </bug>
    <bug>
        <id>501162</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-09-09 12:52:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9][search] find constructs in module-info</short_desc>
        <thetext>constructs should be found in module-info file as applicable.</thetext>
    </bug>
    <bug>
        <id>506391</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-10-22 12:39:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[content assist] Added imports expand the folded imports and shifts text</short_desc>
        <thetext>Added imports expand the folded imports and shifts text.

package p;

import java.util.HashMap;
import java.util.Map;

public class C {
	Map m;
	HashMap h;
	List
}


- make sure the imports are folded
- do content assist after "List"</thetext>
        <comment>
            <comment_id>2769249</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-10-22 12:39:32 -0400</when>
            <comment_text>Works in 4.4.2. Broken since 4.5.</comment_text>
        </comment>
        <comment>
            <comment_id>2770504</comment_id>
            <comment_count>2</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-10-27 05:20:19 -0400</when>
            <comment_text>(In reply to Dani Megert from comment #0)
&gt; Added imports expand the folded imports and shifts text.
&gt; 
&gt; package p;
&gt; 
&gt; import java.util.HashMap;
&gt; import java.util.Map;
&gt; 
&gt; public class C {
&gt; 	Map m;
&gt; 	HashMap h;
&gt; 	List
&gt; }
&gt; 
&gt; 
&gt; - make sure the imports are folded
&gt; - do content assist after "List"

If java.awt.List is chosen from the proposals, the imports expand and are folded back automatically. It is the same behavior in 4.4.2 also.

If java.util.List is chosen, the imports do not expand in 4.4.2. But they expand in 4.7 and are not folded back.

Dani, any clue where the problem could be?</comment_text>
        </comment>
        <comment>
            <comment_id>2770569</comment_id>
            <comment_count>3</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-10-27 08:46:00 -0400</when>
            <comment_text>On debugging the 4.4 and master code, I can see that the difference is in the creation of TextEdits and handling of delimiters between imports (ImportEditor.placeResultantImports(..)).

In 4.4, a single text edit was created:
  {InsertEdit} [41,0] &lt;&lt;import java.util.List;
with text: "import java.util.List;\r\n"

In master, two text edits are created:
  {InsertEdit} [39,0] &lt;&lt;
with text: "\r\n"
followed by:
  {InsertEdit} [39,0] &lt;&lt;import java.util.List;
with text: "import java.util.List;"

Adding the delimiter after the text to be inserted (similar to 4.4) and adjusting the offset fixes this issue.  

(In reply to Noopur Gupta from comment #2)
&gt; If java.awt.List is chosen from the proposals, the imports expand and are
&gt; folded back automatically. It is the same behavior in 4.4.2 also.

This has the same behavior in 4.4 and master because here the delimiter text edit is added after the import text edit in master:
  {InsertEdit} [14,0] &lt;&lt;import java.awt.List;
with text: "import java.awt.List;"
followed by:
  {InsertEdit} [14,0] &lt;&lt;
with text: "\r\n"

Moving to JDT Core based on the above analysis.</comment_text>
        </comment>
        <comment>
            <comment_id>2783111</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-06 01:00:49 -0500</when>
            <comment_text>Moving out to M5.

Manoj, please take a look.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506438</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-10-24 09:13:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] Search for package references doesn't return the package reference in module-info.java</short_desc>
        <thetext>Search for a package reference in a project where the package is also referred in the module-info.java in "exports". The search does not return the reference in the module-info.java file.</thetext>
        <comment>
            <comment_id>2770986</comment_id>
            <comment_count>1</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-10-28 08:40:02 -0400</when>
            <comment_text>(In reply to Noopur Gupta from comment #0)
&gt; Search for a package reference in a project where the package is also
&gt; referred in the module-info.java in "exports". The search does not return
&gt; the reference in the module-info.java file.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506482</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-10-25 03:23:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9][content assist] Type proposals not shown in module-info.java</short_desc>
        <thetext>P20161024-2040

1) Press Ctrl+space in place of '|' =&gt; no proposals are shown.

module PTest {
	uses java.sql.Dr|
}

It works when a semicolon is added:

uses java.sql.Dr|;

2) No proposals are displayed here:

uses java.sql.|;</thetext>
        <comment>
            <comment_id>2769718</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-10-25 03:50:01 -0400</when>
            <comment_text>In my example, even if I add the interface, I get an error that it can't be resolved.

Have /First Module/src/api1/IColorProvider.java
in /First Module/src/module-info.java add uses api1.IColorProvider;</comment_text>
        </comment>
        <comment>
            <comment_id>2769721</comment_id>
            <comment_count>2</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-10-25 03:55:10 -0400</when>
            <comment_text>The same is applicable to "provides/with" also. Have a class p.C which implements "Driver" and press Ctrl+space:

module PTest {
    requires java.sql;
    provides java.sql.Driver with p.C|
}</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507954</id>
        <developer>Jonas -</developer>
        <developer_username>barney2k7</developer_username>
        <dup_id/>
        <creation_time>2016-11-22 09:04:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Type Hierarchy incomplete, misses some anonymous subtypes</short_desc>
        <thetext>Ever since we use Eclipse 4.6 on our code base, we noticed that the 'Type Hierarchy'-View as well as the 'Quick Type Hierarchy' are missing some anonymous subtypes. Weirdly, those subtypes DO show up as long as the corresponding java file is open in an editor. Other Views don't seem to be affected: Search for references on the constructor shows all sites where subtypes are created. Refactoring (e.g. renaming a method that also occurs in the missing anonymous subtype) works properly, too.
So far, we haven't been able to create classes we could share here that reproduce the problem. Maybe someone familiar with the Type Hierarchy could provide feedback under what circumstances subtypes are gathered from the files currently open in an editor.</thetext>
        <comment>
            <comment_id>2778679</comment_id>
            <comment_count>1</comment_count>
            <who>Jonas -</who>
            <commenter_username>barney2k7</commenter_username>
            <when>2016-11-22 09:35:57 -0500</when>
            <comment_text>Here's how to reproduce the issue:

1.) Use a fresh Eclipse 4.6.1 (M20160907-1200) with a new Workspace
2.) create a new java project, add the four java classes A, B, C and D (see attachments)
3.) open A (only A!) in an editor, press ctrl+t on the class name: one anonymous subclass shows up (within B). Same result in the Type Hierarchy View.
4.) open D in an editor, go back to A (leave D open!), press ctrl+t on the class name: all three anonymous subclass shows up (within B and D). Same result in the Type Hierarchy View.</comment_text>
        </comment>
        <comment>
            <comment_id>2778680</comment_id>
            <comment_count>2</comment_count>
            <who>Jonas -</who>
            <commenter_username>barney2k7</commenter_username>
            <when>2016-11-22 09:37:42 -0500</when>
            <comment_text>Created attachment 265511
Classes that reproduce the problem</comment_text>
        </comment>
        <comment>
            <comment_id>2778684</comment_id>
            <comment_count>3</comment_count>
            <who>Jonas -</who>
            <commenter_username>barney2k7</commenter_username>
            <when>2016-11-22 09:50:46 -0500</when>
            <comment_text>Just to be clear: if you close 'D' again after step 4.), the subtypes within D no longer show up</comment_text>
        </comment>
        <comment>
            <comment_id>2778701</comment_id>
            <comment_count>4</comment_count>
            <who>Jonas -</who>
            <commenter_username>barney2k7</commenter_username>
            <when>2016-11-22 10:06:38 -0500</when>
            <comment_text>This seems to be a regression in Eclipse 4.6: the problem does not occur in Eclipse 4.5 (tested Version: Mars.1 (4.5.1) Build id: M20150904-0015)</comment_text>
        </comment>
        <comment>
            <comment_id>2778995</comment_id>
            <comment_count>5</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-11-23 03:10:01 -0500</when>
            <comment_text>The API ITypeHierarchy.getSubtypes(IType type) returns different results when 'D' is open/closed. Moving to JDT/Core.</comment_text>
        </comment>
        <comment>
            <comment_id>2779089</comment_id>
            <comment_count>6</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-23 07:19:51 -0500</when>
            <comment_text>I digged up a bit and found that D is not brought up as a CU with possible sub type in IndexBasedHierarchyBuilder.

Manoj, please take a look.</comment_text>
        </comment>
        <comment>
            <comment_id>2779201</comment_id>
            <comment_count>7</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-23 10:23:23 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #6)
&gt; I digged up a bit and found that D is not brought up as a CU with possible
&gt; sub type in IndexBasedHierarchyBuilder.
&gt; 
&gt; Manoj, please take a look.

Please also check whether this is a regression.</comment_text>
        </comment>
        <comment>
            <comment_id>2779956</comment_id>
            <comment_count>8</comment_count>
            <who>Jonas -</who>
            <commenter_username>barney2k7</commenter_username>
            <when>2016-11-25 03:21:57 -0500</when>
            <comment_text>As this worked fine in 4.5 and is broken in 4.6, this definitely seems to be a regression. Is there any chance to get this fixed in 4.6.2?</comment_text>
        </comment>
        <comment>
            <comment_id>2780819</comment_id>
            <comment_count>9</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-11-29 02:03:17 -0500</when>
            <comment_text>(In reply to Jonas - from comment #8)
&gt;  Is there any chance to get this fixed in 4.6.2?
Will try for 4.6.3 [3rd main. release]</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508867</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-12-08 01:01:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] [test] single error to be reported for "_" - ComplianceDiagnoseTest: testBug399781</short_desc>
        <thetext>follow up of Ref bug 488657 comment 6</thetext>
    </bug>
    <bug>
        <id>506321</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-10-21 06:15:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[1.9] Missing icon under module-info.class</short_desc>
        <thetext>Missing icon under module-info.class.

1. expand module java.base
2. expand the module-info.class entirely
==&gt; missing icon</thetext>
        <comment>
            <comment_id>2768962</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-10-21 08:10:46 -0400</when>
            <comment_text>Caused by recent addition of the Java elements for the module-info.java</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506430</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-10-24 07:28:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] Formatter support for module-info.java</short_desc>
        <thetext>- Create a module-info.java file as:

module Try1 {
exports p;
	requires java.base;
}


- Press Ctrl+Shift+F in the file. 

=&gt; The file is not formatted.

The kind used to format is: CodeFormatter.K_COMPILATION_UNIT</thetext>
        <comment>
            <comment_id>2774018</comment_id>
            <comment_count>1</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-11-08 04:25:30 -0500</when>
            <comment_text>@Mateusz: Could you please take this up as a priority as this is targetted for Beta Java 9?</comment_text>
        </comment>
        <comment>
            <comment_id>2774533</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-09 04:28:55 -0500</when>
            <comment_text>My understanding is we need the DOM nodes (at least be able to understand what nodes represent the new program elements in module-info) for the formatter to work. Of course, Mateusz is the right person to confirm.</comment_text>
        </comment>
        <comment>
            <comment_id>2774543</comment_id>
            <comment_count>3</comment_count>
            <who>Mateusz Matela</who>
            <commenter_username>mateusz.matela</commenter_username>
            <when>2016-11-09 04:47:37 -0500</when>
            <comment_text>I should find some time to look at it this weekend or next week.
Yes, I imagine JAVA9 should have new DOM nodes and corresponding methods in ASTVisitor for them - if that's the case, the formatter implementation should be easy.</comment_text>
        </comment>
        <comment>
            <comment_id>2774988</comment_id>
            <comment_count>4</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-11-10 08:13:02 -0500</when>
            <comment_text>(In reply to Mateusz Matela from comment #3)

&gt; Yes, I imagine JAVA9 should have new DOM nodes and corresponding methods in
&gt; ASTVisitor for them - if that's the case, the formatter implementation
&gt; should be easy.

Not yet - was waiting for a client requirement and now we have this requirement - will address this bug 496123</comment_text>
        </comment>
    </bug>
    <bug>
        <id>509257</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-12-15 02:17:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Formatter tests failing with JRE 9 due to mismatch in whitespace</short_desc>
        <thetext>With JRE9, there are 11 new failures in formatter related tests. All the test failures are about line break at an unexpected position, such as this:

----------- Expected ------------
public class X {\n
	/**\n
	 * @see &lt;a href=\n
	 *      "http://0123"&gt;Test&lt;/a&gt;\n
	 */\n
	void foo() {\n
	}\n
}\n

------------ but was ------------
public class X {\n
	/**\n
	 * @see &lt;a\n
	 *      href="http://0123"&gt;Test&lt;/a&gt;\n
	 */\n
	void foo() {\n
	}\n
}\n

Spent bit of time but no luck yet. Also look at the following change that was about difference in behavior of S.o.println() between JRE 8 and 9:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=b2b62e9b747c9c5edd0b2ae1877982659ff6c4e1</thetext>
        <comment>
            <comment_id>2786469</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-15 02:18:18 -0500</when>
            <comment_text>Mateusz, can you please take a look? Thanks!</comment_text>
        </comment>
    </bug>
    <bug>
        <id>493798</id>
        <developer>Szymon Ptaszkiewicz</developer>
        <developer_username>sptaszkiewicz</developer_username>
        <dup_id/>
        <creation_time>2016-05-17 08:24:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>Suspicious workspace activity of JavaReconciler in recent I-build</short_desc>
        <thetext>Created attachment 261787
Trace 1

I noticed the problem in I20160516-2000 but it could have started a few I-builds ago. Never saw that before.

The attached file is a trace log from my main dev workspace where the only thing I did was to open Eclipse and then close Eclipse. The log is gathered using Window &gt; Preferences &gt; General &gt; Tracing preference page. The option which is shown in logs is org.eclipse.core.resources/build/needbuild=true. I have this and several other options always enabled to track suspicious workspace activity and that's why I can tell such workspace activity of JavaReconciler did not happen before. In case it matters, there are two Java editors open but only one is visible. The number of JavaReconciler operations is different each time, but I can reproduce the problem consistently on my workspace. Attaching several logs as example.</thetext>
        <comment>
            <comment_id>2707817</comment_id>
            <comment_count>1</comment_count>
            <who>Szymon Ptaszkiewicz</who>
            <commenter_username>sptaszkiewicz</commenter_username>
            <when>2016-05-17 08:24:58 -0400</when>
            <comment_text>Created attachment 261788
Trace 2</comment_text>
        </comment>
        <comment>
            <comment_id>2707818</comment_id>
            <comment_count>2</comment_count>
            <who>Szymon Ptaszkiewicz</who>
            <commenter_username>sptaszkiewicz</commenter_username>
            <when>2016-05-17 08:25:12 -0400</when>
            <comment_text>Created attachment 261789
Trace 3</comment_text>
        </comment>
        <comment>
            <comment_id>2707819</comment_id>
            <comment_count>3</comment_count>
            <who>Szymon Ptaszkiewicz</who>
            <commenter_username>sptaszkiewicz</commenter_username>
            <when>2016-05-17 08:25:27 -0400</when>
            <comment_text>Created attachment 261790
Trace 4</comment_text>
        </comment>
        <comment>
            <comment_id>2707838</comment_id>
            <comment_count>4</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-05-17 08:50:10 -0400</when>
            <comment_text>We haven't changed anything in that area. Can you reproduce in a new workspace and provide steps?</comment_text>
        </comment>
        <comment>
            <comment_id>2707952</comment_id>
            <comment_count>5</comment_count>
            <who>Szymon Ptaszkiewicz</who>
            <commenter_username>sptaszkiewicz</commenter_username>
            <when>2016-05-17 10:49:23 -0400</when>
            <comment_text>(In reply to Dani Megert from comment #4)
&gt; We haven't changed anything in that area. Can you reproduce in a new
&gt; workspace and provide steps?

No, but I have another installation and was able to get a stack trace:

Daemon Thread [org.eclipse.jdt.internal.ui.text.JavaReconciler] (Suspended (breakpoint at line 74 in AutoBuildJob))	
	owns: AutoBuildJob  (id=1351)	
	owns: Object  (id=1204)	
	AutoBuildJob.build(boolean) line: 74	
	BuildManager.endTopLevel(boolean) line: 523	
	Workspace.endOperation(ISchedulingRule, boolean, IProgressMonitor) line: 1484	
	Workspace.run(ICoreRunnable, ISchedulingRule, int, IProgressMonitor) line: 2253	
	Workspace.run(IWorkspaceRunnable, ISchedulingRule, int, IProgressMonitor) line: 2267	
	SetContainerOperation(JavaModelOperation).runOperation(IProgressMonitor) line: 795	
	JavaModelManager.getClasspathContainer(IPath, IJavaProject) line: 1973	
	JavaCore.getClasspathContainer(IPath, IJavaProject) line: 3424	
	JavaProject.resolveClasspath(IClasspathEntry[], IClasspathEntry[], boolean, boolean) line: 2693	
	JavaProject.resolveClasspath(JavaModelManager$PerProjectInfo, boolean, boolean) line: 2857	
	JavaProject.getResolvedClasspath() line: 1962	
	JavaProject.buildStructure(OpenableElementInfo, IProgressMonitor, Map, IResource) line: 464	
	JavaProject(Openable).generateInfos(Object, HashMap, IProgressMonitor) line: 259	
	JavaProject(JavaElement).openWhenClosed(Object, boolean, IProgressMonitor) line: 579	
	JavaProject(JavaElement).getElementInfo(IProgressMonitor) line: 316	
	JavaProject(JavaElement).getElementInfo() line: 302	
	JavaProject.getProjectCache() line: 1924	
	JavaProjectElementInfo.newNameLookup(JavaProject, ICompilationUnit[]) line: 310	
	JavaProject.newNameLookup(ICompilationUnit[]) line: 2329	
	CancelableNameEnvironment(SearchableEnvironment).&lt;init&gt;(JavaProject, ICompilationUnit[]) line: 61	
	CancelableNameEnvironment(SearchableEnvironment).&lt;init&gt;(JavaProject, WorkingCopyOwner) line: 68	
	CancelableNameEnvironment.&lt;init&gt;(JavaProject, WorkingCopyOwner, IProgressMonitor) line: 26	
	CompilationUnitProblemFinder.process(CompilationUnit, SourceElementParser, WorkingCopyOwner, HashMap, boolean, int, IProgressMonitor) line: 178	
	CompilationUnitProblemFinder.process(CompilationUnit, WorkingCopyOwner, HashMap, boolean, int, IProgressMonitor) line: 271	
	ReconcileWorkingCopyOperation.makeConsistent(CompilationUnit) line: 191	
	ReconcileWorkingCopyOperation.executeOperation() line: 90	
	ReconcileWorkingCopyOperation(JavaModelOperation).run(IProgressMonitor) line: 724	
	ReconcileWorkingCopyOperation(JavaModelOperation).runOperation(IProgressMonitor) line: 790	
	CompilationUnit.reconcile(int, int, WorkingCopyOwner, IProgressMonitor) line: 1250	
	JavaReconcilingStrategy.reconcile(ICompilationUnit, boolean) line: 128	
	JavaReconcilingStrategy.access$0(JavaReconcilingStrategy, ICompilationUnit, boolean) line: 110	
	JavaReconcilingStrategy$1.run() line: 90	
	SafeRunner.run(ISafeRunnable) line: 42	
	JavaReconcilingStrategy.reconcile(boolean) line: 87	
	JavaReconcilingStrategy.initialReconcile() line: 185	
	JavaCompositeReconcilingStrategy(CompositeReconcilingStrategy).initialReconcile() line: 119	
	JavaCompositeReconcilingStrategy.initialReconcile() line: 136	
	JavaReconciler(MonoReconciler).initialProcess() line: 95	
	JavaReconciler.initialProcess() line: 420	
	AbstractReconciler$BackgroundThread.run() line: 174</comment_text>
        </comment>
        <comment>
            <comment_id>2707953</comment_id>
            <comment_count>6</comment_count>
            <who>Szymon Ptaszkiewicz</who>
            <commenter_username>sptaszkiewicz</commenter_username>
            <when>2016-05-17 10:53:17 -0400</when>
            <comment_text>Created attachment 261801
Stack

(In reply to Szymon Ptaszkiewicz from comment #5)

Formatting of stacks in bugzilla does not look good so I'm attaching the stack as as a text file (with fully qualified names).</comment_text>
        </comment>
        <comment>
            <comment_id>2707963</comment_id>
            <comment_count>7</comment_count>
            <who>Szymon Ptaszkiewicz</who>
            <commenter_username>sptaszkiewicz</commenter_username>
            <when>2016-05-17 11:08:11 -0400</when>
            <comment_text>This seems to be a timing problem because when the breakpoint is enabled, I get only one occurrence of the problem. If I disable the breakpoint, I get many occurrences as shown in attachments with traces.</comment_text>
        </comment>
        <comment>
            <comment_id>2710748</comment_id>
            <comment_count>8</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-05-23 05:36:29 -0400</when>
            <comment_text>Noopur, please check whether you can reproduce, and if so, whether this is a regression.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495292</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-06-02 09:33:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[package explorer] Show required projects in Package Explorer</short_desc>
        <thetext>4.6 RC4.

We need to show required projects in the 'Package Explorer'. The element in the Package Explorer must not be a real IProject, but behave similar to the projects in the 'Plug-in Dependencies' container. To avoid confusion with nested projects we will have to use a new icon that looks like a project reference.

In the first iteration those required projects will be directly under the Java project. Later, we might offer a new container (like 'Referenced Libraries') or include them in the 'Referenced Libraries' container.</thetext>
        <comment>
            <comment_id>2716215</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-06-02 09:36:59 -0400</when>
            <comment_text>Take a look at org.eclipse.jdt.internal.ui.packageview.ClassPathContainer.RequiredProjectWrapper</comment_text>
        </comment>
        <comment>
            <comment_id>2716673</comment_id>
            <comment_count>2</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-06-03 05:49:00 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/74502</comment_text>
        </comment>
        <comment>
            <comment_id>2716677</comment_id>
            <comment_count>3</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-06-03 05:54:20 -0400</when>
            <comment_text>Patch set 1 implements the first iteration.</comment_text>
        </comment>
        <comment>
            <comment_id>2717501</comment_id>
            <comment_count>4</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-06-06 09:07:02 -0400</when>
            <comment_text>Looks good, but the referenced projects should be shown in classpath order, like the other package fragment roots. See org.eclipse.jdt.ui.JavaElementComparator#needsClasspathComparision(..) and #getClassPathIndex(..).</comment_text>
        </comment>
        <comment>
            <comment_id>2717614</comment_id>
            <comment_count>5</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-06-06 12:09:22 -0400</when>
            <comment_text>&gt; include them in the 'Referenced Libraries' container.

I don't think we should show required projects without a simple way to deal with projects that have many dependencies. The 'Referenced Libraries' container solves that problem, and by including the referenced projects there, we can even keep the build path order better visible in the Package Explorer.

Note: Dani and I discussed whether we should put this into the BETA_JAVA9 branch to make it easier to see missing project dependencies to compile module references. However, it looks like we will eventually support module dependencies without requiring explicit project references, so rushing this in is probably not necessary.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501069</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-09-08 08:28:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>IOpenable.isOpen() returns false for an open JavaProject</short_desc>
        <thetext>Reproducible in Eclipse 4.6.

Steps to reproduce:
1. Add a breakpoint in the method: org.eclipse.jdt.internal.ui.actions.GenerateJavadocAction.selectionChanged(IAction action, ISelection selection).
2. Launch a runtime workspace having 2-3 Java projects.
3. In the runtime, click on a Java project in Package explorer to select it.
4. The breakpoint is hit and you can see the IJavaProject is not open in the selection.

You can see the effect by clicking Project &gt; Generate Javadoc... which opens the dialog with no pre-selected project. If you close this dialog and reopen, you can see the selected project from Package explorer is now checked by default in the dialog. This happens as opening the dialog in the first attempt somehow opens the projects.

I am facing this issue while working on bug 482582 to add the option to create module-info.java in "Configure" context menu of a Java project. For the selected project, org.eclipse.jdt.core.IOpenable.isOpen() returns false for the first time in a newly launched workspace. Once I expand that project or if it is accessed in some other way (e.g. check its properties via Java Element View), it gets opened and the method returns true.</thetext>
        <comment>
            <comment_id>2748528</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-08 10:51:14 -0400</when>
            <comment_text>Didn't you mean to ask javaProject.getProject().isOpen() instead of javaProject.isOpen()?

The former asks the resource, the latter the IJavaElement (where open just means: has been accessed).</comment_text>
        </comment>
        <comment>
            <comment_id>2748654</comment_id>
            <comment_count>2</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-09-08 14:41:05 -0400</when>
            <comment_text>Thanks Stephan, that's spot on. Noopur told me about this problem in a call, and without looking at the code, I also missed the subtle difference.

I quickly checked existing references to IOpeanble#isOpen(), and many of them are actually wrong (should use IProject#isOpen()). I've fixed the Javadoc with http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=692bacf3327755b55530860e93e2d2b4cc0fe345

Keeping this bug open to fix existing callers and other references (CompilationParticipant#isActive(IJavaProject), I'm looking at you!).</comment_text>
        </comment>
        <comment>
            <comment_id>2749408</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-12 02:26:38 -0400</when>
            <comment_text>The majority of the changes are going to be on the UI side. So, assigning to Noopur. I will fix the reference Markus mentioned.</comment_text>
        </comment>
        <comment>
            <comment_id>2749432</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-12 03:43:12 -0400</when>
            <comment_text>I just posted a Gerrit patch here: https://git.eclipse.org/r/#/c/80886/

For some reason it didn't automatically appear here. 

Anyway, the patch fixes the reference in Javadoc and one other place (AptConfig). The other suspect is in DeltaProcessor#deleting(IProject), but I can't be certain about the intention from the history or the code, so leaving it as it is.</comment_text>
        </comment>
        <comment>
            <comment_id>2749433</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-12 03:45:59 -0400</when>
            <comment_text>I also tried to make the following code as clickable reference, but whatever I tried didn't work.

javaProject.getProject().isOpen();

The completion works, but either compiler reports a warning and/or the Javadoc links are not clickable. Anyone knows how to make this work?</comment_text>
        </comment>
        <comment>
            <comment_id>2752337</comment_id>
            <comment_count>6</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-09-19 00:26:52 -0400</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/80886 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=3b161059bdaa1ef0a8e5cf5b92188506d0b9dd48</comment_text>
        </comment>
    </bug>
    <bug>
        <id>505623</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-10-10 05:33:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[content assist] Add tests regarding proposal sorting</short_desc>
        <thetext>We recently had several regressions regarding the sorting of proposal, see e.g. bug 488441 and bug 501519.

We need to add a few tests that verify the most common cases regarding sorting of proposal.</thetext>
    </bug>
    <bug>
        <id>507158</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-11-07 08:49:00 -0500</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[1.9][content assist] Import statement should not be added in module-info.java</short_desc>
        <thetext>module test {
	uses Cal|;
}

Press Ctrl+space in place of '|' in the above example and select a type to insert. The import statement is also added in the module-info.java file which is incorrect.</thetext>
        <comment>
            <comment_id>2773561</comment_id>
            <comment_count>1</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-11-07 08:54:28 -0500</when>
            <comment_text>(In reply to Noopur Gupta from comment #0)
&gt; module test {
&gt; 	uses Cal|;
&gt; }
&gt; 
&gt; Press Ctrl+space in place of '|' in the above example and select a type to
&gt; insert. The import statement is also added in the module-info.java file
&gt; which is incorrect.

[Note: The code is yet to be in -This is based on a wip patch shared with Noopur - bug486988 will have the jdt.core patch soon]

One solution suggested by Noopur is to check whether the cu is a module-info.java file by checking the name. An alternate solution is to pass a flag from JDT core at completion time using CompletionFlags  as follows:
	public static final int InsideModuleInfo = 0x0002;
	/**
	 * Not instantiable.
	 */
	/**
	 * Returns whether the given integer includes the {@link #InsideModuleInfo} flag.
	 *
	 * @param flags the flags
	 * @return &lt;code&gt;true&lt;/code&gt; if the {@link #StaticImport} flag is included
	 * @since 3.13 BETA_JAVA9
	 */
	public static boolean isInsideModuleInfo(int flags) {
		return (flags &amp; InsideModuleInfo) != 0;
	}
}</comment_text>
        </comment>
        <comment>
            <comment_id>2773564</comment_id>
            <comment_count>2</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-11-07 08:59:27 -0500</when>
            <comment_text>Created attachment 265224
jdt.core.wip patch to see the issue</comment_text>
        </comment>
        <comment>
            <comment_id>2773569</comment_id>
            <comment_count>3</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-11-07 09:05:45 -0500</when>
            <comment_text>Created attachment 265225
Patch - jdt.ui

(In reply to Manoj Palat from comment #1)
&gt; (In reply to Noopur Gupta from comment #0)
&gt; &gt; module test {
&gt; &gt; 	uses Cal|;
&gt; &gt; }
&gt; &gt; 
&gt; &gt; Press Ctrl+space in place of '|' in the above example and select a type to
&gt; &gt; insert. The import statement is also added in the module-info.java file
&gt; &gt; which is incorrect.
&gt; 
&gt; [Note: The code is yet to be in -This is based on a wip patch shared with
&gt; Noopur - bug486988 will have the jdt.core patch soon]

Since the ';' is added at the invocation location, this issue can be seen without the WIP jdt.core patch also.

&gt; One solution suggested by Noopur is to check whether the cu is a
&gt; module-info.java file by checking the name. 

Attached patch uses IJavaElement.getElementName() to check if the CU is module-info.java. This is done in a similar way for package-info.java also.

Dani/Markus, please let me know if name-based checking is fine.</comment_text>
        </comment>
        <comment>
            <comment_id>2773597</comment_id>
            <comment_count>4</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-07 09:42:22 -0500</when>
            <comment_text>(In reply to Noopur Gupta from comment #3)
&gt; Dani/Markus, please let me know if name-based checking is fine.

I assume we'll need such a check at other places too at some point. I would add a helper method similar to CompilationUnitDeclaration.isPackageInfo() (but of course not in that class).</comment_text>
        </comment>
        <comment>
            <comment_id>2773991</comment_id>
            <comment_count>5</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-11-08 03:46:05 -0500</when>
            <comment_text>Manoj, please provide an API based on comment #4. I will update the jdt.ui patch after that.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508228</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-11-26 06:57:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Transparence for the relation between @SuppressWarnings tokens and compiler options</short_desc>
        <thetext>Following bug 506888 I feel that users don't have a fair chance to fully understand which compiler options correlate to which @SuppressWarnings tokens.

Possible directions for improvement:

(0) Let the quick fix proposed in bug 506888 cover *all* relevant ignored options, either by offering multiple quick fixes (one per option) or by supporting multi-highlighting in the preferences page (not sure if the latter is technically feasible).

(1) Create detailed cross-references between the following help pages:
- reference/preferences/java/compiler/ref-preferences-errors-warnings.htm
- tasks/task-suppress_warnings.htm
Currently neither page refers to the other

(2) Add an optional column to the Errors/Warnings properties page: "suppressable by warning token" (or "controlled by ...").

(3) Add help references from Errors/Warnings page to task-suppress_warnings.htm (the other page is already linked)

Those options are of course not exclusive, maybe we should actually do all of the above.

Since maintaining all this information in help pages is becoming cumbersome, we may even want to think of some automated validation ...


What do others think?</thetext>
    </bug>
    <bug>
        <id>507372</id>
        <developer>Andrew Clement</developer>
        <developer_username>aclement</developer_username>
        <dup_id/>
        <creation_time>2016-11-10 14:40:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Error recovery in producing class file for broken annotation can produce broken class file</short_desc>
        <thetext>Created attachment 265306
testcode

Reported against AspectJ but I think it is actually JDT.

I've attached a zip of code I'm using for AspectJ - haven't totally tested it with JDT to confirm though... That code has an error in the package-info.java type annotation, it refers to a type that isn't there.

  @FetchProfile(name = FetchProfileName.LOCATION, fetchOverrides = {
association = Location.PROPERTY_SYSTEMSTATE),
       				@FetchProfile.FetchOverride(entity = Location.class, association = Location.PROPERTY_KEYVAULT)
})
package org;

The Location class does not exist. Now there is some 'recovery code' in JDT that tries to produce a valid classfile anyway, but it makes a mistake, producing a broken annotation attribute (well, one that violates the spec). See JDT ClassFile.generateAnnotation():

loop: for (int i = 0; i &lt; memberValuePairsLength; i++) {
....
    generateElementValue(memberValuePair.value, methodBinding.returnType, memberValuePairOffset);
    if (this.contentsOffset == memberValuePairOffset) {
        // ignore all annotation values
        this.contents[this.contentsOffset++] = 0;
        this.contents[this.contentsOffset++] = 0;
        break loop;
    }
....
}
this.contents[memberValuePairsLengthPosition++] = (byte) (memberValuePairsCount &gt;&gt; 8);
this.contents[memberValuePairsLengthPosition++] = (byte) memberValuePairsCount;

Notice this recovery block in the middle (marked 'ignore all annotation values'). If the problem is with a second annotation value then when that recovery block is entered, although the contents array data is correctly set to indicate there should be no annotation values, the memberValuePairsCount is not reset to 0. It then breaks from the loop and immediately overwrites the same section of data with 1.  This leaves the class file broken:

//RuntimeInvisibleAnnotations: length = 0x15
// 00 01 00 08 00 02 00 09 73 00 0A 00 0B 5B 00 01
// 40 00 0C 00 01

The trailing 00 01 there indicates there should be more data, but there isn't. A simple fix is to set memberValuePairsCount to 0 in the if block before the break.</thetext>
        <comment>
            <comment_id>2775267</comment_id>
            <comment_count>1</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-11-10 16:11:55 -0500</when>
            <comment_text>In fact there is more than one problem here. In your case, we would generate an invalid annotation for entity = Location.class. So we should not even try to generate the second one as the first one is a compile error.
So I fixed both issues. With the current patch, all annotation tests are green. Working on adding a regression test (need to force -proceedOnError) which is not a default option in current tests.</comment_text>
        </comment>
        <comment>
            <comment_id>2775284</comment_id>
            <comment_count>2</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-11-10 16:34:53 -0500</when>
            <comment_text>The goal was to preserve as much as possible from annotations till the first error. So if only the second one is wrong, we should still generate the first annotation value pair.</comment_text>
        </comment>
        <comment>
            <comment_id>2775285</comment_id>
            <comment_count>3</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-11-10 16:36:06 -0500</when>
            <comment_text>Andrew, could you please sign up the ECA so I can reuse your example? Otherwise I need to write one from scratch.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508777</id>
        <developer>Olivier Thomann</developer>
        <developer_username>Olivier_Thomann</developer_username>
        <dup_id/>
        <creation_time>2016-12-06 12:13:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Move some corext packages/types to org.eclipse.jdt.core.manipulation bundle</short_desc>
        <thetext>In order to accomodate the new jdtls project, we would need some types in the coreext packages to be moved to a non-UI bundle.</thetext>
        <comment>
            <comment_id>2783454</comment_id>
            <comment_count>1</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-06 12:31:34 -0500</when>
            <comment_text>I will provide a gerrit review for a first pass soon.</comment_text>
        </comment>
        <comment>
            <comment_id>2783573</comment_id>
            <comment_count>2</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-06 16:13:58 -0500</when>
            <comment_text>Trying to fix the push to gerrit. It is failing right now.</comment_text>
        </comment>
        <comment>
            <comment_id>2783584</comment_id>
            <comment_count>3</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-06 16:46:18 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/86544</comment_text>
        </comment>
        <comment>
            <comment_id>2783586</comment_id>
            <comment_count>4</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-06 16:47:48 -0500</when>
            <comment_text>Hopefully it worked as expected. I could not get it to work inside Eclipse. I had to use the git bash and the git command line.</comment_text>
        </comment>
        <comment>
            <comment_id>2784093</comment_id>
            <comment_count>5</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-12-07 15:17:57 -0500</when>
            <comment_text>I don't think you followed this part from what we discussed:

&gt; When you move classes from jdt.ui to manipulation, try to maintain the
&gt; declaring package if it's already internal and doesn't contain ".ui". That
&gt; would allow existing products that illegally refer to internal jdt.ui \
&gt; classes to survive by adding a dependency on manipulation.

The split package(s) org.eclipse.jdt.internal.corext* should avoid any code changes in most clients of the moved classes.</comment_text>
        </comment>
        <comment>
            <comment_id>2784094</comment_id>
            <comment_count>6</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-07 15:26:50 -0500</when>
            <comment_text>OK, I'll fix that. I wanted to avoid having the exact same qualified names for two different types as not all methods from some types can be moved as they refer to UI types.</comment_text>
        </comment>
        <comment>
            <comment_id>2784097</comment_id>
            <comment_count>7</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-07 15:33:18 -0500</when>
            <comment_text>I don't see how you can have two types with the same qualified names being used in the same code. This is why I renamed the move package to be able to do the distinction between the two types.</comment_text>
        </comment>
        <comment>
            <comment_id>2784098</comment_id>
            <comment_count>8</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-07 15:36:48 -0500</when>
            <comment_text>For example, org.eclipse.jdt.internal.corext.dom.ASTNodes contains references to ui types even if its package name doesn't contain .ui. So I left there the "UI" part of the code and move the non-UI part. How did you want me to proceed without doing that ?</comment_text>
        </comment>
        <comment>
            <comment_id>2784109</comment_id>
            <comment_count>9</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-07 16:02:54 -0500</when>
            <comment_text>I moved back to the same package names all types that could be completely moved (no UI part left behind). Is this more what you wanted?</comment_text>
        </comment>
        <comment>
            <comment_id>2784112</comment_id>
            <comment_count>10</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-07 16:13:46 -0500</when>
            <comment_text>I amended the previous commit. Do you prefer that I redo it from scratch ?</comment_text>
        </comment>
        <comment>
            <comment_id>2785503</comment_id>
            <comment_count>11</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-12 09:59:07 -0500</when>
            <comment_text>Markus, is the last gerrit change good enough to be delivered? Thanks.</comment_text>
        </comment>
        <comment>
            <comment_id>2785589</comment_id>
            <comment_count>12</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-12 13:48:57 -0500</when>
            <comment_text>Markus, are you waiting for something else from me after the last commit?</comment_text>
        </comment>
        <comment>
            <comment_id>2785884</comment_id>
            <comment_count>13</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-13 09:47:32 -0500</when>
            <comment_text>Markus, it looks like the gerrit review can no longer be merged directly now. Probably due to some recent changes in the same area. How do you want to proceed? We need an I-build with these changes in to be able to update our target platform.</comment_text>
        </comment>
        <comment>
            <comment_id>2785943</comment_id>
            <comment_count>14</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-13 11:50:14 -0500</when>
            <comment_text>I provided a new review with some changes that reduces the amount of changes. Some were due to the usage of OrganizeImports to get rid of some renamed types.

Hopefully this is what you expected to be able to deliver that change.</comment_text>
        </comment>
        <comment>
            <comment_id>2786275</comment_id>
            <comment_count>15</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-14 09:59:11 -0500</when>
            <comment_text>If Markus is too busy to review this change, could it be done by somebody else?</comment_text>
        </comment>
        <comment>
            <comment_id>2786316</comment_id>
            <comment_count>16</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-14 11:14:18 -0500</when>
            <comment_text>Markus, is anything else required on our side to get this delivered? Thanks.</comment_text>
        </comment>
        <comment>
            <comment_id>2786705</comment_id>
            <comment_count>17</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-15 10:27:50 -0500</when>
            <comment_text>Can we get an ETA for this one? I have done what has been asked. I also asked questions on what was expected due to the types with the same qualified name in both bundles if I keep the same package names (see comment 7 and comment 8). I don't know what else I can do to get this gerrit review delivered. As long as this is not done, we cannot update our target platform for lsp work. This is a blocker for us.</comment_text>
        </comment>
        <comment>
            <comment_id>2786869</comment_id>
            <comment_count>18</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-12-15 18:29:50 -0500</when>
            <comment_text>- All files need a proper copyright header, e.g.:
 - ASTSharedValues, which should be called IASTSharedValues. ASTProvider should implement IASTSharedValues.
 - SignatureUtil, which got 2 unused methods. Either remove those methods, or let LazyJavaTypeCompletionProposal use them (I guess that's the source).

- You added various @SuppressWarnings("unchecked"), e.g. in ScopeAnalyzer. Please enable Errors/Warnings &gt; Generic types &gt; Ignore unavoidable... on the project and then remove the unnecessary annotations.

- /org.eclipse.jdt.core.manipulation/core extension/org/eclipse/jdt/internal/core/manipulation/util/Messages.java looks unused.

- The x-friends:="org.jboss.tools..." should not be added at this time. We can eventually mark something like org.eclipse.jls... as a friend.

- The split packages org.eclipse.jdt.internal.corext.* in j.c.manip need treatment similar to bug 140033.


** The general goal is to avoid as much impact on existing clients as possible. Impact includes breaking changes as well as confusion due to duplicate type names.

- For split classes that move some methods to a new class in j.c.manip, the jdt.ui type should extend the j.c.manip type, so that existing users of the jdt.ui type are not affected by the split (e.g. Strings). Existing users would get a "The static method ... from the type ... should be accessed directly" problem, but they still work. In JDT bundles, we resolve these problems.

- For JavaModelUtil, I'd say the solution with the least impact is to move org.eclipse.jdt.internal.corext.util.JavaModelUtil to j.c.manip without changing the package name, and then find a new home for the remaining applyEdit() method. E.g. move it to JavaElementUtil.

Same for ASTNodes. Move the getInsertionIndex() method to BodyDeclarationRewrite.

- BasicElementLabels has been duplicated. Extend the j.c.manip class, remove the duplicated methods. The getWorkingSetLabel() is unfortunate, and I think it's even wrong, but we'll keep it for now.

- JDTUIHelperClasses used to establish a system of 2-way links that lead developers to other helper classes with just two clicks. In cases where
 * @see JDTUIHelperClasses
would be a compile problem, put a comment like this after the Javadoc:
// @see JDTUIHelperClasses


** This is something I need to think about a bit more:

- MANIFEST.MF: Require-Bundle: org.eclipse.jdt.launching
This adds a dependency on the whole debug stack (platform and JDT). Not sure we want that, just to get 3 methods in JavaModelUtil.</comment_text>
        </comment>
        <comment>
            <comment_id>2787144</comment_id>
            <comment_count>19</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-16 13:24:23 -0500</when>
            <comment_text>Markus, I believe all concerns have been addressed in the latest patches in the gerrit review.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491812</id>
        <developer>Peter Jurkovic</developer>
        <developer_username>cpk</developer_username>
        <dup_id/>
        <creation_time>2016-04-15 10:55:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>!MESSAGE Unhandled event loop exception</short_desc>
        <thetext>Created attachment 260987
eclipse.ini

It is quite critical problem, it happens unexpectedly, unsaved changes are being lost.

OS:
Linux Min 17.3 64b
Cinnamon version: 2.8.8
Kernel: 3.16.0-38 generic
(Ubuntu 4.8.4-2ubuntu1~14.04.1) 4.8.4


System info:
Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
CPU(s):                4
On-line CPU(s) list:   0-3
Thread(s) per core:    2
Core(s) per socket:    2
Socket(s):             1
NUMA node(s):          1
Vendor ID:             GenuineIntel
CPU family:            6
Model:                 61
Stepping:              4
CPU MHz:               2394.046
BogoMIPS:              4389.75
Virtualisation:        VT-x
L1d cache:             32K
L1i cache:             32K
L2 cache:              256K
L3 cache:              3072K
NUMA node0 CPU(s):     0-3


Stacktrace:

!ENTRY org.eclipse.ui 4 0 2016-04-15 15:27:01.737
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable (java.lang.IllegalArgumentException: Index out of bounds)
	at org.eclipse.swt.SWT.error(SWT.java:4491)
	at org.eclipse.swt.SWT.error(SWT.java:4406)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:138)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3794)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3433)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:694)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:606)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1515)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1488)
Caused by: java.lang.IllegalArgumentException: Index out of bounds
	at org.eclipse.swt.SWT.error(SWT.java:4472)
	at org.eclipse.swt.SWT.error(SWT.java:4406)
	at org.eclipse.swt.SWT.error(SWT.java:4377)
	at org.eclipse.swt.custom.StyledText.getOffsetAtLine(StyledText.java:4403)
	at org.eclipse.jface.text.JFaceTextUtil.getPartialTopIndex(JFaceTextUtil.java:103)
	at org.eclipse.jface.text.JFaceTextUtil.getPartialTopIndex(JFaceTextUtil.java:151)
	at org.eclipse.jface.text.source.AnnotationRulerColumn.getInclusiveTopIndexStartOffset(AnnotationRulerColumn.java:556)
	at org.eclipse.jface.text.source.AnnotationRulerColumn.doPaint1(AnnotationRulerColumn.java:707)
	at org.eclipse.jface.text.source.AnnotationRulerColumn.doubleBufferPaint(AnnotationRulerColumn.java:532)
	at org.eclipse.jface.text.source.AnnotationRulerColumn.redraw(AnnotationRulerColumn.java:815)
	at org.eclipse.jface.text.source.AnnotationRulerColumn$6.run(AnnotationRulerColumn.java:798)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	... 24 more</thetext>
    </bug>
    <bug>
        <id>490409</id>
        <developer>Gerry Lau</developer>
        <developer_username>gerrylck</developer_username>
        <dup_id/>
        <creation_time>2016-03-24 20:27:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>ToolTip white on white</short_desc>
        <thetext/>
        <comment>
            <comment_id>2686963</comment_id>
            <comment_count>1</comment_count>
            <who>Gerry Lau</who>
            <commenter_username>gerrylck</commenter_username>
            <when>2016-03-24 20:29:10 -0400</when>
            <comment_text>Created attachment 260565
ToolTip white on white</comment_text>
        </comment>
        <comment>
            <comment_id>2686964</comment_id>
            <comment_count>2</comment_count>
            <who>Gerry Lau</who>
            <commenter_username>gerrylck</commenter_username>
            <when>2016-03-24 20:29:57 -0400</when>
            <comment_text>I use Eclipse Mars dark theme and have been trying to get colors right to my best effort.

When you mouseover/hover an item which has a text too long and got partially hidden by window, a tooltip will show up, as shown in the attached image.

As you can see, either the tooltip foreground color needs to change to black or background to dark color.

It does not look like the Window system ToolTip and I could not find the corresponding Eclipse setting covers that.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506021</id>
        <developer>Till Brychcy</developer>
        <developer_username>register.eclipse</developer_username>
        <dup_id/>
        <creation_time>2016-10-15 17:34:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][compiler] inference problem with wildcard bounds</short_desc>
        <thetext>DESCRIPTION:
The following code doesn’t compile, but should:

package test;

interface Result {}

interface Property&lt;V&gt; {}

interface GraphTraversal&lt;E&gt; {}

public class __ {
	public static &lt;E&gt; GraphTraversal&lt;? extends Property&lt;E&gt;&gt; properties2() {
		return null;
	}
	public static GraphTraversal&lt;? extends Property&lt;Result&gt;&gt; properties() {
		return properties2();
	}
}

----------
1. ERROR in test\__.java (at line 14)
	return properties2();
	       ^^^^^^^^^^^^^
Type mismatch: cannot convert from GraphTraversal&lt;capture#2-of ? extends Property&lt;Object&gt;&gt; to GraphTraversal&lt;? extends Property&lt;Result&gt;&gt;
----------

Javac compiles it. Eclipse compiles it, if GraphTraversal is changed to 

interface GraphTraversal&lt;E extends Object&gt; {}

ANALYSIS:
The rule from JLS8, 18.3.2 
* If Bi is Object, then αi &lt;: R implies the constraint formula ‹T &lt;: R›
should be applied, but isn’t, because no bound is set (pi.firstbound==null)
But according to 4.3.2 „The class Object is a superclass (§8.1.4) of all other classes.“, so even if no bound is explicitly given, Bi is Object.

PATCH:
Treats pi.firstbound==null like it was Object.</thetext>
        <comment>
            <comment_id>2766963</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-15 17:37:43 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/83307</comment_text>
        </comment>
        <comment>
            <comment_id>2766964</comment_id>
            <comment_count>2</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-10-15 17:39:59 -0400</when>
            <comment_text>@Stephan, do you agree with this?</comment_text>
        </comment>
        <comment>
            <comment_id>2766965</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-15 17:50:33 -0400</when>
            <comment_text>Please kindly hold on. First, there is prior art regarding the question whether or not explicit "extends Object" makes a difference or not. This needs to be dug out.

Secondly, I'm in the process of significant changes via bug 506016 and friends. Any concurrent changes to type inference potentially complicate that effort.</comment_text>
        </comment>
        <comment>
            <comment_id>2766968</comment_id>
            <comment_count>4</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-10-15 18:27:47 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #3)
&gt; Please kindly hold on. First, there is prior art regarding the question
&gt; whether or not explicit "extends Object" makes a difference or not. This
&gt; needs to be dug out.
&gt; 
&gt; Secondly, I'm in the process of significant changes via bug 506016 and
&gt; friends. Any concurrent changes to type inference potentially complicate
&gt; that effort.

Sure, can wait (same for bug 506022).</comment_text>
        </comment>
        <comment>
            <comment_id>2780335</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-26 18:55:54 -0500</when>
            <comment_text>Found the previous (inconclusive) discussion in this area: bug 429090 comment 4 ff. In that case we were discussing "? extends Object", though.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506022</id>
        <developer>Till Brychcy</developer>
        <developer_username>register.eclipse</developer_username>
        <dup_id/>
        <creation_time>2016-10-15 18:10:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][compiler] Wildcard bounds are sometimes not propagated</short_desc>
        <thetext>DESCRIPTION
With the patches for bug 502871 and bug 506021 applied, i checked if tinkerpop can be compiled with eclipse now (excluding the modules with groovy etc.).
I have found one other remaining kind of problem (another example is in the test cases):
abstract class OutputFormat {
	public abstract int getOutputCommitter();
}

public abstract class Test2 {
	public static &lt;T&gt; T newInstance(Class&lt;T&gt; theClass) {
		return null;
	}

	abstract &lt;U&gt; Class&lt;? extends U&gt; getClass(Class&lt;U&gt; xface);

	int f() {
		return newInstance(getClass(OutputFormat.class)).getOutputCommitter();
	}
}

Gives the error:
----------
1. ERROR in test2\Test2.java (at line 15)
	return newInstance(getClass(OutputFormat.class)).getOutputCommitter();
	                                                 ^^^^^^^^^^^^^^^^^^
The method getOutputCommitter() is undefined for the type Object
----------


ANALYSIS:
Whatever is returned by newInstance must be an instance of a type that matches „? extends OutputFormat“ so it must be an instance of OutputFormat.
As I understand it, it is not possible to propagate this type information according to the JLS, because none of the rules in JLS 18.3.2 matches here.

I think that in JLS 18.3.2, a rule is missing in the section for  „If Ai is a wildcard of the form ? extends T:“
 	•	If αi = beta (for some other inference variable beta) implies the constraint formula ‹beta &lt;: T›

I don’t have an example where this might be needed, but for symmetry reasons there should probably also be a corresponding rule for the section „If Ai is a wildcard of the form ? super T:“ 	•	If αi = beta (for some other inference variable beta) implies the constraint formula ‹beta &gt;: T›

Note: Javac compiles this, but i haven’t found a bug report that sounds like this in https://bugs.openjdk.java.net

PATCH:
Implements above proposed extra rules.</thetext>
        <comment>
            <comment_id>2766967</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-15 18:16:48 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/83308</comment_text>
        </comment>
        <comment>
            <comment_id>2768421</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-19 16:41:53 -0400</when>
            <comment_text>We accept this:

            OutputFormat of = newInstance(getClass(OutputFormat.class));

and even this:

            OutputFormat of = newInstance(getClass(Number.class));

(both are accepted by javac, too).

Wildcards are good for some surprises, huh?

Oh, javac 9 rejects that latter, bogus example!

We should adjust to that fix (at -9).</comment_text>
        </comment>
        <comment>
            <comment_id>2768422</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-19 16:57:01 -0400</when>
            <comment_text>More to the point: let's first scrutinize more if there could be a bug in our implementation (regarding 18.3.2 or elsewhere). If both of us are sure enough that ecj does not hit a bug here, then I will consult with Oracle, if indeed s.t. is missing from JLS.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506108</id>
        <developer>Till Brychcy</developer>
        <developer_username>register.eclipse</developer_username>
        <dup_id/>
        <creation_time>2016-10-17 16:18:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[quick fix] Null annotation correction quick fix doesn’t work if parameter name is different in overridden method</short_desc>
        <thetext>DESCRIPTION:
With null annotations enabled, create the two classes:

package test1;

public class E {
	void foo(Exception e1) {
	}
}

// - - - - - 

package test1;

import org.eclipse.jdt.annotation.NonNull;

public class E2 extends E {
	void foo(@NonNull Exception e2) { // Illegal redefinition of parameter e2, inherited method from E does not constrain this parameter
		e2.printStackTrace();
	}
}

No quick fix is offered for the problem „Illegal redefinition of parameter e2, inherited method from E does not constrain this parameter“
(not even „suppress warnings“)

The log contains the message:
java.lang.RuntimeException: Argument e2 not found in method foo
	at org.eclipse.jdt.internal.corext.fix.NullAnnotationsRewriteOperations$ParameterAnnotationRewriteOperation.&lt;init&gt;(NullAnnotationsRewriteOperations.java:202)
	at org.eclipse.jdt.internal.corext.fix.NullAnnotationsRewriteOperations.createChangeOverriddenParameterOperation(NullAnnotationsRewriteOperations.java:530)
	at org.eclipse.jdt.internal.corext.fix.NullAnnotationsRewriteOperations.createAddAnnotationToOverriddenOperation(NullAnnotationsRewriteOperations.java:502)
	at org.eclipse.jdt.internal.corext.fix.NullAnnotationsRewriteOperations.createAddAnnotationOperation(NullAnnotationsRewriteOperations.java:318)
	at org.eclipse.jdt.internal.corext.fix.NullAnnotationsFix.createNullAnnotationInSignatureFix(NullAnnotationsFix.java:125)
	at org.eclipse.jdt.internal.ui.text.correction.NullAnnotationsCorrectionProcessor.addNullAnnotationInSignatureProposal(NullAnnotationsCorrectionProcessor.java:67)
	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.process(QuickFixProcessor.java:732)
[…]

ANALYSIS:
It is attempted to use the name of the parameter in the overriding method to find the parameter in the overridden method, but they need not be the same.

PATCH:
Determine name of overridden parameter by position.</thetext>
        <comment>
            <comment_id>2767473</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-17 16:23:55 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/83389</comment_text>
        </comment>
        <comment>
            <comment_id>2774759</comment_id>
            <comment_count>2</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-11-09 14:45:15 -0500</when>
            <comment_text>@Stephan, could you please merge this on occasion?</comment_text>
        </comment>
        <comment>
            <comment_id>2785166</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-10 17:45:54 -0500</when>
            <comment_text>The change looks good.

Still, in patch set #4 I added an experiment in avoiding to use the parameter name as an indicator in the first place. Note that we already have a ctor of ParameterAnnotationRewriteOperation that takes an index rather than a name.

The resulting code is actually longer than the previous change sets, but in terms of maintainability it might be clearer? WDYT?


The remaining caller of findAffectedParameterName() only handles the current method so it should be fine as-is, and here having the parameter name comes handy for use in the message. But for consistency's sake, we _could_ also rewrite this to take the index as the primary indicator.</comment_text>
        </comment>
        <comment>
            <comment_id>2785289</comment_id>
            <comment_count>4</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-12-11 17:23:51 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #3)
&gt; The change looks good.
&gt; 
&gt; Still, in patch set #4 I added an experiment in avoiding to use the
&gt; parameter name as an indicator in the first place. Note that we already have
&gt; a ctor of ParameterAnnotationRewriteOperation that takes an index rather
&gt; than a name.
&gt; 
&gt; The resulting code is actually longer than the previous change sets, but in
&gt; terms of maintainability it might be clearer? WDYT?

Either way is good for me. A little detail to improve readability: Even though it isn't needed with patch set #4, I'd prefer to have a different variable "overriddenDeclaration" instead of the existing reassignment of the "declaration"-parameter".

&gt; 
&gt; 
&gt; The remaining caller of findAffectedParameterName() only handles the current
&gt; method so it should be fine as-is, and here having the parameter name comes
&gt; handy for use in the message. But for consistency's sake, we _could_ also
&gt; rewrite this to take the index as the primary indicator.

This would be more consistent and not only allow the removal of findAffectedParameterName, but also of the ParameterAnnotationRewriteOperation-constructor that the takes the arg-name. Having multiple constructors (that don't just delegate to other constructors) often makes it hard to change code, so that would be a win.
But I'm not sure if the improvement is big enough to invest time in this.
On the other hand you already seem to have thought this thru, so maybe it's still better if you just do it to get it out of your head :-)</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506638</id>
        <developer>Till Brychcy</developer>
        <developer_username>register.eclipse</developer_username>
        <dup_id/>
        <creation_time>2016-10-27 12:39:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[1.8][quick fix] Add a quick fix that moves a type annotation to the right location</short_desc>
        <thetext>The quick fix should move the type annotation directly in front of the (leaf) type name (within a qualified name).

It should be applied to the new problem ids from bug 506376 ( IProblem.TypeAnnotationAtQualifiedName and IProblem.NullAnnotationAtQualifyingType), as was well as the previously existing problem id IProblem.IllegalTypeAnnotationsInStaticMemberAccess</thetext>
        <comment>
            <comment_id>2770644</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-27 13:10:51 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/84039</comment_text>
        </comment>
        <comment>
            <comment_id>2770645</comment_id>
            <comment_count>2</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-10-27 13:13:49 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #1)
&gt; New Gerrit change created: https://git.eclipse.org/r/84039

Implementation. TODO: add tests</comment_text>
        </comment>
        <comment>
            <comment_id>2771150</comment_id>
            <comment_count>3</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-10-28 18:09:08 -0400</when>
            <comment_text>(In reply to Till Brychcy from comment #2)
&gt; TODO: add tests

Done in patch set 2 (obviously the gerrit will fail until bug 506376 is merged)</comment_text>
        </comment>
        <comment>
            <comment_id>2774747</comment_id>
            <comment_count>4</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-11-09 14:04:43 -0500</when>
            <comment_text>@Stephan, now that bug 506376 is merged, can you merge this quick fix for it? Or should I ask Noopur?</comment_text>
        </comment>
        <comment>
            <comment_id>2778906</comment_id>
            <comment_count>5</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-11-22 16:31:00 -0500</when>
            <comment_text>
(In reply to Till Brychcy from comment #0)
&gt; The quick fix should move the type annotation directly in front of the
&gt; (leaf) type name (within a qualified name).
&gt; 
&gt; It should be applied to the new problem ids from bug 506376 (
&gt; IProblem.TypeAnnotationAtQualifiedName and
&gt; IProblem.NullAnnotationAtQualifyingType), as was well as the previously
&gt; existing problem id IProblem.IllegalTypeAnnotationsInStaticMemberAccess

I just noted, that this quickfix would also be useful for the existing 
IProblem.IllegalAnnotationForBaseType, in following case:
	@Nullable byte[] m0() {return null;}

To avoid introducing another problem id, we could offer to simply remove the annotation in the following case which is reported with the same IProblem (the quickfix-code actually already does not, just the label would have to be changed):
	@Nullable byte m0() {return null;}</comment_text>
        </comment>
        <comment>
            <comment_id>2778907</comment_id>
            <comment_count>6</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-11-22 16:32:07 -0500</when>
            <comment_text>(In reply to Till Brychcy from comment #5)
&gt; (the quickfix-code actually already does not, just the label would have to
&gt; be changed):

I meant:
(the quickfix-code actually already does *that*, just the label would have to
 be changed):</comment_text>
        </comment>
        <comment>
            <comment_id>2778921</comment_id>
            <comment_count>7</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-11-22 17:02:28 -0500</when>
            <comment_text>While looking at this I noted that the quick fix should work not only for a MarkerAnnotation like @Nullable, but also for NormalAnnotation and SingleValueAnnotation</comment_text>
        </comment>
        <comment>
            <comment_id>2779367</comment_id>
            <comment_count>8</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-11-23 17:45:15 -0500</when>
            <comment_text>(In reply to Till Brychcy from comment #5)
&gt; I just noted, that this quickfix would also be useful for the existing 
&gt; IProblem.IllegalAnnotationForBaseType, in following case:
&gt; 	@Nullable byte[] m0() {return null;}
&gt; 
Done in patch set 4. 

(In reply to Till Brychcy from comment #7)
&gt; While looking at this I noted that the quick fix should work not only for a
&gt; MarkerAnnotation like @Nullable, but also for NormalAnnotation and
&gt; SingleValueAnnotation

Done in patch set 4. 

Also in patch set 4, I fixed the new target location for multi-dimensional arrays

In patch set 5, I've added support for case, where some or all array dimensions of a method return type are specified after the formal parameter list, e.g. the case
@Nullable byte m12()[] { return null; }
or even
@Nullable byte [] methodName()[][] { return null; }</comment_text>
        </comment>
        <comment>
            <comment_id>2781201</comment_id>
            <comment_count>9</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-11-29 16:19:13 -0500</when>
            <comment_text>@Stephan, I think this is ready to be merged - can you please take care of it?

I think it would be great to have this in 4.7M4.</comment_text>
        </comment>
        <comment>
            <comment_id>2785212</comment_id>
            <comment_count>10</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-11 10:30:15 -0500</when>
            <comment_text>(In reply to Till Brychcy from comment #9)
&gt; @Stephan, I think this is ready to be merged - can you please take care of
&gt; it?
&gt; 
&gt; I think it would be great to have this in 4.7M4.

Great work, including a good set of tests, making it difficult for the reviewer to pick any nits, but I succeeded :)

I dropped some comments in gerrit, and will upload a new patch set in a minute.

Let me highlight the use of copyMoveTarget(). For a bit of background see slide #48 of http://www.eclipsecon.org/2012/sites/eclipsecon.org.2012/files/How%20To%20Train%20the%20JDT%20Dragon%20combined.pdf

I added a few tests as variant of existing tests (ending with "a"). Two of these indeed require the copyMoveTarget() trick. Idea is to avoid creating new nodes, where semantically we are only moving existing nodes.

Finally, I tried to get use as a multi-fix/cleanup to work (where the hover shows "Fix n problems of same category in file" - but then nothing happened), but I could get it to work only partially. It still fails when multiple misplaced annotations affect the same type.

	@MyAnnot @Nullable java.lang.String m1() {
		return null;
	}

Here invoking the multi-fix will *move* @Nullable and *delete* @MyAnnot. I started debugging how ASTRewriteAnalyzer creates the resulting edits, but I got stuck here. It's got to be related to the overlap of edits from different fixes, but I couldn't quite locate where we loose edits.
Worst-case: when creating the array of operations we may have to drop any operation that overlaps with another. Not sure.

Unfortunately we don't seem to have the necessary test infrastructure for this scenario, so we may have to debug a runtime IDE.</comment_text>
        </comment>
        <comment>
            <comment_id>2785615</comment_id>
            <comment_count>11</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-12-12 15:18:30 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #10)
&gt; (In reply to Till Brychcy from comment #9)
&gt; Great work, including a good set of tests, making it difficult for the
&gt; reviewer to pick any nits, but I succeeded :)

:-)

&gt; 
&gt; I dropped some comments in gerrit, and will upload a new patch set in a
&gt; minute.
&gt; 
&gt; Let me highlight the use of copyMoveTarget(). For a bit of background see
&gt; slide #48 of
&gt; http://www.eclipsecon.org/2012/sites/eclipsecon.org.2012/files/
&gt; How%20To%20Train%20the%20JDT%20Dragon%20combined.pdf

Very interesting. I thought there should be a way to move nodes, but have overlooked this.

&gt; 
&gt; I added a few tests as variant of existing tests (ending with "a"). Two of
&gt; these indeed require the copyMoveTarget() trick. Idea is to avoid creating
&gt; new nodes, where semantically we are only moving existing nodes.

Very good.

&gt; 
&gt; Finally, I tried to get use as a multi-fix/cleanup to work (where the hover
&gt; shows "Fix n problems of same category in file" - but then nothing
&gt; happened), but I could get it to work only partially. It still fails when
&gt; multiple misplaced annotations affect the same type.
&gt; 
&gt; 	@MyAnnot @Nullable java.lang.String m1() {
&gt; 		return null;
&gt; 	}
&gt; 
&gt; Here invoking the multi-fix will *move* @Nullable and *delete* @MyAnnot. I
&gt; started debugging how ASTRewriteAnalyzer creates the resulting edits, but I
&gt; got stuck here. It's got to be related to the overlap of edits from
&gt; different fixes, but I couldn't quite locate where we loose edits.
&gt; Worst-case: when creating the array of operations we may have to drop any
&gt; operation that overlaps with another. Not sure.
&gt; 
&gt; Unfortunately we don't seem to have the necessary test infrastructure for
&gt; this scenario, so we may have to debug a runtime IDE.

I'll have a look.</comment_text>
        </comment>
        <comment>
            <comment_id>2785996</comment_id>
            <comment_count>12</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-12-13 14:46:36 -0500</when>
            <comment_text>(In reply to Till Brychcy from comment #11)
&gt; 
&gt; I'll have a look.

The problem was that SimpleType needs to be replaced by NameQualifiedType. For repeated replacements, the last one wins. Fixed in patch set 12 by checking in the astRewrite if there already is a replacement.</comment_text>
        </comment>
        <comment>
            <comment_id>2786019</comment_id>
            <comment_count>13</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-12-13 16:01:22 -0500</when>
            <comment_text>patch set 13 adds a test for the cleanup situation</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508215</id>
        <developer>Stefan Tannenbaum</developer>
        <developer_username>s.tannenbaum</developer_username>
        <dup_id/>
        <creation_time>2016-11-25 15:07:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Debugger highlights wrong line in for loops over varargs.</short_desc>
        <thetext>When stepping through the following example code, the debugger highlights line number 9, although it is never executed.

1 public class DebugError {
2 	public static void main(String[] args) {
3		for (Integer i : Arrays.asList(1, 2, 3)) {
4			System.out.print(i);
5
6			if (i &lt; 5) {
7				System.out.println(" is small");
8			} else {
9				System.out.println(" is large");
10			}
11		}
12	}
13}

This seems to happen in any for each loop over an iterable that was created from a varargs argument list directly in the loop. The debugger highlights the last executable of the for loop body every time it steps through the for loop header in line 3. It seems to misinterpret some part of the internal iterable processing as executing code at the end of the body.

The actual execution remains unaffected, even when using the debugger, line 9 is never run and the output is correct. The Netbeans debugger works fine for the same example.</thetext>
        <comment>
            <comment_id>2780209</comment_id>
            <comment_count>1</comment_count>
            <who>Stefan Tannenbaum</who>
            <commenter_username>s.tannenbaum</commenter_username>
            <when>2016-11-25 15:09:53 -0500</when>
            <comment_text>Tested on

Version: Neon.1 (4.6.1)
Build id: M20160907-1200</comment_text>
        </comment>
        <comment>
            <comment_id>2780314</comment_id>
            <comment_count>2</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-11-26 15:15:27 -0500</when>
            <comment_text>I can reproduce this on the master.

Here is the disassembled output corresponding to the example in comment#0
%javap -c -l bin/DebugError.class
Compiled from "DebugError.java"
public class DebugError {
  public DebugError();
    Code:
       0: aload_0
       1: invokespecial #8                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return
    LineNumberTable:
      line 3: 0
    LocalVariableTable:
      Start  Length  Slot  Name   Signature
          0       5     0  this   LDebugError;

  public static void main(java.lang.String[]);
    Code:
       0: iconst_3
       1: anewarray     #16                 // class java/lang/Integer
       4: dup
       5: iconst_0
       6: iconst_1
       7: invokestatic  #18                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      10: aastore
      11: dup
      12: iconst_1
      13: iconst_2
      14: invokestatic  #18                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      17: aastore
      18: dup
      19: iconst_2
      20: iconst_3
      21: invokestatic  #18                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      24: aastore
      25: invokestatic  #22                 // Method java/util/Arrays.asList:([Ljava/lang/Object;)Ljava/util/List;
      28: invokeinterface #28,  1           // InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;
      33: astore_2
      34: goto          81
      37: aload_2
      38: invokeinterface #34,  1           // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;
      43: checkcast     #16                 // class java/lang/Integer
      46: astore_1
      47: getstatic     #40                 // Field java/lang/System.out:Ljava/io/PrintStream;
      50: aload_1
      51: invokevirtual #46                 // Method java/io/PrintStream.print:(Ljava/lang/Object;)V
      54: aload_1
      55: invokevirtual #52                 // Method java/lang/Integer.intValue:()I
      58: iconst_5
      59: if_icmpge     73
      62: getstatic     #40                 // Field java/lang/System.out:Ljava/io/PrintStream;
      65: ldc           #56                 // String  is small
      67: invokevirtual #58                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      70: goto          81
      73: getstatic     #40                 // Field java/lang/System.out:Ljava/io/PrintStream;
      76: ldc           #62                 // String  is large
      78: invokevirtual #58                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      81: aload_2
      82: invokeinterface #64,  1           // InterfaceMethod java/util/Iterator.hasNext:()Z
      87: ifne          37
      90: return
    LineNumberTable:
      line 5: 0
      line 5: 6
      line 6: 47
      line 8: 54
      line 9: 62
      line 10: 70
      line 11: 73
      line 14: 90
    LocalVariableTable:
      Start  Length  Slot  Name   Signature
          0      91     0  args   [Ljava/lang/String;
         47      34     1     i   Ljava/lang/Integer;
}

If „Arrays.asList(1, 2, 3)“ is replaced by „Arrays.asList(new Integer[]{1, 2, 3})“, the problem disappears and the disassembled output is identical, expect for a different LineNumberTable:
[…]
LineNumberTable:
      line 5: 0
      line 6: 47
      line 8: 54
      line 9: 62
      line 10: 70
      line 11: 73
      line 5: 81
      line 14: 90
[…]
The difference is that in the new Integer[]{…}-case there is an entry‚line 5: 81‘, which tells that the hasNext invocation belongs to line 5.
This is missing in the varargs variation (instead there is an entry „line 5: 6“, that is actually redundant as the previous entry is already for line 5)

So the problem is in the code generation =&gt; moving to jdt.core</comment_text>
        </comment>
        <comment>
            <comment_id>2780328</comment_id>
            <comment_count>3</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-11-26 18:01:25 -0500</when>
            <comment_text>ANALYSIS:
The difference between the cases „Arrays.asList(1, 2, 3)“ and „Arrays.asList(new Integer[]{1, 2, 3})“ is that during code generation for new Integer[]{1, 2, 3}, CodeStream.recordPositionsFrom is invoked, but when the code for creating the array for the varargs invocation Arrays.asList(1, 2, 3) is generated in Statement.generateArguments, CodeStream.recordPositionsFrom is not invoked.

PATCH:
Adds corresponding CodeStream.recordPositionsFrom invocations to Statement.generateArguments.
TODO: tests. I haven’t found any existing tests optimized for line number problems. I guess using the disassembler is the way to do it.</comment_text>
        </comment>
        <comment>
            <comment_id>2780330</comment_id>
            <comment_count>4</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-26 18:02:44 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85829</comment_text>
        </comment>
        <comment>
            <comment_id>2780401</comment_id>
            <comment_count>5</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-11-27 17:57:16 -0500</when>
            <comment_text>(In reply to Eclipse Genie from comment #4)
&gt; New Gerrit change created: https://git.eclipse.org/r/85829

I thought a bit about it: While this patch fixes the symptom, it is in the wrong place. So I added some logging to CodeStream.recordPositionsFrom and I think I have found the real bug (actually it exists already in the first revision of CodeStream available in git).

At some point, when pcToSourceMap is as follows:
[ 6 in line 6 ]
[ 33 in line 7 ]
[ 40 in line 6 ]
CodeStream.recordPositionsFrom is invoked with startPC=0 and a sourcePos corresponding to line 6.

Line 6 is the current value of the last entry. Therefore, the code commented with „// widen the existing entry“ is executed.
The insertion point in this case is the beginning of the array.
But the code assumes, that resulting entries will already cover the last entry (probably because it is on the same line) „40 in line 6“ and drops this last entry by only copying (this.pcToSourceMapSize  - 2 - insertionIndex) values and not increasing this.pcToSourceMapSize, so the pcToSourceMap is as follows afterwards:
[ 0 in line 6 ]
[ 6 in line 6 ]
[ 33 in line 7 ]
But this assumption is wrong in this case, as there is already an entry for line 7 in between, so the entry for  "40 in line 6" must NOT be dropped in this situation.</comment_text>
        </comment>
        <comment>
            <comment_id>2782569</comment_id>
            <comment_count>6</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-12-03 14:26:13 -0500</when>
            <comment_text>(In reply to Till Brychcy from comment #5)
&gt; At some point, when pcToSourceMap is as follows:
&gt; [ 6 in line 6 ]
&gt; [ 33 in line 7 ]
&gt; [ 40 in line 6 ]
&gt; CodeStream.recordPositionsFrom is invoked with startPC=0 and a sourcePos
&gt; corresponding to line 6.

It forgot to write, that these numbers where for the following, simplified test case:
package linenumber;
import java.util.Arrays;

public class DebugErrorVarargs1Arg {
	public static void main(String[] args) {
		for (Integer i : Arrays.asList(1)) {
			System.out.println(i);
		}
	}
}

The problem is visible in this example, too: the debugger seems to step twice thru the System.out.println</comment_text>
        </comment>
        <comment>
            <comment_id>2782574</comment_id>
            <comment_count>7</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-12-03 15:09:07 -0500</when>
            <comment_text>CodeStream.recordPositionsFrom contains a lot of replicated code introduces during the performance optimization in Bug 185350, so the bug would have to be fixed in multiple places. It is better to first remove the code replication.

The replication appeared as side effect of a change to avoid the expensive computation of the linenumber using Util.getLineNumber(...).

The replication can be removed first by inlining the replicated code in two methods, then rearranging the simplified remaining code so the linenumber is first either updated or computed using Util.getLineNumber and then the extracted methods are invoked from one place. In a last step, the extracted methods can be inlined again in this single place.

I'll push the refactoring to gerrit in multiple steps for easy verification.</comment_text>
        </comment>
        <comment>
            <comment_id>2782575</comment_id>
            <comment_count>8</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-03 15:15:00 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/86309</comment_text>
        </comment>
        <comment>
            <comment_id>2782577</comment_id>
            <comment_count>9</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-12-03 15:44:04 -0500</when>
            <comment_text>(In reply to Eclipse Genie from comment #8)
&gt; New Gerrit change created: https://git.eclipse.org/r/86309

Fresh start with the refactoring to reduce the code replication.

change set 1: extract the replicated code into two methods using the "extract method" refactoring.

change set 2: removes the redundant invocations of these methods - note that linenumber is set up such that the "if (previousLineNumber != lineNumber)"... will lead to the very same method invocations and the same "this.lastEntryPC = this.position;" is done.</comment_text>
        </comment>
        <comment>
            <comment_id>2782580</comment_id>
            <comment_count>10</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-12-03 16:12:43 -0500</when>
            <comment_text>change set 3: removes a return statement that should already have been removed in changeset 2

change set 4: reduces the replication of the "lineNumber = Util.getLineNumber..." code that appeared in 5 places.</comment_text>
        </comment>
        <comment>
            <comment_id>2782582</comment_id>
            <comment_count>11</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-12-03 16:25:11 -0500</when>
            <comment_text>changeset 5: is a minor optimization to use the local variable lineSeparatorPositions2 

changeset 6: completes the refactoring by inlining the to methods that were extracted in changeset 1</comment_text>
        </comment>
        <comment>
            <comment_id>2782584</comment_id>
            <comment_count>12</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-12-03 16:34:38 -0500</when>
            <comment_text>From the point of readability it might be a good idea to stop at changeset 5 (the performance difference should be negligible), but going to changeset 6 reduces the total diff in this refactoring.

I think it is a good idea to commit this refactoring separately from the (to be created) code change to fix the bug from comment#0</comment_text>
        </comment>
        <comment>
            <comment_id>2783512</comment_id>
            <comment_count>13</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-06 13:57:30 -0500</when>
            <comment_text>You succeeded to simplify the code without breaking any tests, right?

If so, I'd suggest to push that change alone (squashed to one commit) as soon as M4 is done and signed off.

The actual fix can then be done in a new and much reduced change.</comment_text>
        </comment>
        <comment>
            <comment_id>2783517</comment_id>
            <comment_count>14</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-12-06 14:08:15 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #13)
&gt; You succeeded to simplify the code without breaking any tests, right?

Yes. In addition I have verified in a workspace with more than 10000 .class files that the refactored code generates identical class files as the master does.

While testing, I also noted another problem in the code, for which I'll file an extra bug.

&gt; 
&gt; If so, I'd suggest to push that change alone (squashed to one commit) as
&gt; soon as M4 is done and signed off.
Actually the change set in gerrit are already squashed commits, you have to compare them with each other

&gt; 
&gt; The actual fix can then be done in a new and much reduced change.

Yes, that was I tried to express in comment#12 :-)</comment_text>
        </comment>
        <comment>
            <comment_id>2783521</comment_id>
            <comment_count>15</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-06 14:15:25 -0500</when>
            <comment_text>(In reply to Till Brychcy from comment #14)
&gt; Yes, that was I tried to express in comment#12 :-)

apparently reading ability would help ... :p</comment_text>
        </comment>
        <comment>
            <comment_id>2785091</comment_id>
            <comment_count>16</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-09 18:18:46 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/86871</comment_text>
        </comment>
        <comment>
            <comment_id>2785163</comment_id>
            <comment_count>17</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-12-10 17:03:16 -0500</when>
            <comment_text>(In reply to Till Brychcy from comment #14)
&gt; While testing, I also noted another problem in the code, for which I'll file
&gt; an extra bug.

I've created bug 509027 for that.</comment_text>
        </comment>
        <comment>
            <comment_id>2786084</comment_id>
            <comment_count>18</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-12-14 02:32:23 -0500</when>
            <comment_text>Does anybody want to have a look at the patches for refactoring and fixes (incl bug 509027), before I merge them?</comment_text>
        </comment>
        <comment>
            <comment_id>2786137</comment_id>
            <comment_count>19</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-14 04:42:48 -0500</when>
            <comment_text>Because we are talking about code generation, it would be nice to have it reviewed. I am not an expert in this area. Can Sasi or Stephan glance over the patch?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>509027</id>
        <developer>Till Brychcy</developer>
        <developer_username>register.eclipse</developer_username>
        <dup_id/>
        <creation_time>2016-12-10 16:54:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Non-deterministic bug in line number generation</short_desc>
        <thetext>DESCRIPTION:
While repeatedly checking more than 10000 class files in a workspace if there are unexpected changes caused by the refactoring in Bug 508215,
I observed a nondeterministic behaviour already on the master: Some .class file are sometimes (10%-20% of the time) different and differences are in the linenumber table.

ANALYSIS:
It would hard to extract a standalone test case for the non-deterministic behaviour, but I was able to find the problem using conditional breakpoints.
The problem is that in CodeStream.indexOfSameLineEntrySincePC, the pc is used as initial index for pcToSourceMap (which is bogus per se)
The pc may be odd and the entries of pcToSourceMap are alternating pc and line number values, so starting with an odd pc means that  the line parameter is compared as pc values in pcToSourceMap, which is obviously wrong. The non-deterministic behaviour is triggered because the last value compared against is pcToSourceMap[index+1] which for odd index and index&lt;pcToSourceMapSize is actually pcToSourceMap[pcToSourceMap], which doesn’t belong to the current method at all but is a leftover value from generation of a previous method (as pcToSourceMap is reused). If the leftover (pc!) value in this location is accidentally the same value as the line parameter, a match is  returned. 
But actually using indexOfSameLineEntrySincePC to compute existingEntryIndex in recordPositionsFrom is bogus anyway, because the  pcToSourceMap is sorted by pc values and the only valid place where an entry for that pc may be has already been computed as insertionIndex.

The buggy behaviour can e.g. be observed by the bogus line number table for the following example:

package linenumber;

public class Test {
	int[] f = { 1, // linebreak
			2 };
}

   LineNumberTable:
      line 3: 0
      line 4: 5
      line 4: 4
      line 5: 14
      line 3: 19

This bug already exists in the first version of CodeStream available in git.

(Source of the nondeterministic behavior: The leftover data in pcToSourceMap depends on the code generation order. I think hash maps have an influence on the order in which code is generated for things like synthetic methods, but I haven’t examined this further)

PATCH:
Removes CodeStream.indexOfSameLineEntrySincePC and existingEntryIndex, and checks at insertionIndex  for an existing entry that already is sufficient or is widened.</thetext>
        <comment>
            <comment_id>2785162</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-10 17:01:53 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/86877</comment_text>
        </comment>
    </bug>
    <bug>
        <id>509328</id>
        <developer>Till Brychcy</developer>
        <developer_username>register.eclipse</developer_username>
        <dup_id/>
        <creation_time>2016-12-15 18:52:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][null] @NonNullByDefault on constructor ignored when used from anonymous subclass via .class file</short_desc>
        <thetext>DESCRIPTION:
Given the following files in two projects
--- project 1
package test;

import org.eclipse.jdt.annotation.NonNullByDefault;

@NonNullByDefault
public class Feature {
	public Feature(String name) {
	}
}

--- project 2
package test;

import org.eclipse.jdt.annotation.NonNullByDefault;

@NonNullByDefault
public class Test {
	public static void f() {
		new Feature(null) {
			// anonymous subclass
		};
	}
}

No error is reported for the null argument to the Feature constructor, but there should be:
----------
1. ERROR in test\Test.java (at line 8)
	new Feature(null) {
	            ^^^^
Null type mismatch: required '@NonNull String' but the provided value is null
----------

(It should be reported because of the @NonNullByDefault in Feature.java; the @NonNullByDefault in Test.java is irrelevant)

ANALYSIS:
When the types are copied from the inherited constructor to the constructor of the anonymous subclass in TypeDeclaration.createDefaultConstructorWithBinding(MethodBinding, boolean), the NonNullByDefault has not been applied yet.

PATCH:
Before the invocation, use ImplicitNullAnnotationVerifier in QualifiedAllocationExpression.resolveTypeForQualifiedAllocationExpression.

@Stephan, I’m not sure if this is the best place to do this, do you have a better idea?

Also, I’m starting to think we should have a utility method for the if(…IsNullnessKnown) {…new ImplicitNullAnnotationVerifier… } block, which appears in an increasing number of places...</thetext>
        <comment>
            <comment_id>2786872</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-15 19:02:59 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/87280</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508851</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-12-07 12:43:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Debug source viewers (breakpoint condition, Display view) use wrong font</short_desc>
        <thetext>Debug source viewers (breakpoint condition, Display view) use a wrong font (OS font instead of monospace text font).

Was OK until (including) I20161121-2000. Broken in I20161123-2000 and later. Only seems to affect new workspaces. Looks OK in old workspaces that were created before the breakage.

Smoking gun is bug 502061. Maybe the lines 481-490 ...

		PreferenceConverter.putValue(store, JFaceResources.TEXT_FONT, JFaceResources.getFontRegistry().getFontData(PreferenceConstants.EDITOR_TEXT_FONT));
[..]

... were not just for compatibility with old bundles, but were really necessary.

The JDISourceViewer does refer to JFaceResources.TEXT_FONT.</thetext>
        <comment>
            <comment_id>2784040</comment_id>
            <comment_count>1</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-12-07 12:45:52 -0500</when>
            <comment_text>I have to finish something else first, but I'll have a look later.
Please ping me or write a comment here if you start to investigate.</comment_text>
        </comment>
        <comment>
            <comment_id>2784110</comment_id>
            <comment_count>2</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-12-07 16:03:07 -0500</when>
            <comment_text>The cited lines are the ones that produced an AFE in bug 506913, so adding them back unchanged is not a good idea either.

Furthermore, this is not backwards compatibility code, but normal sync code that should update JFace fonts when Eclipse workspace preferences are changed.

However, the code was at the wrong layer. It synced the Java editor font with JFaceResources.TEXT_FONT. That is conceptually wrong. I filed bug 508859 to fix that.


Keeping this bug for the necessary fixes in JDT Debug, which should not use JFaceResources.TEXT_FONT for Java source viewers. It should use org.eclipse.jdt.ui.PreferenceConstants.EDITOR_TEXT_FONT instead.</comment_text>
        </comment>
        <comment>
            <comment_id>2784226</comment_id>
            <comment_count>3</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-12-08 05:03:09 -0500</when>
            <comment_text>JFaceResources.TEXT_FONT is used by platform Debug, Platform Ant and JDT Debug.

In JDT Debug I can replace them by org.eclipse.jdt.ui.PreferenceConstants.EDITOR_TEXT_FONT.

Any change for Platform Debug and Ant Suggested?</comment_text>
        </comment>
        <comment>
            <comment_id>2784373</comment_id>
            <comment_count>4</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-08 09:46:27 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/86705</comment_text>
        </comment>
    </bug>
    <bug>
        <id>509095</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-12-12 11:36:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Remote Java Application page: missing mnemonics</short_desc>
        <thetext>4.6 M4

Remote Java Application page: missing mnemonics.

Port and Connection limit have no mnemonic.</thetext>
    </bug>
    <bug>
        <id>509096</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-12-12 11:38:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Remove Java Application page: connection limit 0 not explained</short_desc>
        <thetext>4.7 M3.

From the N&amp;N of M3:  The connection limit may be set to a fixed number, or 0

And the user knows this how?</thetext>
        <comment>
            <comment_id>2785558</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-12-12 11:39:14 -0500</when>
            <comment_text>(In reply to Dani Megert from comment #0)
&gt; 4.7 M3.
&gt; 
&gt; The connection limit may be set to a fixed number, or 0

The connection limit may be set to a fixed number, or 0 for unlimited connections.</comment_text>
        </comment>
        <comment>
            <comment_id>2785559</comment_id>
            <comment_count>2</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-12-12 11:39:59 -0500</when>
            <comment_text>Also using F1 Help - no luck.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>487153</id>
        <developer>Martin Partel</developer>
        <developer_username>mpartel</developer_username>
        <dup_id/>
        <creation_time>2016-02-03 12:17:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler] Miscompilation when passing byte[] from generic return to varargs</short_desc>
        <thetext>Created attachment 259547
Test case

Let there be a method `void f(Object... args)`.
Here's a case where I think Eclipse miscompiles:

    byte[] bytes = {1, 2, 3, 4};
    ArrayList&lt;byte[]&gt; arrays = new ArrayList&lt;&gt;();
    arrays.add(bytes);
    f(arrays.get(0));  // &lt;-- problem occurs here

The Eclipse compiler emits code that fails with a "ClassCastException: [B cannot be cast to [Ljava.lang.Object;".

javac passes the byte array as a single argument, which I assume is the correct behaviour.

The detour through ArrayList is necessary because the problem seems to only occur when the argument comes from a generic-returning expression.

Looking at the bytecode, Eclipse emits a checkcast "[Ljava/lang/Object;" just after the invokevirtual on ArrayList.get, whereas javac does not.

Full test case attached for convenience.</thetext>
        <comment>
            <comment_id>2667900</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-02-04 02:25:03 -0500</when>
            <comment_text>Reproduced on master.</comment_text>
        </comment>
        <comment>
            <comment_id>2668415</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-04 17:47:32 -0500</when>
            <comment_text>FWIW, this is
- not caused by Java8 type inference, problem can be reproduced with 1.7 &amp; 1.8
- not a recent regression, problem can be reproduced with ecj &gt;= 3.7.1</comment_text>
        </comment>
    </bug>
    <bug>
        <id>493705</id>
        <developer>Erdal Karaca</developer>
        <developer_username>erdal.karaca.de</developer_username>
        <dup_id/>
        <creation_time>2016-05-15 08:42:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>org.eclipse.jdt.internal.compiler.ast.LambdaExpression$CopyFailureException</short_desc>
        <thetext>This is the code that triggers the exception. See comment for details on how to reproduce.

		root.layout(GridLayoutFactory.swtDefaults().numColumns(2).create())//
				.child(() -&gt; SwtUI.create(Label::new)// &lt;-- insert DOT here and
														// the exception occurs
		);


-- Error Details --
Date: Sun May 15 14:13:19 CEST 2016
Message: The 'org.eclipse.jdt.ui.JavaAllCompletionProposalComputer' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension has thrown a runtime exception.
Severity: Warning
Product: Eclipse 4.5.2.20160218-0600 (org.eclipse.epp.package.modeling.product)
Plugin: org.eclipse.jdt.ui
Session Data:
eclipse.buildId=4.5.2.M20160212-1500
java.version=1.8.0_91
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.modeling.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.modeling.product

Exception Stack Trace:
org.eclipse.jdt.internal.compiler.ast.LambdaExpression$CopyFailureException
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.cachedResolvedCopy(LambdaExpression.java:853)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.sIsMoreSpecific(LambdaExpression.java:925)
	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.moreSpecificMain(InferenceContext18.java:686)
	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.isMoreSpecificThan(InferenceContext18.java:662)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.mostSpecificMethodBinding(Scope.java:4324)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findDefaultAbstractMethod(Scope.java:1176)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1809)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2822)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:898)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:712)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1923)
	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:131)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:357)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:345)
	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.internalComputeCompletionProposals(JavaCompletionProposalComputer.java:244)
	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.computeCompletionProposals(JavaCompletionProposalComputer.java:206)
	at org.eclipse.jdt.internal.ui.text.java.JavaTypeCompletionProposalComputer.computeCompletionProposals(JavaTypeCompletionProposalComputer.java:63)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:337)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:322)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:279)
	at org.eclipse.jface.text.contentassist.ContentAssistant$5.run(ContentAssistant.java:1904)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1902)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:573)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$16(CompletionProposalPopup.java:570)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:505)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:499)
	at org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1720)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:180)
	at org.eclipse.ui.texteditor.ContentAssistAction$1.run(ContentAssistAction.java:82)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ui.texteditor.ContentAssistAction.run(ContentAssistAction.java:80)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor54.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:252)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:234)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:493)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:486)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1266)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1112)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1137)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1122)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1164)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1160)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1581)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4795)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:343)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4676)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5050)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3767)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:827)
	at org.eclipse.jface.window.Window.open(Window.java:803)
	at org.eclipse.ui.internal.views.log.EventDetailsDialog.open(EventDetailsDialog.java:181)
	at org.eclipse.ui.internal.views.log.EventDetailsDialogAction.run(EventDetailsDialogAction.java:98)
	at org.eclipse.ui.internal.views.log.LogView$15.doubleClick(LogView.java:546)
	at org.eclipse.jface.viewers.StructuredViewer$1.run(StructuredViewer.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:173)
	at org.eclipse.jface.viewers.StructuredViewer.fireDoubleClick(StructuredViewer.java:829)
	at org.eclipse.jface.viewers.AbstractTreeViewer.handleDoubleSelect(AbstractTreeViewer.java:1470)
	at org.eclipse.jface.viewers.StructuredViewer$4.widgetDefaultSelected(StructuredViewer.java:1263)
	at org.eclipse.jface.util.OpenStrategy.fireDefaultSelectionEvent(OpenStrategy.java:252)
	at org.eclipse.jface.util.OpenStrategy.access$0(OpenStrategy.java:249)
	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:311)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4362)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4180)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3769)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:694)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:606)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1515)</thetext>
        <comment>
            <comment_id>2707330</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-16 07:02:01 -0400</when>
            <comment_text>Could you please provide a sample with the missing types? Thanks!</comment_text>
        </comment>
        <comment>
            <comment_id>2707796</comment_id>
            <comment_count>2</comment_count>
            <who>Erdal Karaca</who>
            <commenter_username>erdal.karaca.de</commenter_username>
            <when>2016-05-17 07:54:01 -0400</when>
            <comment_text>I could not figure out what of my scenario/code causes this bug to extract a minimalistic example.
So, I hope it is fine for you to grab the following plugins from my github repo [1] (sources are EPL):


- de.metadocks.lambdaui
- de.metadocks.lambdaui.snippets

Once you have checked out the projects into your workspace, you can open, for example, the class de.metadocks.lambdaui.snippets.swt.HelloWorld and insert a dot at the end of line 77 (and wait for content assist to help, but fail here).

[1] https://github.com/erdalkaraca/lambda-ui/tree/master/plugins</comment_text>
        </comment>
        <comment>
            <comment_id>2709014</comment_id>
            <comment_count>3</comment_count>
            <who>Erdal Karaca</who>
            <commenter_username>erdal.karaca.de</commenter_username>
            <when>2016-05-19 02:39:39 -0400</when>
            <comment_text>Jay,
Do you think this bug can still be fixed for Neon?</comment_text>
        </comment>
        <comment>
            <comment_id>2711154</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-24 02:59:35 -0400</when>
            <comment_text>(In reply to Erdal Karaca from comment #3)
&gt; Jay,
&gt; Do you think this bug can still be fixed for Neon?

I am afraid not. We will take a look at this during 4.7 and if possible back port to 4.6.1.</comment_text>
        </comment>
        <comment>
            <comment_id>2711280</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-24 06:51:48 -0400</when>
            <comment_text>I gave it a first look, observations:

(In reply to Erdal Karaca from comment #2)
&gt; ...
&gt; insert a dot at the end of line 77 (and wait for content assist to help, but
&gt; fail here).

A dot at the very end didn't trigger the bug for me, but this:
    .text("Selection).|)


At the point where we reparse the lambda, the scanner's toString() throws an exception, happens at:

	buffer.append("&lt;source beginning&gt;\n...\n"); //$NON-NLS-1$
	int line = Util.getLineNumber(this.startPosition-1000, this.lineEnds, 0, this.linePtr);
	int lineStart = getLineStart(line);
	buffer.append(this.source, lineStart, this.startPosition-lineStart);

Current values:
  line = 1
  lineStart = -1

This is a problem with lineEnds, which at that point are an int[250] filled with '0' from top to toe. Perhaps a result of "recordLineSeparators = false", but  this makes debugging painful without a working toString().

Rather than live inspection, this is what DEBUG=true prints during lambda reparse:

-- ENTER INSIDE PARSE METHOD --
NestedLambda ::=
PushLPAREN ::= LPAREN
FormalParameterListopt ::=
PushRPAREN ::= RPAREN
ElidedLeftBraceAndReturn ::=
Name ::= SimpleName
QualifiedName ::= Name DOT SimpleName
Name ::= SimpleName
Dimsopt ::=
NonWildTypeArgumentsopt ::=
IdentifierOrNew ::= new
ReferenceExpression ::= Name Dimsopt COLON_COLON...
Expression ::= AssignmentExpression
MethodInvocation ::= Name LPAREN ArgumentListopt RPAREN
Expression ::= AssignmentExpression
MethodInvocation ::= Primary DOT Identifier LPAREN...
-- EXIT FROM PARSE METHOD --

Doesn't look totally off the mark, but finally null is returned because of "this.lastAct == ERROR_ACTION".

Q: Isn't a syntax error to be expected during complete?

Experiment: set "this.haltOnSyntaxError = false" in parseLambdaExpression()
Result: parsing seems to restart at the top of the file, which is not what we want.


We hit ERROR_ACTION, when currentToken = TokenNameEOF, at a point with the following stack content:

astStack (lenght 1):
      LambdaExpression "() -&gt; {}"
expressionStack (length 1): MessageSend
      SwtUI.create(Label::new).text("Selection")

All looks good, except that we haven't folded the expression into the lambda.
We can't yet do this, because the expression is not properly terminated (the final ')' is outside the range to parse).


So much for my observations trying to understand the CopyFailureException. Next in this theatre: isn't CopyFailureException actually expected during assist parsing?</comment_text>
        </comment>
        <comment>
            <comment_id>2711313</comment_id>
            <comment_count>6</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-24 07:17:19 -0400</when>
            <comment_text>OK, *normally* CopyFailureException during code assist is silently caught in LE.isCompatibleWith().

But in this example the exception is raised in a call chain from LE.sIsMoreSpecific()!

That's a useful cue (which also explains difficulty to isolate the problem in a smaller example).</comment_text>
        </comment>
        <comment>
            <comment_id>2711323</comment_id>
            <comment_count>7</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-05-24 07:42:53 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/73460</comment_text>
        </comment>
        <comment>
            <comment_id>2711329</comment_id>
            <comment_count>8</comment_count>
            <who>Erdal Karaca</who>
            <commenter_username>erdal.karaca.de</commenter_username>
            <when>2016-05-24 07:52:09 -0400</when>
            <comment_text>Thanks, Stephan!
It seems that you have also isolated a minimalistic example/test to reproduce.</comment_text>
        </comment>
        <comment>
            <comment_id>2711339</comment_id>
            <comment_count>9</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-24 08:02:51 -0400</when>
            <comment_text>(In reply to Erdal Karaca from comment #8)
&gt; Thanks, Stephan!
&gt; It seems that you have also isolated a minimalistic example/test to
&gt; reproduce.

The key to this test case was to include these two methods from SwtUI:

	public SwtUI&lt;T&gt; child(ControlSupplier supplier)
	public SwtUI&lt;T&gt; child(ViewerSupplier supplier)

&lt;lecture&gt;
Aside from the completion issue, let me mention that this style of programming drives type inference to its limits (and perhaps beyond): overloading (the most convoluted concept in the Java language) combined with a difference in signatures of only two functional interfaces and then a lambda expression to make that choice with minimal type information contained, wow!

One lesson I learned from implementing this inference: I cannot explain why and when overload resolution works and which result it will pick, at least not in terms that are amenable to a developer's understanding of their own code.
For the sake of comprehensibility and predictability: use different names for those methods. It's so easy and avoids tremendous hassle.
&lt;/lecture&gt;

Jay, Sassi,

if hudons gives +1 I'm fine with putting this in RC3, but I won't push hard on it...</comment_text>
        </comment>
        <comment>
            <comment_id>2712380</comment_id>
            <comment_count>10</comment_count>
            <who>Erdal Karaca</who>
            <commenter_username>erdal.karaca.de</commenter_username>
            <when>2016-05-25 15:34:07 -0400</when>
            <comment_text>That was a solution driven by unconscious programming :-)

(In reply to Stephan Herrmann from comment #9)
&gt; (In reply to Erdal Karaca from comment #8)
&gt; &gt; Thanks, Stephan!
&gt; &gt; It seems that you have also isolated a minimalistic example/test to
&gt; &gt; reproduce.
&gt; 
&gt; The key to this test case was to include these two methods from SwtUI:
&gt; 
&gt; 	public SwtUI&lt;T&gt; child(ControlSupplier supplier)
&gt; 	public SwtUI&lt;T&gt; child(ViewerSupplier supplier)
&gt; 
&gt; &lt;lecture&gt;
&gt; Aside from the completion issue, let me mention that this style of
&gt; programming drives type inference to its limits (and perhaps beyond):
&gt; overloading (the most convoluted concept in the Java language) combined with
&gt; a difference in signatures of only two functional interfaces and then a
&gt; lambda expression to make that choice with minimal type information
&gt; contained, wow!
&gt; 
&gt; One lesson I learned from implementing this inference: I cannot explain why
&gt; and when overload resolution works and which result it will pick, at least
&gt; not in terms that are amenable to a developer's understanding of their own
&gt; code.
&gt; For the sake of comprehensibility and predictability: use different names
&gt; for those methods. It's so easy and avoids tremendous hassle.
&gt; &lt;/lecture&gt;
&gt; 
&gt; Jay, Sassi,
&gt; 
&gt; if hudons gives +1 I'm fine with putting this in RC3, but I won't push hard
&gt; on it...</comment_text>
        </comment>
    </bug>
    <bug>
        <id>493965</id>
        <developer>Raffi Khatchadourian</developer>
        <developer_username>raffi.khatchadourian</developer_username>
        <dup_id/>
        <creation_time>2016-05-18 23:22:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isCompatibleWith0(TypeBinding, Scope) assumes explicit conversion from an interface to a class but LHS may be an interface</short_desc>
        <thetext>The code in org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isCompatibleWith0(TypeBinding, Scope) assumes that the LHS is a class when in fact it can be an interface as well. It states that explicit conversions from interfaces to classes are not allowed but it only checks that the RHS is an interface. It should also check whether the LHS is an interface as well, in which case this statement would not hold.

f (isInterface())  // Explicit conversion from an interface
										// to a class is not allowed
				return false;


-- Configuration Details --
Product: Eclipse 4.5.2.20160218-0600 (org.eclipse.epp.package.committers.product)
Installed Features:
 org.eclipse.jdt 3.11.2.v20160212-1500</thetext>
        <comment>
            <comment_id>2708993</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-19 01:09:45 -0400</when>
            <comment_text>Sasi please take a look.</comment_text>
        </comment>
        <comment>
            <comment_id>2709645</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-19 17:10:18 -0400</when>
            <comment_text>Good catch. From a quick glance this situation has been created by the fix for bug 395002
Please see that prior to that change the previous if:
  if (otherReferenceType.isInterface())...
would always return, so below that point it was safe to assume !otherReferenceType.isInterface().

Now, that there are ways to drop out of the then-block without returning, we should probably change the "if" in question into an "else if", or add "return false" as the last thing into the previous then-block to get closer to the previous behavior.
RunAllJava8Tests is happy with either change.

But, does anyone have a test case where any of this makes a difference??

BTW, bug 395002 was fixed in 4.3M4, so this is not a recent regression (if any).</comment_text>
        </comment>
        <comment>
            <comment_id>2710323</comment_id>
            <comment_count>3</comment_count>
            <who>Raffi Khatchadourian</who>
            <commenter_username>raffi.khatchadourian</commenter_username>
            <when>2016-05-20 15:52:28 -0400</when>
            <comment_text>(In reply to comment #2)
&gt; ...
&gt; But, does anyone have a test case where any of this makes a difference??

Yes, when the implicit parameter is a binding representing an interface.</comment_text>
        </comment>
        <comment>
            <comment_id>2710328</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-20 16:07:04 -0400</when>
            <comment_text>(In reply to Raffi Khatchadourian from comment #3)
&gt; (In reply to comment #2)
&gt; &gt; ...
&gt; &gt; But, does anyone have a test case where any of this makes a difference??
&gt; 
&gt; Yes, when the implicit parameter is a binding representing an interface.

I don't understand, which implicit parameter?  Please attach an example.
Note, we need more than one binding, we need the context to actually pass through all the checks in on a very specific flow path. I'm not convinced that this path is actually possible at runtime.

In other words, we need an example where compilation produces a wrong result due to the current implementation.</comment_text>
        </comment>
        <comment>
            <comment_id>2711465</comment_id>
            <comment_count>5</comment_count>
            <who>Raffi Khatchadourian</who>
            <commenter_username>raffi.khatchadourian</commenter_username>
            <when>2016-05-24 10:18:23 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #4)
&gt; (In reply to Raffi Khatchadourian from comment #3)
&gt; &gt; (In reply to comment #2)
&gt; &gt; &gt; ...
&gt; &gt; &gt; But, does anyone have a test case where any of this makes a difference??
&gt; &gt; 
&gt; &gt; Yes, when the implicit parameter is a binding representing an interface.
&gt; 
&gt; I don't understand, which implicit parameter?  Please attach an example.
&gt; Note, we need more than one binding, we need the context to actually pass
&gt; through all the checks in on a very specific flow path. I'm not convinced
&gt; that this path is actually possible at runtime.
&gt; 
&gt; In other words, we need an example where compilation produces a wrong result
&gt; due to the current implementation.

I don't have an example where compilation fails, but this method is called in the path of org.eclipse.jdt.core.dom.ITypeBinding.isAssignmentCompatible(ITypeBinding), which is a public API. This bug will appear when both the implicit and explicit arguments to the above method call are bindings that represent interfaces. For example:

boolean m(ITypeBinding typeBinding, ITypeBinding otherTypeBinding) {
    //suppose typeBinding and otherTypeBinding represent interface
    //bindings and that typeBinding is assignment compatible with otherTypeBinding.
    return typeBinding.isAssignmentCompatible(otherTypeBinding);
    //this will incorrectly return false.
}</comment_text>
        </comment>
        <comment>
            <comment_id>2711494</comment_id>
            <comment_count>6</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-05-24 10:46:11 -0400</when>
            <comment_text>(In reply to Raffi Khatchadourian from comment #5)
&gt; I don't have an example where compilation fails, but this method is called
&gt; in the path of
&gt; org.eclipse.jdt.core.dom.ITypeBinding.isAssignmentCompatible(ITypeBinding),
&gt; which is a public API. This bug will appear when both the implicit and
&gt; explicit arguments to the above method call are bindings that represent
&gt; interfaces. For example:
&gt; 
&gt; boolean m(ITypeBinding typeBinding, ITypeBinding otherTypeBinding) {
&gt;     //suppose typeBinding and otherTypeBinding represent interface
&gt;     //bindings and that typeBinding is assignment compatible with
&gt; otherTypeBinding.
&gt;     return typeBinding.isAssignmentCompatible(otherTypeBinding);
&gt;     //this will incorrectly return false.
&gt; }

Shouldn't this be handled by
			if (otherReferenceType.isInterface()) { // could be annotation type
				if (implementsInterface(otherReferenceType, true))
					return true;</comment_text>
        </comment>
        <comment>
            <comment_id>2711503</comment_id>
            <comment_count>7</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-24 10:49:21 -0400</when>
            <comment_text>(In reply to Till Brychcy from comment #6)
&gt; (In reply to Raffi Khatchadourian from comment #5)
&gt; &gt; boolean m(ITypeBinding typeBinding, ITypeBinding otherTypeBinding) {
&gt; &gt;     //suppose typeBinding and otherTypeBinding represent interface
&gt; &gt;     //bindings and that typeBinding is assignment compatible with
&gt; &gt; otherTypeBinding.
&gt; &gt;     return typeBinding.isAssignmentCompatible(otherTypeBinding);
&gt; &gt;     //this will incorrectly return false.
&gt; &gt; }
&gt; 
&gt; Shouldn't this be handled by
&gt; 			if (otherReferenceType.isInterface()) { // could be annotation type
&gt; 				if (implementsInterface(otherReferenceType, true))
&gt; 					return true;

Exactly.

(In reply to Raffi Khatchadourian from comment #5)
&gt; I don't have an example where compilation fails

In that case this bug has low priority to me, since I'm not convinced that it is practically relevant.

I'm quite sure if your argumentation were right, we would have hundreds of failures in our test suite, at least. It needs a corner case to make a difference, if any.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496053</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-06-14 03:29:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] Reconciler does not recognize modules referenced from JAR</short_desc>
        <thetext>Steps:

1. Have a project with one module (have a module-info.java in the root of the source folder)
2. Add a binary module in a JAR to the build path of the project.
3. Add a "requires" in the source module.

Even though the compiler finds the referenced module, the editor still reports an error. The reason is we filter out the JarPackageFragmentRoot when we look for modules if the names of the module and JAR file don't match. The following code in NameLookup needs to change:

if (root instanceof JarPackageFragmentRoot) {
  if (!isMatching(nameArray, root.getElementName().toCharArray(), prefix)) {
    continue;
  }
  ...
}

The name of the JAR containing the module should be irrelevant and the code should reflect that.</thetext>
        <comment>
            <comment_id>2720176</comment_id>
            <comment_count>1</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-06-14 03:54:12 -0400</when>
            <comment_text>The instanceof check should be for JrtPackageFragmentRoot instead of JarPackageFragmentRoot. I have this change in a WIP branch of mine :-)</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499429</id>
        <developer>Sasikanth Bharadwaj</developer>
        <developer_username>sasikanth.bharadwaj</developer_username>
        <dup_id/>
        <creation_time>2016-08-09 06:50:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9][compiler] Changes to implicit dependencies in module-info.java are sometimes not picked up by the compiler</short_desc>
        <thetext>Commit http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=9b4c6fe06310162fcf691a59705683aa5c5ce814 added a new ModuleSourcePathContainer to handle dependencies between modules projects.
With this change, implicit dependencies between modules via the 'requires public' statement are automatically added to the build path as exported class path entries.
This, however is not consistently working when module-info.java is changed

For a reproducible case, see org.eclipse.jdt.core.tests.model.ModuleBuilderTests._test_ModuleSourcePath_implicitdeps3().
When 'requires' is changed to 'requires public', compilation should succeed, but doesn't. The reason is that the project cache does not contain the package fragment roots for the implicit dependencies and it is not updated when module-info.java changes.

Need to figure out how to do that</thetext>
    </bug>
    <bug>
        <id>499890</id>
        <developer>Sasikanth Bharadwaj</developer>
        <developer_username>sasikanth.bharadwaj</developer_username>
        <dup_id/>
        <creation_time>2016-08-18 04:42:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler] Follow up changes for bug 490988</short_desc>
        <thetext>https://git.eclipse.org/r/78925 had a few comments that need to be addressed. Reproducing those comments here. Refer bug 490988 for more details

org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference.findCompatibleEnclosing(ReferenceBinding, TypeBinding, BlockScope) line 98
==&gt; compoundName can be null. While currently ProblemReporter doesn't use this compoundName, we should always set a valid compoundName.
==&gt; Also we might get confused later seeing the "unconventional use" (see comment above) applied for an unrelated IProblem ...
==&gt; I'd prefer separate instantiations of the PRB for the different cases.

org.eclipse.jdt.core.compiler.IProblem line 1474

==&gt; The heading of this group of problems says "More problems in generics".
==&gt; This is not a good classifications for the new problems.
==&gt; (similar for messages.properties)</thetext>
    </bug>
    <bug>
        <id>499960</id>
        <developer>Matthew Tamayo-Rios</developer>
        <developer_username>matthew</developer_username>
        <dup_id/>
        <creation_time>2016-08-19 01:54:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>java.lang.IllegalArgumentException: Invalid lambda deserialization</short_desc>
        <thetext>When running a SparkContext from within Eclipse that leverages Java 8 Lambdas serialization fails. 

I've eliminated the Spark instance as the issue, by successfully running the exact same code in Gradle and IntelliJ successfully completes without problems.

The code the repros this is :

SparkConf conf = new SparkConf().setAppName( "Kryptnostic Spark Datastore" )
                .setMaster( "spark://mjolnir:7077" )
                .setJars( new String[] {
                        "&lt;jar containing this class&gt;" } );
JavaSparkContext spark = new JavaSparkContext( conf );
JavaRDD&lt;String&gt; s = spark.textFile( "foo.csv );
s.foreach( l -&gt; System.out.println( l ) );

The stack trace is:

2016-08-18T20:55:21,430 WARN [task-result-getter-1] org.apache.spark.scheduler.TaskSetManager - Lost task 0.0 in stage 0.0 (TID 0, mjolnir): java.io.IOException: unexpected exception type
	at java.io.ObjectStreamClass.throwMiscException(ObjectStreamClass.java:1538)
	at java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1110)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1810)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)
	at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1993)
	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1918)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)
	at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1993)
	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1918)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)
	at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1993)
	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1918)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)
	at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1993)
	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1918)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)
	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:371)
	at org.apache.spark.serializer.JavaDeserializationStream.readObject(JavaSerializer.scala:76)
	at org.apache.spark.serializer.JavaSerializerInstance.deserialize(JavaSerializer.scala:115)
	at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:61)
	at org.apache.spark.scheduler.Task.run(Task.scala:89)
	at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:227)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at java.lang.invoke.SerializedLambda.readResolve(SerializedLambda.java:230)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1104)
	... 27 more
Caused by: java.lang.IllegalArgumentException: Invalid lambda deserialization
	at com.kryptnostic.conductor.ElConductor.$deserializeLambda$(ElConductor.java:10)
	... 37 more</thetext>
        <comment>
            <comment_id>2741732</comment_id>
            <comment_count>1</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-08-19 04:09:18 -0400</when>
            <comment_text>Thanks for the report. Could you create a stand alone minimal test case without external dependencies that reproduces this behavior? That would be of great help to find the problem.</comment_text>
        </comment>
        <comment>
            <comment_id>2741739</comment_id>
            <comment_count>2</comment_count>
            <who>Matthew Tamayo-Rios</who>
            <commenter_username>matthew</commenter_username>
            <when>2016-08-19 04:22:32 -0400</when>
            <comment_text>Sure, it won't be perfect since reproducing requires running a Spark master and slave with a lot of stuff that is path dependent.</comment_text>
        </comment>
        <comment>
            <comment_id>2741812</comment_id>
            <comment_count>3</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-08-19 07:07:39 -0400</when>
            <comment_text>(In reply to comment #2)
&gt; Sure, it won't be perfect since reproducing requires running a Spark master and
&gt; slave with a lot of stuff that is path dependent.
That's ok, just the minimal source that would help me understand what's different between this case and the other serializable lambda cases that work should be enough to get me started</comment_text>
        </comment>
        <comment>
            <comment_id>2742141</comment_id>
            <comment_count>4</comment_count>
            <who>Matthew Tamayo-Rios</who>
            <commenter_username>matthew</commenter_username>
            <when>2016-08-21 07:14:45 -0400</when>
            <comment_text>Download Spark 1.6.2 for Scala 2.10 here: http://spark.apache.org/downloads.html

Running spark is a simple as 

tar -xzvf spark-1.6.2-bin-hadoop2.6.tgz
cd spark-1.6.2-bin-hadoop2.6
sbin/start-all.sh

Take note of the last part of the log name as it will be computername or computername.local. You will have to update src/main/java/com/kryptnostic/sparks/EclipseBugRepro.java with the correct Spark master for your machine. It is sensitive to the presence of .local and it doesn't seem to not like having a network connection available. 

I've created a branch in one of our repositories to make the repro as easy as possible. 

git clone git@github.com:kryptnostic/hazelcast-spark-ha.git
git checkout feature/eclipse-bug-repo
./gradlew build -x tests --daemon
./gradlew check 

The build will pass in gradle with the following version of java.

java version "1.8.0_45"
Java(TM) SE Runtime Environment (build 1.8.0_45-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)

Now run: 

./gradlew eclipse 

Import into eclipse and run the src/test/java/com/kryptnostic/sparks/EclipseTriggerBug.java test

This will fail in Eclipse Version: Neon Release (4.6.0)
Build id: 20160613-1800 and you will see:

2016-08-21T04:00:31,489 WARN [task-result-getter-0] org.apache.spark.scheduler.TaskSetManager - Lost task 0.0 in stage 0.0 (TID 0, 192.168.1.180): java.io.IOException: unexpected exception type
	at java.io.ObjectStreamClass.throwMiscException(ObjectStreamClass.java:1538)
	at java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1110)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1810)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)
	at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1993)
	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1918)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)
	at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1993)
	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1918)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)
	at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1993)
	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1918)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)
	at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1993)
	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1918)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)
	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:371)
	at org.apache.spark.serializer.JavaDeserializationStream.readObject(JavaSerializer.scala:76)
	at org.apache.spark.serializer.JavaSerializerInstance.deserialize(JavaSerializer.scala:115)
	at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:61)
	at org.apache.spark.scheduler.Task.run(Task.scala:89)
	at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:227)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at java.lang.invoke.SerializedLambda.readResolve(SerializedLambda.java:230)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1104)
	... 27 more
Caused by: java.lang.IllegalArgumentException: Invalid lambda deserialization
	at com.kryptnostic.sparks.EclipseBugRepro.$deserializeLambda$(EclipseBugRepro.java:7)
	... 37 more</comment_text>
        </comment>
        <comment>
            <comment_id>2742142</comment_id>
            <comment_count>5</comment_count>
            <who>Matthew Tamayo-Rios</who>
            <commenter_username>matthew</commenter_username>
            <when>2016-08-21 07:16:09 -0400</when>
            <comment_text>One more comment on running ./gradlew build first. It is necessary build that jar containing the lambda on the classpath.</comment_text>
        </comment>
        <comment>
            <comment_id>2742482</comment_id>
            <comment_count>6</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-08-22 14:45:11 -0400</when>
            <comment_text>(In reply to comment #5)
&gt; One more comment on running ./gradlew build first. It is necessary build that
&gt; jar containing the lambda on the classpath.
oops... I was hoping for a simpler testcase without all the dependencies to spark etc... I'm on a windows machine and I don't think I will be able to download and run all that stuff. We can do something else... Could you paste the output of javap on the class EclipseBugRepro here? javap -p -v -s -c should have all the details. Also paste the code of the functional interface that extends java.io.Serializable that fails deserialization. Let's see if I can create a test myself</comment_text>
        </comment>
        <comment>
            <comment_id>2759043</comment_id>
            <comment_count>7</comment_count>
            <who>Adriano Fernandes</who>
            <commenter_username>adrianosf</commenter_username>
            <when>2016-10-03 14:29:29 -0400</when>
            <comment_text>I register a bug (https://bugs.eclipse.org/bugs/show_bug.cgi?id=503118) which may be similar to this one, sorry if it's duplicate. It has a simple test case.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500636</id>
        <developer>Sasikanth Bharadwaj</developer>
        <developer_username>sasikanth.bharadwaj</developer_username>
        <dup_id/>
        <creation_time>2016-09-01 04:18:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler][9] New flags/keywords/attributes related to module declaration need to be supported</short_desc>
        <thetext>The exports keyword may be followed by the modifier dynamic. This specifies that the package is to be exported only at run time, and is concealed at compile time. 
There's also the corresponding flag 0x0040 (ACC_DYNAMIC_PHASE) in the exports section of the module attribute that needs to be supported

The requires keyword may be followed by the modifier static. This specifies that the dependence, while mandatory at compile time, is optional at run time. 

There are also a bunch of new attributes that can be added to the module-info.class that should be looked at

Details can be found at  http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html#jigsaw-2.5</thetext>
        <comment>
            <comment_id>2772905</comment_id>
            <comment_count>1</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-04 04:48:49 -0400</when>
            <comment_text>Recent changes observed in the doc http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html#jigsaw-2.5

requires may be followed by transitive or static. public is no longer valid.

Imports are allowed in module-info.java and annotations are allowed at the top level

New opens keyword which is similar to exports, deals with accessibility of packages via reflection

New notion of an 'open' module and normal module (with out the keyword open)

It is permitted for the to clause of an exports or opens statement to specify a module which is not observable

None of the other keywords/modifiers mentioned in comment 0 are valid. The attributes still exist and need to be looked at</comment_text>
        </comment>
        <comment>
            <comment_id>2773981</comment_id>
            <comment_count>2</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-08 03:33:08 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/84641</comment_text>
        </comment>
        <comment>
            <comment_id>2774065</comment_id>
            <comment_count>3</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-08 05:36:58 -0500</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/84641 was merged to [BETA_JAVA9].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=ee82852b5ab7e8b9dc824e711ee203525a910a0f</comment_text>
        </comment>
        <comment>
            <comment_id>2774069</comment_id>
            <comment_count>4</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-08 05:38:31 -0500</when>
            <comment_text>(In reply to comment #3)
&gt; Gerrit change https://git.eclipse.org/r/84641 was merged to [BETA_JAVA9].
&gt; Commit:
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=ee82852b5ab7e8b9dc824e711ee203525a910a0f
This commit is to allow the to clause in an exports statement to specify a module that is not observable. Changes to grammar to follow</comment_text>
        </comment>
        <comment>
            <comment_id>2776021</comment_id>
            <comment_count>5</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-15 03:24:12 -0500</when>
            <comment_text>(In reply to comment #4)
&gt; (In reply to comment #3)
&gt; &gt; Gerrit change https://git.eclipse.org/r/84641 was merged to [BETA_JAVA9].
&gt; &gt; Commit:
&gt; &gt;
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=ee82852b5ab7e8b9dc824e711ee203525a910a0f
This commit causes open declaration from to clause of an exports statement to fail, because it is no longer resolved and hence does not have a binding. @Jay, what's the best way to fix this?</comment_text>
        </comment>
        <comment>
            <comment_id>2776030</comment_id>
            <comment_count>6</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-15 03:42:00 -0500</when>
            <comment_text>(In reply to Sasikanth Bharadwaj from comment #5)
&gt; This commit causes open declaration from to clause of an exports statement
&gt; to fail, because it is no longer resolved and hence does not have a binding.
&gt; @Jay, what's the best way to fix this?

If the module can be found from the environment, then we have to take care of this in SelectionEngine to look for the module explicitly and create Java elements from thence. I will take a look.</comment_text>
        </comment>
        <comment>
            <comment_id>2778485</comment_id>
            <comment_count>7</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-11-22 04:15:50 -0500</when>
            <comment_text>For a source module, the following changes in module-info.java:

Annotations Supported above ModuleDeclaration 
eg: @Foo(1) @Foo(2) @Bar 
Module M.N {}

Keywords Added  : open, opens, transitive, static

eg: open module moduleName {
  require transitive moduleName;
  require static moduleName2;
 opens &lt;package&gt; [to &lt;module&gt;]
}

Keyword removed : public</comment_text>
        </comment>
        <comment>
            <comment_id>2782279</comment_id>
            <comment_count>8</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-12-02 06:22:18 -0500</when>
            <comment_text>More changes 

With clause can specify multiple implementations
service implementation need not specify a public no arg constructor if it defines a public static method named 'provider' with no formal parameters</comment_text>
        </comment>
        <comment>
            <comment_id>2783736</comment_id>
            <comment_count>9</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-12-07 05:13:36 -0500</when>
            <comment_text>https://git.eclipse.org/r/#/c/86228/ has a WIP patch with grammar changes for the following

Allow imports in module-info
'open' modifier for a module
modifiers for requires statement - transitive and static
Recovery of module-info. Module statements can be recovered now, we still need support in RecoveredModule to populate the nodes properly, but the parser is equipped to deal with recovery
Allow with clause in provides statement to specify multiple implementation names
Also includes the refactoring requested by Manoj - RequiresStatement, ProvidesStatement, UsesStatement and ExportsStatement with declarationSourceStart and end populated properly. 

The last two led to touching a lot of files everywhere (in the model, batch compiler and completion). Completion would be completely broken :-), as I already discussed with Manoj. Will also impact the dom work in progress
@Manoj/Jay, just a heads up so you're abreast with what's coming and can prepare for any possible effects on any of your work in progress. Would also appreciate if you could try it out and let me know any concerns. I will continue work on this to add pending features in the grammar and cleanup</comment_text>
        </comment>
        <comment>
            <comment_id>2785307</comment_id>
            <comment_count>10</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-12 01:15:02 -0500</when>
            <comment_text>From what I have seen, nothing concerning. Some areas within model, like code select (e.g. SelectionOnModuleReference) might need to be re-looked, but that's fine.</comment_text>
        </comment>
        <comment>
            <comment_id>2786077</comment_id>
            <comment_count>11</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-12-14 01:33:20 -0500</when>
            <comment_text>Pushed directly via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=a6ef9792a997e976a5656ba10e946bbed8770443 after running tests locally and confirming that all pass. There seems to be some issue with the hipps again, all builds are just queuing up waiting for executors.
With this, only annotation related changes are pending. Everything else has been taken care of (hopefully).</comment_text>
        </comment>
        <comment>
            <comment_id>2786079</comment_id>
            <comment_count>12</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-12-14 01:37:20 -0500</when>
            <comment_text>(In reply to comment #10)
&gt; From what I have seen, nothing concerning. Some areas within model, like code
&gt; select (e.g. SelectionOnModuleReference) might need to be re-looked, but that's
&gt; fine.
Thanks Jay, I changed a few things there, to ensure existing functionality is not broken, but support for opened packages in the model, as well as selection for those is still pending</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500637</id>
        <developer>Sasikanth Bharadwaj</developer>
        <developer_username>sasikanth.bharadwaj</developer_username>
        <dup_id/>
        <creation_time>2016-09-01 04:24:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler][9] Implement Target Platform equivalent in jdt.core for modules</short_desc>
        <thetext>The module path container currently handles only module projects in the workspace. This should be extended to include binary modules as well, so that adding a dependency to module-info.java would automatically update the module path. For this to be possible, we need a target platform equivalent entity which can be consulted by the container to resolve modules</thetext>
        <comment>
            <comment_id>2747255</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-06 06:55:04 -0400</when>
            <comment_text>In https://wiki.eclipse.org/JDT_Core/Java9/Open_items#Module_Container it sounds like the target platform is only used for {user, system} libraries, but not for workspace projects?

I'm wondering if for our use cases we'd like to have a registry that contains all three kinds of modules, i.e., including workspace projects. Perhaps the only difference would be: we'd like to persist the registered libraries with their (external) locations, whereas the project&lt;-&gt;module mapping can be populated during workbench initialization. Not sure, perhaps even persisting this for workspace projects makes sense?

How is PDE handling workspace projects? How are bundle references resolved to workspace projects? How is their state (is it PDEState) populated?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>502829</id>
        <developer>Sasikanth Bharadwaj</developer>
        <developer_username>sasikanth.bharadwaj</developer_username>
        <dup_id/>
        <creation_time>2016-09-30 04:32:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9][compiler] Follow up tasks after (if) the patch for bug 500265 goes in</short_desc>
        <thetext>This bug is intended to capture comments/concerns raised during the review of the patch for bug 500265, which could not be incorporated straight away either because they needed some thought or they would lead to lot of changes that are not directly relevant to the main change in that patch

Some tasks already identified

1. Investigate why MODULES_CACHE in ClasspathJrt needs to be static
2. UNNAMED_MODULE_CONTEXT can be made to behave like a regular module context
3. ModuleBinding uses several names for the same thing which is confusing. Use consistent names for each kind of dependency, context etc and remove unnecessary methods</thetext>
        <comment>
            <comment_id>2757920</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-30 05:14:05 -0400</when>
            <comment_text>(In reply to Sasikanth Bharadwaj from comment #0)
&gt; 1. Investigate why MODULES_CACHE in ClasspathJrt needs to be static

Now that you mentioned, I re-looked at that after I first wrote that and realized that there's no code to remove the cache at all!</comment_text>
        </comment>
        <comment>
            <comment_id>2760631</comment_id>
            <comment_count>2</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-05 02:58:56 -0400</when>
            <comment_text>Another missing piece - there is no code today to check for modules with the same name - we should detect this and prevent this from occurring, whether in IDE or batch compiler</comment_text>
        </comment>
        <comment>
            <comment_id>2760635</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-05 03:18:29 -0400</when>
            <comment_text>Can I throw in a couple more:

1. Today we allow packages to be exported to the same current module itself.
2. We don't validate presence of packages that are exported.</comment_text>
        </comment>
        <comment>
            <comment_id>2760682</comment_id>
            <comment_count>4</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-05 04:38:12 -0400</when>
            <comment_text>(In reply to comment #3)
&gt; Can I throw in a couple more:
&gt; 
&gt; 1. Today we allow packages to be exported to the same current module itself.
&gt; 2. We don't validate presence of packages that are exported.

I planned to address these as part of bug 500716 :-). Copied your comment there.</comment_text>
        </comment>
        <comment>
            <comment_id>2761842</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-06 08:11:00 -0400</when>
            <comment_text>(In reply to Sasikanth Bharadwaj from bug 500265 comment #25)
&gt; (In reply to comment #22)
&gt; &gt; If we want to support compiling multiple modules at once, then probably *all*
&gt; &gt; call paths towards LE.getType(char[][]) must be replaced by the module-aware
&gt; &gt; variant getType(char[]), right?
&gt; &gt; 
&gt; &gt; I see particular difficulties concerning UnresolvedReferenceBinding, which
&gt; &gt; doesn't seem to have a reference to a current module anywhere near.
&gt; &gt; 
&gt; &gt; So, for the case that two modules privately depend on classes sharing the same
&gt; &gt; name but served from different modules, we cannot tell them apart, but will
&gt; &gt; attempt lookup from the unnamed module? Do we actually resolve all URB from the
&gt; &gt; unnamed module? That'd be pretty bad.
&gt; Yes, URB case was particularly unpleasant, but I couldn't think of a way to
&gt; resolve URBs in the context of a module other than by adding this context to
&gt; the URB itself. But then, I felt it makes sense to resolve a URB in the
&gt; unnamed context and then check if the resolved binding is accessible where
&gt; we have the relevant context available. A URB anyway is a stand-in for
&gt; something we don't know much about, to be resolved when needed, isn't it?

Please don't confuse MissingTypeBinding vs. UnresolvedReferenceBinding. The former indicates a problem, the latter is common usage when creating a BinaryTypeBinding without transitively pulling in the entire universe. When resolving a URB this *must* happen with the correct module context.

Things get tricky, when an URB represents a type that is not visible to the current module. I hold, however, that we should not invest any efforts into resolving that tricky case before we have a specification in hands that tells us what to do.</comment_text>
        </comment>
        <comment>
            <comment_id>2764481</comment_id>
            <comment_count>6</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-08 14:50:10 -0400</when>
            <comment_text>Expanding on the problem I'm seeing with transitive dependencies:

What should the compiler do if:
- module M exports (via the package) a class A
- module M does *not* export class B
  - Bonus: M requires (non-public) B from module O
- class A defines a public method m with B in its signature
  - Bonus: class A has multiple overloaded methods named m
- module N refers to A
  - Bonus: N refers to A.m
Are such questions discussed/answered anywhere?

This could lead us into the dreaded land of
  The type {0} cannot be resolved. It is indirectly referenced from required .class files
which to-date we claim to be unspecified gray area (notably with OGSi).
Is this also a gray area in Java 9 / Jigsaw?
Multiple solutions are possible, so any common sense implementation in JDT
may in the end be plain wrong.</comment_text>
        </comment>
        <comment>
            <comment_id>2765495</comment_id>
            <comment_count>7</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-12 05:07:04 -0400</when>
            <comment_text>(In reply to comment #6)
&gt; Expanding on the problem I'm seeing with transitive dependencies:
&gt; 
&gt; What should the compiler do if:
&gt; - module M exports (via the package) a class A
&gt; - module M does *not* export class B
&gt; - Bonus: M requires (non-public) B from module O
&gt; - class A defines a public method m with B in its signature
&gt; - Bonus: class A has multiple overloaded methods named m
&gt; - module N refers to A
&gt; - Bonus: N refers to A.m
&gt; Are such questions discussed/answered anywhere?
&gt; 
&gt; This could lead us into the dreaded land of
&gt; The type {0} cannot be resolved. It is indirectly referenced from required
&gt; .class files
&gt; which to-date we claim to be unspecified gray area (notably with OGSi).
&gt; Is this also a gray area in Java 9 / Jigsaw?
&gt; Multiple solutions are possible, so any common sense implementation in JDT
&gt; may in the end be plain wrong.
It does take us exactly into the 'indirectly referenced from required .class files' territory. If i remember correctly, it is mentioned in the State of the Module System doc that this is exactly the scenario where implicit dependencies are needed, so that instead of hoping every client of module M will also add a dependency to module O, M can 'require public O'. And the word 'hope' is not my addition, it's in the document. To me, this, like everything else in java9 seems like a gray area</comment_text>
        </comment>
        <comment>
            <comment_id>2765497</comment_id>
            <comment_count>8</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-12 05:10:23 -0400</when>
            <comment_text>And implicit dependency may not be the right word, I guess that is no longer being used anywhere. Implied Readability is what sotms says about 'requires public', so I need to update my vocabulary</comment_text>
        </comment>
        <comment>
            <comment_id>2766122</comment_id>
            <comment_count>9</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-13 08:54:07 -0400</when>
            <comment_text>(In reply to Sasikanth Bharadwaj from comment #7)
&gt; It does take us exactly into the 'indirectly referenced from required .class
&gt; files' territory. If i remember correctly, it is mentioned in the State of
&gt; the Module System doc that this is exactly the scenario where implicit
&gt; dependencies are needed, so that instead of hoping every client of module M
&gt; will also add a dependency to module O, M can 'require public O'. And the
&gt; word 'hope' is not my addition, it's in the document. To me, this, like
&gt; everything else in java9 seems like a gray area

You are referring to this paragraph?

  "One solution to this problem is to hope that every author of every module that both depends upon the java.sql module and contains code that uses Logger objects returned by the getParentLogger method remembers also to declare a dependence upon the java.logging module."

They continue to say "This approach is unreliable" and use this as the motivation for introducing "requires public".

That's, however, a much weaker problem, than what I was illustrating. Method returns are a piece of cake compared to overload resolution based on parameter types which may not all be readable for the caller.

The closest we get in SOTMS is:

  "In general, if one module exports a package containing a type whose signature refers to a package in a second module then the declaration of the first module should include a requires public dependence upon the second. This will ensure that other modules that depend upon the first module will automatically be able to read the second module and, hence, access all the types in that module’s exported packages."

See the word "should"? Does it carry any implementable meaning? I assume "signature" is to generalize over the signatures of all public members. The conflict I'm seeing is:

- it is impossible to enforce that "should", because historically, API types do have signatures mentioning non-API types (API leaks). It's bad design but without enforcement by tools (like API tools does) its bogus to assume soundness in this regard.

- if types with "API leaks" exist, the compiler is back to being unspecified.

- the above doesn't even mention the case of non-exported packages from the same module.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>503074</id>
        <developer>Tagir Valeev</developer>
        <developer_username>lany</developer_username>
        <dup_id/>
        <creation_time>2016-10-03 10:50:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][compiler] Eclipse does not issue an error when inheriting an interface with override-equivalent signature</short_desc>
        <thetext>Consider the following code:

public interface Parent&lt;T&gt; {
	default void foo(String x) {System.out.println(x);}
	void foo(T x);
	
	@FunctionalInterface
	interface StringChild extends Parent&lt;String&gt; {};
}

Eclipse Neon.1 Release (4.6.1) (org.eclipse.jdt.core_3.12.1.v20160829-0950.jar) does not issue any error or warning on this interface. However javac refuses to compile it with the following message:

Parent.java:8: error: interface StringChild inherits abstract and default for foo(String) from types Parent and Parent
        interface StringChild extends Parent&lt;String&gt; {};
        ^
Parent.java:7: error: Unexpected @FunctionalInterface annotation
        @FunctionalInterface
        ^
  StringChild is not a functional interface
    no abstract method found in interface StringChild
2 errors

I think, this case is covered by JLS 9.4.1.3:
https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.4.1.3

&gt; If an interface I inherits a default method whose signature is override-equivalent with another method inherited by I, then a compile-time error occurs. (This is the case whether the other method is abstract or default.) 

I think, Eclipse should report an error here as well.</thetext>
        <comment>
            <comment_id>2759308</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-04 00:34:03 -0400</when>
            <comment_text>I see this on the latest I build too.

Stephan/Sasi, can you confirm if this is indeed a bug on our side?

BTW, if I move the abstract foo method to another interface in the hierarchy, then both compilers accept that.</comment_text>
        </comment>
        <comment>
            <comment_id>2759387</comment_id>
            <comment_count>2</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-04 02:53:47 -0400</when>
            <comment_text>(In reply to comment #1)
&gt; I see this on the latest I build too.
&gt; 
&gt; Stephan/Sasi, can you confirm if this is indeed a bug on our side?
&gt; 
&gt; BTW, if I move the abstract foo method to another interface in the hierarchy,
&gt; then both compilers accept that.
I remember seeing a duplicate sometime ago, that we do not report name clash between default and abstract methods in some cases. Will dig it out, but to answer your question, we do have a bug in this area and I believe it is not a regression (recent or otherwise)</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506461</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-10-24 14:41:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Full build fails when there multiple source folders in a Java project</short_desc>
        <thetext>Looks like the design of Classpath locations doesn't take into account that a Java project can contain multiple source folders and only one of them will physically contain a module-info.java. In that scenario, both the source folders share the same module and all the source files from the other module (the one that doesn't contain the module-info) as well should be considered part of the module. There are scenarios where this doesn't happen. For e.g. a clean + buid.

In AbstractImageBuilder.addAllSourceFiles(), we consider each source location individually and look for module-info in them. But we must also make sure that all source locations in a particular project should share the module. Additionally we could also report multiple module-info early (rather than waiting for the compiler to report an error).</thetext>
        <comment>
            <comment_id>2769650</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-24 15:09:50 -0400</when>
            <comment_text>Created attachment 265030
Temporary fix

This is the safest and minimalist fix I can think of.

Sasi, let me know if there's any provision to get access to modules from other source locations early in the build.</comment_text>
        </comment>
        <comment>
            <comment_id>2769704</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-25 01:39:37 -0400</when>
            <comment_text>The fix was released but still need to revisited to better support at design level.

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=288a70caf87a5129f236aa9b79387a30d5a666f8</comment_text>
        </comment>
        <comment>
            <comment_id>2769705</comment_id>
            <comment_count>3</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-25 02:06:26 -0400</when>
            <comment_text>(In reply to comment #1)
&gt; Created attachment 265030
&gt; Temporary fix
&gt; 
&gt; This is the safest and minimalist fix I can think of.
&gt; 
&gt; Sasi, let me know if there's any provision to get access to modules from other
&gt; source locations early in the build.
You're right. We should move away from the earlier notion of each source folder being a module. So instead of every ClasspathLocation also being an IModulePathEntry, we would need to build the appropriate IModulePathEntry for all folders. Should be possible without an overhaul</comment_text>
        </comment>
        <comment>
            <comment_id>2769720</comment_id>
            <comment_count>4</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-25 03:52:42 -0400</when>
            <comment_text>*** Bug 506483 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
        <comment>
            <comment_id>2776402</comment_id>
            <comment_count>5</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-16 01:06:28 -0500</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/84863 was merged to [BETA_JAVA9].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=75c83fee1def803bd86d5ae889b845d131a1b5e5</comment_text>
        </comment>
        <comment>
            <comment_id>2776403</comment_id>
            <comment_count>6</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-16 01:10:21 -0500</when>
            <comment_text>(In reply to comment #5)
&gt; Gerrit change https://git.eclipse.org/r/84863 was merged to [BETA_JAVA9].
&gt; Commit:
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=75c83fee1def803bd86d5ae889b845d131a1b5e5

@Jay, would appreciate if you can try out and see, especially the error reporting part - if it is the standard way or needs to be improved</comment_text>
        </comment>
        <comment>
            <comment_id>2776404</comment_id>
            <comment_count>7</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-16 01:12:39 -0500</when>
            <comment_text>(In reply to comment #6)
&gt; (In reply to comment #5)
&gt; &gt; Gerrit change https://git.eclipse.org/r/84863 was merged to [BETA_JAVA9].
&gt; &gt; Commit:
&gt; &gt;
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=75c83fee1def803bd86d5ae889b845d131a1b5e5
&gt; 
&gt; @Jay, would appreciate if you can try out and see, especially the error
&gt; reporting part - if it is the standard way or needs to be improved

Another thing to think about - Do we need similar change on the batch compiler as well?</comment_text>
        </comment>
        <comment>
            <comment_id>2777303</comment_id>
            <comment_count>8</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-18 02:03:16 -0500</when>
            <comment_text>(In reply to Sasikanth Bharadwaj from comment #6)
&gt; @Jay, would appreciate if you can try out and see, especially the error
&gt; reporting part - if it is the standard way or needs to be improved

This looks good. Better than just reporting a duplicate type like we do for package-info.

BTW, some of the code (e.g. JavaProject#isModuleProject()) doesn't seem to be used. DO you have plan for that?</comment_text>
        </comment>
        <comment>
            <comment_id>2777324</comment_id>
            <comment_count>9</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-18 03:24:29 -0500</when>
            <comment_text>(In reply to comment #8)
&gt; (In reply to Sasikanth Bharadwaj from comment #6)
&gt; &gt; @Jay, would appreciate if you can try out and see, especially the error
&gt; &gt; reporting part - if it is the standard way or needs to be improved
&gt; 
&gt; This looks good. Better than just reporting a duplicate type like we do for
&gt; package-info.
&gt; 
&gt; BTW, some of the code (e.g. JavaProject#isModuleProject()) doesn't seem to be
&gt; used. DO you have plan for that?

I thought they were being used. Will remove those, can be added later when required. May have just seeped in from other experiments</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506487</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-10-25 04:49:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] Handle different projects with same module name in the workspace</short_desc>
        <thetext>Created attachment 265033
Sample projects

P20161024-2040

- Import attached projects.
- Open PN1 - module-info.java. It has the error:
The type java.lang.Object cannot be resolved. It is indirectly referenced from required .class files
- Open PN1 - p.C.java. NPE is logged in Error Log view:

java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.canBeSeenBy(PackageBinding.java:273)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:205)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findImport(CompilationUnitScope.java:476)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findSingleImport(CompilationUnitScope.java:531)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInImports(CompilationUnitScope.java:407)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:455)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1075)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1255)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:185)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:119)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:136)
	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:95)
	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:420)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:174)</thetext>
        <comment>
            <comment_id>2769792</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-25 07:44:28 -0400</when>
            <comment_text>Here's what's happening:

1. The project is at compliance 9 and has a valid module-info.
2. So, everything we compile in this project is compiled with that module context. For e.g., we look for java.lang.Object from java.base.
3. But the project has only a JDK 8, which has no notion of module or java.base. Hence the Object can't be resolved error.

We need to fix two things:
First, the NPE. A simple null check in PackageBinding.canBeSeenBy() should be enough.

The second is, we should report a better build path error (if possible) rather than can't resolve Object error.</comment_text>
        </comment>
        <comment>
            <comment_id>2769795</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-25 07:51:01 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #1)
&gt; The second is, we should report a better build path error (if possible)
&gt; rather than can't resolve Object error.

I am thinking when we are compiling/resolving a source module-info, we should look for a java.base in the environment/buildpath and warn the user.</comment_text>
        </comment>
        <comment>
            <comment_id>2769799</comment_id>
            <comment_count>3</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-10-25 07:59:56 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #1)
&gt; 3. But the project has only a JDK 8

Both the projects are JDK 9 projects. Sorry, I was using the JRE and not EE9.</comment_text>
        </comment>
        <comment>
            <comment_id>2769802</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-25 08:04:01 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #1)
&gt; 3. But the project has only a JDK 8, which has no notion of module or
&gt; java.base. Hence the Object can't be resolved error.

This was incorrect. The workspace had a specific JRE and not a EE in its build path. The absence of a JDK with that name forced to use the default JDK 8 in my setup.

With that, the real cause is the presence of two modules with the same name. We don't yet handle this situation in the module system. We have this code in NameLookup:

		if (modules.length == 1) { // TODO what to do??
			return new Answer(modules[0]);
		}

We end up returning null instead of not choosing one of the available.</comment_text>
        </comment>
        <comment>
            <comment_id>2776446</comment_id>
            <comment_count>5</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-16 03:27:54 -0500</when>
            <comment_text>Adjusted the title to describe the real issue. Will start on this</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499730</id>
        <developer>Clovis Seragiotto</developer>
        <developer_username>clovis.seragiotto</developer_username>
        <dup_id/>
        <creation_time>2016-08-16 06:38:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null][1.8] NullPointerException on array contents access, even though null analysis says the program is OK</short_desc>
        <thetext>The following program throws a NPE but the Null Analysis says it is ok (no errors, no warnings).

import org.eclipse.jdt.annotation.NonNull;
public class Foo {
	public static void main(String[] args) {
		@NonNull Object[] x = new @NonNull Object[1];
		x[0].toString();
	}
}</thetext>
        <comment>
            <comment_id>2765972</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-13 04:06:58 -0400</when>
            <comment_text>Interesting...

Stephan, this one's for you :)</comment_text>
        </comment>
        <comment>
            <comment_id>2766047</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-13 06:36:00 -0400</when>
            <comment_text>Arrays are a pain :)

Basically, what's missing is a constructor: when creating the array we should be able to provide a method that consistently fills the array with non-null content.

To solve this we could
 - introduce a new annotation for uninitialized arrays, or
 - issue a general notice ("info"?) that "new @NonNull Object[1]" doesn't live up to its own promise, never.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501106</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-09-08 16:20:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Follow-up after bug 111208</short_desc>
        <thetext>The fix for bug 111208 leaves a few loose ends:

- At 1.7 we still perform the illegal recursive capture,
  simply because my compensation only works in 1.8 inference.
  Thus, GTT.test1118() still works with a bogus expectation at 1.7-

- New reduction rule in ConstraintTypeFormula still needs to be approved

- Test AMT.test087() demonstrates this oddity:
   javac7: accept
   javac8: reject
   ecj-1.7 reject
   ecj-1.8 accept
  I hold that accept should be the right answer moving forward.</thetext>
        <comment>
            <comment_id>2748739</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-08 17:36:08 -0400</when>
            <comment_text>In http://stackoverflow.com/a/39400532/4611488 I myself argued why a constraint ⟨T#0 = ?⟩ reduces to FALSE. As such we now have this inconsistency that for '&lt;=' we perform our (illegal) reduction, whereas for '=' we don't.

We should check if that perhaps reflects a similar inconsistency in javac. Perhaps bug 111208 was a bug in javac all along.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>502327</id>
        <developer>Alexander Rookey</developer>
        <developer_username>atrookey</developer_username>
        <dup_id/>
        <creation_time>2016-09-27 17:11:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler] Problem marker 'method not applicable for the arguments'</short_desc>
        <thetext>Created attachment 264459
Source code to reproduce bug

The attached code Bug.java compiles with javac.  However, problem markers are added on line 15 in Eclipse.

The problem markers:

The method foo(Bug.ClassA&lt;? super String,Bug.ExampleType,VC,VO&gt;) in the type Bug is not applicable for the arguments (Bug.ClassC&lt;Bug.ExampleType&gt;)	Bug.java	/Bug/src/example1	line 15	Java Problem

Type mismatch: cannot convert from Bug.ClassC&lt;Bug.ExampleType&gt; to Bug.ClassA&lt;? super String,Bug.ExampleType,VC,VO&gt;	Bug.java	/Bug/src/example1	line 15	Java Problem</thetext>
        <comment>
            <comment_id>2756129</comment_id>
            <comment_count>1</comment_count>
            <who>Alexander Rookey</who>
            <commenter_username>atrookey</commenter_username>
            <when>2016-09-27 17:13:24 -0400</when>
            <comment_text>Created attachment 264460
Screenshot</comment_text>
        </comment>
        <comment>
            <comment_id>2756138</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-27 17:59:16 -0400</when>
            <comment_text>From the code:

  // The issue appears to be caused by ClassC&lt;T&gt;.NestedClassC.  Extracting it into its own
  // top level class causes build errors to disappear.

It suffices to declare ClassC and NestedClassC as static - and adjust references ClassC&lt;X&gt;.NestedClassC to ClassC.NestedClassC.

This change removes the dependency from NestedClassC on the type parameter of its enclosing ClassC, i.e., NestedClassC is no longer generic.


I further reduced the example to:
//---
public class Bug {

  public void execute() {
    foo(bar(new ExampleType()));
  }

  public &lt;VC&gt; void foo(ClassB&lt;VC&gt; a) {}

  public &lt;T&gt; ClassC&lt;T&gt; bar(T t) {
    return null;
  }

  public class ClassC&lt;T&gt; extends ClassB&lt;ClassC&lt;T&gt;.NestedClassC&gt; {
    public class NestedClassC {}
  }

  public abstract static class ClassB&lt;VC&gt; {}

  public class ExampleType {}
}
//---

to yield:
----------
1. ERROR in /tmp/Bug.java (at line 4)
        foo(bar(new ExampleType()));
        ^^^
The method foo(Bug.ClassB&lt;VC&gt;) in the type Bug is not applicable for the arguments (Bug.ClassC&lt;Bug.ExampleType&gt;)
----------
2. ERROR in /tmp/Bug.java (at line 4)
        foo(bar(new ExampleType()));
            ^^^^^^^^^^^^^^^^^^^^^^
Type mismatch: cannot convert from Bug.ClassC&lt;Bug.ExampleType&gt; to Bug.ClassB&lt;VC&gt;
----------

In order to accept, type inference would have to instantiate VC to ClassB&lt;ClassC&lt;ExampleType&gt;.NestedClassC&gt;. Not sure why it fails.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507109</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-11-05 18:25:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] Consider @NonNullByDefault in module-info</short_desc>
        <thetext>We have been waiting for a node above package-info where @NNBD could be specified for larger units of code.

It seems that module-info will accept annotations, and that would be a good match for @NNBD.</thetext>
    </bug>
    <bug>
        <id>496136</id>
        <developer>Stefan Xenos</developer>
        <developer_username>sxenos</developer_username>
        <dup_id/>
        <creation_time>2016-06-14 15:23:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[newindex] Implement a source (.java file) indexer for the new index</short_desc>
        <thetext>Currently the new index can only read .jar or .class files. We should also add support for indexing .java files. This will handle the case where the autobuilder is disabled.

In the case where the autobuilder is enabled, it probably makes sense to delay indexing (of .java files) until after the build completes and then index the derived .class files rather than the original .java files. This should speed up indexing considerably. In the case where the autobuilder is disabled, we should index the .java files directly.

In both cases, the NdResourceFile should point to the ".java" file as the source of truth for its fingerprint tests.</thetext>
        <comment>
            <comment_id>2722217</comment_id>
            <comment_count>1</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-06-20 16:03:14 -0400</when>
            <comment_text>The implementation of the old indexer can be found in SourceElementParser and SourceIndexerRequestor.</comment_text>
        </comment>
        <comment>
            <comment_id>2760038</comment_id>
            <comment_count>2</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-10-04 13:49:42 -0400</when>
            <comment_text>Still an issue. Need to follow up.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497513</id>
        <developer>Stefan Xenos</developer>
        <developer_username>sxenos</developer_username>
        <dup_id/>
        <creation_time>2016-07-07 13:21:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[newindex] Rework the JDT model cache to work better with the new index</short_desc>
        <thetext>This bug relates to the new JDT index being worked on in bug 481796.


THE PROBLEM:
------------

To get optimal performance from the new index, we need to use different access patterns since the bottlenecks are in a different place. With the old (existing) code, opening a new class for the first time was slow and the IBinaryType implementation used a lot of memory. For this reason, the cache worked like this:

1. The first time a type is referenced (or any of its contents), recursively walk up the model and build all the ancestor model nodes.
2. When the node for a class is hit, load the class file and then do a depth-first traversal of the class's contents, inserting them into the cache. (I'll refer to this as the "eager top-down approach").
3. Children of a class file (methods, variables, and whatnot) don't contain any code for populating their own cache entries. They just rely on the fact that their container would have already inserted their data into the cache in step 2.

Step 2 is a problem for the new index.

With the new index, referencing a class for the first time is very cheap and so is the implementation of IBinaryType. However, there is an additional (but small) cost for each additional node read from the index. If you only read the bits you need as you need them, the index is much faster than reading the class files... but if you exhaustively read all the contents of a class from the index, you lose most of that speed-up.

Currently, the newindex branch contains code to suppress the depth-first traversal of in step 2 (and the cache itself) whenever reading data from the index. This addresses the speed problem but has been causing test failures (and presumably API breakage) because methods don't find their data in the index in step 3 and don't currently have the ability to construct that data if its missing. So clearly this has to change.


PROPOSAL:
---------

I propose the following algorithm for constructing (and caching) class contents:

1. The first time a class is referenced, it is loaded from disk using ClassFileReader and a model is built just for the class. No depth-first traversal occurs and nothing is inserted into the existing cache.
2. The ClassFileReader is inserted into a special queue for the indexer. The indexer will give top priority for indexing those classes and it will use the existing ClassFileReader rather than reading from disk if it exists.
3. Children of a class will construct their data lazily on first access, based on their parent's IBinaryType. If the class was unreferenced, it will get a newly-created ClassFileReader and step 1 kicks off. If the class file was previously referenced but hasn't been indexed yet, it gets the existing ClassFileReader from the queue. If the class was already indexed, it gets an IBinaryType from the index.
4. After the indexer processes one of the ClassFileReaders that were created in step 1, it frees up the memory used by the ClassFileReader. Subsequent accesses to that IBinaryType will be served by the index itself.


This has several nice properties:
- Class files won't be read more than once (either by the model and indexer, or by multiple model accesses).
- There will be no code replication between the code that needs to construct the model lazily bottom-up and the code that would construct it eagerly top-down.
- The model should perform well both for classes which haven't been indexed yet and for classes that are present in the index.
- It should address many of the test failures that are currently occurring on the newindex branch.


ALTERNATIVES CONSIDERED:
------------------------

We also considered a couple other approaches:

1. Construct the model lazily and bottom-up, and use a soft reference cache for the ClassFileReaders to prevent redundant reading of class files. Ignore the cache in JavaModelManager. This would address the test failures, would have no code replication, and would perform reasonably well... but the performance wouldn't be optimal. Each class file might be read twice (by the indexer and model), and memory wouldn't be cleaned up by the soft reference cache as quickly as it could.

2. Include code for both lazy bottom-up model construction (for data coming from the index) and eager top-down construction (for data coming from ClassFileReader). This should have better memory characteristics than 1 since it could free up the memory for ClassFileReaders sooner, but would have a lot of logic in two places which would be an easy place for bugs to hide. It would still parse each class file twice.</thetext>
        <comment>
            <comment_id>2740836</comment_id>
            <comment_count>1</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-08-17 06:04:34 -0400</when>
            <comment_text>Can the JDT code team answer Stefans request? This issue seems to block the work for the important change in Bug 481796. 

Our company supports one large customer which considers evaluating other IDEs belong of the long indexing time (&gt;40 min) and I have hopes that the solution of 481796 will help that he stays with Eclipse.</comment_text>
        </comment>
        <comment>
            <comment_id>2741063</comment_id>
            <comment_count>2</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-08-17 12:50:41 -0400</when>
            <comment_text>Re: comment 1

Actually, I'm not really blocked on comments from the rest of the JDT core team in order to fix this (unless someone objects to the proposal, that is). I'm just swamped with work. I was planning to do this myself as soon as I've sorted out the rest of the unit test failures on the newindex branch (there are currently 27 remaining failures)</comment_text>
        </comment>
        <comment>
            <comment_id>2760045</comment_id>
            <comment_count>3</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-10-04 13:53:14 -0400</when>
            <comment_text>Still an issue.</comment_text>
        </comment>
        <comment>
            <comment_id>2770812</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-28 02:46:59 -0400</when>
            <comment_text>Bulk change, moving out all bugs that couldn't make it to M3.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500368</id>
        <developer>Stefan Xenos</developer>
        <developer_username>sxenos</developer_username>
        <dup_id/>
        <creation_time>2016-08-27 03:06:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Add test.dat to .gitignore</short_desc>
        <thetext>test.dat is a file generated by the test cases. It should be in .gitignore.</thetext>
    </bug>
    <bug>
        <id>505799</id>
        <developer>Stefan Xenos</developer>
        <developer_username>sxenos</developer_username>
        <dup_id/>
        <creation_time>2016-10-12 10:53:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Merge CharArrayUtils into CharOperation</short_desc>
        <thetext>CharArrayUtils serves essentially the same purpose as CharOperation. We should merge the former into the latter and eliminate any duplication.</thetext>
        <comment>
            <comment_id>2770807</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-28 02:46:24 -0400</when>
            <comment_text>Bulk change, moving out all bugs that couldn't make it to M3.</comment_text>
        </comment>
        <comment>
            <comment_id>2778437</comment_id>
            <comment_count>2</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-11-22 02:01:43 -0500</when>
            <comment_text>Can I please have a code review here?</comment_text>
        </comment>
        <comment>
            <comment_id>2778463</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-22 03:06:21 -0500</when>
            <comment_text>Looks good to me.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>505800</id>
        <developer>Stefan Xenos</developer>
        <developer_username>sxenos</developer_username>
        <dup_id/>
        <creation_time>2016-10-12 10:55:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Break apart JavaNames</short_desc>
        <thetext>Move methods related to the java VM spec out of JavaNames and into JavaBinaryNames. Move the remaining methods into more specific classes within search.</thetext>
        <comment>
            <comment_id>2765833</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-12 14:25:55 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/83055</comment_text>
        </comment>
        <comment>
            <comment_id>2770814</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-28 02:47:10 -0400</when>
            <comment_text>Bulk change, moving out all bugs that couldn't make it to M3.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>505820</id>
        <developer>Stefan Xenos</developer>
        <developer_username>sxenos</developer_username>
        <dup_id/>
        <creation_time>2016-10-12 14:43:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Test failure in CodeCorrectionTests.testCorrectFieldType2</short_desc>
        <thetext>The following test appears to be failing intermittently. The failure may be related to the new index:

Error Message

should have two suggestions.
----------- Expected ------------
AClass\n
AClass2
------------ but was ------------

--------- Difference is ----------
 expected:&lt;[AClass\n
AClass2]&gt; but was:&lt;[]&gt;
Stacktrace

junit.framework.ComparisonFailure: should have two suggestions.
----------- Expected ------------
AClass\n
AClass2
------------ but was ------------

--------- Difference is ----------
 expected:&lt;[AClass\n
AClass2]&gt; but was:&lt;[]&gt;
	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:259)
	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:235)
	at org.eclipse.jdt.core.tests.model.CodeCorrectionTests.testCorrectFieldType2(CodeCorrectionTests.java:186)</thetext>
        <comment>
            <comment_id>2765861</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-12 15:41:46 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/83062</comment_text>
        </comment>
        <comment>
            <comment_id>2770797</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-28 02:45:55 -0400</when>
            <comment_text>Bulk change, moving out all bugs that couldn't make it to M3.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507795</id>
        <developer>Stefan Xenos</developer>
        <developer_username>sxenos</developer_username>
        <dup_id/>
        <creation_time>2016-11-18 22:24:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Write a functional replacement for project dynamic dependencies</short_desc>
        <thetext>Dynamic dependencies are a way for language tooling to inform the builder about the order in which projects need to be compiled.

However, the current approach (data which must be explicitly attached to the project via setters while holding a workspace lock) is prone to deadlocks. See bug 495062 and bug 241751.

There is also a design flaw in the current API. Since each language sets this data as a single attribute on the project, projects that support multiple languages will have this attribute overwritten by the tooling for each language.

We should replace this system with something that is purely functional. That is, the build system will invoke a function provided by the language tooling to determine the build dependencies rather than having the language tooling attach the dynamic dependencies to the project as metadata.</thetext>
        <comment>
            <comment_id>2777759</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-18 22:31:30 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85332</comment_text>
        </comment>
        <comment>
            <comment_id>2777760</comment_id>
            <comment_count>2</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-18 22:33:53 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85333</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495883</id>
        <developer>Jean-Marie HENAFF</developer>
        <developer_username>jmhenaff</developer_username>
        <dup_id/>
        <creation_time>2016-06-10 10:04:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Erroneous "The local variable xxx may not have been initialized" error message</short_desc>
        <thetext>Consider this sample code:

  public void m() {
    if (false) {
      {
        int i0 = 4;
        do {
          break;
        } while (i0 &lt; 9);
      }
    }
  }

It compiles with javac (1.8.0_40), but ecj 4.6RC4a gives:

----------
1. WARNING in /tmp/Sample/src/com/test/Main.java (at line 6)
	if (false) {
      {
        int i0 = 4;
        do {
          break;
        } while (i0 &lt; 9);
      }
    }
	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Dead code
----------
2. ERROR in /usr/local/google/home/jmhenaff/workspace/ub-jack-2/Sample/src/com/test/Main.java (at line 11)
	} while (i0 &lt; 9);
	         ^^
The local variable i0 may not have been initialized</thetext>
        <comment>
            <comment_id>2719631</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-11 08:50:31 -0400</when>
            <comment_text>The bogus error is only reported inside dead code ("if (false)").
Not sure what's the internal reason, perhaps s.t. like: compiler can see that i0 indeed is never initialized (which is true).

Hence the obvious workaround is: avoid dead code :)


We may want to revisit if we can skip *all* flow analysis within dead code?

For reference: javac accepts this:
  public void m() {
        int i0;
        do {
          break;
        } while (i0 &lt; 9); // accepted, though never initialized
  }
but *not* this:
  public void m() {
      if (false) {
        int i0;
        if (i0 &gt; 1) // error, though never reached
            return;
      }
  }

=&gt; They do generally perform flow analysis within dead code (as of "if (false)"), but don't analyse the condition in this particular do-break-while pattern. Weird.

Not sure if it's worth investing efforts here.</comment_text>
        </comment>
        <comment>
            <comment_id>2722659</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-22 02:34:57 -0400</when>
            <comment_text>See bug 496511 for an example where mandatory flow analysis within dead code is missing.</comment_text>
        </comment>
        <comment>
            <comment_id>2725062</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-06-28 14:11:28 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #2)
&gt; See bug 496511 for an example where mandatory flow analysis within dead code
&gt; is missing.

That was a red herring.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501617</id>
        <developer>Brian de Alwis</developer>
        <developer_username>bsd</developer_username>
        <dup_id/>
        <creation_time>2016-09-16 16:49:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Add Library &gt; JUnit should support pulling junit.jar from org.junit_*.jar</short_desc>
        <thetext>The JDT JUnit BuildPathSupport class, which looks for the embedded junit.jar, assumes the org.junit bundle is exploded on disk.  There are ways to construct a target platform such that the org.junit bundle remains as a jar, which has puzzling consequences as the org.junit_XXXX.jar is bound instead and the JUnit classes are not found.

Steps to repeat:

  1. Create a "directory"-based target platform from a local repository (e.g., using a p2.mirror task), such that org.junit is a jar and has not been exploded on-disk.

  2. Launch the IDE using this target platform.

  3. Create a Java project.  Use Java Build Path &gt; Add Library &gt; JUnit

  4. Notice that the JUnit classes aren't available.

Ultimately the actual problem here is that org.eclipse.jdt.internal.junit.buildpath.BuildPathSupport.JUnitPluginDescription.getLocationIfExists(), which tries to find the junit.jar embedded in the org.junit bundle, doesn't handle the case where the org.junit bundle is as a .jar.  Which is fair enough since org.junit is normally extracted on disk.</thetext>
        <comment>
            <comment_id>2752156</comment_id>
            <comment_count>1</comment_count>
            <who>Brian de Alwis</who>
            <commenter_username>bsd</commenter_username>
            <when>2016-09-16 16:50:49 -0400</when>
            <comment_text>Marking as very very low priority as it's a rare case.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>487400</id>
        <developer>Christian Buck</developer>
        <developer_username>c.buck</developer_username>
        <dup_id/>
        <creation_time>2016-02-07 05:48:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>[patch] Enable filtering for classpath tab entries</short_desc>
        <thetext>Created attachment 259617
Patch for filtered classpath entries

Hi all,

when having projects with very large classpaths the classpath tab entries for run and debug configurations become hard to read.
Common use cases like looking for duplicates or searching for a certain entry are time consuming and error prone.
A possible workaround is opening .classpath in a text editor and using common text search abilities, but this is somehow inconsistent with using an IDE.

After an especially frustrating instance of manual classpath parsing I decided to have a look at the JDT source and suddenly had a working implementation of a filtering classpath tree. The user is able to enter a filter expression using the same well-known UI used in several other places in Eclipse.

I essentially changed RuntimeClasspathViewer from is-a-TreeViewer to has-a-FilteredTree, which also fixes an API misuse (TreeViewer must not be subclassed).
Please note that I have no experience at all in neither using SWT nor Eclipse development, so I kindly ask to review accordingly ;)

The attached patch should apply cleanly to current head.

To follow legal requirements: This contribution complies with http://www.eclipse.org/legal/CoO.php.

Thanks

Christian</thetext>
        <comment>
            <comment_id>2669215</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-02-07 23:15:35 -0500</when>
            <comment_text>Thanks for contributing. I have not yet reviewed it at code level, but functionality wise couple of points if you could look at :
1. Search does not require * for "Entries" . For other partial search I need to use *. It will be good to be consistent.
2. When I clear my search it collapses the entries. It should bring to the default view (What we get to see the first time)
3. If I give the filter word as Entries, I get both Entries , but I can't expand it. I understand that is the normal Filter Tree behavior. Not must, but will be good to be able to expand them, if it is not much of an effort.</comment_text>
        </comment>
        <comment>
            <comment_id>2671634</comment_id>
            <comment_count>2</comment_count>
            <who>Christian Buck</who>
            <commenter_username>c.buck</commenter_username>
            <when>2016-02-14 09:26:20 -0500</when>
            <comment_text>Created attachment 259749
Revised patch addressing points 1 and 2 from comment #1</comment_text>
        </comment>
        <comment>
            <comment_id>2671635</comment_id>
            <comment_count>3</comment_count>
            <who>Christian Buck</who>
            <commenter_username>c.buck</commenter_username>
            <when>2016-02-14 09:26:51 -0500</when>
            <comment_text>Thanks for looking into this!

Regarding your points:

Ad 1. This is actually the default behaviour of PatternFilter, i.e. matching with an implicit trailing wildcard. I tried to keep defaults as much as possible, but I agree that in this case it's not intuitive.
I changed the PatternFilter to match with an implicit leading wildcard, too. Is this better now?

Ad 2. I fully agree.
Due to the filter tree refresh running asynchronously I saw no obvious trivial solution. See RuntimeClasspathViewer.RuntimeClasspathFilteredTree.doCreateRefreshJob() for what I settled on (re-using existing code from FilteredTree seems to be the cleanest way to me).

Ad 3. I'm really not sure what the expected outcome should be. In my use cases I'd like to see all leaf (i.e. non-collapsible) nodes matching the filter pattern. If there are none except the "*Entries" grouping nodes, what would I expect to see when expanding those?

Please find attached the revised patch with changes for points 1 and 2 plus some additional minor cleanups. In RuntimeClasspathViewer.RuntimeClasspathFilteredTree.textChanged() I added a request for review regarding the several different ways to check for empty filter expressions I found elsewhere in the existing code. Perhaps this is a fitting moment to plan some additional code unifications, but please regard that only as an suggestion and remove the comment as you see fit.

Thanks

Christian</comment_text>
        </comment>
        <comment>
            <comment_id>2676751</comment_id>
            <comment_count>4</comment_count>
            <who>Christian Buck</who>
            <commenter_username>c.buck</commenter_username>
            <when>2016-02-28 09:37:22 -0500</when>
            <comment_text>I'm sorry, was I supposed to reassign back to you? Did that now.

Thanks

Christian</comment_text>
        </comment>
        <comment>
            <comment_id>2676816</comment_id>
            <comment_count>5</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-02-28 21:46:08 -0500</when>
            <comment_text>(In reply to Christian Buck from comment #4)
&gt; I'm sorry, was I supposed to reassign back to you? Did that now.
&gt; 
&gt; Thanks
&gt; 
&gt; Christian

No, You remain as the Asignee... Sorry for the delay . I will be reviewing it this week.</comment_text>
        </comment>
        <comment>
            <comment_id>2698778</comment_id>
            <comment_count>6</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-04-25 04:25:42 -0400</when>
            <comment_text>My bad, Couldn't look at it in detail.
Will target it in 4.7 M1</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508257</id>
        <developer>Sergey Prigogin</developer>
        <developer_username>eclipse.sprigogin</developer_username>
        <dup_id/>
        <creation_time>2016-11-27 14:34:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>The "Swap sides" preference negatively affects Refactoring Preview dialog</short_desc>
        <thetext>The Refactoring Preview dialog shows refactored source of the left when the "Swap sides" preference is enabled. This behavior is undesirable because showing the new code on the left is inconsistent with comparing with local history where the newer code is shown on the right when the the "Swap sides" preference is enabled.

The Refactoring Preview dialog does not need to support swapping of sides since it has always been showing the new code on the right, which is a common convention adapted by Gerrit and several other systems.

The proposed solution is to allow the Refactoring Preview dialog to suppress the "Swap sides" preference and the associated button.</thetext>
        <comment>
            <comment_id>2780385</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-27 14:36:54 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85838</comment_text>
        </comment>
        <comment>
            <comment_id>2780387</comment_id>
            <comment_count>2</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-27 14:54:02 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85840</comment_text>
        </comment>
        <comment>
            <comment_id>2780393</comment_id>
            <comment_count>3</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-11-27 16:25:11 -0500</when>
            <comment_text>*** Bug 504474 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
        <comment>
            <comment_id>2780698</comment_id>
            <comment_count>4</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-28 13:01:46 -0500</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/85838 was merged to [master].
Commit: http://git.eclipse.org/c/platform/eclipse.platform.team.git/commit/?id=3faf9a6c45cf2d8f3f7dfca712ef31c70a964826</comment_text>
        </comment>
        <comment>
            <comment_id>2782870</comment_id>
            <comment_count>5</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-12-05 09:30:12 -0500</when>
            <comment_text>This now disables the "Swap sides" preference for some comparisons. You should think a feature to the end before starting to add/change APIs.

The established policy in Eclipse compare editors was:

1) Left: Local workspace version; Right: Remote version

2) When (1) is not applicable because no local version is being compared:
   Left: Older version;           Right: Newer version

The goal of the new preference now apparently is to change policy (1) in some way.

APIs that establish a new behavior should be named after the new behavior. CompareConfiguration#isMirrored()/#isMirroringEnabled() do not reflect the intended new behavior.

Introducing a new behavior should not force unaffected old clients to implement a new API. LTK UI will not accept https://git.eclipse.org/r/#/c/85840/ .

Please modify the "Swap sides" feature so that existing compare clients don't get broken by a preference change.</comment_text>
        </comment>
        <comment>
            <comment_id>2782921</comment_id>
            <comment_count>6</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-12-05 11:07:55 -0500</when>
            <comment_text>The new preference allows users to fix editors (like CVS and egit) that weren't conforming to the platform spec (which you describe in comment 5, and which the patch comment describes more precisely). However, the preference is *breaking* editors which conform to the spec such as the ltk preview pane.

This patch allows call sites to opt out of the preference if they already conform to the spec. Call sites which didn't conform to the spec get the preference by default, so that users who are used to the old behavior still get an opt-out.

&gt; Introducing a new behavior should not force unaffected old clients
&gt; to implement a new API

We either have to make a change to LTK or we have to change all the team plugins (CVS, Egit, etc.). One went with old version on the left and the other went with old version on the right. There's no way for the compare framework itself to identify which version is which unless the caller identifies it somehow, so some old call sites need to change.

&gt; Please modify the "Swap sides" feature so that existing compare clients
&gt; don't get broken by a preference change.

How else would you suggest doing so besides the approach proposed here?</comment_text>
        </comment>
        <comment>
            <comment_id>2783000</comment_id>
            <comment_count>7</comment_count>
            <who>Sergey Prigogin</who>
            <commenter_username>eclipse.sprigogin</commenter_username>
            <when>2016-12-05 14:14:40 -0500</when>
            <comment_text>(In reply to Markus Keller from comment #5)
&gt; The established policy in Eclipse compare editors was:
&gt; 
&gt; 1) Left: Local workspace version; Right: Remote version
&gt; 
&gt; 2) When (1) is not applicable because no local version is being compared:
&gt;    Left: Older version;           Right: Newer version

The problem is that this policy leads to an inconsistent behavior of the compare view with itself and also with most code review systems. Consider the following scenario:
1. Preview of a refactoring change - the new code is shown on the right
2. The same code compared with HEAD in EGit - the new code is shown on the left (the same when comparing with local history and in CVS)
3. The same code reviewed in Gerrit - the new code is on the right.

A more consistent policy was proposed in https://bugs.eclipse.org/bugs/show_bug.cgi?id=504474#c3 but implementing it across all clients of the compare view will take considerable time. The "Swap left and right view" option was introduced to alleviate user suffering in meantime. The change https://git.eclipse.org/r/85840 is necessary to make sure that user suffering is in fact reduces.</comment_text>
        </comment>
        <comment>
            <comment_id>2783002</comment_id>
            <comment_count>8</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-12-05 14:17:57 -0500</when>
            <comment_text>I think we agree that the TextEditChangePreviewViewer correctly uses the compare APIs to set the left and right sides of the comparison.

If the addition of a new preference is breaking old clients that conformed to the old API, then something is wrong with the way the new preference was added. 

You seem to assume that the refactoring preview is the only old client that needs to be updated for the new preference. That assumption is wrong by definition, since you cannot know the set of clients that use a public API. In the Eclipse project, we don't break APIs just because that looks like it's the easiest way to hack a feature. If you want to change an established rule, you have to convince clients to opt in to the new rule.


I'm afraid I don't have time to perform the necessary investigations and write a spec for your new feature. You should start with clarifying what exactly the feature should do. Out of that, you should be able to come up with a name that better describes the intention of the feature. A global "Swap sides" or "mirror" is apparently not what you intended to implement.

I quickly checked what CVS and Local History did in 3.8.2, and I was surprised that Compare with Each Other on two versions showed the newer version on the left. I.e. that doesn't match my assumption, so if I had to implement this feature, I would have to go back and see if I can find out why is was implemented like that. Maybe the assumption was that the local version is often the newest version, and then they extrapolated
[left: local; right: remote] into
[left: newer; right: older].

Maybe the option should be "Show latest/local on the right". Note that the word "maybe" tells you that this is just a hint, not a definitive advice.</comment_text>
        </comment>
        <comment>
            <comment_id>2783030</comment_id>
            <comment_count>9</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-12-05 15:34:20 -0500</when>
            <comment_text>I'm not sure it will still make sense to have a button in the compare viewer that toggles the global preference. Every button makes a UI harder to use, and rarely-used options should be put on a preference page.

However, to support users working with a plug-in that should consume the new preference but doesn't do that yet, a "swap sides" button in the compare viewer could be helpful.

It would be nice to store the state of that toggle per "compare implementation". I don't know the compare code structure by heart, but I guess it should be possible to find an object that could be used to identify different usage contexts like refactoring preview, local history compare editor, CVS compare editor, EGit compare editor, etc. (maybe the class of a compare viewer input or a viewer implementation).

If you really want to keep the global preference toggle in the compare viewer, then it could go into a drop-down menu of the local "swap sides" toolbar button.</comment_text>
        </comment>
        <comment>
            <comment_id>2783577</comment_id>
            <comment_count>10</comment_count>
            <who>Sergey Prigogin</who>
            <commenter_username>eclipse.sprigogin</commenter_username>
            <when>2016-12-06 16:33:51 -0500</when>
            <comment_text>(In reply to Markus Keller from comment #9)
&gt; I'm not sure it will still make sense to have a button in the compare viewer
&gt; that toggles the global preference. Every button makes a UI harder to use,
&gt; and rarely-used options should be put on a preference page.

Agree. The only reason the button was put in the compare viewer was to make the new option easier to discover.

&gt; However, to support users working with a plug-in that should consume the new
&gt; preference but doesn't do that yet, a "swap sides" button in the compare
&gt; viewer could be helpful.

Ideally, all plug-ins that use compare viewer should be changed to use a consistent set of rules for deciding what goes on the right and what on the left side. The "Swap sides" option was created only because a consistent set of rules appeared unattainable due to disagreements over consistency criteria. It makes sense to make another attempt at reaching consensus on a consistent set of rules. I'm going to use bug 508257 for that.

Since there is no way to make all third-party plugins comply to the new set of rules in short term, it still makes sense to give users an ability to swap compare viewer sides when they find the current representation unnatural. Once and if we agree on a set of consistent rules, I will propose a mechanism for limiting the scope of the "Swap side" preference to affect only the compare viewer clients that did not assert compliance with the rules.
  
&gt; It would be nice to store the state of that toggle per "compare
&gt; implementation". I don't know the compare code structure by heart, but I
&gt; guess it should be possible to find an object that could be used to identify
&gt; different usage contexts like refactoring preview, local history compare
&gt; editor, CVS compare editor, EGit compare editor, etc. (maybe the class of a
&gt; compare viewer input or a viewer implementation).

I also thought of something like that. Looks pretty hacky, but would allow user to adjust appearance of the compare view on case by case basis. Before getting deep into this let's try to come up with an agreement on the set of consistent rules.

I'm reverting the change that introduced isMirroringAllowed/setMirroringAllowed methods to focus on the consistent rules first.</comment_text>
        </comment>
        <comment>
            <comment_id>2783578</comment_id>
            <comment_count>11</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-06 16:35:35 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/86543</comment_text>
        </comment>
        <comment>
            <comment_id>2783806</comment_id>
            <comment_count>12</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-07 08:14:05 -0500</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/86543 was merged to [master].
Commit: http://git.eclipse.org/c/platform/eclipse.platform.team.git/commit/?id=97118c23b0193698f0b34f1468117c4070a797dc</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506149</id>
        <developer>Sarika Sinha</developer>
        <developer_username>sarika.sinha</developer_username>
        <dup_id/>
        <creation_time>2016-10-18 09:44:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Advanced Source lookup in JDT</short_desc>
        <thetext>Email from Igor-
From user perspective, the advanced source lookup provides correct
source lookup when runtime classpath is not fully known in advance
and/or contains multiple versions of the same class. It also downloads
sources archives from remote artifact repositories automatically when
they are needed. No manual source lookup path configuration is needed.
In other words, the source lookup just works (at least it fails far less
frequently).

Internally, the implementation uses javaagent to capture exact location
of the running code in a custom JSR45 stratum. When source lookup is
requested by the debugger, the captured location is matched to one of
workspace projects, their dependencies or artifacts in the remote
artifact repositories. If needed, the corresponding sources archive is
located locally or downloaded from remote repoitories. Currently
implementation supports JDT java, Maven and PDE projects, but support
for other project types can be added via an extension point. Only Maven
remote repositories are currently supported, but other repository types
can be supported via extension point too (I hope somebody will implement
P2 support, for example).

The code is currently hosted at Github [1]. I think it makes sense to
split the code among JDT/Debug, which will provide general
infrastructure and extension points, PDE, which will provide support for
Plug-In projects and P2 repositories and M2E, which will provide support
for Maven projects and repositories.

[1] https://github.com/ifedorenko/com.ifedorenko.m2e.sourcelookup</thetext>
        <comment>
            <comment_id>2767721</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-18 09:45:57 -0400</when>
            <comment_text>Igor,
Please attach the gerrit patch for JDT.</comment_text>
        </comment>
        <comment>
            <comment_id>2768078</comment_id>
            <comment_count>2</comment_count>
            <who>Igor Fedorenko</who>
            <commenter_username>igor</commenter_username>
            <when>2016-10-18 20:18:58 -0400</when>
            <comment_text>Javaagent implementation currently uses ASM to manipulate classes bytecode at runtime. To avoid possible conflict with ASM classes used by applications being debugged, javaagent "relocates" ASM classes to a private package at build time using maven-shade-plugin. This implies m2e will be required to work on the javaagent implementation, but not other parts of the code. Do you see a problem with this?</comment_text>
        </comment>
        <comment>
            <comment_id>2768080</comment_id>
            <comment_count>3</comment_count>
            <who>Igor Fedorenko</who>
            <commenter_username>igor</commenter_username>
            <when>2016-10-18 21:17:21 -0400</when>
            <comment_text>Another question. Are you averse to using Google Guava as org.eclipse.jdt.launching dependency?</comment_text>
        </comment>
        <comment>
            <comment_id>2768083</comment_id>
            <comment_count>4</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-19 00:18:11 -0400</when>
            <comment_text>(In reply to Igor Fedorenko from comment #2)
&gt; Javaagent implementation currently uses ASM to manipulate classes bytecode
&gt; at runtime. To avoid possible conflict with ASM classes used by applications
&gt; being debugged, javaagent "relocates" ASM classes to a private package at
&gt; build time using maven-shade-plugin. This implies m2e will be required to
&gt; work on the javaagent implementation, but not other parts of the code. Do
&gt; you see a problem with this?

Did not understand clearly. 
As long as JDT does not have any dependency on maven and JDT user does not have any impact, it fine if m2e needs to add the stuff.</comment_text>
        </comment>
        <comment>
            <comment_id>2768084</comment_id>
            <comment_count>5</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-19 00:19:14 -0400</when>
            <comment_text>(In reply to Igor Fedorenko from comment #3)
&gt; Another question. Are you averse to using Google Guava as
&gt; org.eclipse.jdt.launching dependency?

org.eclipse.jdt.launching can't have a dependency on Google Guava.</comment_text>
        </comment>
        <comment>
            <comment_id>2768199</comment_id>
            <comment_count>6</comment_count>
            <who>Igor Fedorenko</who>
            <commenter_username>igor</commenter_username>
            <when>2016-10-19 07:25:38 -0400</when>
            <comment_text>(In reply to Sarika Sinha from comment #4)
&gt; 
&gt; Did not understand clearly. 
&gt; As long as JDT does not have any dependency on maven and JDT user does not
&gt; have any impact, it fine if m2e needs to add the stuff.

You will need m2e and maven to develop javaagent implementation. Neither m2e nor maven will be needed for the rest of jdt.launching code and, of course, neither m2e nor maven will be needed to use jdt.launching. Is this still acceptable?

(In reply to Sarika Sinha from comment #5)
&gt; (In reply to Igor Fedorenko from comment #3)
&gt; 
&gt; org.eclipse.jdt.launching can't have a dependency on Google Guava.

Just curious, why? Guava is well known and widely used library, already had Eclipse IP review done for it. Avoiding Guava forces me to reimplement some of the same functionality, which I'd rather avoid.</comment_text>
        </comment>
        <comment>
            <comment_id>2769834</comment_id>
            <comment_count>7</comment_count>
            <who>Igor Fedorenko</who>
            <commenter_username>igor</commenter_username>
            <when>2016-10-25 09:55:43 -0400</when>
            <comment_text>Pushed initial draft contribution to https://git.eclipse.org/r/#/c/83862/. It is very much work-in-progress but I would like to understand whether it is generally in line with your expectations or not. I'll wait for your feedback before I continue to work on this contribution.</comment_text>
        </comment>
        <comment>
            <comment_id>2770528</comment_id>
            <comment_count>8</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-27 06:08:46 -0400</when>
            <comment_text>(In reply to Igor Fedorenko from comment #6)
&gt; Just curious, why? Guava is well known and widely used library, already had
&gt; Eclipse IP review done for it. Avoiding Guava forces me to reimplement some
&gt; of the same functionality, which I'd rather avoid.

Eclipse Projects can use guava, true, but jdt.launching is part of eclipse platform so we avoid any dependency which we think can be done by jdk apis and we believe that jdk 8 has support for many apis which are part of guava project.</comment_text>
        </comment>
        <comment>
            <comment_id>2770533</comment_id>
            <comment_count>9</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-27 06:16:35 -0400</when>
            <comment_text>(In reply to Igor Fedorenko from comment #7)
&gt; Pushed initial draft contribution to https://git.eclipse.org/r/#/c/83862/.
&gt; It is very much work-in-progress but I would like to understand whether it
&gt; is generally in line with your expectations or not. I'll wait for your
&gt; feedback before I continue to work on this contribution.

org.eclipse.jdt.launching.javaagent does not import properly. We expect an Eclipse PDE Plugin Project, so please fix it. I hope you are using Eclipse Platform SDK or Eclipse IDE for committers for verification.</comment_text>
        </comment>
        <comment>
            <comment_id>2770551</comment_id>
            <comment_count>10</comment_count>
            <who>Igor Fedorenko</who>
            <commenter_username>igor</commenter_username>
            <when>2016-10-27 07:39:45 -0400</when>
            <comment_text>Thank you for your feedback, Sarika.

(In reply to Sarika Sinha from comment #8)
&gt; Eclipse Projects can use guava, true, but jdt.launching is part of eclipse
&gt; platform so we avoid any dependency which we think can be done by jdk apis
&gt; and we believe that jdk 8 has support for many apis which are part of guava
&gt; project.

Fair enough, added "remove guava usage" to my todo list. For the record, multimaps, immutable collections, convenient hashing are still missing from standard java library and will need to be reimplemented.


(In reply to Sarika Sinha from comment #9)
&gt; 
&gt; org.eclipse.jdt.launching.javaagent does not import properly. We expect an
&gt; Eclipse PDE Plugin Project, so please fix it. I hope you are using Eclipse
&gt; Platform SDK or Eclipse IDE for committers for verification.

Pushed updated code to gerrit, you should be able to import javaagent as "existing eclipse project" in workspace now. Maven is still required to build javaagent jar on command line (see my comment #2), so I added "convert javaagent build to ant" to my todo list.</comment_text>
        </comment>
        <comment>
            <comment_id>2771340</comment_id>
            <comment_count>11</comment_count>
            <who>Igor Fedorenko</who>
            <commenter_username>igor</commenter_username>
            <when>2016-10-30 20:02:41 -0400</when>
            <comment_text>Pushed another update to gerrit. It removes Guava dependency and implements all other major changes I had on my TODO list. I consider the code "ready for review". Please let me know if you have any questions or need anything changed. Or you can just merge the change ;-)</comment_text>
        </comment>
        <comment>
            <comment_id>2772081</comment_id>
            <comment_count>12</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-11-01 23:51:22 -0400</when>
            <comment_text>(In reply to Igor Fedorenko from comment #11)
&gt; Pushed another update to gerrit. It removes Guava dependency and implements
&gt; all other major changes I had on my TODO list. I consider the code "ready
&gt; for review". Please let me know if you have any questions or need anything
&gt; changed. Or you can just merge the change ;-)

Thanks, will be looking into it.</comment_text>
        </comment>
        <comment>
            <comment_id>2776447</comment_id>
            <comment_count>13</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-11-16 03:28:09 -0500</when>
            <comment_text>Any steps to verify the new code functioning ?
Test cases also welcome !!</comment_text>
        </comment>
        <comment>
            <comment_id>2776806</comment_id>
            <comment_count>14</comment_count>
            <who>Igor Fedorenko</who>
            <commenter_username>igor</commenter_username>
            <when>2016-11-16 23:07:59 -0500</when>
            <comment_text>Created attachment 265396
simple demo application

At high-level advanced source lookup provides three "features"

1. "inject" filesystem location information in a custom jsr45 smap of all loaded classes of the application being debugged.
2. uses class filesystem location to match classes to workspace sources.
3. provides extension points to match class filesystem location to artifacts in external artifact repositories and download corresponding sources archives.

I've attached a simple demo application you can use to verify 2 (and indirectly 1). Here is the app layout

.
├── core
│   └── src
│       └── core
│           ├── Echo.java
│           └── Main.java
├── ext-1
│   └── src
│       └── ext
│           ├── Echo1.java
│           └── Ext.java
└── ext-2
    └── src
        └── ext
            ├── Echo2.java
            └── Ext.java

To test advanced source lookup, put a breakpoint in ext.Echo1 (or ext.Echo2), right-click on core.Main, debug as java application. You will need to choose "Eclipse JDT Advanced Launcher" to use advanced source lookup. If everything works, Eclipse will correctly show sources at the breakpoint. You will also be able to step into Ext and Eclipse will show correct sources of that too. Conditional breakpoints, Display expression and everything else is expected to work.

There is no easy way to try 3 (i.e., repository sources lookup) using "plain" jdt. For test purposes I can provide mock repository extensions implementation. I can also give you a demo using m2e Maven repository support if you are interested.

Completely agree this feature needs automated tests but I will need some help setting up initial/skeleton test implementation.</comment_text>
        </comment>
        <comment>
            <comment_id>2776820</comment_id>
            <comment_count>15</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-11-17 00:43:13 -0500</when>
            <comment_text>I am getting the option "Eclipse JDT Advanced Launcher" only in Debug, not in Run ?</comment_text>
        </comment>
        <comment>
            <comment_id>2776976</comment_id>
            <comment_count>16</comment_count>
            <who>Igor Fedorenko</who>
            <commenter_username>igor</commenter_username>
            <when>2016-11-17 07:43:15 -0500</when>
            <comment_text>(In reply to Sarika Sinha from comment #15)
&gt; I am getting the option "Eclipse JDT Advanced Launcher" only in Debug, not
&gt; in Run ?

The new launch delegate is enabled for Debug mode only. I can change that, but I think we need to discuss how advanced source lookup will be provided to the user first. Here is what I think we should do, but I am open for other ideas

* Add workspace preference to enable/disable the advanced source lookup, enabled it by default.
* Change the new launch delegates to support both new and old behaviour, depending on the workspace preference.
* Use the new launch delegates for all JDT launch configurations.
* Mark the old launch delegates as deprecated but keep them as is. 

What do you think?</comment_text>
        </comment>
        <comment>
            <comment_id>2782146</comment_id>
            <comment_count>17</comment_count>
            <who>Igor Fedorenko</who>
            <commenter_username>igor</commenter_username>
            <when>2016-12-01 21:39:50 -0500</when>
            <comment_text>Is there anything I can do to help move this forwards?</comment_text>
        </comment>
        <comment>
            <comment_id>2782149</comment_id>
            <comment_count>18</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-12-01 22:19:25 -0500</when>
            <comment_text>(In reply to Igor Fedorenko from comment #17)
&gt; Is there anything I can do to help move this forwards?

Sorry, Have not been able to spend time on it. Will look at it next week.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>487421</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-02-07 23:57:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9][batch] Support Java 9 options in command line compiler</short_desc>
        <thetext>Java 9 introduces new options for compiling modules in Java 9. These should be implemented in ECJ as well. The new options such as -modulepath are described in JEP 261. Unfortunately, this still seem to be undergoing changes as demonstrated by this:

Update -mp to allow exploded modules to be specified directly
(http://hg.openjdk.java.net/jigsaw/jake/jdk/rev/45ba14321921)

As of now JEP 261, -mp (or -modulepath) option can only specify folders contains modules not modules directly.

So, this needs to be taken up after the spec is finalized.</thetext>
        <comment>
            <comment_id>2674644</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-02-23 01:44:22 -0500</when>
            <comment_text>I will look at the adding the infrastructure before we can finalize on the options.</comment_text>
        </comment>
        <comment>
            <comment_id>2720265</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-14 05:58:34 -0400</when>
            <comment_text>Here are the options that need to be supported by the compiler:

-modulesourcepath, -upgrademodulepath, -system, -modulepath, -addmods, -limitmods, -XaddExports, and -Xpatch.

And the compiler needs to work in one of the following modes:

Legacy mode
  If any of the compliance options is equal to or below 8. None of the above options are supported.

Single-module mode:
  When the compilation level is 9 and -modulesourcepath is not used. 

Multi-module mode:
  When compilation level is 9 and we indicate that we are compiling multiple modules by specifying -modulesourcepath, where source modules are present in their own folder.</comment_text>
        </comment>
        <comment>
            <comment_id>2721571</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-17 08:16:06 -0400</when>
            <comment_text>This requirement is particularly interesting:

"In large systems the source code for a particular module may be spread across several different directories. In the JDK itself, e.g., the source files for a module may be found in any one of the directories src/&lt;module&gt;/share/classes, src/&lt;module&gt;/&lt;os&gt;/classes, or build/gensrc/&lt;module&gt;, where &lt;os&gt; is the name of the target operating system. To express this in a module source path while preserving module identities we allow each element of such a path to use braces ({ and }) to enclose commas-separated lists of alternatives and a single asterisk (*) to stand for the module name. The module source path for the JDK can then be written as

{src/*/{share,&lt;os&gt;}/classes,build/gensrc/*}"</comment_text>
        </comment>
        <comment>
            <comment_id>2724489</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-27 11:51:01 -0400</when>
            <comment_text>The current design for module and module location has short-coming in light of the following requirement:

"If a module descriptor in the form of a module-info.java or module-info.class file is specified on the command line, or is found on the source path or the class path, then source files will be compiled as members of the module named by that descriptor and that module will be the sole root module"

In JDT we always associate a module with a module location (erstwhile classpath). In the special case where the module descriptor is supplied via command line, we need to find a way the work around this. Perhaps we should let the INameEnvironment be the keeper of all modules to support this.</comment_text>
        </comment>
        <comment>
            <comment_id>2724667</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-06-28 00:40:56 -0400</when>
            <comment_text>We use the same model (IModuleLocation) to represent both a classpath and modulepath. But we need to make sure a classpath doesn't behave like a module (like looking for module-info, using module context etc.) if it is supplied via -cp option. I will include this in my upcoming patch.</comment_text>
        </comment>
        <comment>
            <comment_id>2726691</comment_id>
            <comment_count>6</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-07-04 03:08:08 -0400</when>
            <comment_text>First cut solution is related here:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=b637f200e7688ed962e24c55c85d7ead1bbbd786

This provides support for single module compilation and basic multi-module mode via -modulepath and -modulesourcepath.</comment_text>
        </comment>
        <comment>
            <comment_id>2726795</comment_id>
            <comment_count>7</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-07-04 08:24:42 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #6)
&gt; First cut solution is related here:
&gt; 
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
&gt; ?h=BETA_JAVA9&amp;id=b637f200e7688ed962e24c55c85d7ead1bbbd786
&gt; 
&gt; This provides support for single module compilation and basic multi-module
&gt; mode via -modulepath and -modulesourcepath.

@Jay: With this commit for a vanilla X.java (public class X{}), I get the following error :



java.nio.file.ProviderNotFoundException: Provider "jrt" not found
	at java.nio.file.FileSystems.newFileSystem(FileSystems.java:341)
	at org.eclipse.jdt.internal.compiler.util.JrtFileSystem.initialize(JRTUtil.java:185)
	at org.eclipse.jdt.internal.compiler.util.JrtFileSystem.&lt;init&gt;(JRTUtil.java:172)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(JRTUtil.java:115)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:144)
	at org.eclipse.jdt.internal.core.JavaProject.loadModulesInJimage(JavaProject.java:705)
	at org.eclipse.jdt.internal.core.JavaProject.computePackageFragmentRoots(JavaProject.java:621)
	at org.eclipse.jdt.internal.core.JavaProject.computePackageFragmentRoots(JavaProject.java:783)
	at org.eclipse.jdt.internal.core.JavaProject.computePackageFragmentRoots(JavaProject.java:747)
	at org.eclipse.jdt.internal.core.JavaProject.buildStructure(JavaProject.java:474)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:316)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:302)
	at org.eclipse.jdt.internal.core.JavaElement.getChildren(JavaElement.java:257)
	at org.eclipse.jdt.internal.core.JavaProject.getPackageFragmentRoots(JavaProject.java:1940)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.getPackageFragmentRoots(PackageExplorerContentProvider.java:306)
	at org.eclipse.jdt.ui.StandardJavaElementContentProvider.getChildren(StandardJavaElementContentProvider.java:176)

To reproduce:
Take the ToT of BetaJava9 branch, spawn an eclipse - in the child eclipse create a Java 9 based project with a vanilla class X (public class X{}) - this is hit - click on the project to repeat.</comment_text>
        </comment>
        <comment>
            <comment_id>2726901</comment_id>
            <comment_count>8</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-07-04 12:07:46 -0400</when>
            <comment_text>(In reply to Manoj Palat from comment #7)
&gt; @Jay: With this commit for a vanilla X.java (public class X{}), I get the
&gt; following error :

Thanks Manoj for catching this. This happens when Eclipse is run with a JRE 8. I have fixed this with:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=f81497cf3f12c283b35bf7d81ebf758cd023c11d</comment_text>
        </comment>
        <comment>
            <comment_id>2727031</comment_id>
            <comment_count>9</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-07-04 22:47:48 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #8)
&gt; (In reply to Manoj Palat from comment #7)
&gt; &gt; @Jay: With this commit for a vanilla X.java (public class X{}), I get the
&gt; &gt; following error :
&gt; 
&gt; Thanks Manoj for catching this. This happens when Eclipse is run with a JRE
&gt; 8. I have fixed this with:
&gt; 
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
&gt; ?h=BETA_JAVA9&amp;id=f81497cf3f12c283b35bf7d81ebf758cd023c11d

Thanks Jay; I've checked on the same config and its working now.</comment_text>
        </comment>
        <comment>
            <comment_id>2744468</comment_id>
            <comment_count>10</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-29 00:59:52 -0400</when>
            <comment_text>The command line options are being renamed in openJDK:

-modulesourcepath	=&gt;	--module-source-path
-upgrademodulepath	=&gt;	--upgrade-module-path
-system			=&gt;	--system
-modulepath		=&gt;	--module-path
-addmods		=&gt;	--add-modules
-limitmods		=&gt;	--limit-modules
-XaddReads:		=&gt;	--add-reads
-XaddExports:		=&gt;	--add-exports
-Xpatch:		=&gt;	--patch-module

Don't yet have access to the build with these changes. Will rename it ECJ too at a suitable time.</comment_text>
        </comment>
        <comment>
            <comment_id>2751624</comment_id>
            <comment_count>11</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-16 06:29:45 -0400</when>
            <comment_text>Regarding the command line options being discussed in the previous few comments, I posted this on bug 500265 in response to another question:

"Initially, I thought the add-reads and such would be different to what we have in the formal module declaration. But I went back to the JEP 261 and see this:

"The --add-reads option can be used more than once. The effect of each instance is to add a readability edge from the source module to the target module. This is, essentially, a command-line form of a requires clause in a module declaration, or an invocation of an unrestricted form of the Module::addReads method. "

The implementation is also specific to batch compiler. At some point we might want to provide these features via UI too, which means it makes sense to make the code common."</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489056</id>
        <developer>Igor Fedorenko</developer>
        <developer_username>igor</developer_username>
        <dup_id/>
        <creation_time>2016-03-04 17:48:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler][javadoc] inconsistent reporting of missing binary types for @see reference</short_desc>
        <thetext>Created attachment 260105
example project that demonstrates inconsistent javadoc errors

Consider the following scenario: 

Binary type b.B extends missing type c.C.

Compilation unit A references to types b.B and c.C in @see javadoc tag. 

Problem: the code will compile successfully or produce an error depending on the order of @see elements. Specifically, the following code compiles successfully

        public class A {
            	/**
            	 * @see c.C
            	 * @see b.B#c()
            	 */
            	public void a() {}
        }

However, the following results in compilation error "The type c.C cannot be resolved. It is indirectly referenced from required .class files"


        public class A {
            	/**
            	 * @see b.B#c() &lt;&lt; reported error
            	 * @see c.C
            	 */
            	public void a() {}
        }</thetext>
        <comment>
            <comment_id>2693052</comment_id>
            <comment_count>1</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-04-11 12:12:06 -0400</when>
            <comment_text>Some variation in problem messages is acceptable for such a code modification that changes the resolution order, but I agree that both examples should compile without error. The main problem is that the @see tags should not be validated at all for the given project settings.

However, the node still needs to be resolved. This error message slips through the cracks because it's not one of the ProblemReporter#javadocInvalid*(..) problems that gets silenced by the corresponding compiler option.

I don't see a simple fix. Just silencing all errors during resolution of Javadoc references would be problematic: in case the same problem occurs in real code as well, we have to be sure that the error is still reported.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>493151</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-05-06 11:05:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null] Wrong warning about unchecked conversion. Constraints lost after using streams.</short_desc>
        <thetext>+++ This bug was initially created as a clone of Bug #488495 +++

Using Eclipse 4.6-I20160223-0800

After using a few stream methods, it seems that the null constraints get lost. For example, in this code:

@NonNullByDefault
public class Main {

    public static void main(String[] args, Set&lt;String&gt; set) {
        Optional&lt;@Nullable String&gt; kam = set.stream()
                .map(trace -&gt; getString(String.class))
                .findFirst(); // Null type safety (type annotations): The expression of type 'Optional&lt;String&gt;' needs unchecked conversion to conform to 'Optional&lt;@Nullable String&gt;'
        System.out.println(kam);
    }

    public @Nullable static &lt;T extends CharSequence&gt; T getString(Class&lt;T&gt; moduleClass) {
        return null;
    }
}

After the map, it should be a stream of @Nullable String but instead it's just String (can be verified with hover). Because of that, findFirst returns an Optional&lt;String&gt; instead of Optional&lt;@Nullable String&gt;

I attached a sample project for convenience.</thetext>
        <comment>
            <comment_id>2703831</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-06 11:07:07 -0400</when>
            <comment_text>Spawned off bug 488495 after investigation only concerned a second (similar) example.

The attachment mentioned is attachment 259931</comment_text>
        </comment>
        <comment>
            <comment_id>2703851</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-06 11:44:38 -0400</when>
            <comment_text>As of bug 488495 comment 12 I wonder whether the transfer of null hints in BoundSet.incorporate() (under if(analyzeNull)) should differentiate the bound kinds SUBTYPE and SUPERTYPE to determine in which direction a null hint should flow. I'm not sure this is related to this current bug but I will check via this bug anyway.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>486264</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-01-21 08:59:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>entry breakpoint for lambda expression</short_desc>
        <thetext>AFAICS, breakpoints in a lambda can so far only be created as line breakpoints. If a single-line lambda is nested within another expression this means, we cannot set a breakpoint that *only* fires inside the lambda. IntelliJ supports setting a breakpoint directly for the lambda, which I assume might be implemented by an entry breakpoint on the synthetic lambda method.

see also http://stackoverflow.com/questions/34875887/eclipse-breakpoint-in-single-one-line-lambda

LMK if help from JDT/Core is required here :)</thetext>
        <comment>
            <comment_id>2667310</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-02-02 23:39:00 -0500</when>
            <comment_text>For this, first we need to add a support to add breakpoints at different methods/statements on the same line.

Even for non lambda expression, we need to first support breakpoints for method calls in a line, and then we can extend it to the synthetic lambda methods.</comment_text>
        </comment>
        <comment>
            <comment_id>2668071</comment_id>
            <comment_count>2</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-02-04 07:49:22 -0500</when>
            <comment_text>(In reply to Sarika Sinha from comment #1)
&gt; For this, first we need to add a support to add breakpoints at different
&gt; methods/statements on the same line.

Not sure if that's possible in general. Aren't breakpoint locations inherently line-based (in the classfile format, and in the JDI protocol, e.g. in com.sun.jdi.Location)? I think this would require faked line numbers in the classfile, which would break many other scenarios.

(In reply to Stephan Herrmann from comment #0)
&gt; assume might be implemented by an entry breakpoint on the synthetic lambda
&gt; method.

That's an interesting proposal. The implementation challenge will be to cope with the unspecified implementation details for lambdas. For one, the synthetic lambda method name is compiler-dependent. Second, compilers can also reuse lambda methods, or even skip them altogether (e.g. if the lambda could just as well be written as a method reference, then the compiler is free to generate bytecode for a method reference).</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491486</id>
        <developer>Sarika Sinha</developer>
        <developer_username>sarika.sinha</developer_username>
        <dup_id/>
        <creation_time>2016-04-12 03:03:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>[TestCase] DetailFormatter removal throwing NPE</short_desc>
        <thetext>http://download.eclipse.org/eclipse/downloads/drops4/Y20160407-1000/testresults/html/org.eclipse.jdt.debug.tests_ep46Y-unit-mac64_macosx.cocoa.x86_64_8.0.html

testSimpleDetails1	Error	N/A

java.lang.NullPointerException
at org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.removeAssociatedDetailFormatter(JavaDetailFormattersManager.java:768)
at org.eclipse.jdt.debug.tests.variables.DetailFormatterTests.testSimpleDetails1(DetailFormatterTests.java:186)
at org.eclipse.jdt.debug.tests.AbstractDebugTest.runBare(AbstractDebugTest.java:2469)
at org.eclipse.jdt.debug.tests.DebugSuite$1.run(DebugSuite.java:57)
at java.lang.Thread.run(Thread.java:745)

Happening only on Mac.

Also I saw in log :
Caused by: org.xml.sax.SAXParseException; lineNumber: 11; columnNumber: 15; Element type "true" must be followed by either attribute specifications, "&gt;" or "/&gt;".
	at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(ErrorHandlerWrapper.java:203)
	at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.fatalError(ErrorHandlerWrapper.java:177)
	at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:441)
	at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:368)
	at com.sun.org.apache.xerces.internal.impl.XMLScanner.reportFatalError(XMLScanner.java:1437)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.seekCloseOfStartTag(XMLDocumentFragmentScannerImpl.java:1389)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanStartElement(XMLDocumentFragmentScannerImpl.java:1313)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2786)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:606)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:510)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:848)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:777)
	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141)
	at com.sun.org.apache.xerces.internal.parsers.DOMParser.parse(DOMParser.java:243)
	at com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl.parse(DocumentBuilderImpl.java:348)
	at org.eclipse.jdt.internal.launching.PListParser.parseXML(PListParser.java:110)
	at org.eclipse.jdt.internal.launching.PListParser.parse(PListParser.java:65)</thetext>
        <comment>
            <comment_id>2707265</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-05-16 02:50:27 -0400</when>
            <comment_text>This happened in main stream as well.
Looks like the main reason is "Connect to VM" failure</comment_text>
        </comment>
    </bug>
    <bug>
        <id>492052</id>
        <developer>Ian Graham</developer>
        <developer_username>ian.graham</developer_username>
        <dup_id/>
        <creation_time>2016-04-19 21:03:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Evaluating empty varargs expression in debugger fails</short_desc>
        <thetext>Created attachment 261100
Sample code to cause bug

If you put a breakpoint in the first line of the main method in the provided example code and then debug it, you will find that if you evaluate the invocation of method() with no parameters, then you will get a strange error dialog.</thetext>
        <comment>
            <comment_id>2696727</comment_id>
            <comment_count>1</comment_count>
            <who>Ian Graham</who>
            <commenter_username>ian.graham</commenter_username>
            <when>2016-04-19 21:06:42 -0400</when>
            <comment_text>Created attachment 261101
Resulting dialog

I've also attached an image of the resulting dialog.</comment_text>
        </comment>
        <comment>
            <comment_id>2696729</comment_id>
            <comment_count>2</comment_count>
            <who>Ian Graham</who>
            <commenter_username>ian.graham</commenter_username>
            <when>2016-04-19 21:35:15 -0400</when>
            <comment_text>Depending on some syntactical circumstance I couldn't figured out, the message might be "java.lang.ArrayIndexOutOfBoundsException" instead of "-1".

The problem seems to be with running Execute (Ctrl+U) when the empty invocation of the test method is selected.  It occurs with Luna as well as Mars.</comment_text>
        </comment>
        <comment>
            <comment_id>2696737</comment_id>
            <comment_count>3</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-04-19 22:52:59 -0400</when>
            <comment_text>Able to reproduce the bug.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499977</id>
        <developer>Andre Doerscheln</developer>
        <developer_username>andre161292</developer_username>
        <dup_id/>
        <creation_time>2016-08-19 06:52:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Debugger steps into conditional breakpoint</short_desc>
        <thetext>When hitting a conditional breakpoint that is positioned at the head of a loop and that contains function-calls, the debugger will step into the conditions code and hang there. 

Example Code:

public class DebugTest {
  public static void main(String[] args) {
    int i = 0;
    while (i++ &lt; 1) {
    }
  }
  public static boolean test() {
    return true;
  }
}

Set the conditional breakpoint to line 4 (the while-loop) and the condition to:
test()</thetext>
        <comment>
            <comment_id>2742689</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-08-23 06:32:11 -0400</when>
            <comment_text>I am not bale to reproduce this problem.</comment_text>
        </comment>
        <comment>
            <comment_id>2744364</comment_id>
            <comment_count>2</comment_count>
            <who>Andre Doerscheln</who>
            <commenter_username>andre161292</commenter_username>
            <when>2016-08-26 17:56:12 -0400</when>
            <comment_text>I tested it on multiple systems running Windows and Eclipse 4.6. The same thing happens on all of them. 

IMPORTANT: I forgot to say, that it happens only if you use "step into" (F5), when debugger hits the breakpoint.</comment_text>
        </comment>
        <comment>
            <comment_id>2744461</comment_id>
            <comment_count>3</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-08-28 23:52:07 -0400</when>
            <comment_text>(In reply to Andre Doerscheln from comment #2)
&gt; I tested it on multiple systems running Windows and Eclipse 4.6. The same
&gt; thing happens on all of them. 
&gt; 
&gt; IMPORTANT: I forgot to say, that it happens only if you use "step into"
&gt; (F5), when debugger hits the breakpoint.

Thanks, Now I can reproduce it with "Step Into"</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508495</id>
        <developer>David Cowan</developer>
        <developer_username>david</developer_username>
        <dup_id/>
        <creation_time>2016-11-30 15:29:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Debug runs with large classpaths include project root directory when they should not</short_desc>
        <thetext>Bug 327193 fixed an issue with debug runs not working in windows for command lines over 32k characters.  To do this the env variable CLASSPATH is used once commands get to large.  When this is done instead of using the -classpath switch no -classpath is passed and CLASSPATH env variable is used.  The problem with this is that the jvm by default appends a default classpath of the working directory if -classpath is not used.  This had the nasty side effect for me of my run working as expected and not having the project root directory into the classpath until I finally had enough libraries included to break over 32k and suddenly my classpath now includes the root project dir which brings in a classpath I do not want or expect.</thetext>
        <comment>
            <comment_id>2781690</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-11-30 22:25:48 -0500</when>
            <comment_text>@Mike,
Do you want to add anything ?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>509259</id>
        <developer>Marat Kamalov</developer>
        <developer_username>mkamalov85</developer_username>
        <dup_id/>
        <creation_time>2016-12-15 02:35:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Conditional break point doesn't work properly</short_desc>
        <thetext>I faced with issue that conditional break point doesn't work on my PC. I use following code:

package test;

public class Main {

    public static class C1 {
        public static C1 c = new C1();

        public Boolean b = null;

        private boolean isB() {
            if (b == null) {
                b = Boolean.TRUE;
            }
            return b; //USE BREAKPOINT HERE
        }
    }

    public static void main(String[] args) throws Exception {
        Thread[] threads = new Thread[100];
        for (int i = 0; i &lt; 100; i++) {
            Thread t = new Thread(new Runnable() {
                public void run() {
                    C1.c.isB();
                }
            });
            threads[i] = t;
        }
        for (Thread t : threads) {
           t.start();
        }
   }
}
The conditional breakpoint is set to "return b;" line and use "Boolean.TRUE.equals(b)" conditional. I reinstall Eclipse without any plugin and tried different versions of Java 8, but each time I get the same error, that says "Conditional breakpoint encountered runtime exception. Reason: java.lang.InternalError: Got MethodID of ReferenceType that is not a member of the ReferenceType occured retrieving stack frames."

I don't use any JRebel, DCEVM or some profiling tools.

Windows 10 + JDK8u111 + Neon.1a Release (4.6.1). Also doesn't work with Eclipse Mars.

I created a post related this issue: http://stackoverflow.com/questions/41146444/eclipse-conditional-breakpoint-doesnt-work 

People, confirm that this is reproducible. 
Could be related to https://bugs.eclipse.org/bugs/show_bug.cgi?id=413848</thetext>
        <comment>
            <comment_id>2786483</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-12-15 02:57:46 -0500</when>
            <comment_text>Can you take a plain eclipse SDK 4.7 and test your class ?
http://download.eclipse.org/eclipse/downloads/drops4/I20161214-1005/

I could not reproduce the error.</comment_text>
        </comment>
        <comment>
            <comment_id>2786511</comment_id>
            <comment_count>2</comment_count>
            <who>Marat Kamalov</who>
            <commenter_username>mkamalov85</commenter_username>
            <when>2016-12-15 04:27:43 -0500</when>
            <comment_text>Yes, I want to try 4.7 to reproduce this issue. But downloading speed so low, and after I spent more than 30 minutes for download 10MB the connection was lost twice. I don't have troubles with downloading from other resources or downloading 4.6 from official eclipse site. Do you have another link?</comment_text>
        </comment>
        <comment>
            <comment_id>2786527</comment_id>
            <comment_count>3</comment_count>
            <who>Marat Kamalov</who>
            <commenter_username>mkamalov85</commenter_username>
            <when>2016-12-15 05:07:03 -0500</when>
            <comment_text>Finally, I downloaded 4.7 from http://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops4/S-4.7M4-201612080830/eclipse-SDK-4.7M4-win32-x86_64.zip

Yes, it also doesn't work. 

Did you check on Windows 10 with Oracle Java 8?</comment_text>
        </comment>
        <comment>
            <comment_id>2786529</comment_id>
            <comment_count>4</comment_count>
            <who>Marat Kamalov</who>
            <commenter_username>mkamalov85</commenter_username>
            <when>2016-12-15 05:08:03 -0500</when>
            <comment_text>Created attachment 265898
Screenshot on Eclipse 4.7 M4</comment_text>
        </comment>
        <comment>
            <comment_id>2786532</comment_id>
            <comment_count>5</comment_count>
            <who>Andrey Loskutov</who>
            <commenter_username>loskutov</commenter_username>
            <when>2016-12-15 05:20:37 -0500</when>
            <comment_text>I also can't reproduce on RHEL 7.2 / OpenJdk 1.8.0_111 and Eclipse 4.6.2.
Please attach the error log. Why do you think this is not a dup of bug 413848?</comment_text>
        </comment>
        <comment>
            <comment_id>2786533</comment_id>
            <comment_count>6</comment_count>
            <who>Marat Kamalov</who>
            <commenter_username>mkamalov85</commenter_username>
            <when>2016-12-15 05:24:52 -0500</when>
            <comment_text>Guys, please, check on Windows 10. Maybe on other platforms works fine.
Why are you using hardware/software option on bug, if you tring to reproduce on other env? This is so strange.

On StackOverflow post in comments, people confirm that this reproducible on Windows 10.</comment_text>
        </comment>
        <comment>
            <comment_id>2786537</comment_id>
            <comment_count>7</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-12-15 05:30:59 -0500</when>
            <comment_text>I am able to reproduce it now on Windows 8 on a fresh Workspace.

Key is the use of threads.
If you remove all threads with the same condition, it works fine.</comment_text>
        </comment>
        <comment>
            <comment_id>2786538</comment_id>
            <comment_count>8</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-12-15 05:31:30 -0500</when>
            <comment_text>(In reply to Sarika Sinha from comment #7)
&gt; I am able to reproduce it now on Windows 8 on a fresh Workspace.
&gt; 
&gt; Key is the use of threads.
&gt; If you remove all threads with the same condition, it works fine.

Sorry,  Windows 7.</comment_text>
        </comment>
        <comment>
            <comment_id>2786539</comment_id>
            <comment_count>9</comment_count>
            <who>Andrey Loskutov</who>
            <commenter_username>loskutov</commenter_username>
            <when>2016-12-15 05:34:35 -0500</when>
            <comment_text>(In reply to Sarika Sinha from comment #7)
&gt; Key is the use of threads.
&gt; If you remove all threads with the same condition, it works fine.

Sorry, what do you mean by that? Where one need to remove what?</comment_text>
        </comment>
        <comment>
            <comment_id>2786540</comment_id>
            <comment_count>10</comment_count>
            <who>Marat Kamalov</who>
            <commenter_username>mkamalov85</commenter_username>
            <when>2016-12-15 05:38:53 -0500</when>
            <comment_text>Thank you, Sarika.
Yes, you are right. This is some concurrency issue. If threads aren't used, everything works fine. 

Andrey, Sarika means that the issue exists only in multi threads execution. If one thread used break point works fine.</comment_text>
        </comment>
        <comment>
            <comment_id>2786542</comment_id>
            <comment_count>11</comment_count>
            <who>Marat Kamalov</who>
            <commenter_username>mkamalov85</commenter_username>
            <when>2016-12-15 05:48:09 -0500</when>
            <comment_text>Also, I asked a friend to reproduce this issue on his machine. 

He noticed that the issue exists, but reproducible not each time. If this code runs from debug perspective mode, the issue sometimes doesn't fires. I think it could depends on CPU performance. I have extremely fast CPU, and issue reproducible 9 times form 10 runs.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>486172</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-01-20 08:54:00 -0500</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[syntax highlighting] SemanticHighlightings.DeprecatedMemberHighlighting should not highlight references in declaring type</short_desc>
        <thetext>4.5 and later

Probably broken in early 2015 by a few commits without a bug # on class org.eclipse.jdt.internal.ui.javaeditor.SemanticHighlightings.DeprecatedMemberHighlighting

Inside a deprecated type, it doesn't make sense to highlight all references to members of the class as well. If the members are called from outside the type, I can see that such highlightings could be useful, but inside the type, they are just noise.

Example:

package xy;

import static xy.Testing.FIELD;

@Deprecated
public class Testing {
    private int field;
    public static int FIELD;

    public void method() {
    	// semantic highlighting is unnecessary and noisy:
        System.out.println(field);
        method();
    }
}

class Ref {
	void foo(Testing t) {
    	// semantic highlighting is acceptable:
		System.out.println(FIELD);
		t.method();
	}
}</thetext>
    </bug>
    <bug>
        <id>486966</id>
        <developer>Dirk Fauth</developer>
        <developer_username>dirk.fauth</developer_username>
        <dup_id/>
        <creation_time>2016-02-01 16:02:00 -0500</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[content assist] Trying to add an ellipsis performs code completion</short_desc>
        <thetext>I'm trying to create a method that contains an ellipsis parameter. But when trying to enter the triple dot, code completion is performed. This results in changing the desired type to a sub-type and not an ellipsis.

Might be related to Bug 478246.</thetext>
        <comment>
            <comment_id>2668420</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-04 18:05:25 -0500</when>
            <comment_text>(In reply to Dirk Fauth from comment #0)
&gt; I'm trying to create a method that contains an ellipsis parameter. But when
&gt; trying to enter the triple dot, code completion is performed. This results
&gt; in changing the desired type to a sub-type and not an ellipsis.

you mean 'nested type' rather than subtype, right?</comment_text>
        </comment>
        <comment>
            <comment_id>2668448</comment_id>
            <comment_count>2</comment_count>
            <who>Dirk Fauth</who>
            <commenter_username>dirk.fauth</commenter_username>
            <when>2016-02-05 00:15:53 -0500</when>
            <comment_text>Yes nested type. Sometimes also accessible fields are added, for example if there is no nested type. 

Typing the triple dot almost everytime produces something unwanted.</comment_text>
        </comment>
        <comment>
            <comment_id>2668487</comment_id>
            <comment_count>3</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-02-05 03:34:51 -0500</when>
            <comment_text>(In reply to Dirk Fauth from comment #0)
&gt; I'm trying to create a method that contains an ellipsis parameter. But when
&gt; trying to enter the triple dot, code completion is performed. This results
&gt; in changing the desired type to a sub-type and not an ellipsis.
&gt; 
&gt; Might be related to Bug 478246.

Please provide a concrete example using plain Eclipse SDK 4.6 M6:
http://download.eclipse.org/eclipse/downloads/drops4/S-4.6M5-201601282000/</comment_text>
        </comment>
        <comment>
            <comment_id>2668548</comment_id>
            <comment_count>4</comment_count>
            <who>Dirk Fauth</who>
            <commenter_username>dirk.fauth</commenter_username>
            <when>2016-02-05 05:10:01 -0500</when>
            <comment_text>I think M6 is hard to get. ;-)

So I tried with the linked M5 and actually I needed some time to find the setup to reproduce the issue.

First update your preferences to include Java to the auto-completion:
Window -&gt; Preferences -&gt; Java -&gt; Editor -&gt; Content Assist -&gt; Advanced
Check "Java Proposals"

BTW, why are they disabled by default? I would have assumed that Java Proposals are enabled by default for a Java editor. Or do I misunderstand the content assist feature?

Then create a class similar to the following snippet. The key for the reported issue is the public static nested class.

public class Test {

	public InnerTest bar;
	
	public static class InnerTest {
		public String bar;
	}
}

If you now try to create a method in another class that takes Test as ellipsis parameter, you will immediately get Test.InnerTest.. as result.

I assume this is related to activating auto-completion by pressing a . with 0 ms delay.</comment_text>
        </comment>
        <comment>
            <comment_id>2668561</comment_id>
            <comment_count>5</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-02-05 05:42:58 -0500</when>
            <comment_text>(In reply to Dirk Fauth from comment #4)
&gt; First update your preferences to include Java to the auto-completion:
&gt; Window -&gt; Preferences -&gt; Java -&gt; Editor -&gt; Content Assist -&gt; Advanced
&gt; Check "Java Proposals"
&gt; BTW, why are they disabled by default? I would have assumed that Java
&gt; Proposals are enabled by default for a Java editor. Or do I misunderstand
&gt; the content assist feature?

If you had to do that then you did not use a new workspace and the indicated build. Those are checked by default. But unchecked in the lower (cycling) section.

 
&gt; Then create a class similar to the following snippet. The key for the
&gt; reported issue is the public static nested class.
&gt; 
&gt; public class Test {
&gt; 
&gt; 	public InnerTest bar;
&gt; 	
&gt; 	public static class InnerTest {
&gt; 		public String bar;
&gt; 	}
&gt; }
&gt; 
&gt; If you now try to create a method in another class that takes Test as
&gt; ellipsis parameter, you will immediately get Test.InnerTest.. as result.

I can reproduce it now.


&gt; I assume this is related to activating auto-completion by pressing a . with
&gt; 0 ms delay.

Yes, and the fact that the second dot inserts the proposal. See also bug 348857.</comment_text>
        </comment>
        <comment>
            <comment_id>2668645</comment_id>
            <comment_count>6</comment_count>
            <who>Dirk Fauth</who>
            <commenter_username>dirk.fauth</commenter_username>
            <when>2016-02-05 06:41:06 -0500</when>
            <comment_text>(In reply to Dani Megert from comment #5)
&gt; (In reply to Dirk Fauth from comment #4)
&gt; &gt; First update your preferences to include Java to the auto-completion:
&gt; &gt; Window -&gt; Preferences -&gt; Java -&gt; Editor -&gt; Content Assist -&gt; Advanced
&gt; &gt; Check "Java Proposals"
&gt; &gt; BTW, why are they disabled by default? I would have assumed that Java
&gt; &gt; Proposals are enabled by default for a Java editor. Or do I misunderstand
&gt; &gt; the content assist feature?
&gt; 
&gt; If you had to do that then you did not use a new workspace and the indicated
&gt; build. Those are checked by default. But unchecked in the lower (cycling)
&gt; section.

I used the indicated build, but indeed an existing workspace. You are right that it is checked using a new workspace.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>487247</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-02-04 10:44:00 -0500</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[actions] "Add Import" on static method invocation removes qualifier and causes semantic change</short_desc>
        <thetext>"Add Import" on a static method invocation wrongly removes the qualifier even if this causes a semantic change.

Steps:
- open ProjectionDocumentTest from http://git.eclipse.org/c/platform/eclipse.platform.text.git/commit/?id=805de570454ef7bb1d956a147cdc9bc6b8faa0b9
- put caret into "assertEquals" of one of the "Assert.assertEquals(...)" calls
- Source &gt; Add Import (Ctrl+Shift+M)

=&gt; Was: Compile error, because the method resolves to the conflicting
    private void assertEquals(DocumentEvent expected, DocumentEvent received)

=&gt; Expected: No import added, and source not touched. Show an error in the status line "Import could not be added because a conflicting method is in scope".


Add Import should not only be blocked when it causes a compile error, but also when it redirects the method call to a different method.

Example with JUnit4:

public class FileCharSequenceTests {
	@Test
	public void test1() throws Exception {
		Assert.assertEquals("msg", "a", "b"); // Add Import
		assertEquals("msg", "a", "b");
	}
	
	private void assertEquals(String desc, CharSequence actual, CharSequence expected) {
	}
}</thetext>
    </bug>
    <bug>
        <id>488485</id>
        <developer>Carsten Reckord</developer>
        <developer_username>reckord</developer_username>
        <dup_id/>
        <creation_time>2016-02-25 12:15:00 -0500</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[navigation] Quick Outline: show effective members only</short_desc>
        <thetext>Quick Outline (Ctrl+O) should have a mode to show effective members. It currently shows the members declared in the current class initially with an option to show all inherited members.

However, most of the time, I want to see the effective members for the class. So "declared members" is too little and "all inherited members" is too much and really confusing to find anything in. 

For a simple example, do a Ctrl+O+O on ArrayList, and you'll get five entries for "iterator()". What I'm usually only interested in is the list of all effective members, i.e. if the class itself declares or overrides "iterator()" then that's what I'm interested in. If "iterator()" is inherited from the parent class, then I want to see that. I rarely have a need to see all further overrides down to Object...

Alternatively, instead of filtering out overrides further down the class hierarchy, they could also be shown as children of the effective method - initially collapsed in the tree.</thetext>
        <comment>
            <comment_id>2675788</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-25 13:02:08 -0500</when>
            <comment_text>I fully agree. 

Anyone interested in different versions of "iterator()" should simply navigate to the "effective" version and then use Ctrl+T.

One *might* think of cycling through 3 modes instead of 2 by consecutive presses of Ctrl+O, but IMHO that's overkill. At most a workspace preference should toggle between "all inherited" and "effective", unless we agree that "effective" is actually a good replacement and "all inherited" can be dropped entirely.

Am I missing a motivation behind the current design?</comment_text>
        </comment>
        <comment>
            <comment_id>2675795</comment_id>
            <comment_count>2</comment_count>
            <who>Carsten Reckord</who>
            <commenter_username>reckord</commenter_username>
            <when>2016-02-25 13:15:32 -0500</when>
            <comment_text>I agree. Three modes seems overkill and I'd much prefer to have the "all inherited" mode replaced.</comment_text>
        </comment>
        <comment>
            <comment_id>2676922</comment_id>
            <comment_count>3</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-02-29 05:47:37 -0500</when>
            <comment_text>The easiest is to contribute a filter that filters the non-effective members.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490402</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-03-24 19:01:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[hovering] hyper link in hover over compare editor reports "Internal Error"</short_desc>
        <thetext>In a compare editor of a Java source file, left pane (= source from the workspace), hover over a local variable, see its type and try to invoke the hyperlink of that type.

Here's what I get in the log:

Message: Internal Error

Java Model Exception: Java Model Status [&lt;project root&gt; [in  ] is not on its project's build path]
	at org.eclipse.jdt.internal.core.JavaElement.newJavaModelException(JavaElement.java:566)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:247)
	at org.eclipse.jdt.internal.core.Openable.openAncestors(Openable.java:505)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:241)
	at org.eclipse.jdt.internal.core.Openable.openAncestors(Openable.java:505)
	at org.eclipse.jdt.internal.core.CompilationUnit.openAncestors(CompilationUnit.java:1176)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:241)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:316)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:302)
	at org.eclipse.jdt.internal.core.Openable.getBuffer(Openable.java:285)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContentFromSource(JavadocContentAccess2.java:653)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:534)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:717)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover$1.handleInlineJavadocLink(JavadocHover.java:574)
	at org.eclipse.jdt.internal.ui.viewsupport.JavaElementLinks$1.changing(JavaElementLinks.java:293)
	at org.eclipse.swt.browser.WebKit.webkit_navigation_policy_decision_requested(WebKit.java:1945)
	at org.eclipse.swt.browser.WebKit.webViewProc(WebKit.java:552)
	at org.eclipse.swt.browser.WebKit.Proc(WebKit.java:431)
	at org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(Native Method)
	at org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:9501)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1226)
	at org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method)
	at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:2480)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3576)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1119)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1020)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:692)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:605)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:670)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:609)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1516)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1489)</thetext>
        <comment>
            <comment_id>2686937</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-24 19:03:50 -0400</when>
            <comment_text>Correction: it works if the file is indeed from the current workspace. It breaks when looking at a revision from git.

In the original case the compare editor was opened from the git history, so both panes where git revisions, not workspace files.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491120</id>
        <developer>Andreas Hagerup</developer>
        <developer_username>ahagerup</developer_username>
        <dup_id/>
        <creation_time>2016-04-05 17:14:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[syntax highlighting] Highlighting source of exception not working for re-throw in multi-catch block</short_desc>
        <thetext>In the following code, when clicking on ParseException in the throws clause of test(), the Java editor will highlight the first call to test2() and the throw inside the first catch block.

Clicking on IOException or SQLException, the Java editor will highlight the first call to test2(), as expected, but it does not highlight the throw inside the second catch block.

  void test() throws ParseException, IOException, SQLException {
      test2();
      try {
          test2();
      } catch (ParseException e) {
          throw e;
      } catch (IOException | SQLException e) {
          throw e;
      }
  }
  void test2() throws ParseException, IOException, SQLException {
  }</thetext>
    </bug>
    <bug>
        <id>492711</id>
        <developer>Sebastien Arod</developer>
        <developer_username>sebastien.arod</developer_username>
        <dup_id/>
        <creation_time>2016-04-29 05:28:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[syntax highlighting] Support customizing style of ! operator</short_desc>
        <thetext>! Operator is easy to miss when reading through code in some situations.

It is only a single character but it invert the meaning of a whole statement.

If it could be made more obvious it could save some brain power to focus on more important topics.

A way to achieve this is to have a dedicated code style property for ! operator.
We could have an style pref for :
* "operators except !" 
* "! operator": 
Similarly to what is done with return keyword</thetext>
    </bug>
    <bug>
        <id>495775</id>
        <developer>Noopur Gupta</developer>
        <developer_username>noopur_gupta</developer_username>
        <dup_id/>
        <creation_time>2016-06-09 06:53:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[preferences] Disable certain Content Assist &gt; Advanced proposal kinds to prevent duplicates</short_desc>
        <thetext>In Content Assist &gt; Advanced preferences, we should disable the proposals kinds which are already covered by an enabled and checked proposal kind.

For example, if 'Java Proposals' is enabled and checked, disable 'Java Non-Type Proposals' and 'Java Type Proposals'.

See bug 464850 for background.</thetext>
        <comment>
            <comment_id>2718945</comment_id>
            <comment_count>1</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-06-09 11:10:45 -0400</when>
            <comment_text>Maybe bug 464850 works as designed, but the design is bad.

It's confusing to:
- silently disable proposal kinds that are already included in other kinds
- only do that on restart and not directly on Apply / OK
  =&gt; after enabling all proposal kinds, you get duplicate proposals until restart

I would not try to explain the current hack in the UI or add even more hacks to special-case some "Java *" proposals, but rather fix the implementation so that the hack and the explanations become unnecessary. Fiddling with user preferences behind the scene is ugly, and offering an API to do that is even worse. PreferenceConstants#get/setExcludedCompletionProposalCategories(..) should be deprecated.


The general problem is that some proposal kinds replace the functionality of another kind. In JDT, the "Java Proposals" kind includes the two other "Java *" kinds. Mylyn (who asked for bug 140886) has proposal kinds that replace the "Java *" kinds.

The element "javaCompletionProposalComputer" of the extension point "org.eclipse.jdt.ui.javaCompletionProposalComputer" should get a new child element "overrides" whose values are ids that point to other javaCompletionProposalComputer ids.

Then, proposal computers that are overridden in other active computers can silently be skipped when computers are loaded. This strategy also nicely solves all the bugs that arise when a proposal computer that overrides others gets uninstalled. In that case, the previously skipped computers automatically become active again, and no hacks like bug 222403 and bug 250629 are necessary.

The UI could tell about the override mechanism, but that's no critical.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496661</id>
        <developer>Julius Hager</developer>
        <developer_username>Julius_hager</developer_username>
        <dup_id/>
        <creation_time>2016-06-23 11:09:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[content assist] Duplicate recommendations after removing comment</short_desc>
        <thetext>Created attachment 262643
A visual example of the bug

The bug:

When using the recommendations window that normally appear when pressing the ctrl + space shortcut,
if you remove a comment (using backspace) the recommendations window starts to show duplicates of every recommendation. 
Both the single-line (//) and multi-line (/**/) comments are affected.


Speculation:

The number of slashes does not seem to affect the outcome nor type of comment, 
which leads me to believe the bug only appears when the recommendations windows is open and you are moving from a comment to normal code without closing the window.


How to replicate:

1. Type "//" in a normal code setting

2. Open the recommendations window (ctrl + space is default)

3. Press backspace twice to remove the comment while the window is still open</thetext>
        <comment>
            <comment_id>2723712</comment_id>
            <comment_count>1</comment_count>
            <who>Andreas Sewe</who>
            <commenter_username>andreas.sewe</commenter_username>
            <when>2016-06-24 06:09:30 -0400</when>
            <comment_text>(In reply to Julius Hager from comment #0)
&gt; How to replicate:
&gt; 
&gt; 1. Type "//" in a normal code setting
&gt; 
&gt; 2. Open the recommendations window (ctrl + space is default)
&gt; 
&gt; 3. Press backspace twice to remove the comment while the window is still open

Thank you so much for the detailed bug report! This is much appreciated.

I can reproduce the behavior you describe both with Code Recommenders enabled and without, so this seems to be a general issue with the way JDT handles proposal computers when the cursor switches document partitions (from comment to non-comment).

@JDT team:
I have reproduced this with a plain Eclipse 4.6 SDK from [1]. The only difference to the reporter's screenshot is that proposals are only duplicated, not quadruplicated (is this a word?), as less proposal computers are active.

[1] &lt;http://download.eclipse.org/eclipse/downloads/drops4/R-4.6-201606061100/&gt;</comment_text>
        </comment>
        <comment>
            <comment_id>2723862</comment_id>
            <comment_count>2</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-06-24 09:41:31 -0400</when>
            <comment_text>This is visible after the fix for bug 406463.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498404</id>
        <developer>Peter Swulius</developer>
        <developer_username>pswulius</developer_username>
        <dup_id/>
        <creation_time>2016-07-24 18:36:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[typing] Unexpected code formatting for basic anonymous classes while typing</short_desc>
        <thetext>Created attachment 263279
Screenshot of the editor

Strange issue only occurs while typing.  Issuing a Ctrl-Shift-F formats it according to your java formatter settings.

Type this much...

    Link link = new Link( "foobar" )

Press &lt;ENTER&gt;, and add the open &amp; closing braces, and get this...

    Link link = new Link( "foobar" )
            {
                &lt;- cursor here
            }

Expected results:

    Link link = new Link( "foobar" )
    {
        &lt;- cursor here
    }

I would expect the braces to not have extra indentation.

First noticed in Juno.  
Still reproduceable in Neon.
Behavior as expected in Indigo.</thetext>
    </bug>
    <bug>
        <id>498745</id>
        <developer>Nikolay Metchev</developer>
        <developer_username>nikolaymetchev</developer_username>
        <dup_id/>
        <creation_time>2016-07-28 05:26:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[templates] foreach template with generics leaves a rogue angle bracket</short_desc>
        <thetext>If you start off with the first snippet below and use the foreach template to create a foreach loop it will create a foreach loop on the list variable. If you then tab twice and change it to use the set variable the replacement leaves a trailing angle bracket &gt; as shown in the bottom snippet.
-------------------------------------------------------
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

class A&lt;T,Q&gt; {

}

public class Test3 {
  Set&lt;A&lt;?,?&gt;&gt; set = new HashSet&lt;&gt;();
  Set&lt;A&lt;?,?&gt;&gt; m() {
    List&lt;A&lt;?,?&gt;&gt; list = new ArrayList&lt;&gt;();
    foreach //complete here and switch to set variable
    return null;
  }
}

-------------------result------------------------
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

class A&lt;T,Q&gt; {

}

public class Test3 {
  Set&lt;A&lt;?,?&gt;&gt; set = new HashSet&lt;&gt;();
  Set&lt;A&lt;?,?&gt;&gt; m() {
    List&lt;A&lt;?,?&gt;&gt; list = new ArrayList&lt;&gt;();
    for (A&lt;?,?&gt;&gt; a : set) { //extra angle bracket

    }
    return null;
  }
}</thetext>
        <comment>
            <comment_id>2734818</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-07-28 10:02:33 -0400</when>
            <comment_text>Reproducible in Eclipse 4.2 also when "set" declaration is moved inside the method.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501342</id>
        <developer>Lars Vogel</developer>
        <developer_username>Lars.Vogel</developer_username>
        <dup_id/>
        <creation_time>2016-09-13 10:39:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[navigation] Quick Outline should use matching with "contains" logic instead of "startwith"</short_desc>
        <thetext>Currently if I search for a method in Quick Outline containing "maximize" I have to type "*maximize*". 

I think with subwords completion in the JDT editor, we should also match based on the String.contains logic. This is IMHO nicer for the user. 

Please note that we do this for almost every dialog in PDE which allows you to search for a plug-in or feature, if you find one which does not add automatically * that would be a bug in the PDE dialog.</thetext>
        <comment>
            <comment_id>2750810</comment_id>
            <comment_count>1</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-09-14 10:25:10 -0400</when>
            <comment_text>I agree we should investigate this, but it needs more thought than simply adding a "*" at the beginning. In PDE, that was an acceptable shortcut because most bundle names start with the same "org." or "com." anyway, and these words are rarely used as sole filter.

Java Content Assist required more changes to ensure that prefix completion proposals stay on top of the list. In Quick Outline, this also needs changes in all sorting modes.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501714</id>
        <developer>arne anka</developer>
        <developer_username>eclipse-bugs</developer_username>
        <dup_id/>
        <creation_time>2016-09-19 08:28:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>Class File Editor: Source Not Found -- does not name JAR</short_desc>
        <thetext>- Gradle-project
- some non-public JARs in the build path do not have a source JAR


On an object's method RMC -&gt; Open Declaration ... sends me to the "Class File Editor", on top between two blue lines there's a non-copy-able text

"The JAR of this class file belongs to container 'Project and External Dependencies' which does not allow modifications to source attachments on its entries"

but there is no indication what JAR this is, neither a name, nor a path.

It's bad and incomprehensible enough that one cannot add a local source JAR, but at least _what_ JAR we are talking about should be indicated.</thetext>
        <comment>
            <comment_id>2769528</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-10-24 09:40:23 -0400</when>
            <comment_text>(In reply to arne anka from comment #0)
&gt; - Gradle-project
&gt; - some non-public JARs in the build path do not have a source JAR
&gt; 
&gt; 
&gt; there's a non-copy-able text

That's bug 438492.


&gt; "The JAR of this class file belongs to container 'Project and External
&gt; Dependencies' which does not allow modifications to source attachments on
&gt; its entries"
&gt; 
&gt; but there is no indication what JAR this is, neither a name, nor a path.

Confirmed.


Workaround:
- search for the declaration of the type. This will reveal the JAR in the Search view.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>505610</id>
        <developer>Mickael Istria - away until ...</developer>
        <developer_username>mistria</developer_username>
        <dup_id/>
        <creation_time>2016-10-10 03:51:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[templates] Templates for empty .java files</short_desc>
        <thetext>Assuming someone tries content-assist on an empty .java file, it would be nice to show templates such as "Create new class &lt;fileName&gt;", "Create new interface &lt;fileName&gt;", "Create new enum &lt;fileName&gt;"... that would scaffold a minimal content (packange and object declaration at least).
Or maybe those completion items could directly open the right New wizard without leaving opportunity to change the name and let the wizard perform the change.</thetext>
    </bug>
    <bug>
        <id>506148</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-10-18 09:39:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[typing] "Smart" semicolon auto-inserts at end of line in wrapped statements</short_desc>
        <thetext>The "Preferences &gt; Java &gt; Editor &gt; Typing &gt; Automatically insert at correct position &gt; Semicolons" option auto-inserts a semicolon at the end of the current line in wrapped statements. This is clearly not more correct than the location where the user placed the caret.

Example (the long string literal is on one line):

public class A {
    void foo() {
        StringBuilder sb = new StringBuilder();
        sb.append('[').append("Some long content that will make the formatter insert line breaks somewhere around here")
                .append(']');
    }
}

- set caret after "sb.append('[')"
- type ";"
=&gt; was: semicolon gets added at the end of the line
=&gt; expected: since there's no semicolon missing, the correct insertion position is the caret location</thetext>
    </bug>
    <bug>
        <id>507383</id>
        <developer>Lars Vogel</developer>
        <developer_username>Lars.Vogel</developer_username>
        <dup_id/>
        <creation_time>2016-11-10 16:45:00 -0500</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>[templates] Java method templates do not create unique method names</short_desc>
        <thetext>If I use the Java templates for a method, e.g.,. a public method, it always creates the same method name ("name"). This results in syntax errors, after the second insert.

I suggest to generate unique names, like in for local variables which append a number, if another variables already exists with the same name.</thetext>
        <comment>
            <comment_id>2777602</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-18 11:08:21 -0500</when>
            <comment_text>A new variable newMethodName similar to newName and newType needs to be added.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>485121</id>
        <developer>Marvin  Fröhlich</developer>
        <developer_username>qudus</developer_username>
        <dup_id/>
        <creation_time>2016-01-04 05:39:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[package explorer] File sorting should ignore extension</short_desc>
        <thetext>The package explorer uses the full filename including extension and separating dot to sort items. There should at least be the option to ignore the extension (with dot) for sorting and it should be default.

The Package Explorer understands Java and doesn't simply behave like a file tree. In theory it would not even have to show the extension at all, since the symbol is sufficient.
And since it understands Java, it should not use the extension for sorting.</thetext>
    </bug>
    <bug>
        <id>487664</id>
        <developer>Benedikt Aumayr</developer>
        <developer_username>beni</developer_username>
        <dup_id/>
        <creation_time>2016-02-11 08:58:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[extract method] Refactor: Extract method fails to report "Ambiguous return value: selected block contains more than one assignment to local variable"</short_desc>
        <thetext>Given the following code

private static void test() {
  
    int someCounter = 0;
      
    for (int i = 0; i &lt; 10; i++) {
          
      int someValue = -1;
          

      try {
          ////////Extract this into a method
          someCounter++;
          int someOtherValue = 2;            
          someValue = someOtherValue;
          ////////Extract this into a method
      
      } catch (Exception e) {
          someValue = -1;
      }

      
      if (someValue != -1) {
          System.out.println("Not -1");
      }
    }           
}


If you extract the code between the line comments as method it should you give you an error "Ambiguous return value" because someCounter and someValue are modified.
However it does produce this code:
private static void extract(int someCounter) {
  int someValue;
  someCounter++;
  int someOtherValue = 2;
  someValue = someOtherValue;
}

On the other hand, if you remove the try/catch block the error shows up as expected on "Exract method", so this seems to be some kind of scoping issue.</thetext>
        <comment>
            <comment_id>2671059</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-02-11 23:02:10 -0500</when>
            <comment_text>Moving to UI for investigation.</comment_text>
        </comment>
        <comment>
            <comment_id>2671060</comment_id>
            <comment_count>2</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-02-11 23:22:11 -0500</when>
            <comment_text>You will get the same exception, if you remove 
someValue = -1;

from Exception block.

As someValue  is used in exception block, only effective changing variable is someCounter.</comment_text>
        </comment>
        <comment>
            <comment_id>2671955</comment_id>
            <comment_count>3</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-02-15 22:41:56 -0500</when>
            <comment_text>Please reopen, if you think it is still a problem.</comment_text>
        </comment>
        <comment>
            <comment_id>2673042</comment_id>
            <comment_count>4</comment_count>
            <who>Benedikt Aumayr</who>
            <commenter_username>beni</commenter_username>
            <when>2016-02-18 03:04:08 -0500</when>
            <comment_text>I am re-opening this issue because it is still a problem.  The refactor feature is changing the behaviour of code, which is not correct.  Incidentally the exception block is there to cause the issue though it has no affect on the code since no exception is thrown.  Without the exception block Eclipse performs the refactor operation correctly.

Perhaps it is better explained with an alternate example.  Take the following method and execute it and you will see that printed in the console is the text “I EXPECT THIS TO BE PRINTED”:

private static void test() {
            
  int someCounter = 0;
  int someValue = -1;
                  
  try {

    ////////Extract this into a method
    someCounter++;
    int someOtherValue = 2;            
    someValue = someOtherValue;
    ////////Extract this into a method
            
  } catch (Exception e) {
    someValue = -1;
  }
           
  if (someValue != -1) {
    System.out.println("I EXPECT THIS TO BE PRINTED");
  }
}

Now highlight the three lines of code between the comments and choose Refactor | Extract method and you will see that the code gets changed to the following.  If you execute it now you will notice that nothing is printed to the console – meaning the code has changed it's result which is surely not the intention of a refactor operation (notice that the someValue variable never get's anything except -1 assigned but in the first example it actually always got 2 assigned and would therefore go into the if block).

private static void test() {
        
  int someCounter = 0;
  int someValue = -1;
                  
  try {

    ////////Extract this into a method
    extractedMethod(someCounter);
    ////////Extract this into a method
                  
  } catch (Exception e) {
    someValue = -1;
  }
                  
  if (someValue != -1) {
    System.out.println("I EXPECT THIS TO BE PRINTED");
  }
                      
}

private static void extractedMethod(int someCounter) {
  int someValue;
  someCounter++;
  int someOtherValue = 2;            
  someValue = someOtherValue;
}</comment_text>
        </comment>
        <comment>
            <comment_id>2673129</comment_id>
            <comment_count>5</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-02-18 05:06:14 -0500</when>
            <comment_text>(In reply to Benedikt Aumayr from comment #4)
&gt; I am re-opening this issue because it is still a problem.

Confirmed.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>487756</id>
        <developer>Andreas Sewe</developer>
        <developer_username>andreas.sewe</developer_username>
        <dup_id/>
        <creation_time>2016-02-12 12:09:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[open type] Button contributed to toolbar even if no perspective open</short_desc>
        <thetext>Created attachment 259734
No active workbench page error message

On the Mars.2 milestone from [1], JDT contributes an "Open Type" button to the workbench toolbar even if no perspective is open, leading to the error message in the attached screenshot.

I think it would be best if the button were simply not contributed in this (admittedly rare) case.

[1] &lt;http://download.eclipse.org/eclipse/downloads/drops4/M20160208-1530/&gt;</thetext>
        <comment>
            <comment_id>2671727</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-02-15 04:35:48 -0500</when>
            <comment_text>It behaves the same in Mars.1 as well, not a new contribution in Mars.2</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488942</id>
        <developer>Steffen Mikkelsen</developer>
        <developer_username>smikkelsen</developer_username>
        <dup_id/>
        <creation_time>2016-03-03 09:01:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[extract method] Extract method fails to handle side effect in loops</short_desc>
        <thetext>public void x() {
        for (int loopOnce = 0; loopOnce &lt; 1; loopOnce++) {
            int seenUpTo = 0;
            for (int count = 0; count &lt; 2; count++) {
                System.out.println(seenUpTo++); // extract this line to method
            }
        }
    }

Running the code without modification gives this in the console:
0
1

Extracting the System.out.println by selecting line, right click - Refactor - Extract Method gives this:

    public void x() {
        for (int loopOnce = 0; loopOnce &lt; 1; loopOnce++) {
            int seenUpTo = 0;
            for (int count = 0; count &lt; 2; count++) {
                extracted(seenUpTo);
            }
        }
    }

    private void extracted(int seenUpTo) {
        System.out.println(seenUpTo++); // extract this line to method
    }

However running the code now prints this to the console:
0
0</thetext>
        <comment>
            <comment_id>2678400</comment_id>
            <comment_count>1</comment_count>
            <who>Steffen Mikkelsen</who>
            <commenter_username>smikkelsen</commenter_username>
            <when>2016-03-03 09:10:45 -0500</when>
            <comment_text>    public void x() {
        for (int loopOnce = 0; loopOnce &lt; 1; loopOnce++) {
            int seenUpTo = 0;
            for (int count = 0; count &lt; 2; count++) {
                // extract method start
                seenUpTo += 2;
                System.out.println(seenUpTo);
                // extract method end
            }
        }
    }

does the same thing so it doesn't seem to have anything to do with the ++ specifically.

Removing the outer loop but extracting the same line(s) correctly gives an extracted method returning int.</comment_text>
        </comment>
        <comment>
            <comment_id>2678464</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-03-03 10:40:07 -0500</when>
            <comment_text>I don't know if we can do anything here. Moving to UI for comments.</comment_text>
        </comment>
        <comment>
            <comment_id>2678677</comment_id>
            <comment_count>3</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-03-04 01:35:30 -0500</when>
            <comment_text>

*** This bug has been marked as a duplicate of bug 479559 ***</comment_text>
        </comment>
        <comment>
            <comment_id>2778606</comment_id>
            <comment_count>4</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-11-22 07:35:22 -0500</when>
            <comment_text>This is not a duplicate of bug 479559 which is about analyzing additional occurrences while extracting the method.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490765</id>
        <developer>Andreas Sewe</developer>
        <developer_username>andreas.sewe</developer_username>
        <dup_id/>
        <creation_time>2016-03-31 05:55:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Sign AST/JavaElement View plugins</short_desc>
        <thetext>The "AST View" [1] and "JavaElement View" [2] plugins installable from the Marketplace are not signed by the Eclipse Foundation, but probably should be, in particular as they have the "Eclipse Project" banner.

[1] &lt;http://marketplace.eclipse.org/content/ast-view&gt;
[2] &lt;http://marketplace.eclipse.org/content/javaelement-view&gt;</thetext>
    </bug>
    <bug>
        <id>490972</id>
        <developer>Jongwook Kim</developer>
        <developer_username>jongwook.kim</developer_username>
        <dup_id/>
        <creation_time>2016-04-03 23:25:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[introduce parameter] incorrect parameter replacement to references inside the anonymous class</short_desc>
        <thetext>To reproduce, please do "introduce parameter" refactoring to "i"

public class A {
	void m() {
		int i = 1;
		A a = new A() {
			void n() {
				int j = i; // "introduce parameter" to i
			}
		};
	}
}

The following refactored code shows broken binding of i.

public class A {
	void m() {
		int i = 1;
		A a = new A() {
			void n(int i2) {
				int j = i2; // change of binding
			}
		};
	}
}</thetext>
        <comment>
            <comment_id>2690002</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-04-04 04:52:36 -0400</when>
            <comment_text>Reproducible with Eclipse 3.8.1 also.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491552</id>
        <developer>Marc-André Laperle</developer>
        <developer_username>marc-andre.laperle</developer_username>
        <dup_id/>
        <creation_time>2016-04-12 18:28:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[1.8] Convert to lambda expression quick assist does unnecessary renames</short_desc>
        <thetext>Created attachment 260906
Sample project

Using Eclipse 4.6-I20160412-0800

When trying to convert an anonymous class to a lambda expression, a quick assist is offered. If the body of the expression contains two variables with the same name but in different scopes, they get unnecessarily renamed.

I attached a sample project to show this behavior:

public class Main {
    public static void main(String[] args, Set&lt;String&gt; set) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                int i = 0;
                if (i == 0) {
                    int foo = 0;
                    System.out.println(foo);
                } else {
                    int foo = 1;
                    System.out.println(foo);
                }
            }
        });
    }
}


1. Import the project
2. Place the cursor on 'new Runnable'
3. Press Ctrl+1 to invoke quick assist
4. Press the down arrow key to select "Convert to lambda expression"
5. Press Enter.

The two 'foo' variables are renamed foo1 and foo2. This should not be necessary.</thetext>
    </bug>
    <bug>
        <id>492598</id>
        <developer>Thomas Arzdorf</developer>
        <developer_username>thomas.arzdorf</developer_username>
        <dup_id/>
        <creation_time>2016-04-27 15:51:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[jar exporter] Jardesc Export-Wizard should warn if resources are missing</short_desc>
        <thetext>The problem occurs when several classes from different projects are exported into a single jar using a jardesc file. If you define a jardesc file with e.g. package de.test1 from Project1 and de.test2 from Project2 and run the export while Project1 and Project2 are in the workspace then the resulting jar contains all classes from both packages. 
Now assume that Project2 is for some reason currently not in the workspace. If so, the export wizard still exports a jar without any warning or error, but in the resulting jar the classes of de.test2 from Project2 are of cause not contained and the program that uses the jar will fail.

That something is missing for the export is pretty hard to see if you have for example around 100 projects in the workspace and export classes from only some of them into a jar.

I would expect to see at least warning that tells me which resources cannot be found and will not be exported into the jar or even better the wizard shows an error and refuses to create the jar.</thetext>
    </bug>
    <bug>
        <id>493648</id>
        <developer>Raffi Khatchadourian</developer>
        <developer_username>raffi.khatchadourian</developer_username>
        <dup_id/>
        <creation_time>2016-05-13 09:42:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[pull up] Pulling up a method that returns this results in a compile-time error</short_desc>
        <thetext>Before:

class I {
}

abstract class A extends I {
	public A m() {
		return this;
	}
}

After pulling up A.m() to I:

class I {
	public A m() {
		return this;
	}
}

abstract class A extends I {
}

The compile-time type of this has changed. It's no longer of type A but of type I. As such, this refactoring should fail preconditions.</thetext>
        <comment>
            <comment_id>2709017</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-05-19 02:51:58 -0400</when>
            <comment_text>Reproducible in Eclipse 3.8.1 also.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>494283</id>
        <developer>Lukas Eder</developer>
        <developer_username>lukas.eder</developer_username>
        <dup_id/>
        <creation_time>2016-05-23 06:31:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[quick fix] Allow for assigning varargs arguments to a new local variable (or field, etc.)</short_desc>
        <thetext>Consider the following code:

---------------------------------------------
public class Test {
    void method() {
        varargs("a", 1, 2, 3);
    }

    void varargs(String x, Object... objects) {

    }
}
---------------------------------------------

In method "method()", the argument list "1, 2, 3" is really an Object[] array. When selecting "1, 2, 3", I would like to be able to assign that array to a local variable, field, etc., just like any other argument. The result would be something like:

---------------------------------------------
public class Test {
    void method() {
        Object[] objects = { 1, 2, 3 };
        varargs("a", objects);
    }

    void varargs(String x, Object... objects) {

    }
}
---------------------------------------------</thetext>
        <comment>
            <comment_id>2712293</comment_id>
            <comment_count>1</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-05-25 13:17:00 -0400</when>
            <comment_text>Sounds good. The array type should be readily available in the MethodInvocation's method binding (necessary in case the vararg type refers to a type variable).</comment_text>
        </comment>
    </bug>
    <bug>
        <id>494405</id>
        <developer>Aurelien Pupier</developer>
        <developer_username>apupier</developer_username>
        <dup_id/>
        <creation_time>2016-05-24 08:24:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[JUnit] Support JUnit Maven report containing "rerun failures"</short_desc>
        <thetext>Created attachment 261970
Sample result file with rerun failing error

Currently, it is not possible to import a JUnit report when there was the option rerunFailingTestsCount on a Maven project. http://maven.apache.org/surefire/maven-surefire-plugin/test-mojo.html#rerunFailingTestsCount



It ends with this stack in log:

org.xml.sax.SAXParseException; systemId: file:/C:/Users/Aurelien%20Pupier/git/fuse-components/camel-sap/org.fusesource.camel.component.sap.test/target/surefire-reports/TEST-org.fusesource.camel.component.sap.util.RfcUtilTest.xml; lineNumber: 72; columnNumber: 99; unknown node 'rerunFailure'
	at org.eclipse.jdt.internal.junit.model.TestRunHandler.startElement(TestRunHandler.java:175)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(Unknown Source)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanStartElement(Unknown Source)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(Unknown Source)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(Unknown Source)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(Unknown Source)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(Unknown Source)
	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(Unknown Source)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(Unknown Source)
	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(Unknown Source)
	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl.parse(Unknown Source)
	at javax.xml.parsers.SAXParser.parse(Unknown Source)
	at org.eclipse.jdt.internal.junit.model.JUnitModel.importTestRunSession(JUnitModel.java:373)
	at org.eclipse.jdt.internal.junit.ui.TestRunnerViewPart$ImportTestRunSessionAction.run(TestRunnerViewPart.java:500)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:595)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:511)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:420)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4362)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4180)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3769)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:694)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:606)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1515)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1488)</thetext>
        <comment>
            <comment_id>2711455</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-05-24 10:05:30 -0400</when>
            <comment_text>Moving to the right component for consideration.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495262</id>
        <developer>Andrey Loskutov</developer>
        <developer_username>loskutov</developer_username>
        <dup_id/>
        <creation_time>2016-06-02 06:06:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[jar exporter] Add "Export as executable" option to the "Runnable JAR file" wizard</short_desc>
        <thetext>On Linux (end eventually on Windows, no idea for Mac), there is a way to package "java -jar blup.jar" command along with the jar itself into a single executable file, see http://superuser.com/questions/912955/how-to-make-a-java-jar-file-to-be-a-single-file-executable

#######################
1- Create a stub:

MYSELF=`which "$0" 2&gt;/dev/null`
[ $? -gt 0 -a -f "$0" ] &amp;&amp; MYSELF="./$0"
exec java -jar $MYSELF "$@"
exit $?

2- Concatenate the stub and the jar into a new executable:

cat stub.sh Main.jar &gt; main.sh

3- Make the new file executable:

chmod +x main.sh
#######################

This is a nice thing and we should add such an option and functionality to the FatJarPackageWizard.</thetext>
    </bug>
    <bug>
        <id>495369</id>
        <developer>Lars Vogel</developer>
        <developer_username>Lars.Vogel</developer_username>
        <dup_id/>
        <creation_time>2016-06-03 05:48:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Package Explorer - Rename resource should be inline</short_desc>
        <thetext>I'm currently migrating a lot of Documents from DocBook to Asciidoc and have to rename them from .xml to .adoc.

Doing this in the Package Explorer always brings the 
RefactoringWizardDialog2 up. It would be IMHO nicer for the user if simple renames can be done inline and if such popups are only used if necessary, e.g., for refactoring operations.</thetext>
        <comment>
            <comment_id>2716707</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-06-03 06:42:25 -0400</when>
            <comment_text>(In reply to Lars Vogel from comment #0)
&gt; I'm currently migrating a lot of Documents from DocBook to Asciidoc and have
&gt; to rename them from .xml to .adoc.
&gt; 
&gt; Doing this in the Package Explorer always brings the 
&gt; RefactoringWizardDialog2 up. It would be IMHO nicer for the user if simple
&gt; renames can be done inline and if such popups are only used if necessary,
&gt; e.g., for refactoring operations.

Rename is *the* refactoring operation ;-).

Even if you rename a simple file, it will be a refactoring because there can be rename participants. For example, if that simple file is in a 'build.properties' file, then it will also change that file.

Having said that, we also use inline rename inside the Java editor and this can also cause changes in other files.

Note that we would first have to fix bug 74892.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496376</id>
        <developer>Mickael Istria - away until ...</developer>
        <developer_username>mistria</developer_username>
        <dup_id/>
        <creation_time>2016-06-20 04:04:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Add hyperlink on @Override to open overriden method</short_desc>
        <thetext>When doing Ctrl+click on @Override, the current behavior is to open the Override class definition. It would be nice to also provide a link to "Open overriden method" on this annotation.</thetext>
        <comment>
            <comment_id>2724867</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-06-28 08:57:23 -0400</when>
            <comment_text>You can already navigate to the overridden method in the following ways:
- Ctrl+hover on method name in overriding method declaration and select "Open Super Implementation".
- Click on the override indicator (the triangle on the marker bar located at the left of the editor area).</comment_text>
        </comment>
        <comment>
            <comment_id>2724870</comment_id>
            <comment_count>2</comment_count>
            <who>Mickael Istria - away until ...</who>
            <commenter_username>mistria</commenter_username>
            <when>2016-06-28 09:01:22 -0400</when>
            <comment_text>(In reply to Noopur Gupta from comment #1)
&gt; You can already navigate to the overridden method in the following ways:
&gt; - Ctrl+hover on method name in overriding method declaration and select
&gt; "Open Super Implementation".
&gt; - Click on the override indicator (the triangle on the marker bar located at
&gt; the left of the editor area).

Ok, both are actually good. However, I can't tell why, but I usually Ctrl+Click on @Oeverride when I want to access parent definition. Not sure whether it's just me being strange, or if it's shared by an interesting proportion of Eclipse IDE users. So I can't tell whether adding the hyperlink there is worth it or not, it's more food for thoughts.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>501287</id>
        <developer>Lars Vogel</developer>
        <developer_username>Lars.Vogel</developer_username>
        <dup_id/>
        <creation_time>2016-09-12 15:00:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[call hierarchy] Offer next and previous buttons in Call Hierarchy view</short_desc>
        <thetext>Similar to the Search view, I think it would be useful to have a "Next" / "Previous" button to jump to the next caller.</thetext>
        <comment>
            <comment_id>2749892</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-12 16:09:07 -0400</when>
            <comment_text>Given the tree structure of this view, I'm not sure we can easily agree on an intuitive traversal strategy that fits the notion of "Next".
Do you care to elaborate what exactly you had in mind?</comment_text>
        </comment>
        <comment>
            <comment_id>2749893</comment_id>
            <comment_count>2</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-09-12 16:22:04 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #1)
&gt; Do you care to elaborate what exactly you had in mind?

Next/ previous direct caller of the root "search" element</comment_text>
        </comment>
        <comment>
            <comment_id>2749896</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-12 16:33:52 -0400</when>
            <comment_text>(In reply to Lars Vogel from comment #2)
&gt; (In reply to Stephan Herrmann from comment #1)
&gt; &gt; Do you care to elaborate what exactly you had in mind?
&gt; 
&gt; Next/ previous direct caller of the root "search" element

And once you selected a (deeply) nested child node, rather then a direct caller, this operation would be a NOP?</comment_text>
        </comment>
        <comment>
            <comment_id>2749902</comment_id>
            <comment_count>4</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-09-12 16:54:30 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #3)
&gt; And once you selected a (deeply) nested child node, rather then a direct
&gt; caller, this operation would be a NOP?

I think it should continue to select the next / previous direct caller.</comment_text>
        </comment>
        <comment>
            <comment_id>2749907</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-12 17:16:09 -0400</when>
            <comment_text>(In reply to Lars Vogel from comment #4)
&gt; (In reply to Stephan Herrmann from comment #3)
&gt; &gt; And once you selected a (deeply) nested child node, rather then a direct
&gt; &gt; caller, this operation would be a NOP?
&gt; 
&gt; I think it should continue to select the next / previous direct caller.

m()
 - m1()
   - m11()
   - m12()
     - m121()
     - m122()
     - m123()
   - m13()
  -m2()

"Next" on m122() would then jump to m2(). No way! :)</comment_text>
        </comment>
        <comment>
            <comment_id>2750874</comment_id>
            <comment_count>6</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-09-14 12:15:12 -0400</when>
            <comment_text>I agree the Next/Previous buttons/shortcuts from the Search view would also be nice in the Call Hierarchy. They should behave the same as in the Search view where this makes sense (e.g. keep the focus in the view after jumping to the next occurrence).

The Call Hierarchy differs from other views in that the expansion state has much more relevance than elsewhere, so automatically expanding nodes like in the Search view would not be a good idea.

I think the the Up/Down arrow keys already provide most of this, including a useful traversal order. The only missing part is that the Next/Previous actions should additionally traverse through the second, third, etc. match in case there are multiple matches per tree item.</comment_text>
        </comment>
        <comment>
            <comment_id>2750920</comment_id>
            <comment_count>7</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-14 14:11:11 -0400</when>
            <comment_text>(In reply to Markus Keller from comment #6)
&gt; [...] The only missing part is that the Next/Previous
&gt; actions should additionally traverse through the second, third, etc. match
&gt; in case there are multiple matches per tree item.

That would indeed add significant value. I like that.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506044</id>
        <developer>Marc-André Laperle</developer>
        <developer_username>marc-andre.laperle</developer_username>
        <dup_id/>
        <creation_time>2016-10-16 17:10:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[quick fix] Import quick fix cannot be used as multi-fix</short_desc>
        <thetext>Created attachment 264882
Test project

Using Neon.1

When the same import is missing in multiple files, it is not possible to select all of the problems in the Problem view and apply the same quick fix.

1. Import attached project (it contains 2 files with the same missing import)
2. Open the Problem view
3. Select both "List cannot be resolved..." problems (Ctrl-click).
4. Right-click, select Quick Fix

A prompt comes up "the selected problems do not have a common applicable quick fix". But in theory, they have 'Import List' as common quick fix.</thetext>
    </bug>
    <bug>
        <id>506243</id>
        <developer>Sergey Prigogin</developer>
        <developer_username>eclipse.sprigogin</developer_username>
        <dup_id/>
        <creation_time>2016-10-19 19:55:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Infer Generic Type Arguments command should use diamond operator when possible</short_desc>
        <thetext>Infer Generic Type Arguments on the following code

    List list = new ArrayList();
    list.add("");

should produce

    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    list.add("");

instead of

    List&lt;String&gt; list = new ArrayList&lt;String&gt;();
    list.add("");

when source compatibility allows that.</thetext>
    </bug>
    <bug>
        <id>506369</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-10-21 15:21:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[1.9] Support IJavaElements for modules in UI</short_desc>
        <thetext>Support IJavaElements for modules in UI.

As of now, there's the new element IModuleDescription. It currently has more child elements, but IMO those are unnecessary and should be removed again.

I'll add an icon for IModuleDescription for now and I'll disable children of this element where possible.</thetext>
        <comment>
            <comment_id>2769131</comment_id>
            <comment_count>1</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-10-21 15:23:16 -0400</when>
            <comment_text>(In reply to Markus Keller from comment #0)
&gt; I'll add an icon for IModuleDescription for now and I'll disable children of
&gt; this element where possible.
Done with http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=ea9d4c1324f60c894c82d38d61078c85788f442f

This is just a stop-gap commit. The content provider changes will likely be reverted later.</comment_text>
        </comment>
        <comment>
            <comment_id>2769132</comment_id>
            <comment_count>2</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-10-21 15:24:10 -0400</when>
            <comment_text>Created attachment 265003
module_obj.svg</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506591</id>
        <developer>Lars Vogel</developer>
        <developer_username>Lars.Vogel</developer_username>
        <dup_id/>
        <creation_time>2016-10-26 18:43:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[hovering] Allow to disable Java hovers via the Java hover popup</short_desc>
        <thetext>discussed on the Eclipse Platform summit and agreed with Dani, that we should allow the user to disable the hovers via the focused hover directly.

In addition a default shortcut should be defined, I open another bug for that.</thetext>
        <comment>
            <comment_id>2770432</comment_id>
            <comment_count>1</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-10-26 18:49:10 -0400</when>
            <comment_text>Alex, something for you?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506592</id>
        <developer>Lars Vogel</developer>
        <developer_username>Lars.Vogel</developer_username>
        <dup_id/>
        <creation_time>2016-10-26 18:44:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[hovering][key binding] Define a default shortcut to show hovers</short_desc>
        <thetext>As we plan to allow the user to disable the hover, we should provide a default shortcut to show them. See Bug 506591.</thetext>
        <comment>
            <comment_id>2770431</comment_id>
            <comment_count>1</comment_count>
            <who>Lars Vogel</who>
            <commenter_username>Lars.Vogel</commenter_username>
            <when>2016-10-26 18:47:42 -0400</when>
            <comment_text>Alex, something for you?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507667</id>
        <developer>Ed Willink</developer>
        <developer_username>ed</developer_username>
        <dup_id/>
        <creation_time>2016-11-17 05:47:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Problems in the Quick Fix dialog are not sorted and are not sortable</short_desc>
        <thetext>After selecting quick fix in the problems view a helpful dialog appears offering an ability to fix many problems at once.

But the list of selections is not sorted, making it very difficult to select all instances that corresponding to a particular resource.

Suggest:

as a minimum, selecting the "Resource" heading should sort by that column

the entries should in alphabetical resource then line number order from the outset, with the initial selection as invoked.

a regex match filter box</thetext>
        <comment>
            <comment_id>2776977</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-11-17 07:43:30 -0500</when>
            <comment_text>For now, you can sort the Resources in the Problems view and select all the entries where you want to apply the quick fix.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508494</id>
        <developer>Leo Ufimtsev</developer>
        <developer_username>lufimtse</developer_username>
        <dup_id/>
        <creation_time>2016-11-30 14:59:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Implement property change listener in AbstractInformationControl for Javadoc</short_desc>
        <thetext>In:

Bug 507062 – Fix black strip of color in JavaDocHover 

The black-strip issue was fixed. However, the color only changes after you restart eclipse. 
If you go to color preferences and change INFORMATION TEXT or INFORMATION BACKGROUND colors, then the color of the strip at the bottom only changes when you restart eclipse.

From research, I found that we have to add a PropertyChangeListener.

Something like this:

....
  listenForColorChanges()
...

private IPropertyChangeListener fColorListener;
	private void listenForColorChanges() {
		fColorListener= new IPropertyChangeListener() {
			@Override
			public void propertyChange(PropertyChangeEvent event) {
				System.out.println("COLOR Has changed and Abstract has picked up on it."); //$NON-NLS-1$
				// TODO - Find out which propery has changed.
				// TODO - if either HOVER color preferences were changed, set Color again
			}
		};
		JFaceResources.getColorRegistry().addListener(fColorListener);
	}   
  // Based on Javadocview.java -&gt; fFontListener</thetext>
        <comment>
            <comment_id>2783854</comment_id>
            <comment_count>1</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-12-07 09:00:04 -0500</when>
            <comment_text>Make sure you don't screw the lifecycle of fStatusLabelForeground.</comment_text>
        </comment>
        <comment>
            <comment_id>2784076</comment_id>
            <comment_count>2</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-12-07 14:30:10 -0500</when>
            <comment_text>(In reply to Leo Ufimtsev from bug 508776 comment #4)
&gt; &gt; I now even found bug 508494, where you already identified the problem
&gt; &gt; (partially).
&gt; 
&gt; Can you clarify what you mean by 'partially'? Is there something I didn't
&gt; describe in the bug that I should have?

See comment 1. Furthermore, you have to think about other use cases where the dynamic colors can break existing clients, e.g.:

- Clients (e.g. implementors of createContent(..) could assume that the color of the parent composite is constant. Is there something we can do to avoid breakage?

- What do callers of setForegroundColor/setBackgroundColor(..) expect?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>496123</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-06-14 12:24:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] DOM AST for ModuleDeclaration in module-info.java</short_desc>
        <thetext>I'm not sure yet if we desperately need an AST for the ModuleDeclaration in module-info.java. Opening this bug as a place for discussions and to gather requirements.

For consistency, an AST would certainly be nice.

For basic refactorings like Rename Type and Rename Package, reference search results should be enough, since types in module-info.java are always fully-qualified.

But for bug 488754, we might need an AST in order to implement semantic coloring for the restricted keywords.</thetext>
        <comment>
            <comment_id>2778421</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-21 23:48:14 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85453</comment_text>
        </comment>
        <comment>
            <comment_id>2780594</comment_id>
            <comment_count>2</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-11-28 09:39:13 -0500</when>
            <comment_text>http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html dated 2016/10/28 contains new keywords that should also be added to the grammar.

Comments to https://git.eclipse.org/r/#/c/85453/1 :

* ModuleDeclaration:

- Javadoc misses terminating &lt;b&gt;}&lt;/b&gt;

- grammar for children should be: { ExportsStatement | RequiresStatement | UsesStatement | ProvidesStatement }

- should not extend AbstractTypeDeclaration. E.g. "ITypeBinding resolveBinding()" doesn't make sense for a module. A module-info.java can contain only 1 ModuleDeclaration that only shows up at the top level and is not nestable (unlike BodyDeclarations). Since there's no overlap between other Java constructs and ModuleDeclaration, I think the best solution is to:
  - make ModuleDeclaration extend ASTNode
    - add "javadoc" and "modifiers" properties and make sure they are properly added in #propertyDescriptors(int)
  - add CompilationUnit#get/setModule(..)
  - declare in Javadocs of CompilationUnit that not all node combinations make sense

- MODULE_STATEMENTS_PROPERTY: "module statements" in Javadoc should be the same as the string literal in code: "moduleStatements" (camelCase). This property is NO_CYCLE_RISK (I believe already now, but definitely after ModuleDeclaration extends ASTNode).


* ModuleStatement

- should be @noextend. This applies to all abstract ASTNode types, but apparently has been forgotten in the past.

- Javadoc: No commas in the grammar list. Each line should be a variant, and the comma has no meaning in this grammar. Unfortunately already wrong in Statement.java


* module statement node types

- Javadoc grammars:
  - The ',' should be '&lt;b&gt;,&lt;/b&gt;', like all literals that show up in source 1:1.
  - Need &lt;b&gt;;&lt;/b&gt; at the end. 

- Check the cycleRisk of node properties again. Since the module info constructs don't next, I don't think there's a cycle risk anywhere.

- All concrete nodes have some kind of "name" property. All these properties should just be called "name", not "moduleName", "module", "interfacetype", etc. Take ImportDeclaration#NAME_PROPERTY/getName/setName as a template. In general property and getter/setter names should strictly follow the string literal that is used as propertyId in the child descriptor (converting SOME_THING to someThing according to the context).

- Make sure the other properties also use the same spelling everywhere. E.g. ProvidesStatement#IMPLEMENTATION_TYPE_PROPERTY should be 

- RequiresStatement#resolveModuleBinding() would have to return an IModuleBinding (a new kind of IBinding). However, I don't think we need any of the *Statement#resolve*() methods. There's nothing special about those bindings. Clients can just use getName().resolveBinding(). For the exports/opens/provides nodes, a special resolveBinding() method could even be confusing, since there are multiple names contained in those nodes that could be resolved.


* RequiresStatement#getModifiers()

- Javadoc: remove "In the JLS3 API, " (but keep the rest of that paragraph).</comment_text>
        </comment>
        <comment>
            <comment_id>2781512</comment_id>
            <comment_count>3</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-11-30 10:49:19 -0500</when>
            <comment_text>(In reply to Markus Keller from comment #2)
Thanks Markus for the detailed comments - Have updated that in the version 2 which is still under the works. one difference is that in cases where name is more appropriately represented by a Type.class - such as in uses, provides (interface and implementation) the change is done from Name to Type. The WIP patch uploaded now shows the AST in case if you want to take a look.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>509050</id>
        <developer>Manoj Palat</developer>
        <developer_username>manpalat</developer_username>
        <dup_id/>
        <creation_time>2016-12-11 23:08:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[9] code completion support for new grammar changes</short_desc>
        <thetext>code completion support for the changes introduced in ref bug 500636</thetext>
    </bug>
    <bug>
        <id>507737</id>
        <developer>Mauro Molinari</developer>
        <developer_username>mauromol</developer_username>
        <dup_id/>
        <creation_time>2016-11-18 05:33:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[formatter] Still problems in Javadoc formatting for enum values</short_desc>
        <thetext>See bug #471780 comment #28 (I suspect this problem was introduced as a side effect of that fix).

If you have something like:

public enum TestEnum {
	QUEUED(
			"Queued",
			"Very very very very very very very very very very very very very very long text",
			true,
			false,
			false,
			false),
	READY(
			"Ready",
			"Very very very very very very very very very very very very very very long text",
			true,
			false,
			false,
			false),
	RETRYING(
			"Retrying",
			"Very very very very very very very very very very very very very very long text",
			true,
			false,
			false,
			false);

	private final String flowDescription;

	private final String stateInformationPattern;

	private final boolean transiting;

	private final boolean onRemoteSystem;

	private final boolean certified;

	private final boolean stored;

	private TestEnum(String flowDescription, String stateInformation,
			boolean transiting, boolean onRemoteSystem,
			boolean certified, boolean stored) {
		this.flowDescription = flowDescription;
		this.stateInformationPattern = stateInformation;
		this.transiting = transiting;
		this.onRemoteSystem = onRemoteSystem;
		this.certified = certified;
		this.stored = stored;
	}
}

and you add a Javadoc line just before QUEUED (even a simple /** */), all the enum values are formatted on a single line.

This is a sample output:

public enum TestEnum {
	/**  */
	QUEUED("Queued", "Very very very very very very very very very very very very very very long text", true, false, false, false), READY("Ready", "Very very very very very very very very very very very very very very long text", true, false, false, false), RETRYING("Retrying", "Very very very very very very very very very very very very very very long text", true, false, false, false);

	private final String flowDescription;

	private final String stateInformationPattern;

	private final boolean transiting;

	private final boolean onRemoteSystem;

	private final boolean certified;

	private final boolean stored;

	private TestEnum(String flowDescription, String stateInformation, boolean transiting, boolean onRemoteSystem,
			boolean certified, boolean stored) {
		this.flowDescription = flowDescription;
		this.stateInformationPattern = stateInformation;
		this.transiting = transiting;
		this.onRemoteSystem = onRemoteSystem;
		this.certified = certified;
		this.stored = stored;
	}
}

If you add separate Javadoc lines for each value, each single value is put on a single line.

If you use a normal comment /* */ instead of a Javadoc, this seems not to happen.</thetext>
        <comment>
            <comment_id>2777789</comment_id>
            <comment_count>1</comment_count>
            <who>Mateusz Matela</who>
            <commenter_username>mateusz.matela</commenter_username>
            <when>2016-11-19 09:27:06 -0500</when>
            <comment_text>I can reproduce the problem in 4.6.2RC2, but not in I20161118. Can you confirm?

I think we can skip this one, since it seems it will work fine in 4.7 and it is probably not critical enough to fix in 4.6.2 at this stage.</comment_text>
        </comment>
        <comment>
            <comment_id>2778083</comment_id>
            <comment_count>2</comment_count>
            <who>Mauro Molinari</who>
            <commenter_username>mauromol</commenter_username>
            <when>2016-11-21 06:30:12 -0500</when>
            <comment_text>Hi Mateusz,
I confirm it does not happen in I20161119-2000.
However, please note that, as bug #471780 proves, enum Javadoc formatting problems constitute a regression from Eclipse 4.4. If you choose to fix this only in 4.7, it means another full release cycle (the whole 4.6.x, after the whole 4.5.x) without proper enum Javadoc formatting :-(

Anyway, it's your choice, of course.

Thank you for your support!</comment_text>
        </comment>
        <comment>
            <comment_id>2778111</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-21 08:02:38 -0500</when>
            <comment_text>(In reply to Mauro Molinari from comment #2)
&gt; Hi Mateusz,
&gt; I confirm it does not happen in I20161119-2000.
&gt; However, please note that, as bug #471780 proves, enum Javadoc formatting
&gt; problems constitute a regression from Eclipse 4.4. If you choose to fix this
&gt; only in 4.7, it means another full release cycle (the whole 4.6.x, after the
&gt; whole 4.5.x) without proper enum Javadoc formatting :-(

The process only has room for back porting to the previous version, in this case to 4.6.3, which is few weeks away. 4.6.2 went out very recently and is done.

If you have compelling reasons to have this fix in 4.6.3 (i.e. you can't wait till 4.7 is out) we can consider back porting.</comment_text>
        </comment>
        <comment>
            <comment_id>2778123</comment_id>
            <comment_count>4</comment_count>
            <who>Mauro Molinari</who>
            <commenter_username>mauromol</commenter_username>
            <when>2016-11-21 08:23:04 -0500</when>
            <comment_text>The main reason is that this kind of formatter regressions cause issues with code style policies, given that we have formatting code save actions applied to the code we share among our team. So, a bug in the formatter causes issues when team members use different versions of the IDE, especially whenever code merging is involved. That's all.</comment_text>
        </comment>
        <comment>
            <comment_id>2778135</comment_id>
            <comment_count>5</comment_count>
            <who>Mateusz Matela</who>
            <commenter_username>mateusz.matela</commenter_username>
            <when>2016-11-21 09:02:00 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #3) 
&gt; If you have compelling reasons to have this fix in 4.6.3 (i.e. you can't
&gt; wait till 4.7 is out) we can consider back porting.

I didn't look at this closely yet, but I think this problem has been fixed with bug 493296. So it'd probably be a separate fix specifically for the maintenance branch rather than back porting. Unless we want to backport all the major (and a bit risky) changes from bug 493296.

Can we commit to the maintenance branch without corresponding changes in master? If so, I think I can look at this before 4.6.3.</comment_text>
        </comment>
        <comment>
            <comment_id>2778158</comment_id>
            <comment_count>6</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-21 09:32:35 -0500</when>
            <comment_text>(In reply to Mateusz Matela from comment #5)
&gt; I didn't look at this closely yet, but I think this problem has been fixed
&gt; with bug 493296. So it'd probably be a separate fix specifically for the
&gt; maintenance branch rather than back porting. Unless we want to backport all
&gt; the major (and a bit risky) changes from bug 493296.
&gt; 
&gt; Can we commit to the maintenance branch without corresponding changes in
&gt; master? If so, I think I can look at this before 4.6.3.

That makes the 'reason' for back port all the more important. With such a risk associated, I am not inclined to recommend this for 4.6.3.</comment_text>
        </comment>
        <comment>
            <comment_id>2785273</comment_id>
            <comment_count>7</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-12-11 16:11:12 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/86925</comment_text>
        </comment>
        <comment>
            <comment_id>2785276</comment_id>
            <comment_count>8</comment_count>
            <who>Mateusz Matela</who>
            <commenter_username>mateusz.matela</commenter_username>
            <when>2016-12-11 16:24:49 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #6)
&gt; That makes the 'reason' for back port all the more important. With such a
&gt; risk associated, I am not inclined to recommend this for 4.6.3.

I didn't catch your meaning - there's an important reason for back port, but it's not recommended?
Anyway, I was curious to see what's going on and I prepared a bugfix for the maintenance branch. There's a quirk in enum constant wrapping which becomes irrelevant after fix for bug 493296.
This change should be safe as it affects only enum constants with preceding comments. It's your choice to pull it in or not.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488566</id>
        <developer>Roland Tepp</developer>
        <developer_username>rolandt</developer_username>
        <dup_id/>
        <creation_time>2016-02-26 09:51:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[JUnit] Add support for JUnit 5</short_desc>
        <thetext>JUnit team has released first alpha of new JUnit 5 testing framework.

JUnit 5 is complete rewrite of the popular5 testing framework and among other goals of the new version is better support for IDEs and other third party test runners.

They are currently gathering feedback from potential consumers of JUnit api, so I would thing that this is a very good time for Eclipse JDT team to take a hard look at JUnit 5 development and start working together with Junit team on better test runner api design.</thetext>
        <comment>
            <comment_id>2730997</comment_id>
            <comment_count>1</comment_count>
            <who>Robin Textor</who>
            <commenter_username>robin.textor</commenter_username>
            <when>2016-07-15 15:29:06 -0400</when>
            <comment_text>The first stable release of JUnit 5 is out...
IntelliJ already provides support for it...
Time to catch up!</comment_text>
        </comment>
        <comment>
            <comment_id>2732576</comment_id>
            <comment_count>2</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-07-21 07:52:10 -0400</when>
            <comment_text>Noopur, please have a look at http://junit.org/junit5/ and see how we can integrate support for JUnit 5 in Eclipse.

JUnit 5 requires Java 8. Although the JUnit Vintage sub-project should allow running JUnit 3 and 4 tests, we still need to keep the native JUnit 3 and 4 runners to support running tests in environments where Java 8 is not available.

https://dev.eclipse.org/mhonarc/lists/jdt-ui-dev/msg01488.html mentioned a prototype for basic JUnit 5 support in Eclipse, but it doesn't look like it has been updated recently, so I guess it's probably easier to just start from scratch.</comment_text>
        </comment>
        <comment>
            <comment_id>2737185</comment_id>
            <comment_count>3</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-08-04 08:58:43 -0400</when>
            <comment_text>http://search.maven.org/#search%7Cga%7C1%7Corg.junit and page 2 should yield links to download pre-built versions of JUnit 5 JARs and source JARs. These will eventually go into Orbit, but only after they have been officially released.

Use the newer org.junit.platform, org.junit.vintage, and org.junit.jupiter versions (M2), and not the 5.0.0-ALPHA stuff.

Implementation-wise, the new org.eclipse.jdt.junit5.runtime bundle that will be provided as part of this bug will depend on the orbitized JUnit 5 bundles. In non-OSGi contexts where the o.e.j.junit5.runtime JAR will just be put on the classpath, the OSGi dependencies in the MANIFEST.MF will not be processed anyway.</comment_text>
        </comment>
        <comment>
            <comment_id>2772943</comment_id>
            <comment_count>4</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-11-04 06:22:05 -0400</when>
            <comment_text>Released the initial code to BETA_JUNIT5 branch of jdt.ui repo and added the new org.eclipse.jdt.junit5.runtime bundle with required JUnit 5 JARs to a new repo on GitHub.

Follow these steps to setup the code and try out the JUnit 5 support:

- Open a new workspace with Eclipse 4.7 M3 build and set API baseline as Eclipse 4.6.

- Clone the repo: https://github.com/noopur2507/eclipse-junit5.git and import the project: org.eclipse.jdt.junit5.runtime

- Copy the jars from the cloned folder eclipse-junit5\JUnit-5-JARs to your Eclipse's "dropins" folder.

- Clone the repo: git://git.eclipse.org/gitroot/jdt/eclipse.jdt.ui.git and checkout the BETA_JUNIT5 branch. Import the projects: org.eclipse.jdt.ui, org.eclipse.jdt.junit, org.eclipse.jdt.junit.core, org.eclipse.jdt.junit.runtime, org.eclipse.jdt.junit4.runtime

- Restart Eclipse. The workspace should not have any error now.

- Launch a runtime Eclipse application to try out the JUnit 5 support. You can add the JUnit 5 library container to a project via the Java Build Path settings or with the help of a quick fix on @Test / @TestFactory / @Testable.

It's a work in progress and known to have some missing functionality and issues, which are not yet listed on Bugzilla. So, please feel free to provide feedback and report issues.</comment_text>
        </comment>
        <comment>
            <comment_id>2773306</comment_id>
            <comment_count>5</comment_count>
            <who>Sam Brannen</who>
            <commenter_username>sam</commenter_username>
            <when>2016-11-05 12:19:45 -0400</when>
            <comment_text>First and foremost, thanks for the great work Noopur!!!

I tried it out and am really quite impressed. :)

The only issue I noticed is that the green/red success/failure bar in the JUnit view is displayed as green if the return type for a dynamic test method is invalid. The dynamic test and its enclosing class are in fact marked as as failures (i.e., red). Thus, the overall test run should also be marked as a failure. To reproduce this, just run the DynamicTestsDemo [0].

If you need me to create a new bug issue to track this, just let me know.

Cheers,

Sam


[0] https://github.com/junit-team/junit5/blob/ba94add9b2c522f867f17a693960fad6b72716ca/documentation/src/test/java/example/DynamicTestsDemo.java</comment_text>
        </comment>
        <comment>
            <comment_id>2773673</comment_id>
            <comment_count>6</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-11-07 10:37:27 -0500</when>
            <comment_text>(In reply to Sam Brannen from comment #5)

Thanks, Sam. I have created bug 507171 for the reported issue.</comment_text>
        </comment>
        <comment>
            <comment_id>2781350</comment_id>
            <comment_count>7</comment_count>
            <who>Aurelien Pupier</who>
            <commenter_username>apupier</commenter_username>
            <when>2016-11-30 05:30:15 -0500</when>
            <comment_text>Just a note to notify about the 5.0.0-M3 release http://junit.org/junit5/docs/current/user-guide/#release-notes-5.0.0-m3

there are several breaking changes mentioned, I have no idea if Eclipse is hit by one of them but will worth planning to test it.</comment_text>
        </comment>
        <comment>
            <comment_id>2784302</comment_id>
            <comment_count>8</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-12-08 08:21:30 -0500</when>
            <comment_text>I have updated the repositories mentioned in comment #4 to adapt to the 5.0.0-M3 release of JUnit 5.

Instead of Eclipse 4.7 M3 build, the 4.7 M4 build should be used now to try out the JUnit 5 support in Eclipse based on the steps in comment #4.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488748</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-03-01 05:15:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[1.9] Provide a command/tool to convert a project to module</short_desc>
        <thetext>I have released some change in Core for creating a module-info from a given IPackageFragmentRoot. The changes are here:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=b9da98e4a12f82e982be70838141e32cdd231156

The API is not ideal. Ideally we want it to return something like IModule or something like that. But because we don't have a module representation in Java model and DOM, we will have to settle for this for now.

The command can take this string and put it into a unit name module-info.java directly under the package fragment root.</thetext>
        <comment>
            <comment_id>2677351</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-03-01 06:41:59 -0500</when>
            <comment_text>The command/tool will be invoked at the package fragment root (source folder) and will create a module-info.java file (adding the file content received from jdt.core API) in the default package of that source folder.

This is similar to bug 482582 and the same option added for that bug can by used as the tool to convert the root to module (by creating the module-info.java file in its default package).

I will complete the patch for bug 482582 and will use the new JavaCore#createModuleFromPackageRoot API for the file content.</comment_text>
        </comment>
        <comment>
            <comment_id>2677395</comment_id>
            <comment_count>2</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-03-01 08:46:11 -0500</when>
            <comment_text>(In reply to Noopur Gupta from comment #1)
&gt; The command/tool will be invoked at the package fragment root (source
&gt; folder) and will create a module-info.java file (adding the file content
&gt; received from jdt.core API) in the default package of that source folder.
&gt; 
&gt; This is similar to bug 482582 and the same option added for that bug can by
&gt; used as the tool to convert the root to module (by creating the
&gt; module-info.java file in its default package).
&gt; 
&gt; I will complete the patch for bug 482582 and will use the new
&gt; JavaCore#createModuleFromPackageRoot API for the file content.

Released the patch for bug 482582 which can be used for ECNA demo as the migration command. 

If required, this can be added as a separate action later on.</comment_text>
        </comment>
        <comment>
            <comment_id>2748957</comment_id>
            <comment_count>3</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-09-09 07:31:00 -0400</when>
            <comment_text>The action will be available in the "Configure" context menu on a project and will create the module-info.java file.

Changes from bug 482582 will be reverted.</comment_text>
        </comment>
        <comment>
            <comment_id>2748965</comment_id>
            <comment_count>4</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-09-09 07:41:25 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/80783</comment_text>
        </comment>
        <comment>
            <comment_id>2748967</comment_id>
            <comment_count>5</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-09-09 07:42:42 -0400</when>
            <comment_text>*** Bug 482582 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
        <comment>
            <comment_id>2748979</comment_id>
            <comment_count>6</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-09-09 08:00:18 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #4)
&gt; New Gerrit change created: https://git.eclipse.org/r/80783

This patch reverts the changes from bug 482582 and adds a context menu option "Create module-info.java" under the "Configure" context menu on a project with java nature (includes plug-in projects).

It creates the module-info.java file in the default package of the first source folder.

If a module-info.java file already exists in the default package of any source folder in that project, the user is given the option to overwrite it.

If the project has a compliance level below 9, an error message is shown currently. We can improve it later to change the project to 9, if required.

For the file contents, the temporary API from comment #0 is used.

Jay, please have a look at the behavior (CreateModuleInfoAction.java) and suggest if changes are required. Also, provide the final API which can be used instead of the API from comment #0.</comment_text>
        </comment>
        <comment>
            <comment_id>2749406</comment_id>
            <comment_count>7</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-12 02:18:23 -0400</when>
            <comment_text>(In reply to Noopur Gupta from comment #6)
&gt; Jay, please have a look at the behavior (CreateModuleInfoAction.java) and
&gt; suggest if changes are required. Also, provide the final API which can be
&gt; used instead of the API from comment #0.

Looks good. I came across few bugs in the module descriptor's content, though. That part needs significant changes anyway.

So, would returning a JavaModel (let's say IModule) be enough? There's a version of this exists without much documentation already.

Or do you need a assistance from DOM side as well somehow?</comment_text>
        </comment>
        <comment>
            <comment_id>2749443</comment_id>
            <comment_count>8</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-09-12 04:18:57 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #7)
&gt; So, would returning a JavaModel (let's say IModule) be enough? There's a
&gt; version of this exists without much documentation already.
&gt; 
&gt; Or do you need a assistance from DOM side as well somehow?

Java model API(s) should be good enough to create the contents of module-info.java file here.</comment_text>
        </comment>
        <comment>
            <comment_id>2769196</comment_id>
            <comment_count>9</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-10-22 03:57:19 -0400</when>
            <comment_text>What's the state here?</comment_text>
        </comment>
        <comment>
            <comment_id>2769197</comment_id>
            <comment_count>10</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-22 04:10:48 -0400</when>
            <comment_text>I had changed the API being used by UI but then reverted it to keep the build going. The revert was this:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=279152beda9141939083ad9ed1f5782eb729f730

If we could agree on a time for simultaneous release, I can put that change back in. The new API now takes a IJavaProject instead of a package fragment root and returns an IModuleDescription instead of a String.</comment_text>
        </comment>
        <comment>
            <comment_id>2769205</comment_id>
            <comment_count>11</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-22 05:38:20 -0400</when>
            <comment_text>Created attachment 265006
Updated UI patch

Updated the UI patch.

This should go with the new Core API. But we need to have a careful look at the API if it were to be permanent solution. For two reasons:

1. This seems out of place in a global API like JavaCore.
2. The API is going to return a handle only Java element that doesn't exist. So, the utility that constructs the module has to ensure that the element infos are not read. The client code must also ensure that it only accesses the information that is intended. Now, what is intended to be accessed is a sub-set of what the module element 'can' contain, so the client must not try to access other information.

I will also attach a patch for core that goes with this patch.</comment_text>
        </comment>
        <comment>
            <comment_id>2769206</comment_id>
            <comment_count>12</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-22 05:42:15 -0400</when>
            <comment_text>Created attachment 265007
Core part

Patch for the Core part.

The patch I added for UI needs close inspection. I only put that code for testing, I am not sure if that's the right way to create a file content. For e.g., I have hard-coded the line delimiter.</comment_text>
        </comment>
        <comment>
            <comment_id>2769394</comment_id>
            <comment_count>13</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-10-24 04:51:11 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #10)
&gt; If we could agree on a time for simultaneous release, I can put that change
&gt; back in. The new API now takes a IJavaProject instead of a package fragment
&gt; root and returns an IModuleDescription instead of a String.

Jay, I am having a look at the updated patch from comment #11 which uses the new API and making the necessary changes now. We can commit the patches after that.</comment_text>
        </comment>
        <comment>
            <comment_id>2769465</comment_id>
            <comment_count>14</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-10-24 07:34:49 -0400</when>
            <comment_text>Created attachment 265020
Updated UI patch

Attaching the updated UI patch based on the patch from comment #11:

- Using the line delimiter which is used by the specified project.

- For indentation, the patch still uses:
fileContent.append('\t');

I assume this should not be required and the file should be formatted correctly  by the formatter. But currently, the formatter doesn't work with CodeFormatter.K_COMPILATION_UNIT for module-info.java file. Reported bug 506430 for this.

- Removed the code from the patch which adds "to" and "public" in the file as I don't think these details will be available and should be added when a module-info.java file is newly created. Jay, let me know if this is not the case. 

As discussed with Dani, this scenario is not intended to be demoed at ECE 2016. So we need not rush to commit the changes.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506383</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-10-22 08:06:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[1.9] Renaming a package does not rename it in module-info.java</short_desc>
        <thetext>Renaming a package does not rename it in module-info.java.

It also causes an NPE in JDT Core (see bug ).</thetext>
        <comment>
            <comment_id>2769218</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-10-22 08:07:06 -0400</when>
            <comment_text>(In reply to Dani Megert from comment #0)
&gt; It also causes an NPE in JDT Core (see bug ).

See bug 506384.</comment_text>
        </comment>
        <comment>
            <comment_id>2769241</comment_id>
            <comment_count>2</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-10-22 10:54:09 -0400</when>
            <comment_text>See also bug 506384.</comment_text>
        </comment>
        <comment>
            <comment_id>2769512</comment_id>
            <comment_count>3</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-10-24 09:17:20 -0400</when>
            <comment_text>RenamePackageProcessor.PackageRenamer#getReferences does not get package references from module-info.java file from the Search Engine. Reported bug 506438 in jdt.core.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499339</id>
        <developer>Sarika Sinha</developer>
        <developer_username>sarika.sinha</developer_username>
        <dup_id/>
        <creation_time>2016-08-08 00:29:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Improving performance in Step Over return calculation by introducing filter methods</short_desc>
        <thetext>Further to Bug 40912, we can introduce filtering of methods to improve the performance and avoid return value calculations.</thetext>
        <comment>
            <comment_id>2738296</comment_id>
            <comment_count>1</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-08-08 15:23:59 -0400</when>
            <comment_text>To observe return values, method exit events need to be used. This is done for "Step-Return". All possible filter are used for this. For "Step Over", MethodEntryEvents without filters are used, which then auto-trigger a "Step-Return". 

Unfortunately this makes things slower, because it turns the JIT off (see https://docs.oracle.com/javase/8/docs/technotes/guides/jpda/enhancements1.4.html):
"Execution reverts to the interpreter during some debug operations such as single-stepping and when method entry/exit or watchpoints are set." 

A possible optimization would be to turn off the method exit events for step-return, if the current method is in a filtered location (which may have been reached by MethodEntryEvent during step-over). In my experiments, I haven't observed a notable speedup by this kind of filtering, maybe because it takes some time for the JIT to kick in, so this would only be beneficial for really expensive method invocations.

Sarika, do you have a specific test case that we might want to look at or another idea for optimizing things?</comment_text>
        </comment>
        <comment>
            <comment_id>2738304</comment_id>
            <comment_count>2</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-08-08 16:03:13 -0400</when>
            <comment_text>Some (smaller) optimization ideas:
- If the current method returns "void", no method exit events need to be observed. This should a simple, local optimization.
- When a method entry event is observed during "step-over", an (unfiltered) exception request is deleted and an equivalent once is immediately created. Obviously, the existing one could just be left untouched instead. This might make the code harder to read.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508219</id>
        <developer>Till Brychcy</developer>
        <developer_username>register.eclipse</developer_username>
        <dup_id/>
        <creation_time>2016-11-25 16:06:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[quick fix] "remove redundant NonNullByDefault" caused by NonNullByDefault on fields or local variables</short_desc>
        <thetext>The quick-fix that removes redundant NonNullByDefault needs to be updated for the new problem IDs introduced by bug 484926 (once it is merged).
Also, not only ASTNodes of type MarkerAnnotation should be removed, but any Annotation.</thetext>
        <comment>
            <comment_id>2780219</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-25 16:10:16 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85802</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489980</id>
        <developer>Dirk Fauth</developer>
        <developer_username>dirk.fauth</developer_username>
        <dup_id/>
        <creation_time>2016-03-18 19:16:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Not possible to specify Java 8 compact profiles as Execution Environment</short_desc>
        <thetext>With Java 8 the compact profiles where introduced: https://blogs.oracle.com/jtc/entry/a_first_look_at_compact

As of Bug 432027 Equinox sets and already uses such compact profiles as Execution Environment.

It is not possible for a user to select a Java 8 compact profile as Execution Environment in the Manifest Editor. It is also not possible to connect a JRE to such a BREE in the preferences. Therefore I'm not 100% sure if this is a ticket for PDE or JDT.</thetext>
        <comment>
            <comment_id>2684918</comment_id>
            <comment_count>1</comment_count>
            <who>Vikas Chandra</who>
            <commenter_username>Vikas.Chandra</commenter_username>
            <when>2016-03-21 02:30:10 -0400</when>
            <comment_text>This API gives the execution environments
IExecutionEnvironment[] org.eclipse.jdt.internal.launching.environments.EnvironmentsManager.getExecutionEnvironments()

I am getting JavaSE-1.8. I am not sure about compact profile.

Moving to JDT for further investigation.</comment_text>
        </comment>
        <comment>
            <comment_id>2739233</comment_id>
            <comment_count>2</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-08-11 07:24:11 -0400</when>
            <comment_text>Moving it to 4.7 as the implementation will depend on how we decide to implement it for Java 9.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498044</id>
        <developer>Sarika Sinha</developer>
        <developer_username>sarika.sinha</developer_username>
        <dup_id/>
        <creation_time>2016-07-18 05:26:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>[1.9] Adapt JEP 261 changes to support new options</short_desc>
        <thetext>New options to be supported for Java 9 -

1. The upgrade module path (--upgrade-module-path)
2. The application module path (--module-path, or -mp for short)
3. The application's main module (--module, or -m for short)
4. To add modules to the default root set (--add-modules &lt;module&gt;(,&lt;module&gt;)*)
5. To limit the observable modules (--limit-modules &lt;module&gt;(,&lt;module&gt;)*)
6. To read some other module (--limit-modules &lt;module&gt;(,&lt;module&gt;)*)
7. To access unexported type of another module (--add-exports &lt;source-module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*)
8. To replace selected class files or resources of specific modules (--patch-module &lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*)
9. To display the names and version strings of the observable modules (--list-modules)
10. To display the full module descriptors of the named modules (--list-modules &lt;module&gt;(,&lt;module&gt;)*)

Additional diagnostic options supported by the launcher include:

1. -Xdiag:resolver causes the module system to describe its activities as it constructs the initial module graph.

2. -Dsun.reflect.debugModuleAccessChecks causes a thread dump to be shown whenever an access check in the java.lang.reflect API fails with an IllegalAccessException or an InaccessibleObjectException. 

3. -Xlog:modules=[debug|trace] causes the VM to log debug or trace messages as modules are defined and changed in the run-time module graph.


Options not supported in Java 9 -
-bootclasspath, -Xbootclasspath, -extdirs, -endorseddirs, and -XXuserPathsFirst may not be used.</thetext>
        <comment>
            <comment_id>2758765</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-03 05:15:40 -0400</when>
            <comment_text>*** Bug 493899 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
        <comment>
            <comment_id>2759520</comment_id>
            <comment_count>2</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-04 06:00:36 -0400</when>
            <comment_text>(In reply to Sarika Sinha from comment #0)
Correction -
&gt; 6. To read some other module (--add-reads &lt;source-module&gt;=&lt;target-module&gt;)</comment_text>
        </comment>
        <comment>
            <comment_id>2760720</comment_id>
            <comment_count>3</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-05 05:20:22 -0400</when>
            <comment_text>As of Java 9 version 131, available options are -
 -mp &lt;module path&gt;
 -modulepath &lt;module path&gt;...
               A ; separated list of directories, each directory
               is a directory of modules.
 -upgrademodulepath &lt;module path&gt;...
               A ; separated list of directories, each directory
               is a directory of modules that replace upgradeable
               modules in the runtime image
 -m &lt;modulename&gt;[/&lt;mainclass&gt;]
               the initial module to resolve, and the name of the main class
               to execute if not specified by the module
 -addmods &lt;modulename&gt;[,&lt;modulename&gt;...]
               root modules to resolve in addition to the initial module
 -limitmods &lt;modulename&gt;[,&lt;modulename&gt;...]
               limit the universe of observable modules
 -listmods[:&lt;modulename&gt;[,&lt;modulename&gt;...]]
               list the observable modules and exit</comment_text>
        </comment>
        <comment>
            <comment_id>2760740</comment_id>
            <comment_count>4</comment_count>
            <who>Klara Ward</who>
            <commenter_username>klara.ward</commenter_username>
            <when>2016-10-05 05:36:29 -0400</when>
            <comment_text>Notice that these arguments have changed after build 131, and could possible change again, current state in Jigsaw EA 138:

    -p &lt;module path&gt;
    --module-path &lt;module path&gt;...
                  A ; separated list of directories, each directory
                  is a directory of modules.
    --upgrade-module-path &lt;module path&gt;...
                  A ; separated list of directories, each directory
                  is a directory of modules that replace upgradeable
                  modules in the runtime image
    -m &lt;module&gt;[/&lt;mainclass&gt;]
    --module &lt;modulename&gt;[/&lt;mainclass&gt;]
                  the initial module to resolve, and the name of the main class
                  to execute if not specified by the module
    --add-modules &lt;modulename&gt;[,&lt;modulename&gt;...]
                  root modules to resolve in addition to the initial module.
                  &lt;modulename&gt; can also be ALL-DEFAULT, ALL-SYSTEM,
                  ALL-MODULE-PATH.
    --limit-modules &lt;modulename&gt;[,&lt;modulename&gt;...]
                  limit the universe of observable modules
    --list-modules [&lt;modulename&gt;[,&lt;modulename&gt;...]]
                  list the observable modules and exit</comment_text>
        </comment>
    </bug>
    <bug>
        <id>498279</id>
        <developer>Yannis Kargakis</developer>
        <developer_username>jokargakis</developer_username>
        <dup_id/>
        <creation_time>2016-07-21 09:17:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>No Compatible JREs after updating java to 1.8.0_102</short_desc>
        <thetext>Created attachment 263239
screenshot

Hello,
After updating java to 1.8.0_102 eclipse does not show compatible execution environments to JavaSE-1.8 (see attached screenshot).

There is no a solution for me to change JRE library from Java Build Path on the properties of the project, since after a maven update the jre library still to be unbounded.

Any help?
Thanks,</thetext>
        <comment>
            <comment_id>2732630</comment_id>
            <comment_count>1</comment_count>
            <who>Yannis Kargakis</who>
            <commenter_username>jokargakis</commenter_username>
            <when>2016-07-21 09:23:09 -0400</when>
            <comment_text>Releted envirometns (JAVA_HOME,Path etc) have been set it properly</comment_text>
        </comment>
        <comment>
            <comment_id>2732942</comment_id>
            <comment_count>2</comment_count>
            <who>Andrey Loskutov</who>
            <commenter_username>loskutov</commenter_username>
            <when>2016-07-22 03:27:22 -0400</when>
            <comment_text>Please try to check if you see the same behavior with 4.6.0.</comment_text>
        </comment>
        <comment>
            <comment_id>2732944</comment_id>
            <comment_count>3</comment_count>
            <who>Andrey Loskutov</who>
            <commenter_username>loskutov</commenter_username>
            <when>2016-07-22 03:32:53 -0400</when>
            <comment_text>Just tested with the 4.6.0 SDK, everything works. How do you specify the JVM for Eclipse? Do you have multiple JRE installations? What is JAVA_HOME saying?</comment_text>
        </comment>
        <comment>
            <comment_id>2732971</comment_id>
            <comment_count>4</comment_count>
            <who>Yannis Kargakis</who>
            <commenter_username>jokargakis</commenter_username>
            <when>2016-07-22 04:46:45 -0400</when>
            <comment_text>Hello,
I tried to 4.6.0 but the behavor is the same. I have totally removed old JRE installations. JVM for eclipse has been defined on eclipse.ini as: 

-vm
C:\Developer\tools\Java\jdk1.8.0_102\bin\javaw.exe

JAVA_HOME: C:\Developer\tools\Java\jdk1.8.0_102</comment_text>
        </comment>
        <comment>
            <comment_id>2732973</comment_id>
            <comment_count>5</comment_count>
            <who>Yannis Kargakis</who>
            <commenter_username>jokargakis</commenter_username>
            <when>2016-07-22 04:48:33 -0400</when>
            <comment_text>I think that somehow the problem is related with Bug 266651</comment_text>
        </comment>
        <comment>
            <comment_id>2732979</comment_id>
            <comment_count>6</comment_count>
            <who>Andrey Loskutov</who>
            <commenter_username>loskutov</commenter_username>
            <when>2016-07-22 05:07:21 -0400</when>
            <comment_text>(In reply to Yannis Kargakis from comment #5)
&gt; I think that somehow the problem is related with Bug 266651

SO it should not appear if you test with new workspace? So please, try to reproduce it with a clean Eclipse 4.6.0 install and a new workspace.</comment_text>
        </comment>
        <comment>
            <comment_id>2732985</comment_id>
            <comment_count>7</comment_count>
            <who>Yannis Kargakis</who>
            <commenter_username>jokargakis</commenter_username>
            <when>2016-07-22 05:28:07 -0400</when>
            <comment_text>(In reply to Andrey Loskutov from comment #6)
&gt; (In reply to Yannis Kargakis from comment #5)
&gt; &gt; I think that somehow the problem is related with Bug 266651
&gt; 
&gt; SO it should not appear if you test with new workspace? So please, try to
&gt; reproduce it with a clean Eclipse 4.6.0 install and a new workspace.

Unfortunately nothing :(
I have reinstalled java, used a clean Eclipse 4.6.0 with a new workspace</comment_text>
        </comment>
        <comment>
            <comment_id>2733337</comment_id>
            <comment_count>8</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-07-25 02:06:49 -0400</when>
            <comment_text>What was the previous version of Java being used ?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506401</id>
        <developer>Sarika Sinha</developer>
        <developer_username>sarika.sinha</developer_username>
        <dup_id/>
        <creation_time>2016-10-24 01:31:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>[Tests] testTranslateContainers failing with missing /JarProject/lib/sample.jar</short_desc>
        <thetext>Tests are failing since 17th Oct randomly on different tests/machines 

testTranslateContainers	Failure	We did not find a source container that was a PackageFragmentRootSourceContainer and had the name /JarProject/lib/sample.jar

junit.framework.AssertionFailedError: We did not find a source container that was a PackageFragmentRootSourceContainer and had the name /JarProject/lib/sample.jar
at org.eclipse.jdt.debug.tests.sourcelookup.JarSourceLookupTests.testTranslateContainers(JarSourceLookupTests.java:118)
at org.eclipse.jdt.debug.tests.AbstractDebugTest.runBare(AbstractDebugTest.java:2470)
at org.eclipse.jdt.debug.tests.DebugSuite$1.run(DebugSuite.java:57)
at java.lang.Thread.run(Thread.java:745)

http://download.eclipse.org/eclipse/downloads/drops4/N20161021-2100/testresults/html/org.eclipse.jdt.debug.tests_ep47N-unit-cen64_linux.gtk.x86_64_8.0.html

It fails on Windows and linux randomly. On Mac it has not failed yet.</thetext>
        <comment>
            <comment_id>2769334</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-24 01:35:45 -0400</when>
            <comment_text>@Sravan,
Can you help in this failing test.</comment_text>
        </comment>
        <comment>
            <comment_id>2771010</comment_id>
            <comment_count>2</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-10-28 09:13:43 -0400</when>
            <comment_text>*** Bug 412763 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
        <comment>
            <comment_id>2776927</comment_id>
            <comment_count>3</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-11-17 05:32:55 -0500</when>
            <comment_text>I am seeing this common exception in logs with failing tests:

Exception in thread "main" java.lang.SecurityException: class "a.JarClass"'s signer information does not match signer information of other classes in the same package
	at java.lang.ClassLoader.checkCerts(ClassLoader.java:898)
	at java.lang.ClassLoader.preDefineClass(ClassLoader.java:668)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:761)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:73)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:368)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:362)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:361)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at a.RunJar.main(RunJar.java:15)</comment_text>
        </comment>
        <comment>
            <comment_id>2776962</comment_id>
            <comment_count>4</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-11-17 07:10:51 -0500</when>
            <comment_text>Able to reproduce locally sometime with some combination of tests.
JavaProjectSourceContainerTests
SourceLocationTests
TypeResolutionTests
JarSourceLookupTests
JavaLibraryPathTests
ClasspathVariableTests
ClasspathContainerTests
RuntimeClasspathEntryTests
ClasspathProviderTests


Can't reproduce it while debugging</comment_text>
        </comment>
        <comment>
            <comment_id>2777049</comment_id>
            <comment_count>5</comment_count>
            <who>Andrey Loskutov</who>
            <commenter_username>loskutov</commenter_username>
            <when>2016-11-17 09:05:46 -0500</when>
            <comment_text>(In reply to Sarika Sinha from comment #3)
&gt; I am seeing this common exception in logs with failing tests:
&gt; 
&gt; Exception in thread "main" java.lang.SecurityException: class "a.JarClass"'s
&gt; signer information does not match signer information of other classes in the
&gt; same package

So tests running before loaded classes from "a" package from different jar file. Either we should use unique package names or understand why do we have multiple jar files with same package structure.</comment_text>
        </comment>
        <comment>
            <comment_id>2777956</comment_id>
            <comment_count>6</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-11-21 00:07:09 -0500</when>
            <comment_text>Trying with the combinations of 3 tests in this file currently. 
1. Kept testTranslateContainers() and commented testInspectClassFileFromJar() and testShowClassFileFromJar() - no jar sign error in the log but testTranslateContainers fails consistently in all OS which was generally failing in some of them.
2. Have kept testInspectClassFileFromJar() and commented testTranslateContainers() and testShowClassFileFromJar() . 

Bug 499385 was released almost same time. Observing many VMDisconnectedException in the logs (~90) but can't pinpoint the problem right now.</comment_text>
        </comment>
        <comment>
            <comment_id>2778418</comment_id>
            <comment_count>7</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-11-21 22:54:27 -0500</when>
            <comment_text>Bug 499385 has released some changes, reverted the test changes to see the impact.</comment_text>
        </comment>
        <comment>
            <comment_id>2781483</comment_id>
            <comment_count>8</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-30 10:06:45 -0500</when>
            <comment_text>(In reply to Sarika Sinha from comment #7)
&gt; Bug 499385 has released some changes, reverted the test changes to see the
&gt; impact.

Still failing: http://download.eclipse.org/eclipse/downloads/drops4/I20161129-2330/testresults/html/org.eclipse.jdt.debug.tests_ep47I-unit-lin64_linux.gtk.x86_64_8.0.html</comment_text>
        </comment>
        <comment>
            <comment_id>2782294</comment_id>
            <comment_count>9</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-12-02 07:11:05 -0500</when>
            <comment_text>Moving to M5 .
It's still failing but no solution yet. Will try reverting Bug 499385 to see if it is for sure the reason for these failures.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508105</id>
        <developer>Burghard Britzke</developer>
        <developer_username>bubi</developer_username>
        <dup_id/>
        <creation_time>2016-11-24 06:15:00 -0500</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>expressions with German umlauts provoke exceptions</short_desc>
        <thetext>Created attachment 265557
The stacktrace of the logged exception

When entering an expression into the debuggers expression view which contain German umlauts, an error is raised " 'JDI thread evaluations' has encountered a problem. Exception processing async thread queue" - Details: "Exception processing async thread queue, Exception processing async thread queue, String index out of range:5". The number 5 is the length of the expression. An exception is logged to the file .log in the workspace meta data.</thetext>
        <comment>
            <comment_id>2779919</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-11-24 23:29:37 -0500</when>
            <comment_text>Can you check the "Text file encoding used ?
Go to Window-&gt;Preference-&gt;General-&gt;Workspace

If it is not UTF-8, try changing and see if you still get the error?</comment_text>
        </comment>
        <comment>
            <comment_id>2780486</comment_id>
            <comment_count>2</comment_count>
            <who>Burghard Britzke</who>
            <commenter_username>bubi</commenter_username>
            <when>2016-11-28 04:59:20 -0500</when>
            <comment_text>Both project and workspace text encoding is UTF-8 as it is the default for linux systems. But even if I change the encoding of the project to ISO8859-1, the error remains.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488663</id>
        <developer>Jay Arthanareeswaran</developer>
        <developer_username>jarthana</developer_username>
        <dup_id/>
        <creation_time>2016-02-29 00:14:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9] Allow diamond with anonymous classes</short_desc>
        <thetext>The coin project in JEP 213 states:

"Allow diamond with anonymous classes if the argument type of the inferred type is denotable. Because the inferred type using diamond with an anonymous class constructor could be outside of the set of types supported by the signature attribute, using diamond with anonymous classes was disallowed in Java SE 7. As noted in the JSR 334 proposed final draft, it would be possible to ease this restriction if the inferred type was denotable."

This is already supported in JDK 9, we should add support too in our BETA_JAVA9 branch.</thetext>
        <comment>
            <comment_id>2738609</comment_id>
            <comment_count>1</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-08-09 09:58:14 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/78691</comment_text>
        </comment>
        <comment>
            <comment_id>2766108</comment_id>
            <comment_count>2</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-13 08:38:52 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/83111</comment_text>
        </comment>
        <comment>
            <comment_id>2767093</comment_id>
            <comment_count>3</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-17 02:57:29 -0400</when>
            <comment_text>Stephan, please take a look at the change.

I'm not sure about a couple of things with this.

1. In AllocationExpression.inferDiamondCOnstructor, the special handling if allocationType isInterface - would it be better to add the no-arg constructor to the PTB and proceed with sfmb.applyTypeArgumentsOnConstructor?

2. All non-private instance methods in an anonymous class using '&lt;&gt;' must be treated as if they are annotated with @override. To achieve this, I'm setting the TagBits.AnnotationOverride bit on the method. Would it be better to handle this in the MethodDeclaration.resolve instead?

3. Have I covered everything? :-)

Thanks in advance for your time</comment_text>
        </comment>
        <comment>
            <comment_id>2767112</comment_id>
            <comment_count>4</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-17 03:46:57 -0400</when>
            <comment_text>I wonder why genie did not comment on this bug - I released the change as a first cut implementation so that we will have a build with this feature to demo, leaving the bug open for follow up actions comments

Released via commit http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=8f0eb26398d5c8dde9ae3b5affe939426eea53ca</comment_text>
        </comment>
        <comment>
            <comment_id>2767113</comment_id>
            <comment_count>5</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-17 03:49:22 -0400</when>
            <comment_text>One more thing I'm not sure about that I forgot to mention in earlier comment

I assumed redundant type argument specification check would now apply for anonymous diamond too - does that hold?</comment_text>
        </comment>
        <comment>
            <comment_id>2767224</comment_id>
            <comment_count>6</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-17 09:12:53 -0400</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/83111 was merged to [BETA_JAVA9].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=8f0eb26398d5c8dde9ae3b5affe939426eea53ca</comment_text>
        </comment>
        <comment>
            <comment_id>2776523</comment_id>
            <comment_count>7</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-11-16 06:36:00 -0500</when>
            <comment_text>Y20161110-1000

A "Redundant specification of type arguments" problem is wrongly reported for anonymous types in 1.8 mode:

package p;
import java.util.Comparator;
public class C {
	Comparator&lt;String&gt; comparator = new Comparator&lt;String&gt;() { //
		@Override
		public int compare(String o1, String o2) {
			return 0;
		}
	};
}

This causes various compile errors in platform.ui projects.

The new analysis must only be active for source level &gt;= 9. I'm surprised that we don't have a test case for this in Java 7 or 8 mode.</comment_text>
        </comment>
        <comment>
            <comment_id>2777301</comment_id>
            <comment_count>8</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-18 00:43:04 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85256</comment_text>
        </comment>
        <comment>
            <comment_id>2778525</comment_id>
            <comment_count>9</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-22 05:13:13 -0500</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/85256 was merged to [BETA_JAVA9].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=cfc8f74b9c8820b855dd3ffbed748d7233058b28</comment_text>
        </comment>
        <comment>
            <comment_id>2778527</comment_id>
            <comment_count>10</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-22 05:17:11 -0500</when>
            <comment_text>(In reply to comment #7)
&gt; The new analysis must only be active for source level &gt;= 9. I'm surprised that
&gt; we don't have a test case for this in Java 7 or 8 mode.
Thanks Markus. Now we do.</comment_text>
        </comment>
        <comment>
            <comment_id>2779495</comment_id>
            <comment_count>11</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-24 05:11:05 -0500</when>
            <comment_text>Bug 506952 comment 3 identifies some tests that fail when run with JDK9 because of change in behavior w.r.t diamond in anonymous class declarations. Fixed these failures via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&amp;id=30f7fbb7f1e3845d31ba25b4ce8dc4eb4bcb844e</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506315</id>
        <developer>Sergey Toshin</developer>
        <developer_username>stoshins</developer_username>
        <dup_id/>
        <creation_time>2016-10-21 05:04:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>ASTParser.createASTs() in StackMapFrame.addStackItem throws IllegalArgumentException</short_desc>
        <thetext>Created attachment 264982
Sources which occur exception

java.lang.IllegalArgumentException: info cannot be null
	at org.eclipse.jdt.internal.compiler.codegen.StackMapFrame.addStackItem(StackMapFrame.java:81)
	at org.eclipse.jdt.internal.compiler.ClassFile.traverse(ClassFile.java:5626)
	at org.eclipse.jdt.internal.compiler.ClassFile.generateStackMapTableAttribute(ClassFile.java:4375)
	at org.eclipse.jdt.internal.compiler.ClassFile.completeCodeAttribute(ClassFile.java:1424)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:352)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:276)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:568)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:637)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:371)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:878)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1016)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:639)
	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:993)
	at ru.scanner.codeprocessor.EclipseASTParser.prepareCompilationUnitsForFiles(EclipseASTParser.java:30)
	at ru.scanner.codeprocessor.cfg.javaproject.Project.build(Project.java:62)
	at ru.scanner.codeprocessor.Environment.&lt;init&gt;(Environment.java:100)
	at ru.scanner.Main.scanRootDirectory(Main.java:286)
	at ru.scanner.Main.scanDirectory(Main.java:249)
	at ru.scanner.Main.main(Main.java:125)

Sources attached. Send them to ASTParser.createASTs()</thetext>
        <comment>
            <comment_id>2768913</comment_id>
            <comment_count>1</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-10-21 06:30:22 -0400</when>
            <comment_text>Reproduced on master, Will take a look for 4.7 M4</comment_text>
        </comment>
        <comment>
            <comment_id>2773998</comment_id>
            <comment_count>2</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-11-08 03:55:19 -0500</when>
            <comment_text>import java.util.function.Consumer;

public class Test {

    public void test(String method) {
        String str;
        if (!method.equals("")) {
        	str = "String";
        	str.concat(method);
        }
        new Consumer&lt;String&gt;() {
            public void accept(String s) {
            	str = "String";
            }
        };
    }
}

Standalone test that triggers the exception. Caused by trying to emulate outer access for the captured outer local str in the anonymous class declaration. The assignment to the outer local is invalid and is flagged as such, but we still try to emulate outer access leading to the addition of synthetic variable and field in the inner class. As the variable may be uninitialized, the local is not added to the stack frame, leading to the error. Probably better to return early in this case. Fix under test</comment_text>
        </comment>
        <comment>
            <comment_id>2782428</comment_id>
            <comment_count>3</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-12-02 13:14:09 -0500</when>
            <comment_text>I'm not convinced about the fix and didn't get much time to dig deeper, moving to M5</comment_text>
        </comment>
    </bug>
    <bug>
        <id>485080</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-01-02 14:43:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Binding based hover throws NPE on source file that's not on the classpath</short_desc>
        <thetext>In a project configured for null annotations (1.8) store a Java source file with null annotations in its signatures into a plain (ie. not source) folder. Hover over a method name and the following exception will occur:

java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.util.Util.getUnresolvedJavaElement(Util.java:1518)
	at org.eclipse.jdt.core.dom.TypeBinding.getUnresolvedJavaElement(TypeBinding.java:629)
	at org.eclipse.jdt.core.dom.TypeBinding.getUnresolvedJavaElement(TypeBinding.java:620)
	at org.eclipse.jdt.core.dom.TypeBinding.getJavaElement(TypeBinding.java:602)
	at org.eclipse.jdt.internal.ui.viewsupport.BindingLinkedLabelComposer.appendNameLink(BindingLinkedLabelComposer.java:613)
	at org.eclipse.jdt.internal.ui.viewsupport.BindingLinkedLabelComposer.appendTypeBindingLabel(BindingLinkedLabelComposer.java:441)
	at org.eclipse.jdt.internal.ui.viewsupport.BindingLinkedLabelComposer.appendTypeArgumentsBindingLabel(BindingLinkedLabelComposer.java:505)
	at org.eclipse.jdt.internal.ui.viewsupport.BindingLinkedLabelComposer.appendMethodBindingLabel(BindingLinkedLabelComposer.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.BindingLinkedLabelComposer.appendBindingLabel(BindingLinkedLabelComposer.java:91)</thetext>
    </bug>
    <bug>
        <id>486506</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-01-25 14:28:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][resource] leak analysis should consider rc::close references</short_desc>
        <thetext>As discussed in http://stackoverflow.com/questions/34977627/map-one-stream-to-another-stream-and-close-the-first-when-the-second-closes

Eclipse currently issues a warning "Resource leak: 'rc' is never closed" although a reference to the close method is passed on.

This reveals that the analysis is unaware of deferred closing using a method reference.</thetext>
        <comment>
            <comment_id>2687127</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-25 10:29:55 -0400</when>
            <comment_text>Too much on my plate for 4.6. Bulk deferral to 4.7</comment_text>
        </comment>
    </bug>
    <bug>
        <id>486868</id>
        <developer>Ed Willink</developer>
        <developer_username>ed</developer_username>
        <dup_id/>
        <creation_time>2016-01-29 15:29:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null][external] external annotations not resolved to plugins</short_desc>
        <thetext>If external annotations are resolved to a plugin folder that is mentioned in the src.includes build.properties, the annotations are not available to a workspace project that requires the annotations providing bundle.

Invalid external annotation path: '/org.eclipse.qvtd.pivot.qvtbase/annotations' in project 'org.eclipse.qvtd.cs2as.compiler.tests', for classpath entry 'org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8'

(platform:/plugin/) org.eclipse.qvtd.pivot.qvtbase is a project in an outer Eclipse session.

(platform:/resource/) org.eclipse.qvtd.cs2as.compiler.tests is a project in a nested Eclipse session.

This scenario will arise in the future when Import...-&gt;Plugin Development-&gt;Plugins and Fragments is used to import a Java project that references annotations in another not-imported project.</thetext>
        <comment>
            <comment_id>2675448</comment_id>
            <comment_count>1</comment_count>
            <who>Ed Willink</who>
            <commenter_username>ed</commenter_username>
            <when>2016-02-24 14:59:18 -0500</when>
            <comment_text>(In reply to Ed Willink from comment #0)
&gt; This scenario will arise in the future when Import...-&gt;Plugin
&gt; Development-&gt;Plugins and Fragments is used to import a Java project that
&gt; references annotations in another not-imported project.

It also arises today if a GIT version of a project is opened, and it is nastier than I thought. The now-ignored annotations may result in errors making it difficult to use the imported project without applying the annotations manually to the source which may not be possible since it may not use JDT annotations. Enabling JDT annotations may lead to even more problems with the imported project.</comment_text>
        </comment>
        <comment>
            <comment_id>2675796</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-25 13:17:31 -0500</when>
            <comment_text>Tentatively pulling into 4.6.

Ed, how much of your problem could be resolved by:
- supporting platform: URLs for external annotations (me), and
- putting external annotations on bin.includes in build.properties (you)
?</comment_text>
        </comment>
        <comment>
            <comment_id>2675801</comment_id>
            <comment_count>3</comment_count>
            <who>Ed Willink</who>
            <commenter_username>ed</commenter_username>
            <when>2016-02-25 13:41:29 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #2)
&gt; - putting external annotations on bin.includes in build.properties (you)

I already did this, so not a problem; an obvious requirement; maybe a Manifest builder warning one day.

&gt; - supporting platform: URLs for external annotations (me), and

This might solve the original use case, but not the comment#1 use case.

In the /org.eclipse.ocl.pivot/annotations/org/eclipse/emf/ecore/resource/Resource.eea content:

class org/eclipse/emf/ecore/resource/Resource
getContents
 ()Lorg/eclipse/emf/common/util/EList&lt;Lorg/eclipse/emf/ecore/EObject;&gt;;
 ()L1org/eclipse/emf/common/util/EList&lt;L1org/eclipse/emf/ecore/EObject;&gt;;

This is an annotation on a referenced Java Operation. It should make no difference whether the Operation happens to be compiled locally from *.java source, or to be loaded from a *.jar on the classpath.

In the /org.eclipse.ocl.pivot/annotations reference

	&lt;classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"&gt;
		&lt;attributes&gt;
			&lt;attribute name="annotationpath" value="/org.eclipse.ocl.pivot/annotations"/&gt;
		&lt;/attributes&gt;
	&lt;/classpathentry&gt;

this should be a reference to the annotations folder of the org.eclipse.ocl.pivot project if open (platform:/resource/org.eclipse.ocl.pivot) or to the org.eclipse.ocl.pivot bundle if not (platform:/plugin/org.eclipse.ocl.pivot).

You do not need to support platform: URLs, at least not as specified in the .classpath. Rather you should just be doing a two-level search, try the project, else the plugin.

If you allow platform: URLs on the .classpath, you add an extra opportunity for confusion.

NB, once the annotationpath can be multi-entry, each entry contributes either project or plugin but not both.</comment_text>
        </comment>
        <comment>
            <comment_id>2675845</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-25 15:08:53 -0500</when>
            <comment_text>(In reply to Ed Willink from comment #3)
&gt; (In reply to Stephan Herrmann from comment #2)
&gt; &gt; - supporting platform: URLs for external annotations (me), and
&gt; 
&gt; This might solve the original use case, but not the comment#1 use case.

I wasn't quite sure what's the issue in comment 1, but after some experiments I suspect the following:
- Plugin Project A has a dependency on Plugin Project B
- A contains external annotations affecting classes in B
- Things work OK as long as B is read from jar
- Things break as soon as B is referenced as a workspace project.

Is that it?

 
&gt; You do not need to support platform: URLs, at least not as specified in the
&gt; .classpath. Rather you should just be doing a two-level search, try the
&gt; project, else the plugin.
&gt; 
&gt; If you allow platform: URLs on the .classpath, you add an extra opportunity
&gt; for confusion.

If I understand correctly you suggest that users should not specify platform: URLs, but under the hood the tool should try to interpret any absolute path /a/b/c as a shorthand for platform:/plugin/a/b/c, right?

I'm slightly worried how much knowledge about plugins would need to be implemented in JDT. Obviously, JDT must remain agnostic of PDE and such.</comment_text>
        </comment>
        <comment>
            <comment_id>2675876</comment_id>
            <comment_count>5</comment_count>
            <who>Ed Willink</who>
            <commenter_username>ed</commenter_username>
            <when>2016-02-25 15:51:27 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #4)
&gt; Is that it?

No.

Ok scenario

Project A is a provider of external annotations.
Project B uses Project A's external annotations

Problem scenario, Project A is closed so that Plugin A is in use

&gt; 
&gt; I'm slightly worried how much knowledge about plugins would need to be
&gt; implemented in JDT. Obviously, JDT must remain agnostic of PDE and such.

Currently you only consider projects which are very PDE / Eclipse. When a project reference misses you need to fall-back to the same named bundle; an OSGI-ism, nothing to do with PDE.</comment_text>
        </comment>
        <comment>
            <comment_id>2675909</comment_id>
            <comment_count>6</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-25 18:03:34 -0500</when>
            <comment_text>(In reply to Ed Willink from comment #5)
&gt; Project A is a provider of external annotations.
&gt; Project B uses Project A's external annotations
&gt; 
&gt; Problem scenario, Project A is closed so that Plugin A is in use

I thought that's the case of comment 0.

What does comment 1 add then? Why do you say my proposal from comment 2 would solve comment 0 but not comment 1? They must be different use cases then??

Anyway, the confusion caused above triggered new work as bug 488494, for what I understood to be the problem in comment 1 and comment 3. That bug is a pure technical one, no changes required from users.


&gt; &gt; I'm slightly worried how much knowledge about plugins would need to be
&gt; &gt; implemented in JDT. Obviously, JDT must remain agnostic of PDE and such.
&gt; 
&gt; Currently you only consider projects which are very PDE / Eclipse.

No, external annotations can even be used in the batch compiler. Nothing PDE'ish.

&gt; When a
&gt; project reference misses you need to fall-back to the same named bundle; an
&gt; OSGI-ism, nothing to do with PDE.

Same difference, I just said "PDE" as a placeholder for anything OSGi. The compiler knows nothing about OSGi. In other layers of JDT we know about a workspace, here's the complete list of dependencies:
 org.eclipse.core.resources;bundle-version="[3.3.0,4.0.0)",
 org.eclipse.core.runtime;bundle-version="[3.3.0,4.0.0)",
 org.eclipse.core.filesystem;bundle-version="[1.0.0,2.0.0)",
 org.eclipse.text;bundle-version="[3.1.0,4.0.0)",
 org.eclipse.team.core
OK, via o.e.core.runtime we also get o.e.equinox.common, so we can use FileLocator. Mhh..

OTOH, in non-OSGI projects the requested strategy is bogus, and JDT cannot distinguish OSGi vs. non-OSGi projects.

If you definitely want plugin semantics, what's wrong with stating the annotation path as platform:/plugin/... ? (which isn't implemented yet, but appears to be the most explicit variant).

One more concern: obviously, when you consume an annotation location from binary, there's no adding new annotations, i.e., the Annotate command (Ctrl+1) is dead. But I assume you just want to compile, not actively develop in that setting?</comment_text>
        </comment>
        <comment>
            <comment_id>2675991</comment_id>
            <comment_count>7</comment_count>
            <who>Ed Willink</who>
            <commenter_username>ed</commenter_username>
            <when>2016-02-26 01:52:08 -0500</when>
            <comment_text>The two use cases difffer. We need to handle the cases where

Annotated Java declarations are in project / plugin.

Annotating JDT declarations are in project / plugin. 

I don't definitely want plugin semantics. I want open-project-else-plugin semantics, so specifying plugin:/... would be confusing/wrong.

Yes annotating JDT declarations in a plugin would be read-only. That's why annotationpath should be multi-value.</comment_text>
        </comment>
        <comment>
            <comment_id>2676706</comment_id>
            <comment_count>8</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-27 21:34:08 -0500</when>
            <comment_text>(In reply to Ed Willink from comment #7)
&gt; The two use cases difffer. We need to handle the cases where
&gt; 
&gt; Annotated Java declarations are in project / plugin.
&gt; 
&gt; Annotating JDT declarations are in project / plugin. 

I still don't get it. Please explain.</comment_text>
        </comment>
        <comment>
            <comment_id>2676727</comment_id>
            <comment_count>9</comment_count>
            <who>Ed Willink</who>
            <commenter_username>ed</commenter_username>
            <when>2016-02-28 01:51:53 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #8)
&gt; &gt; Annotated Java declarations are in project / plugin.

org.eclipse.ocl.pivot annotates org.eclipse.emf.ecore.resource.Resource.getContents()

1a) If I have EMF installed, then I want the annotation to apply to

org.eclipse.emf.ecore.resource.Resource.class in org.eclipse.emf_....jar

1b) If I have org.eclipse.emf.ecore.resource checked out as a project to aid debugging / instrumentation, then I want the annotation to apply to

/org.eclipse.emf.ecore/bin/org/eclipse/emf/ecore/resource/Resource.class


&gt; &gt; Annotating JDT declarations are in project / plugin. 

The org.eclipse.ocl.pivot distribution annotates org.eclipse.emf.ecore.resource.Resource.getContents() with the annotation in 

/org.eclipse.ocl.pivot/annotations

2a) With the org.eclipse.ocl.pivot distribution installed, I require the JDT editor to use /org.eclipse.ocl.pivot/annotations from the org.eclipse.ocl.pivot bundle to avoid showing inaccurate errors and warnings whenever my source code in *.class form exploits the annotation on Resource.getContents(). 

2b) With org.eclipse.ocl.pivot checked out as a project to aid debugging / instrumentation, I require the JDT editor/compiler to use /org.eclipse.ocl.pivot/annotations from the org.eclipse.ocl.pivot project to avoid showing inaccurate errors and warnings whenever my source code in *.java form exploits the annotation on Resource.getContents().</comment_text>
        </comment>
        <comment>
            <comment_id>2676741</comment_id>
            <comment_count>10</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-28 06:56:50 -0500</when>
            <comment_text>(In reply to Ed Willink from comment #9)
&gt; (In reply to Stephan Herrmann from comment #8)
&gt; &gt; &gt; Annotated Java declarations are in project / plugin.
&gt; 
&gt; org.eclipse.ocl.pivot annotates
&gt; org.eclipse.emf.ecore.resource.Resource.getContents()
&gt; 
&gt; 1a) If I have EMF installed, then I want the annotation to apply to
&gt; 
&gt; org.eclipse.emf.ecore.resource.Resource.class in org.eclipse.emf_....jar
&gt; 
&gt; 1b) If I have org.eclipse.emf.ecore.resource checked out as a project to aid
&gt; debugging / instrumentation, then I want the annotation to apply to
&gt; 
&gt; /org.eclipse.emf.ecore/bin/org/eclipse/emf/ecore/resource/Resource.class

OK, so that *is* what I suspected (
  A = org.eclipse.ocl.pivot
  B = org.eclipse.emf.ecore
  class in B = org.eclipse.emf.ecore.resource.Resource
):

(In reply to Stephan Herrmann from comment #4)
&gt; I wasn't quite sure what's the issue in comment 1, but after some
&gt; experiments I suspect the following:
&gt; - Plugin Project A has a dependency on Plugin Project B
&gt; - A contains external annotations affecting classes in B
&gt; - Things work OK as long as B is read from jar
&gt; - Things break as soon as B is referenced as a workspace project.
&gt; 
&gt; Is that it?

It was your answer "No" that sent me off track.

Anyway that part is almost done in bug 488494.</comment_text>
        </comment>
        <comment>
            <comment_id>2687107</comment_id>
            <comment_count>11</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-25 10:28:51 -0400</when>
            <comment_text>Too much on my plate for 4.6. Bulk deferral to 4.7</comment_text>
        </comment>
    </bug>
    <bug>
        <id>487408</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-02-07 15:11:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler][resource] bogus resource leak warning when reusing a resource variable</short_desc>
        <thetext>This code:

//---
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

public class ResourceLeak {
    void test() throws IOException {
        InputStream input = null;
        try {
            input = getResource("/tmp/f2");
            if (input != null)
                parse(input);
        } finally {
            if (input != null)
                input.close();                 
        }
        try {
            input = getResource("/tmp/f2"); // here
            if (input != null)
                parse(input);
        } finally {
            if (input != null)
                input.close();                 
        }
    }
    InputStream getResource(String fn) throws FileNotFoundException {
    	return new FileInputStream(fn);
    }
    void parse(InputStream input) {}
}
//---

triggers a bogus warning at the location marked "here":

"Potential resource leak: 'input' may not be closed"

Apparently, analysis doesn't see that the resource from the first code block (if any) has been closed properly at the point of re-assignment. Interestingly, the warning disappears when the enclosing try-finally is removed from the second(!) block.</thetext>
        <comment>
            <comment_id>2669171</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-07 15:12:44 -0500</when>
            <comment_text>pulling into 4.6 - time permitting.</comment_text>
        </comment>
        <comment>
            <comment_id>2687126</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-25 10:29:53 -0400</when>
            <comment_text>Too much on my plate for 4.6. Bulk deferral to 4.7</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488645</id>
        <developer>Ed Willink</developer>
        <developer_username>ed</developer_username>
        <dup_id/>
        <creation_time>2016-02-28 07:23:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null][external] Annotation conflict resolution</short_desc>
        <thetext>(Rather than add to the Bug 486868 complexity) A new complexity arises when

project A has annotations that remedy plugin B deficiencies

then B is enhanced to perhaps annotate correctly in the first place

then project A is used against a checkout of the enhanced project B 

---

In this scenario it would be nice to receive

- redundant annotation warnings (A duplicates what is in B)

- conflicting annotation warnings (A conflicts with the enhanced B)

These warnings should be in the *.eea editor or equivalent.

In so far as possible errors should be avoided so that code remains runnable.</thetext>
        <comment>
            <comment_id>2676758</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-28 11:45:05 -0500</when>
            <comment_text>Assigning to self, but not promising a specific target milestone.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488973</id>
        <developer>yac yac</developer>
        <developer_username>yac</developer_username>
        <dup_id/>
        <creation_time>2016-03-03 13:14:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null] Null Type Safety warning on inlined code but not with intermediary local variable</short_desc>
        <thetext>import com.google.common.base.Preconditions;

class ThirdPartyLib {
	String getString() {
		return "";
	}
}

@javax.annotation.ParametersAreNonnullByDefault
public class sscce {
    ThirdPartyLib l = new ThirdPartyLib();
    
    void sscce1_inline() {
    	Preconditions.checkNotNull(l.getString());
    	// Null type safety: The expression of type 'String' needs unchecked conversion to conform to '@Nonnull String'
    }
    void sscce1_intermediary() {
    	String s = l.getString();
    	Preconditions.checkNotNull(s);
    	// no warning
    }
    
    void sscce2_inline() {
    	checkNotNull(l.getString());
    	// Null type safety: The expression of type 'String' needs unchecked conversion to conform to '@Nonnull String'
    }
    void sscce2_intermediary() {
    	String s = l.getString();
    	checkNotNull(s);
    	// Null type safety: The expression of type 'String' needs unchecked conversion to conform to '@Nonnull String'
    }
    
   

  // copy of guava's cNN:
  /**
   * Ensures that an object reference passed as a parameter to the calling method is not null.
   *
   * @param reference an object reference
   * @return the non-null reference that was validated
   * @throws NullPointerException if {@code reference} is null
   */
  public static &lt;T&gt; T checkNotNull(T reference) {
    if (reference == null) {
      throw new NullPointerException();
    }
    return reference;
  }
}</thetext>
        <comment>
            <comment_id>2678567</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-03 14:10:42 -0500</when>
            <comment_text>I had some trouble reproducing, but this succeeded:

Create my own copy of class com.google.common.base.Preconditions (with that exact qualified name) and add @javax.annotation.ParametersAreNonnullByDefault on top of that class.

I doubt that this is your situation?

If so, there might be two issues in conflict:

- via the default annotation the method parameter is @NonNull

- ecj has special treatment to handle com.google.common.base.Preconditions.checkNotNull as an assertion utility that ensures that the passed value will not be null *after* the method call.

It's the second item that lets us treat a variable different from a method call (as the argument to checkNotNull()). This might explain the difference you are observing.

With the original (unannotated) version of com.google.common.base.Preconditions.checkNotNull ecj has no reason to complain and I don't see it doing so, independent of inlining.

Ergo, I don't see how the problem can be produced using the original class from guava.</comment_text>
        </comment>
        <comment>
            <comment_id>2678814</comment_id>
            <comment_count>2</comment_count>
            <who>yac yac</who>
            <commenter_username>yac</commenter_username>
            <when>2016-03-04 06:58:38 -0500</when>
            <comment_text>The guava's class is annotated with javax.annotation.ParametersAreNonnullByDefault via package-info in it's package package com.google.common.base</comment_text>
        </comment>
        <comment>
            <comment_id>2678815</comment_id>
            <comment_count>3</comment_count>
            <who>yac yac</who>
            <commenter_username>yac</commenter_username>
            <when>2016-03-04 07:01:10 -0500</when>
            <comment_text>I forgot to mention, I am using eclipse's null analysis using annotation with the annotation reconfigured to use the javax.annotation Nonnull, Nullable and ParametersAreNonnullByDefault</comment_text>
        </comment>
        <comment>
            <comment_id>2678885</comment_id>
            <comment_count>4</comment_count>
            <who>yac yac</who>
            <commenter_username>yac</commenter_username>
            <when>2016-03-04 09:58:58 -0500</when>
            <comment_text>So I guess this works as intended with the explanation that there is the special treatment for guava's cNN by ecj that covers variables only.</comment_text>
        </comment>
        <comment>
            <comment_id>2698696</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-04-24 17:07:24 -0400</when>
            <comment_text>Bulk move: too late for 4.6 M7.

Very likely has to be moved out of 4.6 entirely.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489609</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-03-14 21:10:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][null] null annotation on wildcard is dropped during inference</short_desc>
        <thetext>The following test (on behalf of bug 442103)

//---
import org.eclipse.jdt.annotation.*;
import static org.eclipse.jdt.annotation.Checks.*;
public class X {
	static void test(@Nullable String str) {
		ifNonNull(str, s -&gt; print(s));
	}
	static void print(@NonNull String s) {
		System.out.print(s);
	}
	public static void main(String... args) {
		test("good");
	}
}
//---

wrongly reports:

----------
1. WARNING in X.java (at line 5)
	ifNonNull(str, s -&gt; print(s));
	                          ^
Null type safety (type annotations): The expression of type \'String\' needs unchecked conversion to conform to \'@NonNull String\'
----------


The target type of the lambda is:
   @NonNull Consumer&lt;@NonNull ? super T&gt;
but the null annotation on the wildcard is not used during inference.

First, WildcardBinding.substituteInferenceVariable() simply forgets to re-apply existing type annotations, but later reducing a CExprF with a proper right type simply answers TRUE without propagating any nullhint.</thetext>
        <comment>
            <comment_id>2682169</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-14 21:11:41 -0400</when>
            <comment_text>Till, does this sound like anything you've already analyzed? Otherwise I'll take this one.</comment_text>
        </comment>
        <comment>
            <comment_id>2682556</comment_id>
            <comment_count>2</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-03-15 13:15:31 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #1)
&gt; Till, does this sound like anything you've already analyzed? Otherwise I'll
&gt; take this one.

No</comment_text>
        </comment>
        <comment>
            <comment_id>2698699</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-04-24 17:07:32 -0400</when>
            <comment_text>Bulk move: too late for 4.6 M7.

Very likely has to be moved out of 4.6 entirely.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>489673</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-03-15 13:22:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][compiler][impl] check necessity of field outerInferenceContext in MessageSend &amp; AllocationExpression</short_desc>
        <thetext>Classes MessageSend &amp; AllocationExpression both have a field outerInferenceContext. In AE this field seems unused, and even in MS commenting the only significant assignment doesn't cause any failures in GRT_1_8.

Looks like a relict from the times before bug 437444 that may be obsolete by now.</thetext>
        <comment>
            <comment_id>2698698</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-04-24 17:07:31 -0400</when>
            <comment_text>Bulk move: too late for 4.6 M7.

Very likely has to be moved out of 4.6 entirely.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490004</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-03-19 09:36:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null][impl] unassigned variable annotationZip in ClassFile.getJarBinaryTypeInfo()</short_desc>
        <thetext>As pointed out by Stefan Xenos, method ClassFile.getJarBinaryTypeInfo() has a local variable 'annotationZip' which is never assigned.

This is a bug incurred by a refactoring as can be seen in the corresponding feature branch at http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/diff/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java?h=sherrmann/ExternalAnnotations&amp;id=c3cae79e8be6f20fef5f88069e40403a2946ea1e

We do have ExternalAnnotations18Test.testLibsWithFieldsZipped() and friends to ensure that zipped .eea work. We may, however, be leaking a file handle, since the following call is currently without effect:

	JavaModelManager.getJavaModelManager().closeZipFile(annotationZip);</thetext>
        <comment>
            <comment_id>2684752</comment_id>
            <comment_count>1</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-03-19 15:58:21 -0400</when>
            <comment_text>Please take pity on me and fix bug 490010 before fixing this. Otherwise, I'll have to do another unpleasant merge.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>493133</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-05-06 07:24:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][inference] Function&lt;?,?&gt; type inference not always correct</short_desc>
        <thetext>+++ This bug was initially created as a clone of Bug 487746 comment 9 +++
Here is an extended example which does not compile in Eclipse, but which javac accepts:


public void doesntCompile(List&lt;Something&gt; things) {
   things.stream()
       .filter(thing -&gt; thing.getSize() &gt; 100)
       .collect(Collectors.collectingAndThen(
         Collectors.&lt;Something&gt;toList(),
         list -&gt; list.stream().collect(Collectors.groupingBy(Something::getSize,
                  Collectors.collectingAndThen(
                     Collectors.&lt;Something&gt;toList(),
                     list2 -&gt; list2.stream().sorted(Comparator.comparing(Something::getTime)).limit(1).findAny().orElse(null)
                  )
               ))))
   .forEach((size, thing) -&gt; {
       System.out.println(thing.getSize());   // Compile error because Eclipse thinks 'thing' is Object
   });
}



The Eclipse compile error goes away if I explicitly type list2 as List&lt;Something&gt;, so the inner collectingAndThen call becomes:

Collectors.collectingAndThen(
   Collectors.toList(),
   (List&lt;Something&gt; list2) -&gt; list2.stream().sorted(Comparator.comparing(Something::getTime)).limit(1).findAny().orElse(null)
)


However, why this is necessary is not at all obvious - the hover shows me that list2 is List&lt;Something&gt; even without the explicit typing.</thetext>
        <comment>
            <comment_id>2703740</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-06 07:25:24 -0400</when>
            <comment_text>I separated this part out, since everything else in  Bug 487746 has already been resolved as of 4.6 M6.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>494733</id>
        <developer>Jens Li</developer>
        <developer_username>skrap</developer_username>
        <dup_id/>
        <creation_time>2016-05-27 06:10:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[compiler] Wildcard type information lost causes invalid assignment</short_desc>
        <thetext>Created attachment 262057
Complete example of progra which exposes this bug. Includes a some other examples and observations.

Information about whether a type has a wildcard upper bound seems to get lost for programs which use a certain combination of generic methods. The result is that incorrect programs type check without warnings, which might lead to heap pollution and unexpected ClassCastExceptions.

I have tried this with Eclipse 4.5.2 (realeased version) and Eclipse 4.6 (Build id: I20160525-2000). JDK 1.8.0_77 also has the same behaviour.

Example:

    public static void main(String[] args) {
        List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;();
        Set&lt;List&lt;Number&gt;&gt; numbetListSet = Collections.singleton(toWildcardGeneric(integerList));
        numbetListSet.iterator().next().add(new Float(1.0));
        Integer i = integerList.get(0); // Throws ClassCastException
    }
    
    static &lt;T&gt; List&lt;? extends T&gt; toWildcardGeneric(List&lt;T&gt; l) {
        return l;
    }</thetext>
        <comment>
            <comment_id>2713738</comment_id>
            <comment_count>1</comment_count>
            <who>Jens Li</who>
            <commenter_username>skrap</commenter_username>
            <when>2016-05-29 06:04:04 -0400</when>
            <comment_text>Having played around with this some more I notice that there is a simpler sequence of similar methods that causes an unexpected ClassCastException:

public static void main(String[] args) {
    List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;();
    List&lt;Object&gt; objectList = id(toWildcardGeneric(integerList));
    objectList.add("Woo?");
    Integer i = integerList.get(0);        
}


static &lt;T&gt; T id(T o) {
    return o;
}

static &lt;T&gt; List&lt;? extends T&gt; toWildcardGeneric(List&lt;T&gt; l) {
    return l;
}</comment_text>
        </comment>
        <comment>
            <comment_id>2713754</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-29 07:28:28 -0400</when>
            <comment_text>Thanks, those are interesting, tricky examples.

Seeing that for comment 0 ecj and javac produce the same bogus code could mean any of these:
- both compilers truthfully implement a buggy JLS
- both compilers independently have the same bug
- ecj intentionally emulates a known bug in javac.

Regarding comment 0 if we fix the bug, people will probably complain that we broke compatibility with javac.

OTOH, we really need to understand what's going on here, because in comment 1 javac does detect the problem, whereas ecj does not (which again could mean a lot of different things, as long as we don't understand ... :) )</comment_text>
        </comment>
        <comment>
            <comment_id>2713757</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-29 07:38:20 -0400</when>
            <comment_text>Looking at the example in comment 0, this expression
  Collections.singleton(toWildcardGeneric(integerList))
is inferred to this method substitute:
  public static Set&lt;List&lt;java.lang.Number&gt;&gt; singleton(List&lt;java.lang.Number&gt;) 
  
At this point we already lost the wildcard information.

The full inference result is:
Type Bounds:
	TypeBound  T#1 = java.lang.Integer
	Dependency T#0 :&gt; java.util.List&lt;? extends T#1#2&gt;
	TypeBound  T#0 :&gt; java.util.List&lt;java.lang.Number&gt;
	TypeBound  T#0 = java.util.List&lt;java.lang.Number&gt;
	TypeBound  ? extends T#1#2 = java.lang.Number
Using the following inference variables:
  T#0 represents &lt;T&gt; declared by Collections.singleton()
  T#1 represents &lt;T&gt; declared by toWildcardGeneric(List&lt;T&gt;) 
  ? extends T#1#2 represents the wildcard ? extends T#1

(BTW: using different names for type parameters would improve readability :) )

So, inference indeed seems to replace a wildcard with the specific type Number.

Next: can we identify a bug in this invocation of type inference?</comment_text>
        </comment>
        <comment>
            <comment_id>2713762</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-29 08:14:38 -0400</when>
            <comment_text>We start invocation type inference (18.5.2) with this inference context:

Inference Context (applicability inferred) (strict)
Inference Variables:
	T#0	:	NOT INSTANTIATED
	T#1	:	java.lang.Integer
	? extends T#1#2	:	NOT INSTANTIATED
Type Bounds:
	TypeBound  T#1 = java.lang.Integer
	Dependency T#0 :&gt; java.util.List&lt;? extends T#1#2&gt;

All seems still open.

Then, from the target type 
  Set&lt;List&lt;Number&gt;&gt;
we infer this new constraint:
  ⟨Set&lt;T#0&gt; → Set&lt;List&lt;Number&gt;&gt;⟩
which in several steps reduces to the type bound / instantiation
  T#0 = List&lt;Number&gt;

This should be expected: the target type "wants" T#0 to be List&lt;Number&gt;

Question: Aren't there any other constraint that conflict with this instantiation, thus letting inference fail??

Candidate: we have this dependency:
  T#0 :&gt; List&lt;? extends T#1#2&gt;

So watch out for incorporation of the new instantiation with this existing dependency. Combining both type bounds -- using this rule:
  α = S and T &lt;: α imply ⟨T &lt;: S⟩
creates a new constraint:
  ⟨List&lt;Number&gt; :&gt; List&lt;? extends T#1#2&gt;⟩
during reduction, this constraint
  ⟨? extends T#1#2 &lt;= Number⟩
is reduced to this constraint
  ⟨? extends T#1#2 = Number⟩
and then the corresponding type bound / instantiation
  ? extends T#1#2 = Number
  
I stepped through these details and found no code location where we knowingly apply any reasoning other than literal implementation of JLS.

Note, that the last reduction steps seem to ignore the fact that the inference variable "? extends T#1#2" represents a wildcard. The wildcard has T#1 as its bound, so bound check needs to be performed.

We have the facility to deriveTypeArgumentConstraints(boundI,boundJ), but this is not triggered, because the flag deriveTypeArgumentConstraints is false (mh?).
By tweaking the flag to true I get this constraint:
   ⟨? extends T#1#2 = Number⟩
So, this is nothing new (see above).

Let's me think, however: reducing this last constraint asks whether the lhs is a type or a wildcard. It *is* a type variable representing a wildcard. So, what should the answer be? If I let the wildcard-representing inference variable answer "WILDCARD_TYPE", meaning this "is not a type", then reduction fails right here!

As a result ecj *would* report

----------
1. ERROR in X.java (at line 5) 
	Set&lt;List&lt;Number&gt;&gt; numbetListSet = Collections.singleton(toWildcardGeneric(integerList)); 
	                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
Type mismatch: cannot convert from Set&lt;List&lt;Object&gt;&gt; to Set&lt;List&lt;Number&gt;&gt; 
----------

Saying "Object" doesn't give the full explanation, but the result *would* be rejection as desired.</comment_text>
        </comment>
        <comment>
            <comment_id>2713763</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-29 08:35:35 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #4)
&gt; is reduced to this constraint
&gt;   ⟨? extends T#1#2 = Number⟩
&gt;
&gt; [..]
&gt; 
&gt; Let's me think, however: reducing this last constraint asks whether the lhs
&gt; is a type or a wildcard. It *is* a type variable representing a wildcard.
&gt; So, what should the answer be? If I let the wildcard-representing inference
&gt; variable answer "WILDCARD_TYPE", meaning this "is not a type", then
&gt; reduction fails right here!

Bad news: with this tweak in our implementation we'd get 44 new regressions in GenericsRegressionTest_1_8 alone. From looking at the first few regressions, all seem to be rejecting programs that previously were accepted.

=&gt; This cannot be done without a change in JLS, or at least a confirmation that the modified interpretation is "correct".</comment_text>
        </comment>
        <comment>
            <comment_id>2713769</comment_id>
            <comment_count>6</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-29 09:15:07 -0400</when>
            <comment_text>One more experiment: previously I assumed that type inference according to JLS 18 can only produce legal results, or must fail. What if we drop this assumption, let inference compute a result, but still do a full type check afterwards? 

Implementationwise, this could correpond to removing this from Scope.computeCompatibleMethod():
     if (infCtx != null)
         return method; // inference is responsible, no need to recheck.
(there's several occurrences, not sure if all should be considered).

With one occurrence of that stanza deleted I see us answering a ProblemMethodBinding(NotFound), which prints the same error as my experiment in comment 4. But this also causes regressions in 4 tests of GenericsRegressionTest_1_8.

Let's check them individually:

testBug470958
new error (assuming this is a the primary among 3 errors):
  The method collect(Collector&lt;? super Map.Entry&lt;String,List&lt;Hotel&gt;&gt;,A,R&gt;) in the type Stream&lt;Map.Entry&lt;String,List&lt;Hotel&gt;&gt;&gt; is not applicable for the arguments (Collector&lt;Object,?,Map&lt;Object,Object&gt;&gt;)\n


testBug424205b
new error:
	one(new X&lt;&gt;((String s) -&gt; { }));
	    ^^^^^^^^^^^^^^^^^^^^^^^^^^
Cannot infer type arguments for X&lt;&gt;


testBug424930c
changes error reported against
  new X&lt;&gt;(() -&gt; new ArrayDeque&lt;&gt;(dequeCapacity));
from
  Cannot make a static reference to the non-static field dequeCapacity
to
  Cannot infer type arguments for X&lt;&gt;


test447767
new error:
	one(new X&lt;&gt;((String s) -&gt; { }));
	    ^^^^^^^^^^^^^^^^^^^^^^^^^^
Cannot infer type arguments for X&lt;&gt;
(anyone has a deja vu? :) )


Essentially, we need to know if two new errors are correct (considering the one dup and ignoring the change from one error to another).</comment_text>
        </comment>
        <comment>
            <comment_id>2713772</comment_id>
            <comment_count>7</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-29 09:27:44 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #6)
&gt; testBug470958
&gt; new error (assuming this is a the primary among 3 errors):
&gt;   The method collect(Collector&lt;? super Map.Entry&lt;String,List&lt;Hotel&gt;&gt;,A,R&gt;)
&gt; in the type Stream&lt;Map.Entry&lt;String,List&lt;Hotel&gt;&gt;&gt; is not applicable for the
&gt; arguments (Collector&lt;Object,?,Map&lt;Object,Object&gt;&gt;)\n

Here we are detecting the following incompatibilities:

when checking 
  toMap(Map.Entry::getKey, (&lt;no type&gt; entry) -&gt; completedFuture(entry.getValue()))
method reference
   Map.Entry::getKey
is imcompatible with the parameter
   Function&lt;? super Object,? extends Object&gt;

when checking the outer
  loadMany(codes, begin, end).entrySet().stream().collect(toMap(..))
argument of type
   Collector&lt;Object,?,Map&lt;Object,Object&gt;&gt;
is incompatible with parameter
   Collector&lt;? super Map.Entry&lt;String,List&lt;Hotel&gt;&gt;,capture#1-of ?,Map&lt;String,CompletableFuture&lt;List&lt;Hotel&gt;&gt;&gt;&gt;


On the same example javac is silent, but seeing wildcards and captures in the mix, that is no definite answer.</comment_text>
        </comment>
        <comment>
            <comment_id>2713773</comment_id>
            <comment_count>8</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-29 09:41:13 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #6)
&gt; testBug424930c
&gt; changes error reported against
&gt;   new X&lt;&gt;(() -&gt; new ArrayDeque&lt;&gt;(dequeCapacity));
&gt; from
&gt;   Cannot make a static reference to the non-static field dequeCapacity
&gt; to
&gt;   Cannot infer type arguments for X&lt;&gt;

Here the lambda
  (String s) -&gt; {}
is considered pertinent to applicability but cannot be typed against target type Object (which is not a functional interface..)

Here Object is just the provisional result of applicability inference.

=&gt; The new checks are performed too early, i.e., before invocation type inference has run.</comment_text>
        </comment>
        <comment>
            <comment_id>2713779</comment_id>
            <comment_count>9</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-05-29 10:23:34 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/73877</comment_text>
        </comment>
        <comment>
            <comment_id>2713780</comment_id>
            <comment_count>10</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-29 10:25:11 -0400</when>
            <comment_text>I found a better location for inserting the new check: ASTNode.resolvePolyExpressionArguments() which is run as to finalize type checking involving (nested) poly expressions.

With adding a new compatibility check here, we are able to reject the example from comment 0 with only 3 "regressions" in GenericsRegressionTest_1_8.

In two cases a correct error report is simply duplicated.

The last case adds

    return s3.map(s2 -&gt; s2.map(s1 -&gt; Integer.parseInt(s1))).findAny().orElse(Stream.of(new Object()));
                                                                             ^^^^^^^^^^^^^^^^^^^^^^^
Type mismatch: cannot convert from Stream&lt;Object&gt; to Stream&lt;Integer&gt;

where we already have

    return s3.map(s2 -&gt; s2.map(s1 -&gt; Integer.parseInt(s1))).findAny().orElse(Stream.of(new Object()));
                                                                      ^^^^^^
The method orElse(Stream&lt;Integer&gt;) in the type Optional&lt;Stream&lt;Integer&gt;&gt; is not applicable for the arguments (Stream&lt;Object&gt;)


This doesn't look too bad.


(In reply to Eclipse Genie from comment #9)
&gt; New Gerrit change created: https://git.eclipse.org/r/73877

Dumped the above experiment there, to be picked up later.</comment_text>
        </comment>
        <comment>
            <comment_id>2713799</comment_id>
            <comment_count>11</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-29 12:16:36 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #9)
&gt; New Gerrit change created: https://git.eclipse.org/r/73877

Some failures were expected, here's the full set of them:

    org.eclipse.jdt.core.tests.compiler.regression.GenericTypeTest.test1142 - 1.8
    org.eclipse.jdt.core.tests.compiler.regression.GenericTypeTest.test1271 - 1.8
    org.eclipse.jdt.core.tests.compiler.regression.GenericsRegressionTest.test427728a - 1.8
    org.eclipse.jdt.core.tests.compiler.regression.GenericsRegressionTest.test440019_c9 - 1.8
    org.eclipse.jdt.core.tests.compiler.regression.GenericsRegressionTest.test434118 - 1.8
    org.eclipse.jdt.core.tests.compiler.regression.GenericsRegressionTest_1_8.testBug425493 - 1.8
    org.eclipse.jdt.core.tests.compiler.regression.GenericsRegressionTest_1_8.test427218_reduced - 1.8
    org.eclipse.jdt.core.tests.compiler.regression.GenericsRegressionTest_1_8.test433852 - 1.8
    org.eclipse.jdt.core.tests.compiler.regression.MethodVerifyTest.test094 - 1.8
    org.eclipse.jdt.core.tests.compiler.regression.NegativeLambdaExpressionsTest.test428857a - 1.8
    org.eclipse.jdt.core.tests.compiler.regression.NegativeLambdaExpressionsTest.test428857b - 1.8
    org.eclipse.jdt.core.tests.compiler.regression.NegativeLambdaExpressionsTest.test428857g - 1.8
    org.eclipse.jdt.core.tests.compiler.regression.OverloadResolutionTest8.test427748 - 1.8
    org.eclipse.jdt.core.tests.compiler.regression.StaticImportTest.testBug479287 - 1.8
    org.eclipse.jdt.core.tests.compiler.regression.VarargsTest.test470370 - 1.8



Some obervations from a quick glance:

GenericsRegressionTest.test427728a, test440019_c9
OverloadResolutionTest8.test427748
  I simply forgot to take boxing into consideration - fixable


NegativeLambdaExpressionsTest.test428857a, test428857b, test428857g 
new error:
 System.out.println(func.apply(Arrays.asList("a", "b")));
                               ^^^^^^^^^^^^^^^^^^^^^^^
Type mismatch: cannot convert from List&lt;String&gt; to ArrayList&lt;String&gt;


Most everything seems to involve wildcards / captures in a way that need a closer look to tell, which version (old/new) is correct.</comment_text>
        </comment>
        <comment>
            <comment_id>2713805</comment_id>
            <comment_count>12</comment_count>
            <who>Jens Li</who>
            <commenter_username>skrap</commenter_username>
            <when>2016-05-29 13:00:03 -0400</when>
            <comment_text>I reported this problem to the javac team using the Oracle bug reporting page (bugreport.java.com/). I'll post here when I get any reaction to that. I unfortunately didn't think about including a link to this bug report. 

I got an automatic replay saying I got "Review ID: JI-9038574" if that is to any use for anyone.

I would report the bug to the Open JDK issue system but it doesn't seem possible to get an account there if one is not a contributor.</comment_text>
        </comment>
        <comment>
            <comment_id>2713807</comment_id>
            <comment_count>13</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-29 13:14:25 -0400</when>
            <comment_text>(In reply to Lii Woo from comment #12)
&gt; I reported this problem to the javac team using the Oracle bug reporting
&gt; page (bugreport.java.com/). I'll post here when I get any reaction to that.

Thanks, much appreciated.
 
&gt; I got an automatic replay saying I got "Review ID: JI-9038574" if that is to
&gt; any use for anyone.

I don't thinks so ...

&gt; I would report the bug to the Open JDK issue system but it doesn't seem
&gt; possible to get an account there if one is not a contributor.

I know &lt;sigh&gt;.</comment_text>
        </comment>
        <comment>
            <comment_id>2713808</comment_id>
            <comment_count>14</comment_count>
            <who>Jens Li</who>
            <commenter_username>skrap</commenter_username>
            <when>2016-05-29 13:31:55 -0400</when>
            <comment_text>@Stephan: Since you don't seem to have commented on that I'd like to draw attention to one of the examples in the attached file.

The example demonstrates the *very* interesting fact that if Collections.singleton is called using a static import then this problem is detected and a compilation error is generated. Static imports seem to be handled differently. (I guess because there is overloading resolution involved when they are called.)

I tested the same thing with the id method from commen #2 (put it in a separated class and added a static import to it) and this also generates a compilation error.</comment_text>
        </comment>
        <comment>
            <comment_id>2713810</comment_id>
            <comment_count>15</comment_count>
            <who>Jens Li</who>
            <commenter_username>skrap</commenter_username>
            <when>2016-05-29 13:41:53 -0400</when>
            <comment_text>(In reply to Lii Woo from comment #14)
&gt; I tested the same thing with the id method from comment #2 (put it in a
&gt; separated class and added a static import to it) and this also generates a
&gt; compilation error.

And javac does not detect that error in that case, i.e. it seem to treat static imports and explicit static references in the same way, accepting both.</comment_text>
        </comment>
        <comment>
            <comment_id>2713831</comment_id>
            <comment_count>16</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-05-29 16:57:21 -0400</when>
            <comment_text>(In reply to Lii Woo from comment #14)
&gt; @Stephan: Since you don't seem to have commented on that I'd like to draw
&gt; attention to one of the examples in the attached file.
&gt; 
&gt; The example demonstrates the *very* interesting fact that if
&gt; Collections.singleton is called using a static import then this problem is
&gt; detected and a compilation error is generated. Static imports seem to be
&gt; handled differently. (I guess because there is overloading resolution
&gt; involved when they are called.)

Thanks for the heads-up.

This difference got lost between 4.6M2 and 4.6M3. I.e., starting with 4.6M3 also the variant with static import *is* (wrongly) accepted. 
But this could actually be good: before my patch equal behavior between qualified reference and static import was already established, and both variants are fixed by my draft patch.

Looking closer, this change at 4.6M3 was most likely caused by bug 479287, which in fact can be found in our list of regressions: StaticImportTest.testBug479287 :-/ Here we have another user who will be unhappy about the fix in this bug.


We need to sort out two things
- address regressions
- coordinate with Oracle

At this point I'm putting my pen down, for the moment.</comment_text>
        </comment>
        <comment>
            <comment_id>2780333</comment_id>
            <comment_count>17</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-26 18:51:17 -0500</when>
            <comment_text>EA build towards Java 9 of javac rejects the example:

LostWildCardCompilerBug.java:41: error: incompatible types: inference variable T#1 has incompatible bounds
        Set&lt;List&lt;Number&gt;&gt; numbetListSet = Collections.singleton(toWildcardGeneric(integerList));
                                                               ^
    equality constraints: List&lt;Number&gt;
    lower bounds: List&lt;CAP#1&gt;
  where T#1,T#2 are type-variables:
    T#1 extends Object declared in method &lt;T#1&gt;singleton(T#1)
    T#2 extends Object declared in method &lt;T#2&gt;toWildcardGeneric(List&lt;T#2&gt;)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Integer from capture of ? extends T#2
Note: LostWildCardCompilerBug.java uses or overrides a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
1 error

After recent alignment with javac's inference we should take a fresh look here.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499037</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-08-02 06:05:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.9][resource] Include effectively final variables in t-w-r in resource leak analysis</short_desc>
        <thetext>Following bug 488659 resource leak analysis may need to be adjusted to cover the case of effectively final variables used as resources in try-with-resources</thetext>
    </bug>
    <bug>
        <id>499716</id>
        <developer>Clovis Seragiotto</developer>
        <developer_username>clovis.seragiotto</developer_username>
        <dup_id/>
        <creation_time>2016-08-16 03:52:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Quick fix "change return type to @NonNull" generates exception</short_desc>
        <thetext>import org.eclipse.jdt.annotation.*;

interface Type&lt;@Nullable K&gt; {
	@NonNullByDefault(DefaultLocation.RETURN_TYPE)
	K get();

	class U implements Type&lt;@Nullable String&gt; {
		@Override
		public String get() { // &lt;-- error "The default '@NonNull' conflicts..."
			return "";
		}
		
	}
}

To fix the error, of of the possible quick fixes is "change return type of get(..) to @NonNull". This quick fix generates an exception, however ("The fix generated a null change")</thetext>
        <comment>
            <comment_id>2740339</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-08-16 04:04:48 -0400</when>
            <comment_text>I believe this goes to the UI?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>500024</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-08-20 08:53:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][null] fix glitches regarding ExternalAnnotationStatus</short_desc>
        <thetext>(In reply to Stephan Herrmann from bug 490010 comment #13)
&gt; The only effect we currently draw from the difference NO_EEA_FILE vs
&gt; NOT_EEA_CONFIGURED is fine tuning of the severity of
&gt; IProblem.NonNullTypeVariableFromLegacyMethod and
&gt; .NonNullMethodTypeVariableFromLegacyMethod. In one case it's warning, in the
&gt; other just info.
&gt; 
&gt; Creating such test failed due to bug 496137: FileSystem is only used by the
&gt; batch compiler, but that beast doesn't even report the difference between
&gt; WARNING &amp; INFO, its either ERROR or WARNING, nothing else.
&gt; 
&gt; So for FileSystem we should conclude: it is a bug independent of the changes
&gt; in this bug. And: the bug is not observable currently. Similar for other
&gt; compiler.batch.* classes.
&gt; 
&gt; We could safely let this rest until either bug 496137 is fixed, or other
&gt; observable effects of NO_EEA_FILE are introduced.

Today I observed such a difference: the same issue is reported as info in the Problems view and as warning in the editor.

Here the project was not configured for external annotations, but both involved classes are in the same project. Here warning should be OK, haven't looked at why info is reported in the Problems view.</thetext>
        <comment>
            <comment_id>2742088</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-20 09:07:05 -0400</when>
            <comment_text>Edit: in workspace preferences the JRE had an annotation location configured, when I observed the inconsistency between Problems view and editor.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507814</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-11-19 16:36:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.8][inference] housekeeping re InferenceVariables after bug 507716</short_desc>
        <thetext>After bug 507716 two questions are worth investigating:

By storing all inference variables in a CompilationUnitScope, do we waste memory that should be freed at some point? While IC18 has a cleanUp() method, this is not a suitable hook for clean up of ivars, because an ivar can be relevant to several IC18. OTOH, InferenceVariable doesn't hold a lot of memory, no contained objects that could be freed after just releasing the InferenceVariable. =&gt; No-Op?

Secondly, after establishing consistent interning we can probably simplify code by removing hand-crafted equals() and hashCode() methods. Actually, object identity can be meaningfully used, now. As hashmap lookup for ivars is a frequent operation during inference this could actually matter performance-wise.


Additionally, method InferenceVariable.erasure() looks obsolete, given that #superclass is already set to j.l.Object in the constructor.</thetext>
    </bug>
    <bug>
        <id>507923</id>
        <developer>Frank Benoit</developer>
        <developer_username>frank.rene.benoit</developer_username>
        <dup_id/>
        <creation_time>2016-11-22 02:42:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Annotate external not working for ByteArrayOutputStream.toByteArray</short_desc>
        <thetext>This function has an unusual syntax:

public synchronized byte toByteArray()[] {

I want to make the returned byte[] being NonNull.
Trying to bring up the annotate actions with Ctrl+1 succeeds at no cursor position.</thetext>
    </bug>
    <bug>
        <id>508745</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-12-06 09:15:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>grammar fix in ecj -help</short_desc>
        <thetext>(In reply to Stephan Herrmann from bug 508344 comment #3)
&gt; [...]
&gt; 
&gt; From "$ ecj -help":
&gt; 
&gt;       suppress           + enable @SuppressWarnings
&gt;                            When used with -err:, it can also silent optional
&gt;                            errors and warnings
&gt; 
&gt; (BTW: shouldn't this read "silence" instead of "silent"?)</thetext>
    </bug>
    <bug>
        <id>508834</id>
        <developer>Gunnar Wagenknecht</developer>
        <developer_username>gunnar</developer_username>
        <dup_id/>
        <creation_time>2016-12-07 09:35:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[regression] Compile error with flatMap after updating to 3.12.2.v20161124-1400</short_desc>
        <thetext>Created attachment 265746
test project

3.12.2.v20161124-1400
org.eclipse.jdt.feature.group

Please see the attached code. Method test2() causes a compile error after updating to 3.12.2.v20161124-1400. It compiled fine before.</thetext>
        <comment>
            <comment_id>2784074</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-07 14:27:42 -0500</when>
            <comment_text>This error message ...
    The method map(Function&lt;? super Object,? extends R&gt;) in the type Stream&lt;Object&gt; is not applicable for the arguments (TypeB::getText)

... indicates that inference for flatMap didn't produce any educated result, i.e., R = Object.

In the oxygen stream the change happened during M3.

Workaround: explicitly say:
    Stream.&lt;TypeB&gt;of(a.getArrayOfB())

I wonder if we failed to check a non-varargs invocation at some point?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495062</id>
        <developer>Stefan Xenos</developer>
        <developer_username>sxenos</developer_username>
        <dup_id/>
        <creation_time>2016-05-31 15:10:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[newindex] JavaSearchNameEnvironment is slow for large classpaths</short_desc>
        <thetext>Open a project with a large classpath (100+ jars). Performing a search with ctrl-shift-g. Observe that a large amount of time is spent in JavaSearchNameEnvironment, with a stack resembling this:

Thread[Worker-1330,1,main]
        at java.util.zip.ZipFile.open(Native Method)
        at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:225)
        at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:150)
        at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:164)
        at org.eclipse.jdt.internal.core.JavaModelManager.getZipFile(JavaModelManager.java:2678)
        at org.eclipse.jdt.internal.core.JavaModelManager.getZipFile(JavaModelManager.java:2644)
        at org.eclipse.jdt.internal.core.search.matching.JavaSearchNameEnvironment.mapToClassPathLocation(JavaSearchNameEnvironment.java:104)
        at org.eclipse.jdt.internal.core.search.matching.JavaSearchNameEnvironment.computeClasspathLocations(JavaSearchNameEnvironment.java:92)
        at org.eclipse.jdt.internal.core.search.matching.JavaSearchNameEnvironment.&lt;init&gt;(JavaSearchNameEnvironment.java:51)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.initialize(MatchLocator.java:1152)
        at org.eclipse.jdt.internal.core.search.matching.SuperTypeNamesCollector.collect(SuperTypeNamesCollector.java:157)
        at org.eclipse.jdt.internal.core.search.matching.MethodLocator.initializePolymorphicSearch(MethodLocator.java:121)
        at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1356)
        at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:122)
        at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232)
        at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516)
        at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584)
        at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144)
        at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91)
        at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)</thetext>
        <comment>
            <comment_id>2722017</comment_id>
            <comment_count>1</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-06-20 08:07:21 -0400</when>
            <comment_text>Thanks Stefan for the commits listed below in reverse chronological order:

https://github.com/sxenos/eclipse.jdt.core/commit/4a835fc0d782fc4985b5fe2213a230488d16fa5c

https://github.com/sxenos/eclipse.jdt.core/commit/4981ff54ef8ee248f64be537eb545bb5548abfea

https://github.com/sxenos/eclipse.jdt.core/commit/b15c9533ec0c943a046318927a3d2e4df7b25704

https://github.com/sxenos/eclipse.jdt.core/commit/f808cc2f5e6d5197ab12f2615f85b65e5f6e2264q</comment_text>
        </comment>
        <comment>
            <comment_id>2723143</comment_id>
            <comment_count>2</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-06-23 04:27:42 -0400</when>
            <comment_text>(In reply to Manoj Palat from comment #1)
&gt; Thanks Stefan for the commits listed below in reverse chronological order:

&gt; https://github.com/sxenos/eclipse.jdt.core/commit/
&gt; f808cc2f5e6d5197ab12f2615f85b65e5f6e2264q

Correction - the last character is noise - the correct link is :
https://github.com/sxenos/eclipse.jdt.core/commit/f808cc2f5e6d5197ab12f2615f85b65e5f6e2264</comment_text>
        </comment>
        <comment>
            <comment_id>2723364</comment_id>
            <comment_count>3</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-06-23 10:55:00 -0400</when>
            <comment_text>- IndexBasedJavaSearchEnvironment.IBJSE() - Constructor - line 54 JavaProjectIterator - In one case I see a project  repeated - The root cause of the issue can be traced to the code change  at MatchLocator.Initialize(): line 1185 (added in this commit itself) - can be reproduced by selecting "List" in a project with the following code and search for List:
	package p;
	import java.util.List;
	public class X {
	 List x;
	}
The issue may be solved by an additional non-equal condition for project and the focus project before adding to the list.
	 
- IndexBasedJavaSearchEnvironment.IBJSE() - Constructor - Line 97: this.sourceEntryPosition = i; this needs to be followed with a break; out of the for loop - currently sEP gets overwritten multiple times to return the last i instead of the first i. [effects the result of the conditional of IBJSE.isBetter - line 232].

- Warning &amp; cleanup:There are a few warnings in IBJSE - please remove the warnings as well as the code which is commented (eg: IBJSE : 65-67)
Once the code is committed with the above changes, please update the link of the commit in the bug for cross-reference.</comment_text>
        </comment>
        <comment>
            <comment_id>2723589</comment_id>
            <comment_count>4</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-06-23 23:12:21 -0400</when>
            <comment_text>I just pushed a fix for an NPE in PathMap. Sorry - I know I was planning to capture a stack trace the next time this happened but I forgot to capture it when it occurred. :-(</comment_text>
        </comment>
        <comment>
            <comment_id>2723592</comment_id>
            <comment_count>5</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-06-23 23:44:09 -0400</when>
            <comment_text>I believe these commits should address the concerns raised, above.

https://github.com/sxenos/eclipse.jdt.core/commit/a0dd9890f397d7d930988709b79884049de8cfdc

https://github.com/sxenos/eclipse.jdt.core/commit/b11ad0cb57ffa082df084c67c21631e483c6378a

However, I'm concerned about one aspect of this patch and I was wondering if you had any advice on this. The patch does, indeed, make things a lot faster... but it won't return results from unindexed locations until after the indexer finishes doing its thing.

This isn't a problem for things like UI, but I notice that IBJSE is sometimes used from contexts such as the indexer itself and the compiler and I wouldn't want to introduce a compiler error because the indexer hadn't had a chance to run yet.

I'd suggest temporarily disabling this part of the index using a preference until we've fully worked out this detail.</comment_text>
        </comment>
        <comment>
            <comment_id>2723594</comment_id>
            <comment_count>6</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-06-23 23:52:24 -0400</when>
            <comment_text>Add a preference to disable the search environment changes

https://github.com/sxenos/eclipse.jdt.core/commit/ab6664338580826fc847b815216174ad0489749c

This should let us merge the branch tomorrow without risk of regressions.</comment_text>
        </comment>
        <comment>
            <comment_id>2760032</comment_id>
            <comment_count>7</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-10-04 13:47:02 -0400</when>
            <comment_text>This fix was not included in the newindex merge (or rather the code was included in a disabled state). Need to follow up.</comment_text>
        </comment>
        <comment>
            <comment_id>2762271</comment_id>
            <comment_count>8</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-06 12:32:59 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/82660</comment_text>
        </comment>
        <comment>
            <comment_id>2770803</comment_id>
            <comment_count>9</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-28 02:46:11 -0400</when>
            <comment_text>Bulk change, moving out all bugs that couldn't make it to M3.</comment_text>
        </comment>
        <comment>
            <comment_id>2776385</comment_id>
            <comment_count>10</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-11-15 17:58:49 -0500</when>
            <comment_text>Digging into the test failures. It appears that a lot of the failures are due to the fact that the search queries aren't blocking on the indexer. I'm just trying to figure out where the best place for the blocking should be.</comment_text>
        </comment>
        <comment>
            <comment_id>2776393</comment_id>
            <comment_count>11</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-11-15 21:07:59 -0500</when>
            <comment_text>The next set of failures seems due to the fact that IndexBasedJavaSearchEnvironment.isPackage isn't taking into account unindexed locations.</comment_text>
        </comment>
        <comment>
            <comment_id>2777295</comment_id>
            <comment_count>12</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-11-17 23:23:20 -0500</when>
            <comment_text>The most recent build deadlocked. Thread dump shown below. The deadlock was caused by the scheduling rule described in bug 241751, which is still present in the code and still causing deadlocks.

If I understand the history correctly,
- The scheduling rule is used to protect the project description
- The project description is being written since the classpath containers use setDynamicReferences
- JDT uses setDynamicReferences to instruct the build system about what order the projects need to be compiled in.

However, setDynamicReferences is a very poor way for JDT to communicate the build order to the build system.

- It creates this deadlock.
- If there are multiple builders attached to the project, they would overwrite one another's dynamic references.
- It creates opportunities for staleness, since the dynamic references are derived data and need to be kept in sync with the classpath.

I'd suggest replacing the dynamic references system with a pure functional approach that is computed in the getter. Natures can attach some sort of callback to the project and the getter would compute the union of the projects returned by those getters.

This would work with multiple builders, wouldn't require the use of locks, and wouldn't require persisting any derived data.


Stacks for the deadlock shown below:

Running org.eclipse.jdt.core.tests.model.AllJavaModelTests
java.lang.Exception
	at org.eclipse.jdt.internal.core.search.matching.ComparisonNameEnvironment.findType(ComparisonNameEnvironment.java:39)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:172)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:201)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findImport(CompilationUnitScope.java:466)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findSingleImport(CompilationUnitScope.java:520)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInImports(CompilationUnitScope.java:397)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:445)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1878)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1296)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1337)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1469)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:122)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:238)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:585)
	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:600)
	at org.eclipse.jdt.core.tests.model.AbstractJavaSearchTests.search(AbstractJavaSearchTests.java:1049)
	at org.eclipse.jdt.core.tests.model.AbstractJavaSearchTests.search(AbstractJavaSearchTests.java:1063)
	at org.eclipse.jdt.core.tests.model.JavaSearchBugsTests.testBug222284(JavaSearchBugsTests.java:10341)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at junit.framework.TestCase.runTest(TestCase.java:176)
	at org.eclipse.jdt.core.tests.junit.extension.TestCase.runTest(TestCase.java:954)
	at junit.framework.TestCase.runBare(TestCase.java:141)
	at junit.framework.TestResult$1.protect(TestResult.java:122)
	at junit.framework.TestResult.runProtected(TestResult.java:142)
	at junit.framework.TestResult.run(TestResult.java:125)
	at junit.framework.TestCase.run(TestCase.java:129)
	at junit.framework.TestSuite.runTest(TestSuite.java:252)
	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:112)
	at junit.framework.TestSuite.run(TestSuite.java:247)
	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:96)
	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite$1.protect(SuiteOfTestCases.java:84)
	at junit.framework.TestResult.runProtected(TestResult.java:142)
	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:93)
	at junit.framework.TestSuite.runTest(TestSuite.java:252)
	at junit.framework.TestSuite.run(TestSuite.java:247)
	at junit.framework.TestSuite.runTest(TestSuite.java:252)
	at junit.framework.TestSuite.run(TestSuite.java:247)
	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:264)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:124)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray2(ReflectionUtils.java:208)
	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:156)
	at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:82)
	at org.eclipse.tycho.surefire.osgibooter.OsgiSurefireBooter.run(OsgiSurefireBooter.java:91)
	at org.eclipse.tycho.surefire.osgibooter.HeadlessTestApplication.run(HeadlessTestApplication.java:21)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)
findType(Ref, pack.) didn't return the expected result
Expected: null
Actual: IBinaryType pack/Ref.class
testBug222284 got 2 results:
		"src/Test.java [pack.Ref] EXACT_MATCH\n" + 
		"src/Test.java Test.ref [Ref] EXACT_MATCH"
Encoding tests using Workspace charset: UTF-8 and VM charset: UTF-8
Bug 110576 is not tested under linux os...
ClasspathTests#testInvalidClasspath1() may generate an expected Fatal Error...
[Fatal Error] :3:43: Element type "classpathentry" must be followed by either attribute specifications, "&gt;" or "/&gt;".
testExternalJarChanged5
Possible frozen test case
"Worker-5": TIMED_WAITING
    java.lang.Object.wait(Native Method)
    org.eclipse.core.internal.jobs.WorkerPool.sleep(WorkerPool.java:188)
    org.eclipse.core.internal.jobs.WorkerPool.startJob(WorkerPool.java:220)
    org.eclipse.core.internal.jobs.Worker.run(Worker.java:52)

"Java indexing": WAITING
    java.lang.Object.wait(Native Method)
    java.lang.Object.wait(Object.java:502)
    org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:373)
    java.lang.Thread.run(Thread.java:745)

"Thread-1": TIMED_WAITING
    java.lang.Thread.sleep(Native Method)
    org.eclipse.jdt.core.tests.model.AttachedJavadocTests$1.run(AttachedJavadocTests.java:757)

"[ThreadPool Manager] - Idle Thread": WAITING
    java.lang.Object.wait(Native Method)
    java.lang.Object.wait(Object.java:502)
    org.eclipse.equinox.internal.util.impl.tpt.threadpool.Executor.run(Executor.java:106)

"Worker-4": WAITING
    java.lang.Object.wait(Native Method)
    java.lang.Object.wait(Object.java:502)
    org.eclipse.core.internal.jobs.ThreadJob.waitForRun(ThreadJob.java:304)
    org.eclipse.core.internal.jobs.ThreadJob.joinRun(ThreadJob.java:206)
    org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:92)
    org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:324)
    org.eclipse.core.internal.utils.StringPoolJob.run(StringPoolJob.java:98)
    org.eclipse.core.internal.jobs.Worker.run(Worker.java:56)

"Worker-3": RUNNABLE
    sun.management.ThreadImpl.getThreadInfo1(Native Method)
    sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:178)
    org.eclipse.jdt.core.tests.model.FreezeMonitor$1.run(FreezeMonitor.java:38)
    org.eclipse.core.runtime.jobs.Job$2.run(Job.java:182)
    org.eclipse.core.internal.jobs.Worker.run(Worker.java:56)

"Worker-2": WAITING
    java.lang.Object.wait(Native Method)
    java.lang.Object.wait(Object.java:502)
    org.eclipse.core.internal.jobs.ThreadJob.waitForRun(ThreadJob.java:304)
    org.eclipse.core.internal.jobs.ThreadJob.joinRun(ThreadJob.java:206)
    org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:92)
    org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:324)
    org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:121)
    org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:2188)
    org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2235)
    org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
    org.eclipse.jdt.internal.core.ProjectReferenceChange.updateProjectReferencesIfNecessary(ProjectReferenceChange.java:111)
    org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged(ChangeClasspathOperation.java:59)
    org.eclipse.jdt.internal.core.SetContainerOperation.executeOperation(SetContainerOperation.java:111)
    org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
    org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
    org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
    org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)
    org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:2033)
    org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3441)
    org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2693)
    org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
    org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
    org.eclipse.jdt.internal.core.JavaProject.getAllPackageFragmentRoots(JavaProject.java:1430)
    org.eclipse.jdt.internal.core.JavaProject.getAllPackageFragmentRoots(JavaProject.java:1425)
    org.eclipse.jdt.internal.core.nd.indexer.Indexer.getAllIndexableObjectsInWorkspace(Indexer.java:840)
    org.eclipse.jdt.internal.core.nd.indexer.Indexer.rescan(Indexer.java:219)
    org.eclipse.jdt.internal.core.nd.indexer.Indexer.lambda$0(Indexer.java:122)
    org.eclipse.jdt.internal.core.nd.indexer.Indexer$$Lambda$1/229995302.run(Unknown Source)
    org.eclipse.core.runtime.jobs.Job$2.run(Job.java:182)
    org.eclipse.core.internal.jobs.Worker.run(Worker.java:56)

"Worker-JM": TIMED_WAITING
    java.lang.Object.wait(Native Method)
    org.eclipse.core.internal.jobs.InternalWorker.run(InternalWorker.java:59)

"[Timer] - Main Queue Handler": TIMED_WAITING
    java.lang.Object.wait(Native Method)
    org.eclipse.equinox.internal.util.impl.tpt.timer.TimerImpl.run(TimerImpl.java:141)
    java.lang.Thread.run(Thread.java:745)

"Refresh Thread: Equinox Container: 9e3f77c7-1900-46ea-a47a-a7081d412778": WAITING
    java.lang.Object.wait(Native Method)
    java.lang.Object.wait(Object.java:502)
    org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.getNextEvent(EventManager.java:400)
    org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:336)

"Bundle File Closer": WAITING
    java.lang.Object.wait(Native Method)
    java.lang.Object.wait(Object.java:502)
    org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.getNextEvent(EventManager.java:400)
    org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:336)

"Start Level: Equinox Container: 9e3f77c7-1900-46ea-a47a-a7081d412778": WAITING
    java.lang.Object.wait(Native Method)
    java.lang.Object.wait(Object.java:502)
    org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.getNextEvent(EventManager.java:400)
    org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:336)

"Framework Event Dispatcher: org.eclipse.osgi.internal.framework.EquinoxEventPublisher@7946e1f4": WAITING
    java.lang.Object.wait(Native Method)
    java.lang.Object.wait(Object.java:502)
    org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.getNextEvent(EventManager.java:400)
    org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:336)

"Active Thread: Equinox Container: 9e3f77c7-1900-46ea-a47a-a7081d412778": TIMED_WAITING
    sun.misc.Unsafe.park(Native Method)
    java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)
    java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)
    java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1093)
    java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)
    java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)
    java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)
    java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    java.lang.Thread.run(Thread.java:745)

"Signal Dispatcher": RUNNABLE

"Finalizer": WAITING
    java.lang.Object.wait(Native Method)
    java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)
    java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)
    java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)

"Reference Handler": WAITING
    java.lang.Object.wait(Native Method)
    java.lang.Object.wait(Object.java:502)
    java.lang.ref.Reference.tryHandlePending(Reference.java:191)
    java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)

"main": TIMED_WAITING
    java.lang.Object.wait(Native Method)
    org.eclipse.core.internal.jobs.Semaphore.acquire(Semaphore.java:39)
    org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:926)
    org.eclipse.core.internal.jobs.InternalJob.join(InternalJob.java:345)
    org.eclipse.core.runtime.jobs.Job.join(Job.java:582)
    org.eclipse.jdt.internal.core.nd.indexer.Indexer.waitForIndex(Indexer.java:1061)
    org.eclipse.jdt.core.tests.model.ModifyingResourceTests.createFile(ModifyingResourceTests.java:106)
    org.eclipse.jdt.core.tests.model.ModifyingResourceTests.createFile(ModifyingResourceTests.java:111)
    org.eclipse.jdt.core.tests.model.ModifyingResourceTests.createFile(ModifyingResourceTests.java:115)
    org.eclipse.jdt.core.tests.model.ClasspathInitializerTests$3.run(ClasspathInitializerTests.java:400)
    org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)
    org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
    org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
    org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
    org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5553)
    org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5510)
    org.eclipse.jdt.core.tests.model.ClasspathInitializerTests.testContainerInitializer08(ClasspathInitializerTests.java:375)
    sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    java.lang.reflect.Method.invoke(Method.java:498)
    junit.framework.TestCase.runTest(TestCase.java:176)
    org.eclipse.jdt.core.tests.junit.extension.TestCase.runTest(TestCase.java:954)
    junit.framework.TestCase.runBare(TestCase.java:141)
    junit.framework.TestResult$1.protect(TestResult.java:122)
    junit.framework.TestResult.runProtected(TestResult.java:142)
    junit.framework.TestResult.run(TestResult.java:125)
    junit.framework.TestCase.run(TestCase.java:129)
    junit.framework.TestSuite.runTest(TestSuite.java:252)
    org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:112)
    junit.framework.TestSuite.run(TestSuite.java:247)
    org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:96)
    org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite$1.protect(SuiteOfTestCases.java:84)
    junit.framework.TestResult.runProtected(TestResult.java:142)
    org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:93)
    junit.framework.TestSuite.runTest(TestSuite.java:252)
    junit.framework.TestSuite.run(TestSuite.java:247)
    org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)
    org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:264)
    org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153)
    org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:124)
    sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    java.lang.reflect.Method.invoke(Method.java:498)
    org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray2(ReflectionUtils.java:208)
    org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:156)
    org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:82)
    org.eclipse.tycho.surefire.osgibooter.OsgiSurefireBooter.run(OsgiSurefireBooter.java:91)
    org.eclipse.tycho.surefire.osgibooter.HeadlessTestApplication.run(HeadlessTestApplication.java:21)
    sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    java.lang.reflect.Method.invoke(Method.java:498)
    org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)
    org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)
    org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
    org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
    org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
    org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
    sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    java.lang.reflect.Method.invoke(Method.java:498)
    org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
    org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
    org.eclipse.equinox.launcher.Main.run(Main.java:1519)
    org.eclipse.equinox.launcher.Main.main(Main.java:1492)</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499664</id>
        <developer>Ulrich Hobelmann</developer>
        <developer_username>ulrich.hobelmann</developer_username>
        <dup_id/>
        <creation_time>2016-08-15 09:59:00 -0400</creation_time>
        <product>JDT</product>
        <component>Text</component>
        <short_desc>Exception trying to view outline</short_desc>
        <thetext>I browsed the type hierarchy for Guava's Cache, opened the LocalLoadingCache and hit Ctrl-O to open the Outline popup.

-- Error Details --
Date: Mon Aug 15 15:57:27 CEST 2016
Message: java.lang.IllegalArgumentException: Comparison method violates its general contract!
Workaround for comparator violation:
	Set system property -Djava.util.Arrays.useLegacyMergeSort=true
this: org.eclipse.jdt.internal.ui.text.JavaOutlineInformationControl$OutlineSorter
comparator: null
array:
	LocalLoadingCache(CacheBuilder&lt;? super K, ? super V&gt;, CacheLoader&lt;? super K, V&gt;) - com.goo.com.cache.LocalCache.LocalLoadingCache
	getAll(Iterable&lt;? extends K&gt;) : ImmutableMap&lt;K, V&gt; - com.goo.com.cache.LocalCache.LocalLoadingCache
	refresh(K) : void - com.goo.com.cache.LocalCache.LocalLoadingCache
	serialVersionUID : long - com.goo.com.cache.LocalCache.LocalLoadingCache
	writeReplace() : Object - com.goo.com.cache.LocalCache.LocalLoadingCache
	get(K) : V - com.goo.com.cache.LoadingCache
	getUnchecked(K) : V - com.goo.com.cache.LoadingCache
	getAll(Iterable&lt;? extends K&gt;) : ImmutableMap&lt;K, V&gt; - com.goo.com.cache.LoadingCache
	apply(K) : V - com.goo.com.cache.LoadingCache
	refresh(K) : void - com.goo.com.cache.LoadingCache
	asMap() : ConcurrentMap&lt;K, V&gt; - com.goo.com.cache.LoadingCache
	getIfPresent(K) : V - com.goo.com.cache.Cache
	get(K, Callable&lt;? extends V&gt;) : V - com.goo.com.cache.Cache
	getAllPresent(Iterable&lt;? extends K&gt;) : ImmutableMap&lt;K, V&gt; - com.goo.com.cache.Cache
	put(K, V) : void - com.goo.com.cache.Cache
	invalidate(Object) : void - com.goo.com.cache.Cache
	invalidateAll(Iterable&lt;?&gt;) : void - com.goo.com.cache.Cache
	invalidateAll() : void - com.goo.com.cache.Cache
	size() : long - com.goo.com.cache.Cache
	stats() : CacheStats - com.goo.com.cache.Cache
	asMap() : ConcurrentMap&lt;K, V&gt; - com.goo.com.cache.Cache
	cleanUp() : void - com.goo.com.cache.Cache
	get(K) : V - com.goo.com.cache.Cache
	getUnchecked(K) : V - com.goo.com.cache.Cache
	apply(K) : V - com.goo.com.cache.Cache
	apply(F) : T - com.goo.com.base.Function
	equals(Object) : boolean - com.goo.com.base.Function
	localCache : LocalCache&lt;K, V&gt; - com.goo.com.cache.LocalCache.LocalManualCache
	LocalManualCache(CacheBuilder&lt;? super K, ? super V&gt;) - com.goo.com.cache.LocalCache.LocalManualCache
	LocalManualCache(CacheBuilder&lt;? super K, ? super V&gt;, CacheLoader&lt;? super K, V&gt;) - com.goo.com.cache.LocalCache.LocalManualCache
	getIfPresent(K) : V - com.goo.com.cache.LocalCache.LocalManualCache
	get(K, Callable&lt;? extends V&gt;) : V - com.goo.com.cache.LocalCache.LocalManualCache
	getAllPresent(Iterable&lt;? extends K&gt;) : ImmutableMap&lt;K, V&gt; - com.goo.com.cache.LocalCache.LocalManualCache
	put(K, V) : void - com.goo.com.cache.LocalCache.LocalManualCache
	invalidate(Object) : void - com.goo.com.cache.LocalCache.LocalManualCache
	invalidateAll(Iterable&lt;?&gt;) : void - com.goo.com.cache.LocalCache.LocalManualCache
	invalidateAll() : void - com.goo.com.cache.LocalCache.LocalManualCache
	size() : long - com.goo.com.cache.LocalCache.LocalManualCache
	asMap() : ConcurrentMap&lt;K, V&gt; - com.goo.com.cache.LocalCache.LocalManualCache
	stats() : CacheStats - com.goo.com.cache.LocalCache.LocalManualCache
	cleanUp() : void - com.goo.com.cache.LocalCache.LocalManualCache
	get(K) : V - com.goo.com.cache.LocalCache.LocalManualCache
	getUnchecked(K) : V - com.goo.com.cache.LocalCache.LocalManualCache
	apply(K) : V - com.goo.com.cache.LocalCache.LocalManualCache
	serialVersionUID : long - com.goo.com.cache.LocalCache.LocalManualCache
	writeReplace() : Object - com.goo.com.cache.LocalCache.LocalManualCache
	Object() - jav.lang.Object
	registerNatives() : void - jav.lang.Object
	getClass() : Class&lt;?&gt; - jav.lang.Object
	hashCode() : int - jav.lang.Object
	equals(Object) : boolean - jav.lang.Object
	clone() : Object - jav.lang.Object
	toString() : String - jav.lang.Object
	notify() : void - jav.lang.Object
	notifyAll() : void - jav.lang.Object
	wait(long) : void - jav.lang.Object
	wait(long, int) : void - jav.lang.Object
	wait() : void - jav.lang.Object
	finalize() : void - jav.lang.Object
Severity: Error
Product: Eclipse 4.6.0.20160613-1800 (org.eclipse.epp.package.java.product)
Plugin: org.eclipse.jface
Session Data:
eclipse.buildId=4.6.0.I20160606-1100
java.version=1.8.0_92
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product</thetext>
        <comment>
            <comment_id>2740120</comment_id>
            <comment_count>1</comment_count>
            <who>Ulrich Hobelmann</who>
            <commenter_username>ulrich.hobelmann</commenter_username>
            <when>2016-08-15 10:01:09 -0400</when>
            <comment_text>Additional stacktrace in Error Log, in case that helps.

java.lang.IllegalArgumentException: Comparison method violates its general contract!
	at java.util.TimSort.mergeHi(TimSort.java:899)
	at java.util.TimSort.mergeAt(TimSort.java:516)
	at java.util.TimSort.mergeForceCollapse(TimSort.java:457)
	at java.util.TimSort.sort(TimSort.java:254)
	at java.util.Arrays.sort(Arrays.java:1438)
	at org.eclipse.jface.viewers.ViewerComparator.sort(ViewerComparator.java:193)
	at org.eclipse.jface.viewers.AbstractTreeViewer.getSortedChildren(AbstractTreeViewer.java:644)
	at org.eclipse.jface.viewers.AbstractTreeViewer.updateChildren(AbstractTreeViewer.java:2633)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefreshStruct(AbstractTreeViewer.java:1913)
	at org.eclipse.jface.viewers.TreeViewer.internalRefreshStruct(TreeViewer.java:669)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefreshStruct(AbstractTreeViewer.java:1920)
	at org.eclipse.jface.viewers.TreeViewer.internalRefreshStruct(TreeViewer.java:669)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java:1888)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java:1845)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java:1831)
	at org.eclipse.jface.viewers.StructuredViewer.lambda$0(StructuredViewer.java:1519)
	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1458)
	at org.eclipse.jface.viewers.TreeViewer.preservingSelection(TreeViewer.java:354)
	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1419)
	at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1519)
	at org.eclipse.jface.viewers.ColumnViewer.refresh(ColumnViewer.java:523)
	at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1478)
	at org.eclipse.jdt.internal.ui.text.JavaOutlineInformationControl$OutlineContentProvider.toggleShowInheritedMembers(JavaOutlineInformationControl.java:301)
	at org.eclipse.jdt.internal.ui.text.JavaOutlineInformationControl.toggleShowInheritedMembers(JavaOutlineInformationControl.java:682)
	at org.eclipse.jdt.internal.ui.text.JavaOutlineInformationControl$1.keyPressed(JavaOutlineInformationControl.java:668)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:168)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5219)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1340)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1366)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1349)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1378)
	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:764)
	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:3457)
	at org.eclipse.swt.widgets.Text.gtk_key_press_event(Text.java:1869)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2000)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:5819)
	at org.eclipse.swt.widgets.Text.windowProc(Text.java:2896)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5490)
	at org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(Native Method)
	at org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:9545)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1275)
	at org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method)
	at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:2495)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4141)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:687)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)</comment_text>
        </comment>
        <comment>
            <comment_id>2740122</comment_id>
            <comment_count>2</comment_count>
            <who>Ulrich Hobelmann</who>
            <commenter_username>ulrich.hobelmann</commenter_username>
            <when>2016-08-15 10:06:11 -0400</when>
            <comment_text>(The guava version is a very old 11.0.2-atlassian-02 version that is bundled with JIRA 6.4. Current versions may have quite different classes, methods or hierarchies.)</comment_text>
        </comment>
        <comment>
            <comment_id>2740744</comment_id>
            <comment_count>3</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-08-17 03:42:11 -0400</when>
            <comment_text>(In reply to Ulrich Hobelmann from comment #2)
&gt; (The guava version is a very old 11.0.2-atlassian-02 version that is bundled
&gt; with JIRA 6.4. Current versions may have quite different classes, methods or
&gt; hierarchies.)

Can you always reproduce it with that?</comment_text>
        </comment>
        <comment>
            <comment_id>2740753</comment_id>
            <comment_count>4</comment_count>
            <who>Ulrich Hobelmann</who>
            <commenter_username>ulrich.hobelmann</commenter_username>
            <when>2016-08-17 04:02:44 -0400</when>
            <comment_text>Unfortunately no.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>509247</id>
        <developer>Olivier Thomann</developer>
        <developer_username>Olivier_Thomann</developer_username>
        <dup_id/>
        <creation_time>2016-12-14 14:29:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Cleaning up all warnings about try-with-resources</short_desc>
        <thetext>The patch I will attach cleans up all warnings about try-with-resources. I also noticed that the jar in jar loader code is still compiled using target 1.1 and source 1.3. Any reason for that when all Eclipse bundles now have EE 1.7 at least?</thetext>
        <comment>
            <comment_id>2786395</comment_id>
            <comment_count>1</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-14 14:31:01 -0500</when>
            <comment_text>Created attachment 265890
Proposed patch

Hopefully it can apply on master. I also have other changes in my workspace for the bug 508777. So if it does apply, I should apply once the gerrit review for bug 508777 is delivered.</comment_text>
        </comment>
        <comment>
            <comment_id>2786797</comment_id>
            <comment_count>2</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-12-15 13:28:57 -0500</when>
            <comment_text>Noopur might try to look at this but it's not a top priority at the moment as it does not bring any immediate benefit to our users.

In the meantime, please upload a Gerrit change instead of a patch. Thanks.

NOTE: The code in the 'jar in jar loader' must not be changed it needs to compile with
	source="1.3"
	target="1.1"</comment_text>
        </comment>
        <comment>
            <comment_id>2786827</comment_id>
            <comment_count>3</comment_count>
            <who>Olivier Thomann</who>
            <commenter_username>Olivier_Thomann</commenter_username>
            <when>2016-12-15 16:00:54 -0500</when>
            <comment_text>I will upload the gerrit change once the previous one is done to make sure they don't collide.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>488824</id>
        <developer>Stefan Snooc</developer>
        <developer_username>snooc</developer_username>
        <dup_id/>
        <creation_time>2016-03-02 03:49:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[package explorer] Make it possible to sort by file name in Java packages using Project/Package Explorer</short_desc>
        <thetext>I am using GWT where you have for views a .java file and a .ui.xml file. The problem is that Eclipse is sorting them like this:

AModule.java
APresenter.java
BModule.java
BPresenter.java
AView.ui.yml
BView.ui.xml

This is annoying as the project gets larger. It would be awesome if the files were sorted like this:

AModule.java
APresenter.java
AView.ui.yml
BModule.java
BPresenter.java
BView.ui.xml

I've asked if that is possible on stackoverflow but the only possibility so far is opening the Navigator for this but is it possible to add this feature to the Package / Project Explorer?

See my question on stackoverflow: http://stackoverflow.com/questions/35669324/eclipse-gwt-associate-ui-xml-with-corresponding-java-file/35739779#35739779</thetext>
        <comment>
            <comment_id>2678200</comment_id>
            <comment_count>1</comment_count>
            <who>Brian de Alwis</who>
            <commenter_username>bsd</commenter_username>
            <when>2016-03-02 20:58:03 -0500</when>
            <comment_text>That seems to be the JavaElementComparator, which sorts elements by category and then alphabetically.</comment_text>
        </comment>
        <comment>
            <comment_id>2678280</comment_id>
            <comment_count>2</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-03-03 03:53:37 -0500</when>
            <comment_text>The Navigator view offers this.</comment_text>
        </comment>
        <comment>
            <comment_id>2678665</comment_id>
            <comment_count>3</comment_count>
            <who>Stefan Snooc</who>
            <commenter_username>snooc</commenter_username>
            <when>2016-03-03 19:30:50 -0500</when>
            <comment_text>(In reply to Dani Megert from comment #2)
&gt; The Navigator view offers this.

Yes but the navigator cannot display projects hierarchically and also does not use the "Java Package" icon for the packages but instead just the "Folder" icon.</comment_text>
        </comment>
        <comment>
            <comment_id>2678666</comment_id>
            <comment_count>4</comment_count>
            <who>Stefan Snooc</who>
            <commenter_username>snooc</commenter_username>
            <when>2016-03-03 19:32:37 -0500</when>
            <comment_text>(In reply to Brian de Alwis from comment #1)
&gt; That seems to be the JavaElementComparator, which sorts elements by category
&gt; and then alphabetically.

Well, I am not familiar with the internals of Eclipse. ^^

All I can say is that this would make my life a little easier and that I am longing for this feature for quite a while. :)</comment_text>
        </comment>
    </bug>
    <bug>
        <id>505740</id>
        <developer>Andras Kerekes</developer>
        <developer_username>akerekes</developer_username>
        <dup_id/>
        <creation_time>2016-10-11 15:17:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>[render] Icon decoration for packages with restricted access</short_desc>
        <thetext>Created attachment 264786
icon decoration mock up for discouraged/forbidden packages

When a jar is added to the build path of a project and it has access rules defined that forbid/discourage the usage of some packages inside the jar, it'd be useful to put a decoration on the icon of the package in the package explorer to indicate that those packages are not forbidden/discouraged.

The attached mock-up shows what I'm thinking about.</thetext>
        <comment>
            <comment_id>2765753</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-10-12 11:50:11 -0400</when>
            <comment_text>I don't think this adds much value. More important is that you don't see types that are forbidden. You can also decide to hide discouraged types (see 'Type Filters' preference page).</comment_text>
        </comment>
        <comment>
            <comment_id>2765926</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-12 19:25:21 -0400</when>
            <comment_text>Could the deprecation strike-through be re-used for discouraged content?</comment_text>
        </comment>
        <comment>
            <comment_id>2766033</comment_id>
            <comment_count>3</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-10-13 06:09:55 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #2)
&gt; Could the deprecation strike-through be re-used for discouraged content?

No. Packages can also be deprecated, but we currently don't decorate them in the UI. Plus, there are two access restrictions: discouraged and forbidden.</comment_text>
        </comment>
        <comment>
            <comment_id>2766038</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-10-13 06:18:05 -0400</when>
            <comment_text>(In reply to Dani Megert from comment #3)
&gt; (In reply to Stephan Herrmann from comment #2)
&gt; &gt; Could the deprecation strike-through be re-used for discouraged content?
&gt; 
&gt; No. Packages can also be deprecated, but we currently don't decorate them in
&gt; the UI. Plus, there are two access restrictions: discouraged and forbidden.

I was thinking of filtering "forbidden" and decorating "discouraged". But I didn't think of deprecated packages, so that would be ambiguous...

Was it an active decision not to decorate deprecated packages? 
(Does deprecation of packages even happen in real life?)</comment_text>
        </comment>
        <comment>
            <comment_id>2766043</comment_id>
            <comment_count>5</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-10-13 06:22:52 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #4)
&gt; (In reply to Dani Megert from comment #3)
&gt; &gt; (In reply to Stephan Herrmann from comment #2)
&gt; &gt; &gt; Could the deprecation strike-through be re-used for discouraged content?
&gt; &gt; 
&gt; &gt; No. Packages can also be deprecated, but we currently don't decorate them in
&gt; &gt; the UI. Plus, there are two access restrictions: discouraged and forbidden.
&gt; 
&gt; I was thinking of filtering "forbidden" and decorating "discouraged". But I
&gt; didn't think of deprecated packages, so that would be ambiguous...
&gt; 
&gt; Was it an active decision not to decorate deprecated packages? 
&gt; (Does deprecation of packages even happen in real life?)

No, I don't think so. There was just no request so far.</comment_text>
        </comment>
        <comment>
            <comment_id>2766244</comment_id>
            <comment_count>6</comment_count>
            <who>Andras Kerekes</who>
            <commenter_username>akerekes</commenter_username>
            <when>2016-10-13 10:55:45 -0400</when>
            <comment_text>In my opinion the value of this enhancement is that:
 - if the package/class is forbidden it will not show up in code completion/Open Type/etc., but it's fully visible in the Package Explorer without any indication why it's excluded from the list of suggestions
 - similarly for discouraged packages/classes there's no indication in the Package Explorer about it's status

I often try to figure out which class to use by browsing the jars under project dependencies, and it would be helpful to immediately see which ones are accessible on which level.

Hiding discouraged types does not provide the same experience in my opinion.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>505978</id>
        <developer>Dennis Wagelaar</developer>
        <developer_username>dwagelaar</developer_username>
        <dup_id/>
        <creation_time>2016-10-14 08:51:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>UI freeze after extract local variable refactoring followed by an undo (building workspace)</short_desc>
        <thetext>What steps will reproduce the problem?
1. Refactor -&gt; Extract local variable on an expression. (don't save file)
2. Undo.
3. 


-- Error Details --
Date: Fri Oct 14 14:42:46 CEST 2016
Message: UI freeze of 14s at 14:42:31.741
Severity: Error
Product: Eclipse 4.6.1.20160912-1200 (org.eclipse.epp.package.jee.product)
Plugin: org.eclipse.ui.monitoring
Session Data:
eclipse.buildId=4.6.1.M20160907-1200
java.version=1.8.0_102
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\Users\dwage\workspace-cc\.metadata\.bak_0.log
Created Time: 2016-10-13 13:36:20.400


Further details in attachment (too long).</thetext>
        <comment>
            <comment_id>2766625</comment_id>
            <comment_count>1</comment_count>
            <who>Dennis Wagelaar</who>
            <commenter_username>dwagelaar</commenter_username>
            <when>2016-10-14 08:52:43 -0400</when>
            <comment_text>Created attachment 264857
Eclipse error log</comment_text>
        </comment>
        <comment>
            <comment_id>2766665</comment_id>
            <comment_count>2</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-10-14 09:51:04 -0400</when>
            <comment_text>(In reply to Dennis Wagelaar from comment #0)
&gt; What steps will reproduce the problem?
&gt; 1. Refactor -&gt; Extract local variable on an expression. (don't save file)
&gt; 2. Undo.

I can't reproduce it with those steps. Can you provide a complete example?</comment_text>
        </comment>
        <comment>
            <comment_id>2766692</comment_id>
            <comment_count>3</comment_count>
            <who>Dennis Wagelaar</who>
            <commenter_username>dwagelaar</commenter_username>
            <when>2016-10-14 10:17:31 -0400</when>
            <comment_text>Created attachment 264861
Entire eclipse error log

Eclipse is generally very slow when working on our CareConnect project, which is unfortunately closed source (www.careconnect.be). Eclipse is fast when working on org.eclipse.atl, for example. In LoC, ATL is similar in size as CareConnect:

- CareConnect: 719.174 LoC (private SonarQube measurement)
- ATL: 769.249 LoC (https://www.openhub.net/p/atl/analyses/latest/languages_summary)

The main differences between both projects are:
- CareConnect is a Maven project on top of JavaFX and Tomcat (m2eclipse, WTP)
- CareConnect uses JPA (hibernate)
- CareConnect uses JAX-RS
- CareConnect has &gt; 100 MB of maven dependencies (lots of bytecode on the classpath for Eclipse to go through)

I found the 14 second UI freeze reason enough to report this, even if I cannot be more specific (IntelliJ IDEA does not have these performance issues, for instance). In this case I did not even save my file, but I just wanted to undo a small refactoring (I had selected to small a sub-expression to extract to a local var, and wanted to extract a larger expression instead). Why did the UI have to block on a "building workspace"?</comment_text>
        </comment>
        <comment>
            <comment_id>2766697</comment_id>
            <comment_count>4</comment_count>
            <who>Dennis Wagelaar</who>
            <commenter_username>dwagelaar</commenter_username>
            <when>2016-10-14 10:18:42 -0400</when>
            <comment_text>Created attachment 264862
Output of maven dependency:tree</comment_text>
        </comment>
        <comment>
            <comment_id>2766700</comment_id>
            <comment_count>5</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-10-14 10:22:24 -0400</when>
            <comment_text>I'm sorry. Without more detailed steps we won't work on this.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506043</id>
        <developer>Marc-André Laperle</developer>
        <developer_username>marc-andre.laperle</developer_username>
        <dup_id/>
        <creation_time>2016-10-16 16:53:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Pasting Java snippet as new class doesn't follow code templates</short_desc>
        <thetext>Created attachment 264881
Test project

Using Neon.1

When copying a code snippet and pasting it in the Project explorer, it creates a class properly but doesn't apply the code template for a "New class". My use case is that I have the copyright header in the "New Class" template but in this case specially it doesn't.

1. Import attached project (it contains project-specific Code Template settings)
2. Copy the following code to the clipboard:
public class B {

}
3. In Package Explorer, click on testPackage package, then paste (Ctrl-V).

The file is created but it does not contain the copyright header.</thetext>
        <comment>
            <comment_id>2767110</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-10-17 03:43:15 -0400</when>
            <comment_text>We don't apply any changes to the pasted text (e.g. also no formatting or organize import.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499385</id>
        <developer>Brian de Alwis</developer>
        <developer_username>bsd</developer_username>
        <dup_id/>
        <creation_time>2016-08-08 17:28:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>Socket Listen mode should allow multiple connections</short_desc>
        <thetext>I'm working on some tooling for debugging a server framework that may launch new JVMs.  These JVMs can be configured with an "-Xrunjdwp:transport=dt_socket,server=n,address=XXX" string.  We're looking to create a launch configuration that uses the Socket Listen mode and will accept multiple connections.

There are two stumbling blocks:

First, org.eclipse.jdt.launching.SocketListenerConnector closes its listening socket immediately after accepting the first connection.

Second, although org.eclipse.jdt.internal.connect.SocketListeningConnectorImpl#supportsMultipleConnections() claims to support multiple connections, and org.eclipse.jdi.internal.connect.SocketTransportService would in theory accept multiple connections, the SocketTransportService maintains the newly-accepted socket and its I/O streams as fields rather than maintaining them in the corresponding SocketConnection object:

    try {
      fSocket = fServerSocket.accept();
    } catch (SocketTimeoutException e) {
      throw new TransportTimeoutException();
    }
    fInput = fSocket.getInputStream();
    fOutput = fSocket.getOutputStream();
    performHandshake(fInput, fOutput, handshakeTimeout);
    return new SocketConnection(this);

So in practice it can only accept a single connection at a time as all open connections 'share' the last connection's I/O streams.</thetext>
        <comment>
            <comment_id>2738350</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-08-08 23:20:10 -0400</when>
            <comment_text>Will you like to work on the multiple connection support ?

We will be ready to accept good quality patches but unfortunately we don't have resources to work on this right now.</comment_text>
        </comment>
        <comment>
            <comment_id>2738353</comment_id>
            <comment_count>2</comment_count>
            <who>Brian de Alwis</who>
            <commenter_username>bsd</commenter_username>
            <when>2016-08-08 23:30:02 -0400</when>
            <comment_text>Yes, I will contribute a patch for 4.7.  It's pretty straightforward.  I forked the necessary classes and have a working implementation at:

   https://github.com/GoogleCloudPlatform/gcloud-eclipse-tools/tree/wip-498/plugins/com.google.cloud.tools.eclipse.launching.jdt

A very superficial search didn't turn up any relevant tests.  If you have any pointers, please feel free.

For my proof of concept, I created a new IVMConnector.  For the real patch, I plan to merge this functionality into SocketListenConnector, conditioned on a "multiple" argument taking a boolean and defaulting to false.  It might be more flexible to use "count" with an integer, defaulting to 1, with 0 being unlimited?</comment_text>
        </comment>
        <comment>
            <comment_id>2738354</comment_id>
            <comment_count>3</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-08-08 23:37:21 -0400</when>
            <comment_text>(In reply to Brian de Alwis from comment #2)
&gt; Yes, I will contribute a patch for 4.7.  
  Great!!

&gt; 
&gt; A very superficial search didn't turn up any relevant tests.  

  I will suggest to add a test case to show multiple connections work after the changes are done.</comment_text>
        </comment>
        <comment>
            <comment_id>2743035</comment_id>
            <comment_count>4</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-08-23 23:22:58 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/79579</comment_text>
        </comment>
        <comment>
            <comment_id>2743419</comment_id>
            <comment_count>5</comment_count>
            <who>Brian de Alwis</who>
            <commenter_username>bsd</commenter_username>
            <when>2016-08-24 22:46:50 -0400</when>
            <comment_text>The patch updates the SocketListeningConnector and friends to take an additional integer parameter "acceptCount" to describe the number of incoming connections to accept.  The default value is 1 to mimic the current behaviour of accepting a single incoming connection.  A value of 0 means there is no limit and the connector will continue to listen until terminated.

The SocketListenConnectorProcess enhances the VM labels to indicate the time when the VM was accepted — it can be confusing to differentiate between several VMs.  This is only done if acceptCount != 1 to maintain previous behaviour.

The SocketListenConnectorProcess's waiting job is now marked as a system job as it was found to be distracting to see the wait job in the status bar's progress region.  The wait job is not really a user job per se.  The wait job is shown in the launch tree in the Debug view and can be terminated there.  It was not as distracting previously as the wait job was short-lived.

I'm currently create a Connector.Argument for "acceptCount" in org.eclipse.jdi.internal.connect.SocketListeningConnectorImpl.  This doesn't feel like the right place, since it's not actually used in SocketListeningConnectorImpl, but Connector.IntegerArgumentImpl is package protected and can't be created anywhere else.</comment_text>
        </comment>
        <comment>
            <comment_id>2744469</comment_id>
            <comment_count>6</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-08-29 01:14:28 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #4)
&gt; New Gerrit change created: https://git.eclipse.org/r/79579

Thanks for the contribution, Will be looking it for 4.7 M3 as M2 is quite packed.</comment_text>
        </comment>
        <comment>
            <comment_id>2768676</comment_id>
            <comment_count>7</comment_count>
            <who>Brian de Alwis</who>
            <commenter_username>bsd</commenter_username>
            <when>2016-10-20 09:14:53 -0400</when>
            <comment_text>Created attachment 264962
Connection properties for Socket Listen

The Remove Java Application connection properties area in the "Standard (Socket Listen)" case, as auto-generated from IVMConnector#getDefaultArguments().</comment_text>
        </comment>
        <comment>
            <comment_id>2768937</comment_id>
            <comment_count>8</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-21 06:56:15 -0400</when>
            <comment_text>I will be delivering the changes, Will create a bug to add the help content to describe "Connection limit".
Thanks for the effort.</comment_text>
        </comment>
        <comment>
            <comment_id>2768977</comment_id>
            <comment_count>9</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-21 08:37:38 -0400</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/79579 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.debug.git/commit/?id=ebfe95e17382c3a2558a69fe63ee325136ad866f</comment_text>
        </comment>
        <comment>
            <comment_id>2768980</comment_id>
            <comment_count>10</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-21 08:40:39 -0400</when>
            <comment_text>Released to 4.7.
Bug 506343 for tracking help related changes.</comment_text>
        </comment>
        <comment>
            <comment_id>2768994</comment_id>
            <comment_count>11</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-10-21 09:24:17 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/83684</comment_text>
        </comment>
        <comment>
            <comment_id>2768995</comment_id>
            <comment_count>12</comment_count>
            <who>Andrey Loskutov</who>
            <commenter_username>loskutov</commenter_username>
            <when>2016-10-21 09:24:52 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #11)
&gt; New Gerrit change created: https://git.eclipse.org/r/83684

Please integrate this patch to fix compile errors introduced by previous one.</comment_text>
        </comment>
        <comment>
            <comment_id>2769102</comment_id>
            <comment_count>13</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-21 13:36:41 -0400</when>
            <comment_text>(In reply to Andrey Loskutov from comment #12)
&gt; (In reply to Eclipse Genie from comment #11)
&gt; &gt; New Gerrit change created: https://git.eclipse.org/r/83684
&gt; 
&gt; Please integrate this patch to fix compile errors introduced by previous one.

Thanks for the quick notice.
http://git.eclipse.org/c/jdt/eclipse.jdt.debug.git/commit/?id=137dca5398f3952e224d2f41bcce187bb10922f2</comment_text>
        </comment>
        <comment>
            <comment_id>2769744</comment_id>
            <comment_count>14</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-25 05:25:11 -0400</when>
            <comment_text>http://git.eclipse.org/c/jdt/eclipse.jdt.debug.git/commit/?id=59da8e481d3791dc69af40714a45aea00f478afd

Removed unnecessary "SuppressWarnings"</comment_text>
        </comment>
        <comment>
            <comment_id>2769769</comment_id>
            <comment_count>15</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-25 06:36:35 -0400</when>
            <comment_text>Verified using
Eclipse SDK

Version: Oxygen (4.7)
Build id: I20161024-2000</comment_text>
        </comment>
        <comment>
            <comment_id>2777955</comment_id>
            <comment_count>16</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-11-20 23:36:42 -0500</when>
            <comment_text>Seeing lot of VMDisconnected Exception in logs, change is in the same file but can't really figure out the reason. 

com.sun.jdi.VMDisconnectedException: Got IOException from Virtual Machine
	at org.eclipse.jdi.internal.connect.PacketSendManager.sendPacket(PacketSendManager.java:90)
	at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:187)
	at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:268)
	at org.eclipse.jdi.internal.VirtualMachineImpl.getVersionInfo(VirtualMachineImpl.java:1010)
	at org.eclipse.jdi.internal.VirtualMachineImpl.name(VirtualMachineImpl.java:930)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.initializeState(JDIDebugTarget.java:569)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.initialize(JDIDebugTarget.java:536)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.&lt;init&gt;(JDIDebugTarget.java:359)
	at org.eclipse.jdt.debug.core.JDIDebugModel$1.run(JDIDebugModel.java:201)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2240)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)
	at org.eclipse.jdt.debug.core.JDIDebugModel.newDebugTarget(JDIDebugModel.java:205)
	at org.eclipse.jdt.debug.core.JDIDebugModel.newDebugTarget(JDIDebugModel.java:152)
	at org.eclipse.jdt.internal.launching.SocketListenConnectorProcess$WaitForConnectionJob.run(SocketListenConnectorProcess.java:343)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:56)</comment_text>
        </comment>
        <comment>
            <comment_id>2778308</comment_id>
            <comment_count>17</comment_count>
            <who>Brian de Alwis</who>
            <commenter_username>bsd</commenter_username>
            <when>2016-11-21 12:44:05 -0500</when>
            <comment_text>Does this happen all of the time, Sarika?  Do you see this at the start of a debugging session, or at the end?

It sounds like the waitForConnectionJob is rescheduled after the socket has been closed.

Hmm: there's some subtle interplay between the SocketListenConnectorProcess and its underlying WaitForConnectionJob.  At the end of the WaitForConnectionJob we reschedule the job if we should continue listening (continueListening()).  continueListening() checks if the SocketListenConnectorProcess has been terminated and if we have reached out connectionLimit.

I suppose if the first accept was interrupted somehow, then fAccepted may not have been incremented.  And if the SocketListenConnectorProcess hasn't been terminated, then we may reschedule the job.

I think continueListening() should be checking whether the process is terminated and if the job was told to stopListening().

--- a/org.eclipse.jdt.launching/launching/org/eclipse/jdt/internal/launching/SocketListenConnectorProcess.java
+++ b/org.eclipse.jdt.launching/launching/org/eclipse/jdt/internal/launching/SocketListenConnectorProcess.java
@@ -104,7 +129,9 @@ public class SocketListenConnectorProcess implements IProcess {
                        }
                        @Override
                        public void done(IJobChangeEvent event) {
-                               if (event.getResult().equals(Status.CANCEL_STATUS)){
+                               if (event.getResult().isOK() &amp;&amp; continueListening()) {
+                                       fWaitForConnectionJob.schedule();
+                               } else {
                                        try{
                                                terminate();
                                        } catch (DebugException e){}


@@ -115,6 +142,13 @@ public class SocketListenConnectorProcess implements IProce
ss {
        }
 
        /**
+        * Return true if this connector should continue listening for further connections.
+        */
+       protected boolean continueListening() {
+               return !isTerminated() &amp;&amp; (fConnectionLimit &lt;= 0 || fConnectionLimit - fAccepted &gt; 0);
+       }
+
+       /**
         * Returns an error status using the passed parameters.
         * 
         * @param message the status message</comment_text>
        </comment>
        <comment>
            <comment_id>2778309</comment_id>
            <comment_count>18</comment_count>
            <who>Brian de Alwis</who>
            <commenter_username>bsd</commenter_username>
            <when>2016-11-21 12:46:51 -0500</when>
            <comment_text>I don't see these stack traces in my logs.</comment_text>
        </comment>
        <comment>
            <comment_id>2778312</comment_id>
            <comment_count>19</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-21 12:51:57 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85425</comment_text>
        </comment>
        <comment>
            <comment_id>2778313</comment_id>
            <comment_count>20</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-21 12:51:57 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85425</comment_text>
        </comment>
        <comment>
            <comment_id>2778415</comment_id>
            <comment_count>21</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-21 22:48:27 -0500</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/85425 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.debug.git/commit/?id=df96dbe2c92dcdb7393b9b9947cdee0024493461</comment_text>
        </comment>
        <comment>
            <comment_id>2778417</comment_id>
            <comment_count>22</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-11-21 22:50:08 -0500</when>
            <comment_text>As the gerrit build was failing, have modified the patch a bit and release to to see the impact on logs.
I also don't get these message during my local testing but on Test machines they are consistent.</comment_text>
        </comment>
        <comment>
            <comment_id>2780895</comment_id>
            <comment_count>23</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-11-29 05:02:07 -0500</when>
            <comment_text>I still see them failing.</comment_text>
        </comment>
        <comment>
            <comment_id>2782289</comment_id>
            <comment_count>24</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-12-02 07:03:53 -0500</when>
            <comment_text>Brian, any idea to solve this issue ? As it is failing continuously daily.
I have seen them failing locally as well.</comment_text>
        </comment>
        <comment>
            <comment_id>2782408</comment_id>
            <comment_count>25</comment_count>
            <who>Brian de Alwis</who>
            <commenter_username>bsd</commenter_username>
            <when>2016-12-02 11:56:26 -0500</when>
            <comment_text>Sarika, can you point me to some of the logs?</comment_text>
        </comment>
        <comment>
            <comment_id>2782752</comment_id>
            <comment_count>26</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-12-05 04:19:53 -0500</when>
            <comment_text>(In reply to Brian de Alwis from comment #25)
&gt; Sarika, can you point me to some of the logs?

http://download.eclipse.org/eclipse/downloads/drops4/I20161204-2000/testresults/ep47I-unit-win32_win32.win32.x86_8.0/org.eclipse.jdt.debug.tests.AutomatedSuite.txt</comment_text>
        </comment>
        <comment>
            <comment_id>2786423</comment_id>
            <comment_count>27</comment_count>
            <who>Brian de Alwis</who>
            <commenter_username>bsd</commenter_username>
            <when>2016-12-14 16:29:45 -0500</when>
            <comment_text>I just saw this for the first time in the debugger.</comment_text>
        </comment>
        <comment>
            <comment_id>2786891</comment_id>
            <comment_count>28</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-12-16 00:32:27 -0500</when>
            <comment_text>It is consistently failing on Windows ( on others OS randomly), so if you could look at it priority, it will help.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>490724</id>
        <developer>Markus Keller</developer>
        <developer_username>markus_keller</developer_username>
        <dup_id/>
        <creation_time>2016-03-30 15:32:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[1.5][compiler] Compilation of 1.3 source against 1.5 classfile aborts on reference to member type of parameterized type</short_desc>
        <thetext>master, broken at least back to 4.4.1

// compile with JavaSE-1.8:
package p18;
public class Klass&lt;T&gt; {
	class MethodInfo { }
	void addMethod(MethodInfo mi) { }
}

// compile with J2SE-1.3, in a project that has the above class on build path:
package p13;
public final class J13 {
	p18.Klass c; 
}


Result:

Error in /J13/src/p13/J13.java: The class file Klass&lt;T&gt; contains a signature '(Lp18/Klass&lt;TT;&gt;.MethodInfo;)V' ill-formed at position 17


To debug, set a breakpoint at SignatureWrapper.computeEnd() line: 84
with condition:
    toString().startsWith("(Lp18/Klass&lt;TT;&gt;.MethodInfo;)V")


Analysis:

The problem is that SignatureWrapper#computeEnd() assumes that type arguments in angle brackets always introduce the end of a type signature. It that were true, skipAngleContents(..) would work fine. But in this case, a nested type name follows. The compound type name is no longer a subsequence of the generic signature, but it picks multiple non-contiguous subsequences ("Klass", "MethodInfo").

This bug cannot be resolved by a simple change in SignatureWrapper#computeEnd(). It will also need fixes in callers of that method. In this case in LookupEnvironment#getTypeFromTypeSignature(..).</thetext>
        <comment>
            <comment_id>2688627</comment_id>
            <comment_count>1</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-03-30 15:36:47 -0400</when>
            <comment_text>This bug blocks compilation of 1.3 code against an upcoming version of the IBM Java SDK.</comment_text>
        </comment>
        <comment>
            <comment_id>2688718</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-03-31 00:11:13 -0400</when>
            <comment_text>(In reply to Markus Keller from comment #0)
&gt; This bug cannot be resolved by a simple change in
&gt; SignatureWrapper#computeEnd(). It will also need fixes in callers of that
&gt; method. In this case in LookupEnvironment#getTypeFromTypeSignature(..).

Hmm.. there are as many as 32 references to the SignatureWrapper in over a dozen distinct places. Some of them directly looking for '&gt;'.</comment_text>
        </comment>
        <comment>
            <comment_id>2689256</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-01 00:35:49 -0400</when>
            <comment_text>Trying to understand the code and figured that we use the same instance of SignatureWrapper to extract type names over multiple iterations. We never alter the signature (of course) and wherever necessary, we simply ignore certain parts. For e.g. the generic information in our case. But looks like we might have to depart from that approach.

Consider this case:

(Lp18/Klass&lt;TT;&gt;.MethodInfo&lt;Ljava/lang/String;&gt;.InnerMethodInfo&lt;Ljava/lang/String;&gt;;)V @ 84

Even if the computeEnd() scans beyond the '.' and returns the full type signature, we are having trouble further down with the java/lang/String because we try to split on'/'.

Stephan/Markus, do you see any problem with completely getting rid of the generics information from the signature? For the above case, we would end up with:

(Lp18/Klass.MethodInfo.InnerMethodInfo;)V @ 84</comment_text>
        </comment>
        <comment>
            <comment_id>2689363</comment_id>
            <comment_count>4</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-04-01 05:31:42 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/69689</comment_text>
        </comment>
        <comment>
            <comment_id>2689366</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-01 05:34:50 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #4)
&gt; New Gerrit change created: https://git.eclipse.org/r/69689

So, I went ahead with that idea I spoke of (removing the generic information from the type name part of the signature) and posted the patch. But I still keep the type parameter upfront for resolution of method parameters, return type etc. I am more comfortable with this patch because this effectively applies the fix to all clients of SignatureWrapper. Touching the myriad uses of the said class seems like trouble to me. But like I said, it is possible I overlooked something, so please take a look at.

All existing tests pass locally.</comment_text>
        </comment>
        <comment>
            <comment_id>2689509</comment_id>
            <comment_count>6</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-04-01 09:56:58 -0400</when>
            <comment_text>The difficulty is with code that accesses the public field SignatureWrapper#signature. I made a pass over all references and didn't spot anything that would assume that the SignatureWrapper retains type arguments.

I've fixed the name of the new method and cleaned up some Javadoc and implementation problems.

Verified that the fix fixes comment 0 and the original scenario from which I extracted that test case.

Remaining TODO: Move the test into a compiler test.

The ReconcilerTests#testBug490724() passes even without the fix in SignatureWrapper. This confirms what I see in the IDE: The reconciler doesn't report this problem. The reconciler is entirely source-based. But the compiler compiles against class files, and that's where we're getting in trouble.

The difference is here, where the answer for the compiler is the binary type of p18/Klass, but the answer for the reconciler is a source type, and that one doesn't need to parse the signature from the class file:

LookupEnvironment.askForType(PackageBinding, char[]) line: 180	
PackageBinding.getTypeOrPackage(char[]) line: 201	
MethodScope(Scope).getPackage(char[][]) line: 2879	
QualifiedTypeReference.getTypeBinding(Scope) line: 97	
QualifiedTypeReference(TypeReference).internalResolveType(Scope, int) line: 495	
QualifiedTypeReference(TypeReference).resolveType(BlockScope, boolean, int) line: 586	
QualifiedTypeReference(TypeReference).resolveType(BlockScope, boolean) line: 582	
SourceTypeBinding.resolveTypeFor(FieldBinding) line: 1759	
SourceTypeBinding.fields() line: 934	
SourceTypeBinding.internalFaultInTypeForFieldsAndMethods() line: 903	
SourceTypeBinding.faultInTypesForFieldsAndMethods() line: 899	
CompilationUnitScope.faultInTypes() line: 448	
Compiler.process(CompilationUnitDeclaration, int) line: 854	
ProcessTaskManager.run() line: 141	
Thread.run() line: 745</comment_text>
        </comment>
        <comment>
            <comment_id>2689668</comment_id>
            <comment_count>7</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-01 13:27:58 -0400</when>
            <comment_text>(In reply to Markus Keller from comment #6)
&gt; I've fixed the name of the new method and cleaned up some Javadoc and
&gt; implementation problems.
&gt; 
&gt; Verified that the fix fixes comment 0 and the original scenario from which I
&gt; extracted that test case.

Thanks Markus, the changes look good to me.

&gt; Remaining TODO: Move the test into a compiler test.
&gt; 
&gt; The ReconcilerTests#testBug490724() passes even without the fix in
&gt; SignatureWrapper. This confirms what I see in the IDE: The reconciler
&gt; doesn't report this problem. The reconciler is entirely source-based. But
&gt; the compiler compiles against class files, and that's where we're getting in
&gt; trouble.

My bad. I assumed this was an issue in the reconciler as well since the original bug that introduced/surfaced this (bug 324850) had tests in reconciler. I will move the new test.</comment_text>
        </comment>
        <comment>
            <comment_id>2689768</comment_id>
            <comment_count>8</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-04-01 22:49:19 -0400</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/69689 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=2591e7dafb5fe2d67f8808853a52c3c718d48679</comment_text>
        </comment>
        <comment>
            <comment_id>2689769</comment_id>
            <comment_count>9</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-01 22:53:14 -0400</when>
            <comment_text>Thanks Markus, I have released the fix now.</comment_text>
        </comment>
        <comment>
            <comment_id>2692442</comment_id>
            <comment_count>10</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-04-08 17:26:41 -0400</when>
            <comment_text>This fix revealed another problem, see bug 491354. Make sure any backport includes both changes.</comment_text>
        </comment>
        <comment>
            <comment_id>2700162</comment_id>
            <comment_count>11</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-04-27 05:32:12 -0400</when>
            <comment_text>Verified for Neon M7 using I20160426-1615 build</comment_text>
        </comment>
        <comment>
            <comment_id>2729288</comment_id>
            <comment_count>12</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-07-11 09:09:20 -0400</when>
            <comment_text>.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>506888</id>
        <developer>Dani Megert</developer>
        <developer_username>daniel_megert</developer_username>
        <dup_id/>
        <creation_time>2016-11-02 07:08:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Unused @SuppressWarnings("incomplete-switch") not reported</short_desc>
        <thetext>I20161027-0700.

Unused @SuppressWarnings("incomplete-switch") is not reported.


Paste the following code into the Package Explorer:

	@SuppressWarnings("incomplete-switch")
	public void test1() {
	}

	@SuppressWarnings("unused")
	public void test2() {
	}

Everything looks good so far.

Now, replace the org.eclipse.jdt.core.prefs settings file with the attached one. The warnings will now be errors (expected).

Now set the 'Switch is missing default case' to 'Ignore'
==&gt; Bug: the first error is no longer shown.


NOTE: The strange thing is that I can't reproduce by manually setting the unused suppressWarnings to 'Error'. There must be something in the settings that's causing this.</thetext>
        <comment>
            <comment_id>2772184</comment_id>
            <comment_count>1</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-02 07:09:17 -0400</when>
            <comment_text>Created attachment 265154
jdt.core settings</comment_text>
        </comment>
        <comment>
            <comment_id>2772523</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-03 03:24:30 -0400</when>
            <comment_text>Same with @SuppressWarnings("fallthrough") and switch case fall-through combination.</comment_text>
        </comment>
        <comment>
            <comment_id>2772625</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-03 08:05:50 -0400</when>
            <comment_text>The missing default error is grouped with incompleteEnumSwitch and in the attached pref file, it is set to "ignored". Looking at the code, if option is ignored, then the unused @SuppressWarnings("incomplete-switch") is not reported.

This can be observed by manually by changing the option from ignored to warning.</comment_text>
        </comment>
        <comment>
            <comment_id>2772666</comment_id>
            <comment_count>4</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-03 09:59:00 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #3)
&gt; The missing default error is grouped with incompleteEnumSwitch

And we agree that this is wrong, right?</comment_text>
        </comment>
        <comment>
            <comment_id>2772704</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-03 11:08:59 -0400</when>
            <comment_text>To be sure we speak of the same things:

IProblem constants include:
  MissingEnumConstantCase
  MissingEnumConstantCaseDespiteDefault
  MissingEnumDefaultCase
  MissingDefaultCase

These are grouped to irritants (publicly configurable options):

  case IProblem.MissingEnumConstantCase :
  case IProblem.MissingEnumConstantCaseDespiteDefault :
	return CompilerOptions.MissingEnumConstantCase;

  case IProblem.MissingDefaultCase :
  case IProblem.MissingEnumDefaultCase :
	return CompilerOptions.MissingDefaultCase;

both irritants are mapped to the same warning token (for @SW):
  case MissingEnumConstantCase :
  case MissingDefaultCase :
	return "incomplete-switch";

This follows our general strategy to reduce the number of options at each stage.

What exactly should be wrong here?


When we map the above to the CLI, things are a bit more convoluted:

  enumSwitch: 
    OPTION_ReportIncompleteEnumSwitch
    irritant MissingEnumConstantCase

  enumSwitchPedantic: 
    OPTION_ReportIncompleteEnumSwitch | OPTION_ReportMissingEnumCaseDespiteDefault
    irritant MissingEnumConstantCase + extra flag in CompilerOptions

  switchDefault:
    OPTION_ReportMissingDefaultCase
    irritant MissingDefaultCase
    

Inconsistency: CLI can distinguish OPTION_ReportMissingEnumCaseDespiteDefault, which is not covered by any irritant / @SW-token (I do take blame for the convolution around 'enumSwitchPedantic' :-/, see also bug 374605).

Interestingly, CLI is more fine grained here than warning tokens.</comment_text>
        </comment>
        <comment>
            <comment_id>2772708</comment_id>
            <comment_count>6</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-03 11:16:14 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #5)

I am looking at this as a user and as such, looking at the empty #test1, @SuppressWarnings("incomplete-switch") is clearly unused. I'm not going to argue where the bug in JDT Core is or how a fix would look like ;-).</comment_text>
        </comment>
        <comment>
            <comment_id>2772724</comment_id>
            <comment_count>7</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-03 11:41:31 -0400</when>
            <comment_text>What exactly is the user's expectation?

Compiler perspective:

- if you are interested in 'Switch is missing default case' then 
  @SW("incomplete-switch") can be used to suppress individual warnings.
  Any unused @SW("incomplete-switch") will be flagged.

- the same if 'Incomplete switch case on Enum' is enabled

- if none of these options are enabled, the corresponding @SW token is
  pointless. Consequently, we cannot flag @SW("incomplete-switch") as
  unused because we simply didn't perform any analysis in this topic,
  so we don't know whether it would be used or unused when the option
  were enabled.
  Put differently: we don't want to report more warnings just because the
  user disabled a warning.</comment_text>
        </comment>
        <comment>
            <comment_id>2772747</comment_id>
            <comment_count>8</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-03 12:45:55 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #7)
&gt; - if none of these options are enabled, the corresponding @SW token is
&gt;   pointless. Consequently, we cannot flag @SW("incomplete-switch") as
&gt;   unused because we simply didn't perform any analysis in this topic,
&gt;   so we don't know whether it would be used or unused when the option
&gt;   were enabled.
&gt;   Put differently: we don't want to report more warnings just because the
&gt;   user disabled a warning.

If there's not going to be a warning what is the need to suppress it? Why do we want to differentiate between "absence of the culprit code" and "absence of the relevant option"?</comment_text>
        </comment>
        <comment>
            <comment_id>2772755</comment_id>
            <comment_count>9</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-03 13:26:02 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #8)
&gt; (In reply to Stephan Herrmann from comment #7)
&gt; &gt; - if none of these options are enabled, the corresponding @SW token is
&gt; &gt;   pointless. Consequently, we cannot flag @SW("incomplete-switch") as
&gt; &gt;   unused because we simply didn't perform any analysis in this topic,
&gt; &gt;   so we don't know whether it would be used or unused when the option
&gt; &gt;   were enabled.
&gt; &gt;   Put differently: we don't want to report more warnings just because the
&gt; &gt;   user disabled a warning.
&gt; 
&gt; If there's not going to be a warning what is the need to suppress it? Why do
&gt; we want to differentiate between "absence of the culprit code" and "absence
&gt; of the relevant option"?

Here's what Ed W. and Philipe discussed on these matters 9 years ago: bug 210213

On a technical level, the interaction between ProblemHandler.handle(), ProblemHandler.record() and CompilationUnitDeclaration.finalizeProblems() is not capable of detecting if a suppressed warning *would* be raised if it had been enabled, but isn't (disabled problems are never recorded).

In particular for annotation-based null analysis, the current contract is: if you disable it, it should not run at all (e.g., to avoid bugs in the analysis). If it is not run, we cannot decide if @SW("null") is used or not.


From a user's p.o.v. my understanding is: if I have @SW("something") in my code (for good reasons), and if for some other reason at some point in time I or s.o. else doesn't wan't to see *any* "something" problems in the code and therefore  (temporarily?) disables that analysis, this person surely doesn't want to see lots of "unused @SW". In other context (=compiling with original compiler options) the @SW is still needed.
As said: when disabling a warning results in more warnings being reported, users will be confused.

However, I see the point that we miss a chance to get rid of @SW's that will never be used. Sounds like a trade-off to me, unless we invent '[ ] report unused @SW for problems that are not being analysed' (and how do you suppress this? sounds like the entrance to infinite recursion ... :p ).</comment_text>
        </comment>
        <comment>
            <comment_id>2772920</comment_id>
            <comment_count>10</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-04 05:20:01 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #8)
&gt; If there's not going to be a warning what is the need to suppress it? Why do
&gt; we want to differentiate between "absence of the culprit code" and "absence
&gt; of the relevant option"?

+2.

No user (that has no insights in our compiler) would expect that unused @SW depends on some other options. He just wants to see and most likely delete them.</comment_text>
        </comment>
        <comment>
            <comment_id>2773243</comment_id>
            <comment_count>11</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-04 19:47:01 -0400</when>
            <comment_text>I'm not sure I exactly understand what you are requesting.

We have two mechanisms for filtering problems: settings (E/W/I/I) and @SW. Can these two mechanisms be explained as a chain of two filters, one applied after the other? I hold that this would be the most intuitive way of precisely describing the semantics, but which one is first?

If we first apply settings, then @SW analysis no longer sees problems that are dropped due to Ignore settings. Hence for disabled options we don't know which @SW is used / unused. Hence this bug.

If, OTOH, we first apply @SW then we don't yet know if suppressing is allowed (because the problem might be configured as error and @SW may not be enabled for optional errors).


It must be something different from filtering, because neither of the possible orders of filtering produce the outcome you want.


Are you suggesting that an Ignore setting should *not* prevent the problem from being recorded? Should it make the problem only *invisible*?

If so, we can check if any given @SW finds an actual problem (visible or invisible).</comment_text>
        </comment>
        <comment>
            <comment_id>2773244</comment_id>
            <comment_count>12</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-04 19:51:49 -0400</when>
            <comment_text>A side effect of the proposed change seems to be: 

   disabling an warning cannot shortcut the corresponding analysis. 

For annotation-based null analysis alone this would be a HUGE change. E.g., would compilation at 1.8+ NEVER be allowed to directly use class TypeSystem, ALL must go through AnnotatableTypeSystem. This could also result in performance problems, i.e., compilation pays the price for annotation-aware type checking even when type annotations are not used. Etc.</comment_text>
        </comment>
        <comment>
            <comment_id>2773362</comment_id>
            <comment_count>13</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-06 11:08:47 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #11)
&gt; I'm not sure I exactly understand what you are requesting.

I want that if a user has this code:

	@SuppressWarnings("incomplete-switch")
	public void test1() {
	}

and enables to report unused @SuppressWarnings, that the expected problem is reported. Very simple. You still argue on the compiler level which is completely irrelevant for the user.</comment_text>
        </comment>
        <comment>
            <comment_id>2773369</comment_id>
            <comment_count>14</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-06 13:42:04 -0500</when>
            <comment_text>(In reply to Dani Megert from comment #13)
&gt; (In reply to Stephan Herrmann from comment #11)
&gt; &gt; I'm not sure I exactly understand what you are requesting.
&gt; 
&gt; I want that if a user has this code:
&gt; 
&gt; 	@SuppressWarnings("incomplete-switch")
&gt; 	public void test1() {
&gt; 	}
&gt; 
&gt; and enables to report unused @SuppressWarnings, that the expected problem is
&gt; reported. Very simple. You still argue on the compiler level which is
&gt; completely irrelevant for the user.

Do you only want us to solve this one single example?

Voila:
  if (methodDecl.toString().equals("@SuppressWarnings(\"incomplete-switch\")\n"+
	  "public void test1() {\n" +
	  "}\n"))
      report("Unused @SuppressWarnings");

or is it allowed to discuss how the two related / conflicting features
  - problem settings (E/W/I/I)
  - @SuppressWarnings
interact in general?


Seriously, I did my best to separate discussions about observable behaviour (comment 11) and implementation concerns (comment 12).

Much of my commenting aimed at showing that a naive implementation of the request will cause harm elsewhere. Should we deliver the naive implementation and wait for users to cry that we broke it??</comment_text>
        </comment>
        <comment>
            <comment_id>2773416</comment_id>
            <comment_count>15</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-06 17:08:55 -0500</when>
            <comment_text>(In reply to Dani Megert from comment #13)
&gt; (In reply to Stephan Herrmann from comment #11)
&gt; &gt; I'm not sure I exactly understand what you are requesting.
&gt; 
&gt; I want that if a user has this code:
&gt; 
&gt; 	@SuppressWarnings("incomplete-switch")
&gt; 	public void test1() {
&gt; 	}
&gt; 
&gt; and enables to report unused @SuppressWarnings, that the expected problem is
&gt; reported. Very simple. You still argue on the compiler level which is
&gt; completely irrelevant for the user.

Still puzzled where the misunderstanding may be rooted, I should state that I never intended to argue that keeping silent in this case is good. So please stop blaming me for ignoring a users' p.o.v.

I only tried to explain, that the current behaviour is the result of intentional design 9 years back (bug 210213), and that a better solution has to be based on understanding the rationale of that design - and then improving it.


The existing design ensures that we don't get "unused @SW" on
    @SuppressWarnings("incomplete-switch")
    public void test2(SomeEnum e) {
        switch (e) {
            // incomplete list of cases
        }
    }
*even* if the warning is already disabled via settings, and thus the @SW doesn't actually suppress anything.


My starting point was to ensure that this design is not broken by fixing this current bug. And that turns out to be more involved than we would like - involved both conceptually and technically.


Doesn't anybody agree that this discussion is necessary for designing a good fix here?</comment_text>
        </comment>
        <comment>
            <comment_id>2773424</comment_id>
            <comment_count>16</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-07 00:59:24 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #15)
&gt; Doesn't anybody agree that this discussion is necessary for designing a good
&gt; fix here?

I agree. Sorry for harping on the point about "from the programmer point of view", without getting the big picture.</comment_text>
        </comment>
        <comment>
            <comment_id>2773498</comment_id>
            <comment_count>17</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-07 05:31:11 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #16)
&gt; (In reply to Stephan Herrmann from comment #15)
&gt; &gt; Doesn't anybody agree that this discussion is necessary for designing a good
&gt; &gt; fix here?
&gt; 
&gt; I agree. Sorry for harping on the point about "from the programmer point of
&gt; view", without getting the big picture.

Yes, I agree too :-). I just wasn't sure whether you agree that the reported issue needs a fix.</comment_text>
        </comment>
        <comment>
            <comment_id>2773720</comment_id>
            <comment_count>18</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-07 11:39:56 -0500</when>
            <comment_text>Ok, back to the drawing board :)

I believe one root of confusion is the mismatch between "SuppressWarnings" and how we handle it:

Strictly speaking the compiler detects "problems". Problems only turn into warnings, if so configured in the settings.


We departed from a strict interpretation of SuppressWarnings when the option to suppress optional *errors* using SuppressWarnings was introduced.

Next, we silently extended the semantics to suppressing "Info" problems.

Bug 210213 could have extended this further to support @SW for "Ingore" problems.

Had bug 210213 been implemented in this way, then an @SW on a detected but disabled problem would indeed still be "used".

Instead, Philipe decided to just avoid checking if a @SW is used or not when a corresponding irritant is set to Ignore (to avoid false positives for the price of false negatives).


I *would* love to propose the following resolution:

- decide that we interpret @SW indeed as "suppress problem" (no matter if the problem is an error, warning, info or ignored).

- to emphasize the above, perhaps we should reverse the option
    "Suppress optional errors with '@SuppressWarnings'"
  to s.t. like
    "Make optional errors unsuppressable" (default enabled)
  this would harmonize with the notion that *all optional problems* can be
  suppressed - unless stated otherwise.  
  
- agree that suppressing an ignored problem is a relevant use of @SW.

Unfortunately, Idoubt that we can afford this solution in full size. Here I explicitly mean implementation concerns, so I will stop arguing for now :)



As an alternative resolution I *do* propose to introduce a new "Info" problem , when we detect:
- @SW("foo") is declared
- (some) problems in category "foo" are set to Ignore.

We could say s.t. like:
  Problems of category "foo" are not analysed (due to compiler settings ...)

If a user decides that the current compiler settings are mandatory for everybody, then @SW can be removed. Otherwise she can temporarily enable the corresponding problem and see if @SW is then used or unused.</comment_text>
        </comment>
        <comment>
            <comment_id>2773948</comment_id>
            <comment_count>19</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-08 01:59:31 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #18)
&gt; As an alternative resolution I *do* propose to introduce a new "Info"
&gt; problem , when we detect:
&gt; - @SW("foo") is declared
&gt; - (some) problems in category "foo" are set to Ignore.
&gt; 
&gt; We could say s.t. like:
&gt;   Problems of category "foo" are not analysed (due to compiler settings ...)
&gt; 
&gt; If a user decides that the current compiler settings are mandatory for
&gt; everybody, then @SW can be removed. Otherwise she can temporarily enable the
&gt; corresponding problem and see if @SW is then used or unused.

I like this. I can offer to work on this unless Stephan already has a prototype or something :)</comment_text>
        </comment>
        <comment>
            <comment_id>2774040</comment_id>
            <comment_count>20</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-08 04:50:01 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #19)
&gt; (In reply to Stephan Herrmann from comment #18)
&gt; &gt; As an alternative resolution I *do* propose to introduce a new "Info"
&gt; &gt; problem , when we detect:
&gt; &gt; - @SW("foo") is declared
&gt; &gt; - (some) problems in category "foo" are set to Ignore.
&gt; &gt; 
&gt; &gt; We could say s.t. like:
&gt; &gt;   Problems of category "foo" are not analysed (due to compiler settings ...)
&gt; &gt; 
&gt; &gt; If a user decides that the current compiler settings are mandatory for
&gt; &gt; everybody, then @SW can be removed. Otherwise she can temporarily enable the
&gt; &gt; corresponding problem and see if @SW is then used or unused.
&gt; 
&gt; I like this. I can offer to work on this unless Stephan already has a
&gt; prototype or something :)

Go ahead :)

I haven't prepared any code changes.

According to comment 3 you were already looking at the exact code location that this proposal is meant for.</comment_text>
        </comment>
        <comment>
            <comment_id>2774556</comment_id>
            <comment_count>21</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-09 05:10:36 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #19)
&gt; (In reply to Stephan Herrmann from comment #18)
&gt; &gt; As an alternative resolution I *do* propose to introduce a new "Info"
&gt; &gt; problem , when we detect:
&gt; &gt; - @SW("foo") is declared
&gt; &gt; - (some) problems in category "foo" are set to Ignore.
&gt; &gt; 
&gt; &gt; We could say s.t. like:
&gt; &gt;   Problems of category "foo" are not analysed (due to compiler settings ...)
&gt; &gt; 
&gt; &gt; If a user decides that the current compiler settings are mandatory for
&gt; &gt; everybody, then @SW can be removed. Otherwise she can temporarily enable the
&gt; &gt; corresponding problem and see if @SW is then used or unused.
&gt; 
&gt; I like this. 

I like the direction too, but the message must clearly mention which option(s) need to be enabled. Two Quick Fixes could be offered to remove the @SW and to enable the problem(s).</comment_text>
        </comment>
        <comment>
            <comment_id>2775873</comment_id>
            <comment_count>22</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-14 11:10:23 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/84989</comment_text>
        </comment>
        <comment>
            <comment_id>2775875</comment_id>
            <comment_count>23</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-14 11:28:52 -0500</when>
            <comment_text>(In reply to Eclipse Genie from comment #22)
&gt; New Gerrit change created: https://git.eclipse.org/r/84989

This is the simplest possible patch. Unfortunately, this doesn't tell the user which option needs to be enabled. What I am not sure is, what exactly do we tell the user about the option? The option description in the UI (which jdt.core is not aware of) or the option name, for e.g., org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation, which the user probably has no clue about?

What the fix could still do (but doesn't yet) is to pass the option ID as problem argument, which would be used by the second quick fix that Dani mentioned.</comment_text>
        </comment>
        <comment>
            <comment_id>2775879</comment_id>
            <comment_count>24</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-11-14 11:37:51 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #23)
&gt; (In reply to Eclipse Genie from comment #22)
&gt; &gt; New Gerrit change created: https://git.eclipse.org/r/84989
&gt; 
&gt; This is the simplest possible patch. Unfortunately, this doesn't tell the
&gt; user which option needs to be enabled. What I am not sure is, what exactly
&gt; do we tell the user about the option? The option description in the UI
&gt; (which jdt.core is not aware of

We do have a link from the problem (ID) to the UI option. For example, we mark the option in the UI when the user wants to configure it via problem hover.</comment_text>
        </comment>
        <comment>
            <comment_id>2775901</comment_id>
            <comment_count>25</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-14 13:21:23 -0500</when>
            <comment_text>Another problem I ran into while testing is this: The reporting of unused SuppressWarning is also grouped with the other "unused" problems categories. This means that the conditions to report the new "info" is never met. 

I.e., one of the following is always true:

1) the SuppressWarning is disabled, which means we don't care about SuppressWarning 
2) SuppressWarning is enabled, which means the at least one of the irritant that is mapped to @SW("unused") is turned on, which in turn means we can't possibly determine that the analysis is not done.</comment_text>
        </comment>
        <comment>
            <comment_id>2775931</comment_id>
            <comment_count>26</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-14 16:29:59 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #25)
&gt; Another problem I ran into while testing is this: The reporting of unused
&gt; SuppressWarning is also grouped with the other "unused" problems categories.
&gt; This means that the conditions to report the new "info" is never met. 
&gt; 
&gt; I.e., one of the following is always true:
&gt; 
&gt; 1) the SuppressWarning is disabled, which means we don't care about
&gt; SuppressWarning 
&gt; 2) SuppressWarning is enabled, which means the at least one of the irritant
&gt; that is mapped to @SW("unused") is turned on, which in turn means we can't
&gt; possibly determine that the analysis is not done.

I meant to propose checking the condition that *at least one* of the irritants is set to ignore - not that *all* irritants are set to ignore. See comment 18.

This opens the door for:
- some irritant is disabled
- the @SW is still needed for the sake of an enabled irritant.
In that case we should ideally not report the new info.</comment_text>
        </comment>
        <comment>
            <comment_id>2775986</comment_id>
            <comment_count>27</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-15 00:51:15 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #26)
&gt; I meant to propose checking the condition that *at least one* of the
&gt; irritants is set to ignore - not that *all* irritants are set to ignore. See
&gt; comment 18.

My bad. I guess the following thought made me take that approach:

  We will end up reporting an unused @SW warning and the new info together, if one of the irritants is set to warning and the other to ignore. Am I missing something? Or this is what you had in mind too?</comment_text>
        </comment>
        <comment>
            <comment_id>2776037</comment_id>
            <comment_count>28</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-15 04:03:03 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85033</comment_text>
        </comment>
        <comment>
            <comment_id>2776038</comment_id>
            <comment_count>29</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-15 04:03:06 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85033</comment_text>
        </comment>
        <comment>
            <comment_id>2776039</comment_id>
            <comment_count>30</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-15 04:03:07 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85033</comment_text>
        </comment>
        <comment>
            <comment_id>2776046</comment_id>
            <comment_count>31</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-15 04:19:05 -0500</when>
            <comment_text>(In reply to Eclipse Genie from comment #29)
&gt; New Gerrit change created: https://git.eclipse.org/r/85033

This is as per requirements stated in comment #18. The deliberate limitation in the patch is, only the first ignored irritant is reported. This is passed on to the UI via the problem arguments. And because we offer to fix the option severity, I feel it is not necessary to include the option description in the problem summary. Besides, it makes the summary longer than one might like.

(In reply to Eclipse Genie from comment #30)
&gt; New Gerrit change created: https://git.eclipse.org/r/85033

A draft patch for quick fixes that I used to test. Note that in cases like comment #27, there will be two suggestions (duplicated and should be eliminated) to remove the @SW token and two "configure severity" offers (as expected, one each for @SW and relevant irritant's option).

Noopur, when everyone is happy with the core patch, can I request you to take the UI patch forward?</comment_text>
        </comment>
        <comment>
            <comment_id>2776155</comment_id>
            <comment_count>32</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-11-15 08:49:17 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #31)
&gt; (In reply to Eclipse Genie from comment #30)
&gt; &gt; New Gerrit change created: https://git.eclipse.org/r/85033
&gt; 
&gt; A draft patch for quick fixes that I used to test. Note that in cases like
&gt; comment #27, there will be two suggestions (duplicated and should be
&gt; eliminated) to remove the @SW token and two "configure severity" offers (as
&gt; expected, one each for @SW and relevant irritant's option).
&gt; 
&gt; Noopur, when everyone is happy with the core patch, can I request you to
&gt; take the UI patch forward?

I haven't tried any of the patches yet. Regarding the duplicate quick fixes mentioned above, is it because we will have multiple problemIds at the same location? If so, it is a known wontfix issue - see bug 366645.

Also, it would be helpful to attach some examples which can be used to test this and write test cases for the quick fixes.</comment_text>
        </comment>
        <comment>
            <comment_id>2776161</comment_id>
            <comment_count>33</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-15 08:58:26 -0500</when>
            <comment_text>(In reply to Noopur Gupta from comment #32)
&gt; Also, it would be helpful to attach some examples which can be used to test
&gt; this and write test cases for the quick fixes.

The example in AnnotationTest#testBug506888a() is what I am talking about. The test case is:

public class X {
	@SuppressWarnings({"incomplete-switch"})
	void foo() {
	}
}

and

 CompilerOptions.OPTION_ReportUnusedWarningToken is set to WARNING/ERROR 

and at least one of 

 CompilerOptions.OPTION_ReportIncompleteEnumSwitch
 CompilerOptions.OPTION_ReportMissingDefaultCase

is set to IGNORE. This testcase will produce two problems on the @SW (comment #27).</comment_text>
        </comment>
        <comment>
            <comment_id>2776313</comment_id>
            <comment_count>34</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-15 13:58:50 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #27)
&gt; (In reply to Stephan Herrmann from comment #26)
&gt; &gt; I meant to propose checking the condition that *at least one* of the
&gt; &gt; irritants is set to ignore - not that *all* irritants are set to ignore. See
&gt; &gt; comment 18.
&gt; 
&gt; My bad. I guess the following thought made me take that approach:
&gt; 
&gt;   We will end up reporting an unused @SW warning and the new info together,
&gt; if one of the irritants is set to warning and the other to ignore. Am I
&gt; missing something? Or this is what you had in mind too?

I can't claim I had the full layout of the logic in front of me, when I proposed the new info :)

But after a little tweaking of your change (see patch set 3) I arrived at s.t. that looks good to me:

- the new logic should *replace* the key change from bug 210213
  i.e., no more "if options.isAnyEnabled(tokenIrritants)"

- give priority to the new info over an uncertain "@SW is unused"
  and never report both

- @SW("all") at any enclosing scope still rules/silences them all

WDYT?</comment_text>
        </comment>
        <comment>
            <comment_id>2776418</comment_id>
            <comment_count>35</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-16 02:15:21 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #34)
&gt; WDYT?

Sounds good, thanks!</comment_text>
        </comment>
        <comment>
            <comment_id>2778982</comment_id>
            <comment_count>36</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-23 02:18:50 -0500</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/84989 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=8b3b76d9e0df45554ba959021d798047877d1acc</comment_text>
        </comment>
        <comment>
            <comment_id>2779022</comment_id>
            <comment_count>37</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-23 04:07:25 -0500</when>
            <comment_text>Resolving.</comment_text>
        </comment>
        <comment>
            <comment_id>2779660</comment_id>
            <comment_count>38</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-11-24 08:32:15 -0500</when>
            <comment_text>(In reply to Eclipse Genie from comment #36)
&gt; Gerrit change https://git.eclipse.org/r/84989 was merged to [master].
&gt; Commit:
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
&gt; ?id=8b3b76d9e0df45554ba959021d798047877d1acc

This causes test failures in org.eclipse.jdt.ui.tests.quickfix.ModifierCorrectionsQuickFixTest

https://hudson.eclipse.org/platform/job/eclipse.jdt.ui-Gerrit/1015/</comment_text>
        </comment>
        <comment>
            <comment_id>2779853</comment_id>
            <comment_count>39</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-24 15:35:59 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85722</comment_text>
        </comment>
        <comment>
            <comment_id>2779855</comment_id>
            <comment_count>40</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-24 15:39:16 -0500</when>
            <comment_text>(In reply to Till Brychcy from comment #38)
&gt; (In reply to Eclipse Genie from comment #36)
&gt; &gt; Gerrit change https://git.eclipse.org/r/84989 was merged to [master].
&gt; &gt; Commit:
&gt; &gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
&gt; &gt; ?id=8b3b76d9e0df45554ba959021d798047877d1acc
&gt; 
&gt; This causes test failures in
&gt; org.eclipse.jdt.ui.tests.quickfix.ModifierCorrectionsQuickFixTest
&gt; 
&gt; https://hudson.eclipse.org/platform/job/eclipse.jdt.ui-Gerrit/1015/

Part one will be immediately fixed by https://git.eclipse.org/r/#/c/85033 (remove unnecessary @SW will be offered via a new IProblem).

After that remains a small problem in jdt.core, to the effect that the second expected quick fix is still not proposed: 
Method CompilerOptions.getIgnoredIrritant(IrritantSet) claims to answer just the first ignored irritant bit, but we actually work with bitsets here. As a result, CompilerOptions.optionKeyFromIrritant() doesn't find the corresponding key, to be passed to the jdt.ui side for the sake of it's new quick fix.

Once that's fixed, then the new quick fixes from https://git.eclipse.org/r/#/c/85033/ will make the failing tests pass again.</comment_text>
        </comment>
        <comment>
            <comment_id>2779860</comment_id>
            <comment_count>41</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-24 15:56:11 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #40)
&gt; After that remains a small problem in jdt.core, to the effect that the
&gt; second expected quick fix is still not proposed: 
&gt; Method CompilerOptions.getIgnoredIrritant(IrritantSet) claims to answer just
&gt; the first ignored irritant bit, but we actually work with bitsets here. As a
&gt; result, CompilerOptions.optionKeyFromIrritant() doesn't find the
&gt; corresponding key, to be passed to the jdt.ui side for the sake of it's new
&gt; quick fix.

A fix for this is coming in a minute. The test is the tricky part.</comment_text>
        </comment>
        <comment>
            <comment_id>2779866</comment_id>
            <comment_count>42</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-11-24 16:08:22 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #40)
&gt; Part one will be immediately fixed by https://git.eclipse.org/r/#/c/85033
&gt; (remove unnecessary @SW will be offered via a new IProblem).
&gt; 
&gt; After that remains a small problem in jdt.core, to the effect that the
&gt; second expected quick fix is still not proposed: 
&gt; Method CompilerOptions.getIgnoredIrritant(IrritantSet) claims to answer just
&gt; the first ignored irritant bit, but we actually work with bitsets here. As a
&gt; result, CompilerOptions.optionKeyFromIrritant() doesn't find the
&gt; corresponding key, to be passed to the jdt.ui side for the sake of it's new
&gt; quick fix.
&gt; 
&gt; Once that's fixed, then the new quick fixes from
&gt; https://git.eclipse.org/r/#/c/85033/ will make the failing tests pass again.


(In reply to Eclipse Genie from comment #39)
&gt; New Gerrit change created: https://git.eclipse.org/r/85722
OK, I'll abandons this.</comment_text>
        </comment>
        <comment>
            <comment_id>2779890</comment_id>
            <comment_count>43</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-24 17:53:23 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85727</comment_text>
        </comment>
        <comment>
            <comment_id>2779891</comment_id>
            <comment_count>44</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-24 17:56:25 -0500</when>
            <comment_text>(In reply to Eclipse Genie from comment #43)
&gt; New Gerrit change created: https://git.eclipse.org/r/85727

Wow, this stirred up a bit more dust than expected:

After fixing CompilerOptions.getIgnoredIrritant(IrritantSet) several tests failed, signalling the new INFO where "unused @SW" was expected. 

I compensated for this, by setting all warnings of the respective group ("unused", "null" or "resource") to warning.

Still UnusedDeclaredThrownException caused trouble, because in optionKeyFromIrritant() it was incorrectly mapped to OPTION_ReportUnusedDeclaredThrownExceptionWhenOverriding, which however is not a E/W/I/I option, but a boolean sub-option. CompilerInvocationTests even expected this wrong mapping. When this was introduced in bug 163194 focus was on s.t. else, so I doubt it was done by intention.

Next, MissingNonNullByDefaultAnnotation was raised in some tests, which I then opportunistically excluded from this entire game. First, this warning doesn't necessarily have a location for suppressing it (if no package-info.java exists). Second, I simply don't believe that s.o. enabling this warning then wants to suppress it. Conversely, it's an option that many folks keep disabled, even when they are keen on null warnings. Including it in the new logic would mean that all these folks will see the new INFO instead of "unused @SW".

Finally a new test checks for the newly passed problem argument.</comment_text>
        </comment>
        <comment>
            <comment_id>2779927</comment_id>
            <comment_count>45</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-25 01:29:13 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #40)
&gt; After that remains a small problem in jdt.core, to the effect that the
&gt; second expected quick fix is still not proposed: 
&gt; Method CompilerOptions.getIgnoredIrritant(IrritantSet) claims to answer just
&gt; the first ignored irritant bit, but we actually work with bitsets here. As a
&gt; result, CompilerOptions.optionKeyFromIrritant() doesn't find the
&gt; corresponding key, to be passed to the jdt.ui side for the sake of it's new
&gt; quick fix.

Thanks for the analysis and the patches. My bad.

In hindsight, this was more work than what we would have wanted :)</comment_text>
        </comment>
        <comment>
            <comment_id>2780237</comment_id>
            <comment_count>46</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-25 17:13:07 -0500</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/85727 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=d4a42e338d4b7a3675ded36e4f113e216c85af03</comment_text>
        </comment>
        <comment>
            <comment_id>2780238</comment_id>
            <comment_count>47</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-25 17:18:56 -0500</when>
            <comment_text>(In reply to Eclipse Genie from comment #46)
&gt; Gerrit change https://git.eclipse.org/r/85727 was merged to [master].
&gt; Commit:
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=d4a42e338d4b7a3675ded36e4f113e216c85af03
&gt; 

Released this second part for 4.6 M4, see comment 40 &amp; comment 44

(In reply to Jay Arthanareeswaran from comment #45)
&gt; In hindsight, this was more work than what we would have wanted :)

:)

and this was the tiny, tiny solution compared to the alternatives we had!</comment_text>
        </comment>
        <comment>
            <comment_id>2780276</comment_id>
            <comment_count>48</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-26 06:27:49 -0500</when>
            <comment_text>(In reply to Till Brychcy from comment #38)
&gt; (In reply to Eclipse Genie from comment #36)
&gt; &gt; Gerrit change https://git.eclipse.org/r/84989 was merged to [master].
&gt; &gt; Commit:
&gt; &gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
&gt; &gt; ?id=8b3b76d9e0df45554ba959021d798047877d1acc
&gt; 
&gt; This causes test failures in
&gt; org.eclipse.jdt.ui.tests.quickfix.ModifierCorrectionsQuickFixTest
&gt; 
&gt; https://hudson.eclipse.org/platform/job/eclipse.jdt.ui-Gerrit/1015/

After rebase https://git.eclipse.org/r/#/c/85033/ still failed.
Reason: yesterday's IBuild failed, so hudson still used I20161124-2000 :(

I'll keep trying...</comment_text>
        </comment>
        <comment>
            <comment_id>2780283</comment_id>
            <comment_count>49</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-26 06:57:35 -0500</when>
            <comment_text>FYI: I just proposed bug 508228 in JDT/UI.</comment_text>
        </comment>
        <comment>
            <comment_id>2780780</comment_id>
            <comment_count>50</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-28 18:22:49 -0500</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/85033 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=d528dbc1af351a5a7f89693cffcca207b027b637</comment_text>
        </comment>
        <comment>
            <comment_id>2780781</comment_id>
            <comment_count>51</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-28 18:25:07 -0500</when>
            <comment_text>(In reply to Eclipse Genie from comment #50)
&gt; Gerrit change https://git.eclipse.org/r/85033 was merged to [master].
&gt; Commit:
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=d528dbc1af351a5a7f89693cffcca207b027b637
&gt; 

The changes in Core finally became visible for UI builds.
=&gt; Released the UI part for 4.6 M4 to resolve the test failures (comment 38).</comment_text>
        </comment>
        <comment>
            <comment_id>2781197</comment_id>
            <comment_count>52</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-11-29 16:13:35 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #51)
&gt; 
&gt; The changes in Core finally became visible for UI builds.
&gt; =&gt; Released the UI part for 4.6 M4 to resolve the test failures (comment 38).

Thanks, I can confirm that test failures have disappeared!</comment_text>
        </comment>
        <comment>
            <comment_id>2783338</comment_id>
            <comment_count>53</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-12-06 09:53:52 -0500</when>
            <comment_text>This is not fixed.

Now I get an Info on my example from comment 0 instead of a Warning marker. That info cannot be configured. When using the 'Configure problem severity' quick fix, I'm taken to some preference but not the one that would allow to configure /disable the info. When I change the preference from Ignore to Warning, I'm taken to another preference the next time I invoke the quick fix.

The behavior in 4.6. was better where I got the expected warning for the example from comment 0.</comment_text>
        </comment>
        <comment>
            <comment_id>2783347</comment_id>
            <comment_count>54</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-06 10:06:47 -0500</when>
            <comment_text>(In reply to Dani Megert from comment #53)
&gt; This is not fixed.
&gt; 
&gt; Now I get an Info on my example from comment 0 instead of a Warning marker.
&gt; That info cannot be configured.

I don't know which settings you use, but AFAICS, this is as per the design in comment 18, which we all agreed upon, didn't we? (see "alternative resolution").

I do see room for improving UX for "Configure problem severity". Or maybe you want a solution for bug 508228?

If none of these, I cannot help but recommend we abandon everything here and focus on more important tasks in JDT/Core, because the efforts needed for fiddling with this issue far outweigh the benefits, IMO.</comment_text>
        </comment>
        <comment>
            <comment_id>2783355</comment_id>
            <comment_count>55</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-12-06 10:16:59 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #54)
&gt; I don't know which settings you use,

New workspace.


&gt; but AFAICS, this is as per the design
&gt; in comment 18, which we all agreed upon, didn't we? (see "alternative
&gt; resolution").

I agreed with additional requests, see comment 21.


My main problem is that we now show a problem that can't be configured by itself. Maybe I don't want to see this. Maybe I want this as a warning. This isn't possible. This is on top of bug 508228.</comment_text>
        </comment>
        <comment>
            <comment_id>2783440</comment_id>
            <comment_count>56</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-06 11:48:11 -0500</when>
            <comment_text>(In reply to Dani Megert from comment #55)
&gt; My main problem is that we now show a problem that can't be configured by
&gt; itself. Maybe I don't want to see this. Maybe I want this as a warning. This
&gt; isn't possible. This is on top of bug 508228.

I thought we agreed on Info - anyway...
So in addition to the fix here you want a new configuration option:

Report when a @SuppressWarning could possibly be unused, whereas the compiler cannot really decide because some analysis necessary for this decision has been disabled via compiler options.

Right?

We may need to apply bzip2 to squeeze the option description into a single line in the UI :p Any suggestions?

Question: should it be a boolean flag or [E/W/I/I]?

Any proposals what the corresponding cli option should be named? -warn:possiblyUnusedSuppressWarnings ? I know it's too long, but ...</comment_text>
        </comment>
        <comment>
            <comment_id>2783632</comment_id>
            <comment_count>57</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-06 23:07:16 -0500</when>
            <comment_text>We thought INFO to be the right option because people can simply ignore unlike warnings/errors and if they are really bothered about it, then it's there to see. Yes, it is a user's prerogative, but if there's to be an exception to this rule, then this is it.</comment_text>
        </comment>
        <comment>
            <comment_id>2783906</comment_id>
            <comment_count>58</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-12-07 09:41:46 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #57)
&gt; We thought INFO to be the right option because people can simply ignore
&gt; unlike warnings/errors and if they are really bothered about it, then it's
&gt; there to see. Yes, it is a user's prerogative, but if there's to be an
&gt; exception to this rule, then this is it.

No, we don't report problems (with whatever default) without allowing the user to change it. And there's not just the issue of getting rid of it, but also of increasing the severity for those who want this as warning or error.</comment_text>
        </comment>
        <comment>
            <comment_id>2783920</comment_id>
            <comment_count>59</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-12-07 09:55:35 -0500</when>
            <comment_text>(In reply to Dani Megert from comment #53)
&gt; This is not fixed.
&gt; 
&gt; Now I get an Info on my example from comment 0 instead of a Warning marker.

If the already enabled diagnostics result in an unused warning for the token, I think it would be better to show that warning instead of the new message. Otherwise, the only way to make it work and get rid of the message is to enable all related diagnostics and that's often not what the user wants.</comment_text>
        </comment>
        <comment>
            <comment_id>2783926</comment_id>
            <comment_count>60</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-12-07 10:06:08 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #56)
&gt; (In reply to Dani Megert from comment #55)
&gt; &gt; My main problem is that we now show a problem that can't be configured by
&gt; &gt; itself. Maybe I don't want to see this. Maybe I want this as a warning. This
&gt; &gt; isn't possible. This is on top of bug 508228.
&gt; 
&gt; I thought we agreed on Info - anyway...

Yes, as default for the new diagnostic.


&gt; So in addition to the fix here you want a new configuration option:

Yes.

 
&gt; Report when a @SuppressWarning could possibly be unused, whereas the
&gt; compiler cannot really decide because some analysis necessary for this
&gt; decision has been disabled via compiler options.

Following up on my previous comment: we could do what we also do in the null analysis: we have the normal unused option and the new one would be "Potential unused '@SuppressWarnings' token:".

The code snippet from comment 0 would give a warning like in M3 while the reported issue would trigger the new potential info message.</comment_text>
        </comment>
        <comment>
            <comment_id>2784129</comment_id>
            <comment_count>61</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-07 18:31:59 -0500</when>
            <comment_text>I was going to write "you got what you paid for", but then I discovered that bug bug 210213 is implemented slightly differently from what I assumed from the comments: 

As of bug 210213, unused @SW was flagged if

   options.isAnyEnabled(tokenIrritants)

Emphasis on *any*.

This also explains the misunderstanding near comment 26: while Jay was looking at "isAnyEnabled()" I was assuming "areAllEnabled()" (or "!isAnyDisabled()").

If we'd restore that, then we're left to solve two more things:

- resolve the dilemma from comment 25

- rephrase the new message

old:

At least one of the problems in category ''{0}'' is not analysed due to a compiler option being ignored

new s.t. like:

None of the problems in category ''{0}'' are analysed due to a compiler options being ignored


From a logic point of view I still like the current solution better: if there's any doubt whether @SW makes sense report the more tentative form. 
More agressively reporting unused @SW (as requested by Dani) may lead to removing @SW where s.b. else with different compiler options may still need it, which isn't nice at all.

Maybe, keeping the logic as it is and making the new issue configurable would serve all purposes at hand?</comment_text>
        </comment>
    </bug>
    <bug>
        <id>495674</id>
        <developer>Stik Dragon</developer>
        <developer_username>stikdragon</developer_username>
        <dup_id/>
        <creation_time>2016-06-08 07:05:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Content assist immediately after case statement inside lambda expression hangs Eclipse</short_desc>
        <thetext>With the following code, typing single '.' character on the line immediately after the 'case' statement causes Eclipse to lock up.  As if you meant to type 'a.something' but didn't quite catch the first key. 

public class CrashEclipse {
	public void f() {
		Function&lt;String, String&gt; func = a -&gt; {
			switch (a.length()) {
			case 1: 
				// typing a . here crashes eclipse
			}
			return null;
		};
	}
}

Also present in older version, 4.4.2</thetext>
        <comment>
            <comment_id>2718295</comment_id>
            <comment_count>1</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-06-08 07:27:56 -0400</when>
            <comment_text>I cannot reproduce the crash in Eclipse 4.5 or 4.6. Do you have any logs?

There is a long delay after typing a dot and then Eclipse becomes responsive again. 

The delay is seen in returning from ICodeAssist.codeComplete(int offset, CompletionRequestor requestor, IProgressMonitor monitor).</comment_text>
        </comment>
        <comment>
            <comment_id>2718435</comment_id>
            <comment_count>2</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-06-08 11:00:50 -0400</when>
            <comment_text>Something is definitely wrong here.

After pasting the code and organizing the imports, content assist at the mentioned location does not give me any proposals, e.g.
Str&lt;Ctrl+Space&gt;</comment_text>
        </comment>
        <comment>
            <comment_id>2718449</comment_id>
            <comment_count>3</comment_count>
            <who>Stik Dragon</who>
            <commenter_username>stikdragon</commenter_username>
            <when>2016-06-08 11:19:54 -0400</when>
            <comment_text>I don't have any error logs.  I guess "crash" is the wrong description, it simply becomes unresponsive and i end-task the process.  I've just tried leaving it to see how long it would take, but after 15 minutes it still has not returned.

How long is "a long delay" for you?</comment_text>
        </comment>
        <comment>
            <comment_id>2718456</comment_id>
            <comment_count>4</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-06-08 11:26:20 -0400</when>
            <comment_text>(In reply to Stik Dragon from comment #3)
&gt; How long is "a long delay" for you?

4 seconds.</comment_text>
        </comment>
        <comment>
            <comment_id>2718477</comment_id>
            <comment_count>5</comment_count>
            <who>Stik Dragon</who>
            <commenter_username>stikdragon</commenter_username>
            <when>2016-06-08 12:05:32 -0400</when>
            <comment_text>I've just installed a fresh version of Mars, and i see a 5 or 6s delay now.  

I then tried installing https://developers.google.com/eclipse/, which i use on my other installs, and the problem has reappeared.  I guess this means it is not an issue with Eclipse itself.  I will report the bug with the plugin instead.</comment_text>
        </comment>
        <comment>
            <comment_id>2718486</comment_id>
            <comment_count>6</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-06-08 12:20:43 -0400</when>
            <comment_text>(In reply to Stik Dragon from comment #5)
&gt; I've just installed a fresh version of Mars, and i see a 5 or 6s delay now.  
&gt; 
&gt; I then tried installing https://developers.google.com/eclipse/, which i use
&gt; on my other installs, and the problem has reappeared.  I guess this means it
&gt; is not an issue with Eclipse itself.  I will report the bug with the plugin
&gt; instead.

Thanks for the update Stik, but there's still something wrong (see my comment 2).</comment_text>
        </comment>
    </bug>
    <bug>
        <id>502241</id>
        <developer>James Nord</developer>
        <developer_username>jnord</developer_username>
        <dup_id/>
        <creation_time>2016-09-27 08:26:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Unable to launch scrapbook VM: CreateProcess error=206, The filename or extension is too long</short_desc>
        <thetext>Launching a scrapbook on Windows fails due to the path being too long.

Eclipse should be using unicode APIs which do not suffer from the path lengh issue.  (#327193 was similarly fixed but the scrapbook still has issues).


Unable to launch scrapbook VM
  Exception occurred executing command line.
  Cannot run program "C:\Java\jdk1.8.0_91\bin\javaw.exe" (in directory "C:\workarea\source\github\xxxxxxxxx\xxxxxxxxxx-xxxxxx-xxx\xxxxxxxxxx-xxxxxx-xxxxxxxxx\xxxxxxxxxx-xxxxxx-xxxxxxxxx-xxxxxxxx"): CreateProcess error=206, The filename or extension is too long

individual characters where replaced with an x above...


The full length of the path including the filename (.scrapbook.jpage) is 139 characters - which is below the 260 MAX_PATH for DOS.

Installation Details and versions:
  Code Recommenders for Java Developers	2.4.0.v20160607-1609	org.eclipse.recommenders.rcp.feature.feature.group	Eclipse Code Recommenders
  Dynamic Languages Toolkit - Ruby Development Tools	5.5.0.201605241149	org.eclipse.dltk.ruby.feature.group	Eclipse DLTK
  Eclipse Git Team Provider	4.4.0.201606070830-r	org.eclipse.egit.feature.group	Eclipse EGit
  Eclipse Git Team Provider - Task focused interface	4.4.0.201606070830-r	org.eclipse.egit.mylyn.feature.group	Eclipse EGit
  Eclipse GitHub integration with task focused interface	4.4.0.201606070830-r	org.eclipse.mylyn.github.feature.feature.group	Eclipse EGit
  Eclipse Java Development Tools	3.11.2.v20160212-1500	org.eclipse.jdt.feature.group	Eclipse.org
  Eclipse Java EE Developer Tools	3.8.0.v201605251556	org.eclipse.jst.enterprise_ui.feature.feature.group	Eclipse Web Tools Platform
  Eclipse Java Web Developer Tools	3.7.1.v201512021921	org.eclipse.jst.web_ui.feature.feature.group	Eclipse Web Tools Platform
  Eclipse Platform	4.6.0.I20160606-1100	org.eclipse.platform.ide	Eclipse.org
  Eclipse XML Editors and Tools	3.7.2.v201511240257	org.eclipse.wst.xml_ui.feature.feature.group	Eclipse Web Tools Platform
  m2e - Maven Integration for Eclipse (includes Incubating components)	1.7.0.20160504-0322	org.eclipse.m2e.feature.feature.group	Eclipse.org - m2e
  m2e connector for build-helper-maven-plugin	0.15.0.201207090124	org.sonatype.m2e.buildhelper.feature.feature.group	Sonatype, Inc.
  m2e connector for the Maven Dependency Plugin	0.0.4.201409291703	com.ianbrandt.tools.m2e.mdp.feature.feature.group	null</thetext>
        <comment>
            <comment_id>2756344</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-09-28 03:55:23 -0400</when>
            <comment_text>

*** This bug has been marked as a duplicate of bug 397047 ***</comment_text>
        </comment>
        <comment>
            <comment_id>2756445</comment_id>
            <comment_count>2</comment_count>
            <who>James Nord</who>
            <commenter_username>jnord</commenter_username>
            <when>2016-09-28 05:25:12 -0400</when>
            <comment_text>@Jay Arthanareeswaran - WHAT?  You are duplicating this on BUGSPAM?  This is a valid report - why do you consider it BUGSPAM?</comment_text>
        </comment>
        <comment>
            <comment_id>2756447</comment_id>
            <comment_count>3</comment_count>
            <who>James Nord</who>
            <commenter_username>jnord</commenter_username>
            <when>2016-09-28 05:27:18 -0400</when>
            <comment_text>NO comment on either bug as to why this is a duplicate of BUGSPAM so re-opening as this is a distinct issue</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507567</id>
        <developer>Stephan Herrmann</developer>
        <developer_username>stephan.herrmann</developer_username>
        <dup_id/>
        <creation_time>2016-11-15 15:49:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>o.e.j.c.tests.builder.ErrorTests.test0105() consistently fails on Linux.</short_desc>
        <thetext>See, e.g., http://download.eclipse.org/eclipse/downloads/drops4/I20161114-2000/testresults/html/org.eclipse.jdt.core.tests.builder_ep47I-unit-lin64_linux.gtk.x86_64_8.0.html

and also recent gerrit builds.

I can also see it in the IDE (running on linux).</thetext>
        <comment>
            <comment_id>2776357</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-15 16:01:21 -0500</when>
            <comment_text>Caused by a change in bug 463744

Additionally, I just found this:

(In reply to Maxime Daniel from bug 97998 comment #12)
&gt; Created attachment 73518 [details] [diff]
&gt; Fix + test case
&gt; 
&gt; This patch combines Kent's for the code with mine for the test, further
&gt; tuned to pass ErrorsTests under Linux (the added test won't cope with
&gt; Windozes as is - JDK 6 has APIs that would allow this, but we cannot use
&gt; it). Other tests currently running.

Since we have JDK 6 by now, if we keep the test, we should make it portable!</comment_text>
        </comment>
        <comment>
            <comment_id>2777264</comment_id>
            <comment_count>2</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-11-17 18:23:40 -0500</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/85245</comment_text>
        </comment>
        <comment>
            <comment_id>2777821</comment_id>
            <comment_count>3</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-19 16:48:33 -0500</when>
            <comment_text>In order to push the fix for bug 507716 via gerrit / hudson I had to temporarily disable the test in question - until decision is made whether the expected exception is essential or not.</comment_text>
        </comment>
        <comment>
            <comment_id>2778488</comment_id>
            <comment_count>4</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-11-22 04:30:58 -0500</when>
            <comment_text>Raising priority to blocker since this basically blocks development on JDT core.</comment_text>
        </comment>
        <comment>
            <comment_id>2778698</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-22 10:05:05 -0500</when>
            <comment_text>(In reply to Stefan Xenos from comment #4)
&gt; Raising priority to blocker since this basically blocks development on JDT
&gt; core.

Not sure what you mean. Is it still blocking tests after Stephan disabled the test?</comment_text>
        </comment>
        <comment>
            <comment_id>2778781</comment_id>
            <comment_count>6</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-11-22 12:18:05 -0500</when>
            <comment_text>I saw it fail last night:

https://hudson.eclipse.org/platform/job/eclipse.jdt.core-Gerrit/1935/</comment_text>
        </comment>
        <comment>
            <comment_id>2778783</comment_id>
            <comment_count>7</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-11-22 12:19:29 -0500</when>
            <comment_text>...but perhaps I didn't leave enough time for his change to propogate. I'll see if it happens again and will raise the priority if it recurs.</comment_text>
        </comment>
        <comment>
            <comment_id>2778861</comment_id>
            <comment_count>8</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-22 14:31:36 -0500</when>
            <comment_text>(In reply to Stefan Xenos from comment #7)
&gt; ...but perhaps I didn't leave enough time for his change to propogate. I'll
&gt; see if it happens again and will raise the priority if it recurs.

it looks like you rebased only for patch set #3 and since then you're fighting different bugs, right?</comment_text>
        </comment>
        <comment>
            <comment_id>2783093</comment_id>
            <comment_count>9</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-05 23:36:32 -0500</when>
            <comment_text>Builds are passing again. Marking this as fixed.</comment_text>
        </comment>
        <comment>
            <comment_id>2783297</comment_id>
            <comment_count>10</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-06 08:41:57 -0500</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #9)
&gt; Builds are passing again. Marking this as fixed.

Jay, I only disabled the failing test to enable development via gerrit/hudson. Do you really see that as a solution? I see nothing that I could take credits for. Sorry for being a pita ... :)</comment_text>
        </comment>
        <comment>
            <comment_id>2783633</comment_id>
            <comment_count>11</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-06 23:11:12 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #10)
&gt; Jay, I only disabled the failing test to enable development via
&gt; gerrit/hudson. Do you really see that as a solution? I see nothing that I
&gt; could take credits for. Sorry for being a pita ... :)

Sorry about that. Sometimes book keeping gets tedious :)</comment_text>
        </comment>
    </bug>
    <bug>
        <id>507758</id>
        <developer>Torge Kummerow</developer>
        <developer_username>torgato</developer_username>
        <dup_id/>
        <creation_time>2016-11-18 08:16:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Redundand Null Check wrongly higlights non null check after calling HashMap get function if using @NonNullByDefault</short_desc>
        <thetext>Overview: 

   If the value part of a HashMap is defined as @NonNull, and I get a value via a key, the result still can be null if the key does not exist. So a null check is still neccessary afterwards but gets highlighted as redundant



Steps to Reproduce: 

Set "Redundant Null Check" in Java/Compiler/Error&amp;Warnings to info or above

import java.util.HashMap;

import org.eclipse.jdt.annotation.NonNullByDefault;
import org.eclipse.jdt.annotation.Nullable;

@NonNullByDefault
public class NullAnnotationTest2 {

	static HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();

	public static void main(String[] args) {

		@Nullable
		final String testString = NullAnnotationTest2.map.get("");

		if (testString != null) {
			System.out.println(testString);
		}
	}

}



Actual Results:

if(testString != null) gets highlighted as: "Redundant null check: The variable testString cannot be null at this location"



Expected Results: 

No highlighting



Build Date &amp; Hardware: 

Version: Neon.1a Release (4.6.1)
Build id: 20161007-1200
Windows 7
org.eclipse.jdt.annotation_2.1.0.v20160418-1457.jar



Additional Information: 

@NonNullByDefault extends HashMap&lt;String, String&gt; to HashMap&lt;@NonNull String, @NonNull String&gt;. If I overwrite this by saying:

static HashMap&lt;String, @Nullable String&gt; map = new HashMap&lt;&gt;();
The highlighting stops. But I still think that it also should not highlight with 

static HashMap&lt;String, @NonNull String&gt; map = new HashMap&lt;&gt;();

As this only means that I am not allowed to use put() with null values and that I am guaranteed, that when iterating over the entrySet that there are no null values. But if I try to get a value by a key, it still can return null if the key does not exist.</thetext>
        <comment>
            <comment_id>2777501</comment_id>
            <comment_count>1</comment_count>
            <who>Torge Kummerow</who>
            <commenter_username>torgato</commenter_username>
            <when>2016-11-18 08:30:28 -0500</when>
            <comment_text>Ok, I guess I just understood the problem, and how Annotation in combination with Generic work...

Mentioned in the section "Substitution" @ http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Ftasks%2Ftask-using_null_type_annotations.htm



So this is not really a bug. I understand I would have to solve this by somewhow specifying external null annotations. 

http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Ftasks%2Ftask-using_external_null_annotations.htm

I'll see how this work. Closing this bug report again.</comment_text>
        </comment>
        <comment>
            <comment_id>2777607</comment_id>
            <comment_count>2</comment_count>
            <who>Torge Kummerow</who>
            <commenter_username>torgato</commenter_username>
            <when>2016-11-18 11:13:47 -0500</when>
            <comment_text>After fighting witt External Null Annotations and failing to get them run I think maybe an "option" would be nice to, by default, threat such cases as "Potentially null" instead of showing the warning: 

Unsafe interpretation of method return type as '@NonNull' based on the receiver type 'HashMap&lt;@NonNull ServiceState,@NonNull Integer&gt;'. Type 'HashMap&lt;K,V&gt;' doesn't seem to be designed with null type annotations in mind

So a null check is required after accessing such function like the Map.get function.

Getting rid of such warnings by using external annotations seems didious. And I would prefer to just add an additional null check in such a case, without getting an "redundand" warning for it.</comment_text>
        </comment>
        <comment>
            <comment_id>2777609</comment_id>
            <comment_count>3</comment_count>
            <who>Torge Kummerow</who>
            <commenter_username>torgato</commenter_username>
            <when>2016-11-18 11:15:29 -0500</when>
            <comment_text>Just to be clear, when that option is enabled this code would be free of any warnings:

import java.util.HashMap;

import org.eclipse.jdt.annotation.NonNullByDefault;
import org.eclipse.jdt.annotation.Nullable;

@NonNullByDefault
public class NullAnnotationTest2 {

	static HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();

	public static void main(String[] args) {

		String testString = NullAnnotationTest2.map.get("");

		if (testString != null) {
		 System.out.println(testString);
		}
	}

}</comment_text>
        </comment>
        <comment>
            <comment_id>2783520</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-06 14:13:03 -0500</when>
            <comment_text>Of all things, mostly comment 0 looks fishy: 

- we're about to report:
  Unsafe interpretation of method return type as '@NonNull' ...

- but assigning this value to a @Nullable variable silences this

- still we trust the @NonNull value and flag the null check as redundant


I'd favor treating the value as really-nullable, rather than adding yet another option.

If that is fixed you can use the assignment to @Nullable to override the "unsafe interpretation as @NonNull".

OTOH, there's nothing better than using external annotations to mark get() as returning nullable.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>508860</id>
        <developer>Patrick Tasse</developer>
        <developer_username>patrick.tasse</developer_username>
        <dup_id/>
        <creation_time>2016-12-07 17:08:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>OutOfMemoryError in HashtableOfObject</short_desc>
        <thetext>Occurs regularly, latest with build I20161204-2000

!ENTRY org.eclipse.jdt.core 4 4 2016-12-05 09:40:05.545
!MESSAGE Background Indexer Crash Recovery
!STACK 0
java.lang.OutOfMemoryError: Requested array size exceeds VM limit
	at org.eclipse.jdt.internal.compiler.util.HashtableOfObject.&lt;init&gt;(HashtableOfObject.java:38)
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:663)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategory(DiskIndex.java:466)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategories(DiskIndex.java:458)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeWith(DiskIndex.java:560)
	at org.eclipse.jdt.internal.core.index.Index.save(Index.java:197)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex(IndexManager.java:939)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndexes(IndexManager.java:981)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.notifyIdle(IndexManager.java:676)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:379)
	at java.lang.Thread.run(Thread.java:745)</thetext>
        <comment>
            <comment_id>2784154</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-12-08 00:16:51 -0500</when>
            <comment_text>I don't recall we ever going over the 2GB limit for array size.

Can something go wrong while reading? If not, how did we manage to write it in first place.

Copying Stefan and Manoj for comments.</comment_text>
        </comment>
        <comment>
            <comment_id>2784160</comment_id>
            <comment_count>2</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-12-08 00:58:09 -0500</when>
            <comment_text>See also bug 474323, which requests better error handling for this case. We can investigate the root cause here.

I've had a bunch of reports of this from my own users in the past week. I can't reproduce it myself but I have a user who can reproduce it consistently.

- The user reported that his largest index file was 56 megs. That was unusually large but wasn't nearly large enough to cause this sort of overflow.

- I asked the user to delete the index manually and restart Eclipse. He reported that the problem came back within an hour of restarting.

This leads me to suspect that the index is corrupt - not just overflowing - and that the index is being corrupted by something inside Eclipse.</comment_text>
        </comment>
        <comment>
            <comment_id>2784163</comment_id>
            <comment_count>3</comment_count>
            <who>Andrey Loskutov</who>
            <commenter_username>loskutov</commenter_username>
            <when>2016-12-08 01:05:53 -0500</when>
            <comment_text>Yep, that is a dup.

*** This bug has been marked as a duplicate of bug 474323 ***</comment_text>
        </comment>
        <comment>
            <comment_id>2784165</comment_id>
            <comment_count>4</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-12-08 01:09:41 -0500</when>
            <comment_text>I'd suggest we use two bugs to track, separately, better error handling in the case of a corrupt index (bug 474323) and whatever is causing the frequent corruption in the builds from the past few weeks (this bug).</comment_text>
        </comment>
        <comment>
            <comment_id>2784572</comment_id>
            <comment_count>5</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-12-08 14:18:10 -0500</when>
            <comment_text>Note that this only affects the legacy index so it will go away once we replace the legacy index with the new one. However, that is still a long way away so it's still worth trying to fix this in the meantime.</comment_text>
        </comment>
        <comment>
            <comment_id>2784588</comment_id>
            <comment_count>6</comment_count>
            <who>Patrick Tasse</who>
            <commenter_username>patrick.tasse</commenter_username>
            <when>2016-12-08 14:56:32 -0500</when>
            <comment_text>FYI, initially I had "Disable new Java index" unchecked (having never changed the preference) when I noticed the problem a few times. Then I checked the option to disable the new index, and after restarting Eclipse it still happened a short time later and I wrote the bug.

I don't know the internal details e.g. if I needed to do something to rebuild the index from one version to the other.

I think it mostly occurred after fetching a patch from gerrit.</comment_text>
        </comment>
        <comment>
            <comment_id>2784590</comment_id>
            <comment_count>7</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-12-08 15:05:33 -0500</when>
            <comment_text>This is a problem with the legacy index. Disabling the new index is unlikely to have any effect on this problem.</comment_text>
        </comment>
        <comment>
            <comment_id>2784638</comment_id>
            <comment_count>8</comment_count>
            <who>Marc-André Laperle</who>
            <commenter_username>marc-andre.laperle</commenter_username>
            <when>2016-12-08 23:16:33 -0500</when>
            <comment_text>(In reply to Stefan Xenos from comment #7)
&gt; This is a problem with the legacy index. Disabling the new index is unlikely
&gt; to have any effect on this problem.

Just to be clear, when the new index is enabled, could this problem still occur? Are both old and new index being used simultaneously?</comment_text>
        </comment>
        <comment>
            <comment_id>2784678</comment_id>
            <comment_count>9</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-12-09 04:11:39 -0500</when>
            <comment_text>&gt; Are both old and new index being
&gt; used simultaneously?

Yes. Most of JDT hasn't been migrated to the new index yet and the new index can't (yet) index source files, so both indexes are used when the new one is enabled.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>509039</id>
        <developer>Frank Benoit</developer>
        <developer_username>frank.rene.benoit</developer_username>
        <dup_id/>
        <creation_time>2016-12-11 11:46:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[null] local flow analysis for final fields</short_desc>
        <thetext>This code:

public class FinalNull {

	@Nullable
	private final Object value;

	public FinalNull( @Nullable Object value ){
		this.value = value;
	}

	void action(){
		if( value != null ){
			value.toString(); // Here for 'value'
		}
	}
}

Error:
Potential null pointer access: this expression has a '@Nullable' type


This should not give the warning, as the field is checked for non-null and it is final, hence cannot be null in that line.</thetext>
        <comment>
            <comment_id>2785226</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-11 13:15:34 -0500</when>
            <comment_text>Thanks for the report, but this is working exactly as designed.

The general strategy for @Nullable fields is discussed in "The case of fields" in the help [1]. There's more on this in the wiki [2] in particular under "Risks of flow analysis for fields".

Some time ago we had a discussion to apply special analysis just for final fields. Marking as duplicate of that (unresolved) RFE.

[1] http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Ftasks%2Ftask-using_null_annotations.htm&amp;cp=1_3_9_0_4&amp;anchor=design_by_contract

[2] https://wiki.eclipse.org/JDT_Core/Null_Analysis/Options

*** This bug has been marked as a duplicate of bug 237236 ***</comment_text>
        </comment>
        <comment>
            <comment_id>2785228</comment_id>
            <comment_count>2</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-11 13:20:00 -0500</when>
            <comment_text>I was a bit quick closing as duplicate, since the other bug is closed wontfix, but that applies for the more general case.

Re-opening to have a place to discuss just admitting flow analysis for final fields (as opposed to analysing nullness from field initialization).</comment_text>
        </comment>
        <comment>
            <comment_id>2787159</comment_id>
            <comment_count>3</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-12-16 14:21:03 -0500</when>
            <comment_text>*** Bug 498726 has been marked as a duplicate of this bug. ***</comment_text>
        </comment>
        <comment>
            <comment_id>2787160</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-12-16 14:37:43 -0500</when>
            <comment_text>Note for a future investigator: technically, any flow analysis for fields needs infrastructure as we had developed for bug 247564, which was later withdrawn as of bug 247564 comment 176. I should add that this work (see commit d6c2a90130be430285c5f6a000090d250c310afd) had quite some complexity. The main issue was: extending bit vectors to include fields and tweaking computation of IDs so that all variables in scope (incl. inherited and from outer instances) would be linearized nicely.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>485542</id>
        <developer>Marvin  Fröhlich</developer>
        <developer_username>qudus</developer_username>
        <dup_id/>
        <creation_time>2016-01-11 07:47:00 -0500</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Show currently used method signature</short_desc>
        <thetext>Preconditions:
There is an overloaded method with many arguments per signature.
There is a call to one of them.

Now I want to check, if the call is correct and therefore show method signature highlighting. I hit CTRL+Space and a list of method signatures shows up.

It is hard to know, which method signature is currently being used, if they're similar. Of course I can place the caret at one of the later parameters and hit CTRL-Space. But if the signatures differ in the last parameter only or my call is incorrect and it doesn't perfectly match, this is difficult.

It would be nice, if there was a way to show method signature highlighting (CTRL+Space -&gt; Choose -&gt; Hit Enter), that is currently selected by the compiler by just hitting a hotkey.</thetext>
        <comment>
            <comment_id>2659160</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-01-11 19:02:01 -0500</when>
            <comment_text>I'm not sure I understand your situation: the full method call with all arguments already exists? In that case, I wouldn't think of Ctrl-space, as you don't want to insert new text.

What do you mean by "my call is incorrect"? Are you speaking of a compile error, or of an invocation of a different method than you intended?

Doesn't the javadoc hover serve your purpose?

Or is this about visually associating formal parameter names with arguments, like it is done during completion, after selecting a method and while editing the arguments of the call in "linked mode"?</comment_text>
        </comment>
        <comment>
            <comment_id>2659294</comment_id>
            <comment_count>2</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-01-12 03:25:44 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #1)
&gt; I'm not sure I understand your situation:

Same here.</comment_text>
        </comment>
        <comment>
            <comment_id>2659534</comment_id>
            <comment_count>3</comment_count>
            <who>Marvin  Fröhlich</who>
            <commenter_username>qudus</commenter_username>
            <when>2016-01-12 09:24:37 -0500</when>
            <comment_text>Yes, the full method call already exists.

Yes, it is about linked mode. And yes, I want to visually associate my arguments. Hence javadoc hover doesn't do the trick.

By that "incorrect call" thing I was talking about an existing method call, that got compiler wisely incorrect for some reason. Let's say, I inserted a parameter somewhere in the original method. If the IDE is still able to guess a method signature selection, then it can help me with linked mode to check and fix my arguments.</comment_text>
        </comment>
        <comment>
            <comment_id>2682449</comment_id>
            <comment_count>4</comment_count>
            <who>Marvin  Fröhlich</who>
            <commenter_username>qudus</commenter_username>
            <when>2016-03-15 10:19:58 -0400</when>
            <comment_text>Will this be addressed?</comment_text>
        </comment>
        <comment>
            <comment_id>2683934</comment_id>
            <comment_count>5</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-03-17 11:36:55 -0400</when>
            <comment_text>You're looking for Show Parameter Hints (Ctrl+Shift+Space), but that one is still broken for overloaded methods, see bug 70631.

*** This bug has been marked as a duplicate of bug 70631 ***</comment_text>
        </comment>
        <comment>
            <comment_id>2684261</comment_id>
            <comment_count>6</comment_count>
            <who>Marvin  Fröhlich</who>
            <commenter_username>qudus</commenter_username>
            <when>2016-03-18 05:37:23 -0400</when>
            <comment_text>Sorry, no, this is not, what I am looking for. Unfortunately I cannot screenshot this.

Let's say, you have a syntactically correct method call. If you place the caret before the first argument, hit CTRL+Space(, select the desired overloaded method variant) and hit Enter, then you get into a mode, where the argument (with type) with the caret on it is highlighted. I want to get into this mode. I think, this is not exactly linked mode, but something similar.

If you're browsing a read-only class (binary view), you cannot start this mode, because eclipse assumes, you want to start editing, which might not be true.

If the method call is wrong and cannot be compiled for what ever reason, eclipse still tries to do a best match and could still allow to start this mode for debugging reasons.

I hope, this explains better, what I am looking for. Please remove the "duplicate of" for 70631. This is not true.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>491700</id>
        <developer>Stephanie Swiderski</developer>
        <developer_username>ssw</developer_username>
        <dup_id/>
        <creation_time>2016-04-14 09:37:00 -0400</creation_time>
        <product>JDT</product>
        <component>UI</component>
        <short_desc>Rename in workspace does not update matching JavaDoc reference</short_desc>
        <thetext/>
        <comment>
            <comment_id>2694634</comment_id>
            <comment_count>1</comment_count>
            <who>Stephanie Swiderski</who>
            <commenter_username>ssw</commenter_username>
            <when>2016-04-14 09:43:46 -0400</when>
            <comment_text>In the following example renaming foo will present two linked ui areas for 
the foo in the declaration of foo and in the wrong @see reference.
After confirmation with return the changes at the @see reference will disappear.
Expectation: no linked UI for wrong @see reference.

/**
 * Breaking example
 */
package basic;

public class TestArea {
	
	
	public void foo() {  // Try to rename foo

	}
	
	/**
	 * @see TestArea#foo   this foo reference will have linked ui 
	 */
	public void fooOther() {

	}

}</comment_text>
        </comment>
        <comment>
            <comment_id>2694644</comment_id>
            <comment_count>2</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-14 10:02:39 -0400</when>
            <comment_text>Moving to UI for investigation. This might very well be a problem in core, but we will need some inputs as to what's going wrong in case.</comment_text>
        </comment>
        <comment>
            <comment_id>2695171</comment_id>
            <comment_count>3</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-04-15 08:42:40 -0400</when>
            <comment_text>Those references do match.</comment_text>
        </comment>
        <comment>
            <comment_id>2695236</comment_id>
            <comment_count>4</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-04-15 10:19:28 -0400</when>
            <comment_text>(In reply to Dani Megert from comment #3)
&gt; Those references do match.

The issue I see is when renamed, the reference in Javadoc doesn't change. Is that expected?</comment_text>
        </comment>
        <comment>
            <comment_id>2695239</comment_id>
            <comment_count>5</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-04-15 10:26:12 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #4)
&gt; (In reply to Dani Megert from comment #3)
&gt; &gt; Those references do match.
&gt; 
&gt; The issue I see is when renamed, the reference in Javadoc doesn't change. Is
&gt; that expected?

Well, the problem is that the bug has a wrong summary and is not precise. The reference match and that is correct. There are two different rename commands. One for the file and one for the workspace. The latter seems to fail.</comment_text>
        </comment>
        <comment>
            <comment_id>2695266</comment_id>
            <comment_count>6</comment_count>
            <who>Stephanie Swiderski</who>
            <commenter_username>ssw</commenter_username>
            <when>2016-04-15 10:56:21 -0400</when>
            <comment_text>Actually I think the match is not correct 
since the reference is pointing to a field like:

public int foo;


If this field is added to the example the match does not any longer occur
and the linked UI is not drawn.</comment_text>
        </comment>
        <comment>
            <comment_id>2695275</comment_id>
            <comment_count>7</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-04-15 11:06:23 -0400</when>
            <comment_text>(In reply to Stephanie Swiderski from comment #6)
&gt; Actually I think the match is not correct 
&gt; since the reference is pointing to a field like:

Nope, this is valid Javadoc for methods, e.g. if you don't want to restrict the Javadoc @see to a specific signature of #foo.

There will be a problem for rename if there's more than one foo in the same file.</comment_text>
        </comment>
        <comment>
            <comment_id>2695278</comment_id>
            <comment_count>8</comment_count>
            <who>Stephanie Swiderski</who>
            <commenter_username>ssw</commenter_username>
            <when>2016-04-15 11:10:55 -0400</when>
            <comment_text>By Java Doc documentation:
http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html#tag

@see class#field

is different to 

@see class#method()

and so I expect that renaming TestArea#foo()
would not touch the comment
/**
 * @see TestArea#foo   this foo reference will have linked ui 
 */</comment_text>
        </comment>
        <comment>
            <comment_id>2695282</comment_id>
            <comment_count>9</comment_count>
            <who>Stephanie Swiderski</who>
            <commenter_username>ssw</commenter_username>
            <when>2016-04-15 11:13:39 -0400</when>
            <comment_text>Ok my mistake:
http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html#see
Here is desribed what you meant.</comment_text>
        </comment>
        <comment>
            <comment_id>2695294</comment_id>
            <comment_count>10</comment_count>
            <who>Stephanie Swiderski</who>
            <commenter_username>ssw</commenter_username>
            <when>2016-04-15 11:23:35 -0400</when>
            <comment_text>Then (In reply to Dani Megert from comment #7)
&gt; (In reply to Stephanie Swiderski from comment #6)
&gt; &gt; Actually I think the match is not correct 
&gt; &gt; since the reference is pointing to a field like:
&gt; 
&gt; Nope, this is valid Javadoc for methods, e.g. if you don't want to restrict
&gt; the Javadoc @see to a specific signature of #foo.
&gt; 
&gt; There will be a problem for rename if there's more than one foo in the same
&gt; file.

Maybe close this bug an reopen a different one for the failing rename command.
I started the rename with rename refactoring hotkey and cursor on foo().</comment_text>
        </comment>
        <comment>
            <comment_id>2695296</comment_id>
            <comment_count>11</comment_count>
            <who>Dani Megert</who>
            <commenter_username>daniel_megert</commenter_username>
            <when>2016-04-15 11:24:59 -0400</when>
            <comment_text>(In reply to Stephanie Swiderski from comment #10)
&gt; Then (In reply to Dani Megert from comment #7)
&gt; &gt; (In reply to Stephanie Swiderski from comment #6)
&gt; &gt; &gt; Actually I think the match is not correct 
&gt; &gt; &gt; since the reference is pointing to a field like:
&gt; &gt; 
&gt; &gt; Nope, this is valid Javadoc for methods, e.g. if you don't want to restrict
&gt; &gt; the Javadoc @see to a specific signature of #foo.
&gt; &gt; 
&gt; &gt; There will be a problem for rename if there's more than one foo in the same
&gt; &gt; file.
&gt; 
&gt; Maybe close this bug an reopen a different one for the failing rename
&gt; command.
&gt; I started the rename with rename refactoring hotkey and cursor on foo().

It's fine - we can use that for the workspace rename.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>499258</id>
        <developer>Gan Ming</developer>
        <developer_username>xyuu</developer_username>
        <dup_id/>
        <creation_time>2016-08-05 21:57:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.ast.FieldReference.analyseCode(FieldReference.java:154)</short_desc>
        <thetext>Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.ast.FieldReference.analyseCode(FieldReference.java:154)

fixbug:

replace

org.eclipse.jdt.internal.compiler.ast.FieldReference.analyseCode(FieldReference.java:154)

from:

if (!fieldInits.isDefinitelyAssigned(fieldBinding)) {

to:

if (fieldInits!=null&amp;&amp;!fieldInits.isDefinitelyAssigned(fieldBinding)) {</thetext>
        <comment>
            <comment_id>2737737</comment_id>
            <comment_count>1</comment_count>
            <who>Gan Ming</who>
            <commenter_username>xyuu</commenter_username>
            <when>2016-08-05 22:11:42 -0400</when>
            <comment_text>compiler this project:

https://github.com/asciidocfx/AsciidocFX.git

Description	Resource	Path	Location	Type
Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.ast.FieldReference.analyseCode(FieldReference.java:154)	ShellTab.java	
/AsciidocFX/src/main/java/com/kodcu/shell	line 0	Java Problem</comment_text>
        </comment>
        <comment>
            <comment_id>2737746</comment_id>
            <comment_count>2</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-08-06 05:09:17 -0400</when>
            <comment_text>(In reply to Gan Ming from comment #1)
&gt; compiler this project:
&gt; 
&gt; https://github.com/asciidocfx/AsciidocFX.git
&gt; 

Thanks for the report. 

I can reproduce it and will distill a standalone testcase.</comment_text>
        </comment>
        <comment>
            <comment_id>2737747</comment_id>
            <comment_count>3</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-08-06 05:20:41 -0400</when>
            <comment_text>(In reply to Till Brychcy from comment #2)
&gt; I can reproduce it and will distill a standalone testcase.

class Controller {
	public void newTerminal(Object... path) {
	}
}

interface EventHandler {
	void handle();
}

public class ShellTab {
	private final Controller controller;

	public ShellTab(Controller controller) {
		this.controller = controller;
		EventHandler h = this.controller::newTerminal;
	}
}

If the varargs parameter is removed from newTerminal, the problem doesn't appear.</comment_text>
        </comment>
        <comment>
            <comment_id>2737748</comment_id>
            <comment_count>4</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-08-06 05:23:00 -0400</when>
            <comment_text>(In reply to Gan Ming from comment #0)
&gt; Internal compiler error: java.lang.NullPointerException at
&gt; org.eclipse.jdt.internal.compiler.ast.FieldReference.
&gt; analyseCode(FieldReference.java:154)
&gt; 
&gt; fixbug:
&gt; 
&gt; replace
&gt; 
&gt; org.eclipse.jdt.internal.compiler.ast.FieldReference.
&gt; analyseCode(FieldReference.java:154)
&gt; 
&gt; from:
&gt; 
&gt; if (!fieldInits.isDefinitelyAssigned(fieldBinding)) {
&gt; 
&gt; to:
&gt; 
&gt; if (fieldInits!=null&amp;&amp;!fieldInits.isDefinitelyAssigned(fieldBinding)) {

Thanks for looking into the code and trying to help.
This would fix the symptom, but the real problem is that fieldInits is null at all.</comment_text>
        </comment>
        <comment>
            <comment_id>2737836</comment_id>
            <comment_count>5</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-06 18:29:01 -0400</when>
            <comment_text>(In reply to Till Brychcy from comment #4)
&gt; Thanks for looking into the code and trying to help.
&gt; This would fix the symptom, but the real problem is that fieldInits is null
&gt; at all.

I agree. I was thinking that probably we should even change the null return in getInitsForFinalBlankInitializationCheck() to throwing IllegalStateException. None of the callers handles null (so in an annotated world we would return '@NonNull FlowInfo' or else throw).</comment_text>
        </comment>
        <comment>
            <comment_id>2738730</comment_id>
            <comment_count>6</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-08-09 15:09:33 -0400</when>
            <comment_text>ANALYSIS:
This happens, when an implicit lambda is generated for the method reference to a varargs method. 
In ReferenceExpression.generateImplicitLambda(), a ExceptionHandlingFlowContext with null parent and initializationParent is created , so no InitializationFlowContext is found when FlowContext.getInitsForFinalBlankInitializationCheck is invoked to get fieldInits. Actually no error reporting is needed in this context (note that UnconditionalFlowInfo.fakeInitializedFlowInfo() is used, too)

(Similar code is in LambdaExpression.analyzeExceptions(), but this contains as  "catch (Exception e) { }".)

I see two options: 
- make FlowContext.getInitsForFinalBlankInitializationCheck somehow return a fake result like UnconditionalFlowInfo.fakeInitializedFlowInfo()
- Document this scenario for the current behaviour in FlowContext.getInitsForFinalBlankInitializationCheck() and add null checks at all usages. As refinement, maybe add some flag to ExceptionHandlingFlowContext so a null is only return in contexts where UnconditionalFlowInfo.fakeInitializedFlowInfo() is used and throw an IllegalStateException otherwise.

Following is a stack trace:

java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.FieldReference.analyseCode(FieldReference.java:154)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:140)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.analyseCode(LambdaExpression.java:518)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.generateImplicitLambda(ReferenceExpression.java:245)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.generateCode(ReferenceExpression.java:274)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.generateCode(LocalDeclaration.java:153)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.internalGenerateCode(ConstructorDeclaration.java:441)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.generateCode(ConstructorDeclaration.java:293)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:568)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:637)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:371)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:878)</comment_text>
        </comment>
        <comment>
            <comment_id>2738739</comment_id>
            <comment_count>7</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-09 15:40:08 -0400</when>
            <comment_text>Questions: 

Inside getInitsForFinalBlankInitializationCheck() is flowInfo the exact fakeInitializedFlowInfo() you mentioned?
If so, maybe all can be handled wrt this flowInfo? Mark it using a new tag bit, return the fake as a fall back etc.?


As you mention similarity to LambdaExpression.analyzeExceptions(): would catching exceptions be justified also in generateImplicitLambda()?
See also:
	// Process the lambda, taking care not to double report diagnostics. Don't expect any from resolve, Any from code generation should surface, but not those from flow analysis.


We could also subclass ExceptionHandlingFlowContext and override getInitsForFinalBlankInitializationCheck() as to return a special crafted fake flow info. This might be the cleanest option after all - well in line with the use of fakeInitializedFlowInfo()?</comment_text>
        </comment>
        <comment>
            <comment_id>2739097</comment_id>
            <comment_count>8</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-08-10 14:49:46 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #7)
&gt; Questions: 
&gt; 
&gt; Inside getInitsForFinalBlankInitializationCheck() is flowInfo the exact
&gt; fakeInitializedFlowInfo() you mentioned?
&gt; If so, maybe all can be handled wrt this flowInfo? Mark it using a new tag
&gt; bit, return the fake as a fall back etc.?
No, the fakeInitializedFlowInfo is created in parallel to the ExceptionHandlingFlowContext with parent==null and initializationParent==null

&gt; 
&gt; 
&gt; As you mention similarity to LambdaExpression.analyzeExceptions(): would
&gt; catching exceptions be justified also in generateImplicitLambda()?

I think that is not a good idea. LambdaExpression.analyzeExceptions is sometimes used during type inference when not all types are resolved yet, but generateImplicitLambda is used at code generation time, when all types must be known. Actually it's the other way round: fixing this bug might be an improvement for some corner cases when LambdaExpression.analyzeExceptions is used.

&gt; See also:
&gt; 	// Process the lambda, taking care not to double report diagnostics. Don't
&gt; expect any from resolve, Any from code generation should surface, but not
&gt; those from flow analysis.
&gt; 
&gt; 
&gt; We could also subclass ExceptionHandlingFlowContext and override
&gt; getInitsForFinalBlankInitializationCheck() as to return a special crafted
&gt; fake flow info. This might be the cleanest option after all - well in line
&gt; with the use of fakeInitializedFlowInfo()?

The idea is good, but overriding wouldn't work, because the FlowContext may get wrapped. The new subclass just has to be handled like the others in getInitsForFinalBlankInitializationCheck. 
I think we could simply use FlowInfo.DEAD_END as fake flow info - it returns true for all fields (I haven't tried yet).</comment_text>
        </comment>
        <comment>
            <comment_id>2739106</comment_id>
            <comment_count>9</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-08-10 15:31:57 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/78804</comment_text>
        </comment>
        <comment>
            <comment_id>2739107</comment_id>
            <comment_count>10</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-08-10 15:41:13 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #9)
&gt; New Gerrit change created: https://git.eclipse.org/r/78804

LambdaExpression.analyzeExceptions() already uses a subclass of ExceptionHandlingFlowContext, namely ExceptionInferenceFlowContext. 
As I understood things, it should be ok to use that in generateImplicitLambda and handle it in getInitsForFinalBlankInitializationCheck as described in comment #8.

@Stephan, what do you think?

Maybe this should go into 4.6.1, too? 
(BTW: I'll be on vacation, soon)</comment_text>
        </comment>
        <comment>
            <comment_id>2739213</comment_id>
            <comment_count>11</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-08-11 06:01:06 -0400</when>
            <comment_text>(In reply to comment #10)
&gt; (In reply to Eclipse Genie from comment #9)
&gt; &gt; New Gerrit change created: https://git.eclipse.org/r/78804
&gt; 
&gt; LambdaExpression.analyzeExceptions() already uses a subclass of
&gt; ExceptionHandlingFlowContext, namely ExceptionInferenceFlowContext.
&gt; As I understood things, it should be ok to use that in generateImplicitLambda
&gt; and handle it in getInitsForFinalBlankInitializationCheck as described in
&gt; comment #8.
&gt; 
Returning FlowInfo.DEAD_END (or similar) instead of null from with in getInitsForFinalBlankInitializationCheck seems better to me. The name ExceptionInferenceFlowContext and associated comment in the source file do not make it obvious that it fakes initialization info, which might cause difficulties later.</comment_text>
        </comment>
        <comment>
            <comment_id>2739227</comment_id>
            <comment_count>12</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-08-11 06:57:01 -0400</when>
            <comment_text>(In reply to Sasikanth Bharadwaj from comment #11)
&gt; Returning FlowInfo.DEAD_END (or similar) instead of null from with in
&gt; getInitsForFinalBlankInitializationCheck seems better to me. 

You mean simply return that always where currently null is returned (without additional instanceof checks)? That would be the simplest change, but it might hide some bugs later.


&gt; The name
&gt; ExceptionInferenceFlowContext and associated comment in the source file do
&gt; not make it obvious that it fakes initialization info, which might cause
&gt; difficulties later.

We could also introduce

class FieldInitFakingFlowContext extends ExceptionHandlingFlowContext

and let ExceptionInferenceFlowContext extend FieldInitFakingFlowContext.</comment_text>
        </comment>
        <comment>
            <comment_id>2739235</comment_id>
            <comment_count>13</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-08-11 07:50:04 -0400</when>
            <comment_text>(In reply to Till Brychcy from comment #12)
&gt; (In reply to Sasikanth Bharadwaj from comment #11)
&gt; &gt; Returning FlowInfo.DEAD_END (or similar) instead of null from with in
&gt; &gt; getInitsForFinalBlankInitializationCheck seems better to me. 
&gt; 
&gt; You mean simply return that always where currently null is returned (without
&gt; additional instanceof checks)? That would be the simplest change, but it
&gt; might hide some bugs later.

I agree. Reaching the bottom of that method would almost always indicate a bug. Exposing that bug via ISE expresses this design best.


&gt; &gt; The name
&gt; &gt; ExceptionInferenceFlowContext and associated comment in the source file do
&gt; &gt; not make it obvious that it fakes initialization info, which might cause
&gt; &gt; difficulties later.
&gt; 
&gt; We could also introduce
&gt; 
&gt; class FieldInitFakingFlowContext extends ExceptionHandlingFlowContext
&gt; 
&gt; and let ExceptionInferenceFlowContext extend FieldInitFakingFlowContext.

Something like that. Aside from naming, would there be any differences between FieldInitFakingFlowContext and ExceptionInferenceFlowContext.

As far as I understood:
- existing ExceptionInferenceFlowContext is used for a best-effort flow analysis during lambda exception analysis. This analysis may be incomplete (due to missing bindings), but we need to know things like: can the body return normally?
- for RE we don't really need any flow analysis, because an RE doesn't specify any flow (except for NPE check on the receiver? but that should be done earlier already, right?). I believe we only need to call analyse for the sake of some side effects that are needed(?) for generateCode(), right?

Once we have a good grip on similarities/differences of these two scenarios, good naming shouldn't be hard to find.</comment_text>
        </comment>
        <comment>
            <comment_id>2739362</comment_id>
            <comment_count>14</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-08-11 13:16:09 -0400</when>
            <comment_text>New Gerrit change created: https://git.eclipse.org/r/78890</comment_text>
        </comment>
        <comment>
            <comment_id>2739372</comment_id>
            <comment_count>15</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-08-11 13:41:00 -0400</when>
            <comment_text>@Sasi, somehow you were not on the CC list, I've added you - I hope that's ok.

(In reply to Till Brychcy from comment #12)

I've done both now.

&gt; (In reply to Sasikanth Bharadwaj from comment #11)
&gt; &gt; Returning FlowInfo.DEAD_END (or similar) instead of null from with in
&gt; &gt; getInitsForFinalBlankInitializationCheck seems better to me. 
&gt; 
&gt; You mean simply return that always where currently null is returned (without
&gt; additional instanceof checks)? That would be the simplest change, but it
&gt; might hide some bugs later.
(In reply to Eclipse Genie from comment #14)
&gt; New Gerrit change created: https://git.eclipse.org/r/78890

This variation in a patch prepared for 4.6.1, because NPE's are always bad and it is easy to see that this can't break anything.

&gt; 
&gt; 
&gt; &gt; The name
&gt; &gt; ExceptionInferenceFlowContext and associated comment in the source file do
&gt; &gt; not make it obvious that it fakes initialization info, which might cause
&gt; &gt; difficulties later.
&gt; 
&gt; We could also introduce
&gt; 
&gt; class FieldInitFakingFlowContext extends ExceptionHandlingFlowContext
&gt; 
&gt; and let ExceptionInferenceFlowContext extend FieldInitFakingFlowContext.

This Variation in patch set 2 of the original gerrit, with IllegalStateException like Stephan suggested.</comment_text>
        </comment>
        <comment>
            <comment_id>2739489</comment_id>
            <comment_count>16</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-08-11 16:18:35 -0400</when>
            <comment_text>(In reply to Till Brychcy from comment #15)

I forgot to add: 
Personally, I'd prefer patch set 2 from the original gerrit even for a possible back port but I know this code now so any solution is good for me :-)</comment_text>
        </comment>
        <comment>
            <comment_id>2739517</comment_id>
            <comment_count>17</comment_count>
            <who>Sasikanth Bharadwaj</who>
            <commenter_username>sasikanth.bharadwaj</commenter_username>
            <when>2016-08-12 01:44:08 -0400</when>
            <comment_text>(In reply to comment #13)
&gt; (In reply to Till Brychcy from comment #12)
&gt; 
&gt; As far as I understood:
&gt; - existing ExceptionInferenceFlowContext is used for a best-effort flow analysis
&gt; during lambda exception analysis. This analysis may be incomplete (due to
&gt; missing bindings), but we need to know things like: can the body return
&gt; normally?
Yes
&gt; - for RE we don't really need any flow analysis, because an RE doesn't specify
&gt; any flow (except for NPE check on the receiver? but that should be done earlier
&gt; already, right?). I believe we only need to call analyse for the sake of some
&gt; side effects that are needed(?) for generateCode(), right?
&gt; 
Yes again.


(In reply to comment #16)
&gt; (In reply to Till Brychcy from comment #15)
&gt; 
&gt; I forgot to add:
&gt; Personally, I'd prefer patch set 2 from the original gerrit even for a possible
&gt; back port but I know this code now so any solution is good for me :-)
I agree, patch set 2 looks good. It's just the naming now I guess, and I'm not any good with that, so I bow out :-)</comment_text>
        </comment>
        <comment>
            <comment_id>2739520</comment_id>
            <comment_count>18</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-08-12 02:10:49 -0400</when>
            <comment_text>(In reply to Sasikanth Bharadwaj from comment #17)
&gt; I agree, patch set 2 looks good. It's just the naming now I guess, and I'm
&gt; not any good with that, so I bow out :-)

Good, I've updated the gerrit for the maintenance branch.

@Stephan, maybe you have still have a suggestion for a better name? But note that we don't need a *common* name anymore, because ReferenceExpression doesn't use ExceptionInferenceFlowContext now, but FieldInitFakingFlowContext.</comment_text>
        </comment>
        <comment>
            <comment_id>2739958</comment_id>
            <comment_count>19</comment_count>
            <who>Eclipse Genie</who>
            <commenter_username>genie</commenter_username>
            <when>2016-08-14 09:48:34 -0400</when>
            <comment_text>Gerrit change https://git.eclipse.org/r/78804 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=3369a84b4c06f4d0949c6b8b6eef32cf25538cfd</comment_text>
        </comment>
        <comment>
            <comment_id>2739959</comment_id>
            <comment_count>20</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-08-14 09:53:38 -0400</when>
            <comment_text>(In reply to Eclipse Genie from comment #19)
&gt; Gerrit change https://git.eclipse.org/r/78804 was merged to [master].
&gt; Commit:
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
&gt; ?id=3369a84b4c06f4d0949c6b8b6eef32cf25538cfd

Released for 4.7M2</comment_text>
        </comment>
        <comment>
            <comment_id>2739960</comment_id>
            <comment_count>21</comment_count>
            <who>Till Brychcy</who>
            <commenter_username>register.eclipse</commenter_username>
            <when>2016-08-14 10:02:21 -0400</when>
            <comment_text>@Jay, I see you already put yourself on the CC list. 

Do you approve a back port to 4.6.1?</comment_text>
        </comment>
        <comment>
            <comment_id>2746737</comment_id>
            <comment_count>22</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-09-04 05:10:36 -0400</when>
            <comment_text>Probably too late for 4.6.1, now (RC3 is done).

Updating white board to reconsider for 4.6.2.

@Jay, do you approve for 4.6.2?</comment_text>
        </comment>
        <comment>
            <comment_id>2750098</comment_id>
            <comment_count>23</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-09-13 06:05:48 -0400</when>
            <comment_text>Verified for Eclipse Oxygen 4.7 M2 with build id: Build id: I20160912-1005</comment_text>
        </comment>
        <comment>
            <comment_id>2776284</comment_id>
            <comment_count>24</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-15 12:18:21 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #22)
&gt; Probably too late for 4.6.1, now (RC3 is done).
&gt; 
&gt; Updating white board to reconsider for 4.6.2.
&gt; 
&gt; @Jay, do you approve for 4.6.2?

It seems this fell through the cracks. I don't want to push too hard to get this into 4.6.2 at this point (RC2 nearly done).

I'd still propose this for 4.6.x, since exception thrown by the compiler is never good.</comment_text>
        </comment>
        <comment>
            <comment_id>2779670</comment_id>
            <comment_count>25</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-11-24 08:38:36 -0500</when>
            <comment_text>Let's try a little harder to get this into 4.6.3 :)</comment_text>
        </comment>
        <comment>
            <comment_id>2779934</comment_id>
            <comment_count>26</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-11-25 02:32:49 -0500</when>
            <comment_text>(In reply to Stephan Herrmann from comment #25)
&gt; Let's try a little harder to get this into 4.6.3 :)

Sorry for missing out on this one. +1 for back port.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>503050</id>
        <developer>Chandrakala MS</developer>
        <developer_username>chandra-ms</developer_username>
        <dup_id/>
        <creation_time>2016-10-03 06:39:00 -0400</creation_time>
        <product>JDT</product>
        <component>Debug</component>
        <short_desc>[1.9] junit test cannot be run even though the classpath has been configured to point to junit.jar</short_desc>
        <thetext>Unable to run a junit test both as a module and as a non-module, I get the below error with eclipse version eclipse-SDK-Y20160908-1000-win32-x86_64 that supports Java9.


Error: Could not find or load main class org.eclipse.jdt.internal.junit.runner.RemoteTestRunner

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;classpath&gt;
	&lt;classpathentry kind="src" path="src"/&gt;
	&lt;classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-9"/&gt;
	&lt;classpathentry exported="true" kind="lib" path="/lib.java/junit-4.12/junit-4.12.jar"/&gt;
	&lt;classpathentry kind="lib" path="/lib.java/junit-4.12/hamcrest-core-1.3.jar"/&gt;
	&lt;classpathentry kind="output" path="bin"/&gt;
&lt;/classpath&gt;</thetext>
        <comment>
            <comment_id>2758818</comment_id>
            <comment_count>1</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-03 08:26:02 -0400</when>
            <comment_text>I can reproduce.

Noopur, can you help me with some insight on Junit side as to what's going on? Is the JUnitContainer even resolved properly?</comment_text>
        </comment>
        <comment>
            <comment_id>2766139</comment_id>
            <comment_count>2</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-10-13 09:17:04 -0400</when>
            <comment_text>org.eclipse.jdt.internal.junit.runner.RemoteTestRunner is the main class which is present in org.eclipse.jdt.junit.runtime bundle. This bundle is specified from the JUnit side in the classpath to org.eclipse.jdt.launching.VMRunnerConfiguration as:
.../eclipse.jdt.ui/org.eclipse.jdt.junit.runtime/bin/

This is same for both JDK8 and JDK9 projects running the test.

Further, the classpath and other passed args from VMRunnerConfiguration are used in org.eclipse.jdt.internal.launching.StandardVMDebugger#run, which eventually gives the specified error from the VM.

The command line args passed to the java.lang.Runtime.exec(String[] cmdarray, String[] envp, File dir) method in DebugPlugin#exec are same for both JDK8 and JDK9 projects running the test (except the corresponding path of javaw.exe, which is obvious).

Moving to JDT Debug for further analysis.</comment_text>
        </comment>
        <comment>
            <comment_id>2766176</comment_id>
            <comment_count>3</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-13 09:49:47 -0400</when>
            <comment_text>I investigated this and found a problem with the path of the jdt.junit bundle:

/C:/JDT/repo/eclipse.jdt.ui/org.eclipse.jdt.junit.runtime/bin/

Note the '/' at the beginning.

I don't yet know how we end up with this, but I have a vague feeling I have seen this before, albeit long ago.</comment_text>
        </comment>
        <comment>
            <comment_id>2766179</comment_id>
            <comment_count>4</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-10-13 09:52:57 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #3)
&gt; I investigated this and found a problem with the path of the jdt.junit
&gt; bundle:
&gt; 
&gt; /C:/JDT/repo/eclipse.jdt.ui/org.eclipse.jdt.junit.runtime/bin/
&gt; 
&gt; Note the '/' at the beginning.
&gt; 
&gt; I don't yet know how we end up with this, but I have a vague feeling I have
&gt; seen this before, albeit long ago.

We get the same for a test being run in a JDK8 project, which runs successfully.</comment_text>
        </comment>
        <comment>
            <comment_id>2766189</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-13 10:04:41 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #3)
&gt; I investigated this and found a problem with the path of the jdt.junit
&gt; bundle:
&gt; 
&gt; /C:/JDT/repo/eclipse.jdt.ui/org.eclipse.jdt.junit.runtime/bin/
&gt; 
&gt; Note the '/' at the beginning.
&gt; 
&gt; I don't yet know how we end up with this, but I have a vague feeling I have
&gt; seen this before, albeit long ago.

I am afraid that's not the full story. Yes, when I run the command after removing the '/', things are better, but the tests do run fine with the same arguments!</comment_text>
        </comment>
        <comment>
            <comment_id>2766194</comment_id>
            <comment_count>6</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-13 10:09:07 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #5)
&gt; I am afraid that's not the full story. Yes, when I run the command after
&gt; removing the '/', things are better, but the tests do run fine with the same
&gt; arguments!

I meant to say, run fine with JRE 8 (same observation as Noopur mentioned)</comment_text>
        </comment>
        <comment>
            <comment_id>2767518</comment_id>
            <comment_count>7</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-18 01:49:23 -0400</when>
            <comment_text>(In reply to Noopur Gupta from comment #2)
&gt; org.eclipse.jdt.internal.junit.runner.RemoteTestRunner is the main class
&gt; which is present in org.eclipse.jdt.junit.runtime bundle. This bundle is
&gt; specified from the JUnit side in the classpath to
&gt; org.eclipse.jdt.launching.VMRunnerConfiguration as:
&gt; .../eclipse.jdt.ui/org.eclipse.jdt.junit.runtime/bin/
&gt; 


org.eclipse.jdt.internal.junit.runner.RemoteTestRunner comes as the classTolaunch, but classpath does not have junit path or bundle. I don't see any class path as ".../eclipse.jdt.ui/org.eclipse.jdt.junit.runtime/bin/"
attaching the classpath input screenshot.</comment_text>
        </comment>
        <comment>
            <comment_id>2767519</comment_id>
            <comment_count>8</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-18 01:49:51 -0400</when>
            <comment_text>Created attachment 264905
Classpath</comment_text>
        </comment>
        <comment>
            <comment_id>2767636</comment_id>
            <comment_count>9</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-18 06:51:21 -0400</when>
            <comment_text>(In reply to Jay Arthanareeswaran from comment #6)
&gt; (In reply to Jay Arthanareeswaran from comment #5)
&gt; &gt; I am afraid that's not the full story. Yes, when I run the command after
&gt; &gt; removing the '/', things are better, but the tests do run fine with the same
&gt; &gt; arguments!
&gt; 
&gt; I meant to say, run fine with JRE 8 (same observation as Noopur mentioned)

Removing the extra '/" in the starting makes it work in Java 9 as well. So some change in JDK behaviour, where it used to work in Java 8 (with or without '/' but not any more in Java 9 with '/'.
And JDT UI is getting this url using the method from org.eclipse.core.runtime.FileLocator

FileLocator.toFileURL(url).getFile(); 

It should be handled at runtime level perhaps as it can cause problems at other places as well with Java9.</comment_text>
        </comment>
        <comment>
            <comment_id>2768130</comment_id>
            <comment_count>10</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-19 04:09:41 -0400</when>
            <comment_text>org.eclipse.core.runtime.FileLocator.toFileURL(url) uses deprecated method File.toURL(); This method was deprecated in Java 6.
Java Doc says -
Deprecated.  This method does not automatically escape characters that are illegal in URLs. It is recommended that new code convert an abstract pathname into a URL by first converting it into a URI, via the toURI method, and then converting the URI into a URL via the URI.toURL method.

In ant also, we had to change this to use something like this

 (URIUtil.toFile(URIUtil.toURI(FileLocator.toFileURL(url))).getAbsolutePath()

and making this change in JDT UI works as well to run Junits for JDK 9 and JDK 8 both.

I see that FileLocator.toFileURL(url) is being used at several places, so updating this method to make it relevant will make more sense.</comment_text>
        </comment>
        <comment>
            <comment_id>2768687</comment_id>
            <comment_count>11</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-10-20 09:22:39 -0400</when>
            <comment_text>(In reply to Sarika Sinha from comment #10)
&gt; org.eclipse.core.runtime.FileLocator.toFileURL(url) uses deprecated method
&gt; File.toURL(); This method was deprecated in Java 6.
&gt; Java Doc says -
&gt; Deprecated.  This method does not automatically escape characters that are
&gt; illegal in URLs. It is recommended that new code convert an abstract
&gt; pathname into a URL by first converting it into a URI, via the toURI method,
&gt; and then converting the URI into a URL via the URI.toURL method.

&gt; In ant also, we had to change this to use something like this
&gt; 
&gt;  (URIUtil.toFile(URIUtil.toURI(FileLocator.toFileURL(url))).getAbsolutePath()
&gt; 
&gt; and making this change in JDT UI works as well to run Junits for JDK 9 and
&gt; JDK 8 both.

Added the fix mentioned above to JUnit code in BETA_JAVA9 branch:
http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?h=BETA_JAVA9&amp;id=9f4494f811c7ee074c01ab7796be5e38f49488f2

&gt; I see that FileLocator.toFileURL(url) is being used at several places, so
&gt; updating this method to make it relevant will make more sense.</comment_text>
        </comment>
        <comment>
            <comment_id>2768787</comment_id>
            <comment_count>12</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-20 13:19:34 -0400</when>
            <comment_text>Verified for BETA_JAVA9 with build Y20161020-1000.

Chandra, please let me know if this works for you too.</comment_text>
        </comment>
        <comment>
            <comment_id>2769100</comment_id>
            <comment_count>13</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-10-21 13:24:38 -0400</when>
            <comment_text>(In reply to Sarika Sinha from comment #10)
&gt; org.eclipse.core.runtime.FileLocator.toFileURL(url) uses deprecated method
&gt; File.toURL(); This method was deprecated in Java 6.

FileLocator#toFileURL(URL) doesn't use that method. Please file a new bug for Platform/Runtime, make it block this bug, and add a stacktrace that shows where File#toURL() is called in this sencario.

Also note in that bug that touching this area is very risky. The JDK's handling of "unencoded" URLs was buggy in several places for a long time, and I don't know what the current state is. But I do know that the Eclipse Platform and the SDK are full of hacks that work around the worst issues (e.g. to support paths with spaces). OTOH bug 339422 tells that URIUtil doesn't even know what it's meant for.

This is an area where there are only two successful strategies:
a) Don't touch anything.
b) Thoroughly analyze the problem bottom-up, carefully document any behavior changes (even if they just align the implementation with the spec), and recursively follow all dependencies until you're sure nothing relies on the old behavior any more.</comment_text>
        </comment>
        <comment>
            <comment_id>2769441</comment_id>
            <comment_count>14</comment_count>
            <who>Markus Keller</who>
            <commenter_username>markus_keller</commenter_username>
            <when>2016-10-24 06:33:40 -0400</when>
            <comment_text>Reopening to make sure comment 21 doesn't get lost.

The released hack also needs a comment in the code. Your change only works by chance (or by accident) and that is not a pattern for anybody to use.

Also post the JDK9 version that exhibits the problem.

http://mail.openjdk.java.net/pipermail/jdk9-dev/2016-October/005062.html could be related. Sarika, please test the scenario in a broken build with VM arg "-Djdk.io.permissionsUseCanonicalPath=true". The change in http://hg.openjdk.java.net/jdk9/jdk9/jdk/diff/4251b451be17/src/java.base/share/classes/sun/net/www/protocol/file/FileURLConnection.java looks like it targets exactly the kind of URLs that cause problems here. Maybe that code caused the problem, or maybe it's a workaround for the same underlying problem that broke us.</comment_text>
        </comment>
        <comment>
            <comment_id>2769455</comment_id>
            <comment_count>15</comment_count>
            <who>Noopur Gupta</who>
            <commenter_username>noopur_gupta</commenter_username>
            <when>2016-10-24 06:56:17 -0400</when>
            <comment_text>(In reply to Markus Keller from comment #14)
&gt; Sarika, please test the scenario in a broken build with VM
&gt; arg "-Djdk.io.permissionsUseCanonicalPath=true".

Tested with jdk-9-ea+140_windows-x64 after reverting the committed fix and using the above VM arg. We get the same error:
Error: Could not find or load main class org.eclipse.jdt.internal.junit.runner.RemoteTestRunner</comment_text>
        </comment>
        <comment>
            <comment_id>2769710</comment_id>
            <comment_count>16</comment_count>
            <who>Chandrakala MS</who>
            <commenter_username>chandra-ms</commenter_username>
            <when>2016-10-25 03:00:05 -0400</when>
            <comment_text>I have tested with this eclipse-SDK-Y20161020-1000-win32-x86_64

- Simple junit test worked
- Above test as a module worked
- But when tried with some other module that has other project dependencies, it failed with compilation errors - import org cannot be resolved. 

Both build path &amp; .classpath contain the junit jar

Will open a new bug for this.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>497119</id>
        <developer>Stefan Xenos</developer>
        <developer_username>sxenos</developer_username>
        <dup_id/>
        <creation_time>2016-06-30 14:48:00 -0400</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>[newindex] Enable the unit tests for the new index</short_desc>
        <thetext>The unit tests for the new index are currently disabled. We should enable them.</thetext>
        <comment>
            <comment_id>2769774</comment_id>
            <comment_count>1</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-25 06:51:08 -0400</when>
            <comment_text>Which tests in JDT Debug were disabled ?</comment_text>
        </comment>
        <comment>
            <comment_id>2769801</comment_id>
            <comment_count>2</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-10-25 08:03:58 -0400</when>
            <comment_text>None. I think it was just the tests for the new index. I think they're enabled now... But I'll check when I get back to my computer.</comment_text>
        </comment>
        <comment>
            <comment_id>2769995</comment_id>
            <comment_count>3</comment_count>
            <who>Sarika Sinha</who>
            <commenter_username>sarika.sinha</commenter_username>
            <when>2016-10-25 23:15:48 -0400</when>
            <comment_text>I don't see any tests in JDT Debug for index, Please reopen if you think otherwise.</comment_text>
        </comment>
        <comment>
            <comment_id>2770002</comment_id>
            <comment_count>4</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-10-26 00:36:25 -0400</when>
            <comment_text>Reopening and moving to correct component.</comment_text>
        </comment>
        <comment>
            <comment_id>2770798</comment_id>
            <comment_count>5</comment_count>
            <who>Jay Arthanareeswaran</who>
            <commenter_username>jarthana</commenter_username>
            <when>2016-10-28 02:45:57 -0400</when>
            <comment_text>Bulk change, moving out all bugs that couldn't make it to M3.</comment_text>
        </comment>
        <comment>
            <comment_id>2783397</comment_id>
            <comment_count>6</comment_count>
            <who>Stefan Xenos</who>
            <commenter_username>sxenos</commenter_username>
            <when>2016-12-06 11:03:41 -0500</when>
            <comment_text>This was fixed earlier in M4.</comment_text>
        </comment>
        <comment>
            <comment_id>2783644</comment_id>
            <comment_count>7</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-12-07 00:06:21 -0500</when>
            <comment_text>(In reply to Stefan Xenos from comment #6)
&gt; This was fixed earlier in M4.

@Stefan: Could you please share the commit link here?</comment_text>
        </comment>
        <comment>
            <comment_id>2784155</comment_id>
            <comment_count>8</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-12-08 00:17:43 -0500</when>
            <comment_text>(In reply to Manoj Palat from comment #7)
&gt; (In reply to Stefan Xenos from comment #6)
&gt; &gt; This was fixed earlier in M4.
&gt; 
&gt; @Stefan: Could you please share the commit link here?

From the logs, the commit at : http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=b278712ee6059101d67fa5211607300703492366

@Stefan: The tests are enabled. However, the addition is more appropriate in RunJavaSearchTests rather than AllJavaModelTests (which includes RJST anyway).

re-opening for this and moving the target to M5.</comment_text>
        </comment>
    </bug>
    <bug>
        <id>487758</id>
        <developer>Christoph Nievergelt</developer>
        <developer_username>nievi</developer_username>
        <dup_id/>
        <creation_time>2016-02-12 12:17:00 -0500</creation_time>
        <product>JDT</product>
        <component>Core</component>
        <short_desc>Improve error message for illegal super() in anonymous class</short_desc>
        <thetext>The Parser does not accept the following code:

import java.util.HashMap;
import java.util.Map;
 
public class Bug {
 
  private static final Map&lt;String , String[]&gt; FONT_FILES = new HashMap&lt;String , String[]&gt;() {
    private static final long serialVersionUID = 1L;
    {
      super(1);
      put("Key", new String[]{"Value1", "Value2"});
    }
  };
 
}

but complains that super must be at the beginning of a constructor.
When you run the code (disregarding the IDEs warning) the code runs just fine and invokes the appropriate HashMap constructor.</thetext>
        <comment>
            <comment_id>2671362</comment_id>
            <comment_count>1</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-02-12 12:50:15 -0500</when>
            <comment_text>The code example contains no constructor declaration. What you wrote is an "instance initializer", cf. http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.6

An explicit constructor invocation (like "super(1)") can, however, only occur within a constructor declaration.

When ignoring the error message, this is the implicit constructor I see in the byte code:

  Bug$1();
    descriptor: ()V
    flags:
    Code:
      stack=3, locals=1, args_size=1
         0: new           #13                 // class java/lang/Error
         3: dup
         4: ldc           #15                 // String Unresolved compilation problem: \n\tConstructor call must be the first statement in a constructor\n
         6: invokespecial #17                 // Method java/lang/Error."&lt;init&gt;":(Ljava/lang/String;)V
         9: athrow
      LineNumberTable:
        line 9: 0

It will not invoke a HashMap constructor, but abort the program via a java.lang.Error.


FYI, there doesn't seem to be a direct workaround, because anonymous classes cannot contain explicit constructor declarations. If you need an explicit constructor, use a name class (may still be local to the current method).</comment_text>
        </comment>
        <comment>
            <comment_id>2683093</comment_id>
            <comment_count>2</comment_count>
            <who>Manoj Palat</who>
            <commenter_username>manpalat</commenter_username>
            <when>2016-03-16 10:24:49 -0400</when>
            <comment_text>Verified for Eclipse Neon 4.6 M6 using Build id: I20160315-2000</comment_text>
        </comment>
        <comment>
            <comment_id>2684736</comment_id>
            <comment_count>3</comment_count>
            <who>Christoph Nievergelt</who>
            <commenter_username>nievi</commenter_username>
            <when>2016-03-19 12:51:54 -0400</when>
            <comment_text>(In reply to Stephan Herrmann from comment #1)
&gt; The code example contains no constructor declaration. What you wrote is an
&gt; "instance initializer", cf.
&gt; http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.6
&gt; 
&gt; An explicit constructor invocation (like "super(1)") can, however, only
&gt; occur within a constructor declaration.
&gt; 
&gt; When ignoring the error message, this is the implicit constructor I see in
&gt; the byte code:
&gt; 
&gt;   Bug$1();
&gt;     descriptor: ()V
&gt;     flags:
&gt;     Code:
&gt;       stack=3, locals=1, args_size=1
&gt;          0: new           #13                 // class java/lang/Error
&gt;          3: dup
&gt;          4: ldc           #15                 // String Unresolved
&gt; compilation problem: \n\tConstructor call must be the first statement in a
&gt; constructor\n
&gt;          6: invokespecial #17                 // Method
&gt; java/lang/Error."&lt;init&gt;":(Ljava/lang/String;)V
&gt;          9: athrow
&gt;       LineNumberTable:
&gt;         line 9: 0
&gt; 
&gt; It will not invoke a HashMap constructor, but abort the program via a
&gt; java.lang.Error.
&gt; 
&gt; 
&gt; FYI, there doesn't seem to be a direct workaround, because anonymous classes
&gt; cannot contain explicit constructor declarations. If you need an explicit
&gt; constructor, use a name class (may still be local to the current method).

Sorry Stephan
I did not realize your response to my bug report until now (didn't expect that fast a response).
You are correct, that my code is faulty and Eclipse should treat it accordingly (I can no longer recreate the conditions that allowed me to step in the debugger into the HashMap constructor :-&lt;).
You are also correct about the instance initializer.

However, the error message "Constructor call must be the first statement in a constructor" is certainly misleading; something along the lines of "Constructor call must be the first statement in a constructor (anonymous classes cannot have explicit constructors)" would be less confusing.

But it would be really great, if the message could help developer to find the correct solution, which is to place the constructor parameter(s) in the bracket of class instance creation expression, like so:

  private static final Map&lt;String , String[]&gt; FONT_FILES = new HashMap&lt;String , String[]&gt;(1) {
    private static final long serialVersionUID = 1L;
    {
      put("Key", new String[]{"Value1", "Value2"});
    }
  };

as explained in paragraph "15.9.5.1. Anonymous Constructors".

So, yes, there is no workaround, but there is a (little obscured) language construct and a message like "Constructor call must be the first statement in a constructor (anonymous classes cannot have explicit constructors; actual arguments for the implictly declared anonymous class constructor have to be given in the class instance creation expression)" would lead the developer to the solution and a better understanding of the language (researching this topic certainly did for me :-).

I also found that I'm not the first person to complain about this: https://bugs.openjdk.java.net/browse/JDK-6479551</comment_text>
        </comment>
        <comment>
            <comment_id>2684738</comment_id>
            <comment_count>4</comment_count>
            <who>Stephan Herrmann</who>
            <commenter_username>stephan.herrmann</commenter_username>
            <when>2016-03-19 13:09:47 -0400</when>
            <comment_text>OK, we could debate whether this is still the same bug.
Instead I adjusted title and some meta data to reflect the updated RFE.

The given message is not wrong (you placed a super-ctor call in a wrong location and the message tells you so), but I agree, that the message could be more specific, e.g., in telling which part of the requirement ("first statement in a constructor") is violated (like saying "but this is not a constructor" :) ).

I wouldn't, however, consider this situation wide-spread enough to motivate putting a recipe for correction into the error message. If recipe, JDT would typically do this by offering a quick fix, but I don't really see us going so far.</comment_text>
        </comment>
    </bug>
</bugs>
